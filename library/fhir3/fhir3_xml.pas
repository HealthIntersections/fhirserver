unit fhir3_xml;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir3.inc}

interface

// FHIR v3.0.1 generated 2018-06-12T19:15:59+10:00

uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_collections, fsl_xml,
  fhir_parser, fhir_objects, 
  fhir3_parserBase, fhir3_resources, fhir3_constants, fhir3_types, fhir3_resources_base;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase3)
  protected
    function ParseElement(element : TMXmlElement; path : string) : TFhirElement;

    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : TMXmlElement) : boolean;
    function ParseBackboneElement(element : TMXmlElement; path : string) : TFhirBackboneElement;

    function ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : TMXmlElement) : TFhirEnum;
    function ParseDate(element : TMXmlElement; path : string) : TFhirDate;
    function ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
    function ParseString(element : TMXmlElement; path : string) : TFhirString;
    function ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
    function ParseUri(element : TMXmlElement; path : string) : TFhirUri;
    function ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
    function ParseXhtml(element : TMXmlElement; path : string) : TFhirXhtml;
    function ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
    function ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : TMXmlElement; path : string) : TFhirTime;
    function ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
    function ParseCode(element : TMXmlElement; path : string) : TFhirCode;
    function ParseOid(element : TMXmlElement; path : string) : TFhirOid;
    function ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
    function ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
    function ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
    function ParseId(element : TMXmlElement; path : string) : TFhirId;
    function ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : TMXmlElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : TMXmlElement) : boolean;
    Procedure ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : TMXmlElement);
    Function ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
    function ParseParametersParameterChild(element : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
    function ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
    function ParseParametersChild(element : TFhirParameters; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PARAMETERS}

    function ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
    function ParseExtensionChild(element : TFhirExtension; path : string; child : TMXmlElement) : boolean;
    function ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
    function ParseNarrativeChild(element : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
    function ParseContributor(element : TMXmlElement; path : string) : TFhirContributor;
    function ParseContributorChild(element : TFhirContributor; path : string; child : TMXmlElement) : boolean;
    function ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
    function ParseAttachmentChild(element : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementCodeFilter(element : TMXmlElement; path : string) : TFhirDataRequirementCodeFilter;
    function ParseDataRequirementCodeFilterChild(element : TFhirDataRequirementCodeFilter; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementDateFilter(element : TMXmlElement; path : string) : TFhirDataRequirementDateFilter;
    function ParseDataRequirementDateFilterChild(element : TFhirDataRequirementDateFilter; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirement(element : TMXmlElement; path : string) : TFhirDataRequirement;
    function ParseDataRequirementChild(element : TFhirDataRequirement; path : string; child : TMXmlElement) : boolean;
    function ParseDosage(element : TMXmlElement; path : string) : TFhirDosage;
    function ParseDosageChild(element : TFhirDosage; path : string; child : TMXmlElement) : boolean;
    function ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
    function ParseIdentifierChild(element : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
    function ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
    function ParseCodingChild(element : TFhirCoding; path : string; child : TMXmlElement) : boolean;
    function ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
    function ParseSampledDataChild(element : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
    function ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
    function ParseRatioChild(element : TFhirRatio; path : string; child : TMXmlElement) : boolean;
    function ParseReference(element : TMXmlElement; path : string) : TFhirReference;
    function ParseReferenceChild(element : TFhirReference; path : string; child : TMXmlElement) : boolean;
    function ParseTriggerDefinition(element : TMXmlElement; path : string) : TFhirTriggerDefinition;
    function ParseTriggerDefinitionChild(element : TFhirTriggerDefinition; path : string; child : TMXmlElement) : boolean;
    function ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
    function ParsePeriodChild(element : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
    function ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
    function ParseQuantityChild(element : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
    function ParseRange(element : TMXmlElement; path : string) : TFhirRange;
    function ParseRangeChild(element : TFhirRange; path : string; child : TMXmlElement) : boolean;
    function ParseRelatedArtifact(element : TMXmlElement; path : string) : TFhirRelatedArtifact;
    function ParseRelatedArtifactChild(element : TFhirRelatedArtifact; path : string; child : TMXmlElement) : boolean;
    function ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
    function ParseAnnotationChild(element : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
    function ParseContactDetail(element : TMXmlElement; path : string) : TFhirContactDetail;
    function ParseContactDetailChild(element : TFhirContactDetail; path : string; child : TMXmlElement) : boolean;
    function ParseUsageContext(element : TMXmlElement; path : string) : TFhirUsageContext;
    function ParseUsageContextChild(element : TFhirUsageContext; path : string; child : TMXmlElement) : boolean;
    function ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
    function ParseSignatureChild(element : TFhirSignature; path : string; child : TMXmlElement) : boolean;
    function ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
    function ParseCodeableConceptChild(element : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
    function ParseParameterDefinition(element : TMXmlElement; path : string) : TFhirParameterDefinition;
    function ParseParameterDefinitionChild(element : TFhirParameterDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
    function ParseContactPointChild(element : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
    function ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
    function ParseHumanNameChild(element : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
    function ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
    function ParseMetaChild(element : TFhirMeta; path : string; child : TMXmlElement) : boolean;
    function ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
    function ParseAddressChild(element : TFhirAddress; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
    function ParseElementDefinitionSlicingChild(element : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionSlicingDiscriminator(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicingDiscriminator;
    function ParseElementDefinitionSlicingDiscriminatorChild(element : TFhirElementDefinitionSlicingDiscriminator; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
    function ParseElementDefinitionBaseChild(element : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
    function ParseElementDefinitionTypeChild(element : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionExample(element : TMXmlElement; path : string) : TFhirElementDefinitionExample;
    function ParseElementDefinitionExampleChild(element : TFhirElementDefinitionExample; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
    function ParseElementDefinitionConstraintChild(element : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
    function ParseElementDefinitionBindingChild(element : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
    function ParseElementDefinitionMappingChild(element : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
    function ParseElementDefinitionChild(element : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
    function ParseTimingRepeatChild(element : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
    function ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
    function ParseTimingChild(element : TFhirTiming; path : string; child : TMXmlElement) : boolean;
    function ParseCount(element : TMXmlElement; path : string) : TFhirCount;
    function ParseCountChild(element : TFhirCount; path : string; child : TMXmlElement) : boolean;
    function ParseMoney(element : TMXmlElement; path : string) : TFhirMoney;
    function ParseMoneyChild(element : TFhirMoney; path : string; child : TMXmlElement) : boolean;
    function ParseAge(element : TMXmlElement; path : string) : TFhirAge;
    function ParseAgeChild(element : TFhirAge; path : string; child : TMXmlElement) : boolean;
    function ParseDistance(element : TMXmlElement; path : string) : TFhirDistance;
    function ParseDistanceChild(element : TFhirDistance; path : string; child : TMXmlElement) : boolean;
    function ParseDuration(element : TMXmlElement; path : string) : TFhirDuration;
    function ParseDurationChild(element : TFhirDuration; path : string; child : TMXmlElement) : boolean;

{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(element : TMXmlElement; path : string) : TFhirAccountCoverage;
    function ParseAccountCoverageChild(element : TFhirAccountCoverage; path : string; child : TMXmlElement) : boolean;
    function ParseAccountGuarantor(element : TMXmlElement; path : string) : TFhirAccountGuarantor;
    function ParseAccountGuarantorChild(element : TFhirAccountGuarantor; path : string; child : TMXmlElement) : boolean;
    function ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
    function ParseAccountChild(element : TFhirAccount; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(element : TMXmlElement; path : string) : TFhirActivityDefinitionParticipant;
    function ParseActivityDefinitionParticipantChild(element : TFhirActivityDefinitionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseActivityDefinitionDynamicValue(element : TMXmlElement; path : string) : TFhirActivityDefinitionDynamicValue;
    function ParseActivityDefinitionDynamicValueChild(element : TFhirActivityDefinitionDynamicValue; path : string; child : TMXmlElement) : boolean;
    function ParseActivityDefinition(element : TMXmlElement; path : string) : TFhirActivityDefinition;
    function ParseActivityDefinitionChild(element : TFhirActivityDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventSuspectEntity(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntity;
    function ParseAdverseEventSuspectEntityChild(element : TFhirAdverseEventSuspectEntity; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEvent(element : TMXmlElement; path : string) : TFhirAdverseEvent;
    function ParseAdverseEventChild(element : TFhirAdverseEvent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
    function ParseAllergyIntoleranceReactionChild(element : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
    function ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
    function ParseAllergyIntoleranceChild(element : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointmentParticipantChild(element : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
    function ParseAppointmentChild(element : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
    function ParseAppointmentResponseChild(element : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventAgent(element : TMXmlElement; path : string) : TFhirAuditEventAgent;
    function ParseAuditEventAgentChild(element : TFhirAuditEventAgent; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventAgentNetwork(element : TMXmlElement; path : string) : TFhirAuditEventAgentNetwork;
    function ParseAuditEventAgentNetworkChild(element : TFhirAuditEventAgentNetwork; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
    function ParseAuditEventSourceChild(element : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventEntity(element : TMXmlElement; path : string) : TFhirAuditEventEntity;
    function ParseAuditEventEntityChild(element : TFhirAuditEventEntity; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventEntityDetail(element : TMXmlElement; path : string) : TFhirAuditEventEntityDetail;
    function ParseAuditEventEntityDetailChild(element : TFhirAuditEventEntityDetail; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
    function ParseAuditEventChild(element : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
    function ParseBasicChild(element : TFhirBasic; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
    function ParseBinaryChild(element : TFhirBinary; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    function ParseBodySite(element : TMXmlElement; path : string) : TFhirBodySite;
    function ParseBodySiteChild(element : TFhirBodySite; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
    function ParseBundleLinkChild(element : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
    function ParseBundleEntryChild(element : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
    function ParseBundleEntrySearchChild(element : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
    function ParseBundleEntryRequestChild(element : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
    function ParseBundleEntryResponseChild(element : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
    function ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
    function ParseBundleChild(element : TFhirBundle; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(element : TMXmlElement; path : string) : TFhirCapabilityStatementSoftware;
    function ParseCapabilityStatementSoftwareChild(element : TFhirCapabilityStatementSoftware; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementImplementation(element : TMXmlElement; path : string) : TFhirCapabilityStatementImplementation;
    function ParseCapabilityStatementImplementationChild(element : TFhirCapabilityStatementImplementation; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRest(element : TMXmlElement; path : string) : TFhirCapabilityStatementRest;
    function ParseCapabilityStatementRestChild(element : TFhirCapabilityStatementRest; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestSecurity(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurity;
    function ParseCapabilityStatementRestSecurityChild(element : TFhirCapabilityStatementRestSecurity; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestSecurityCertificate(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurityCertificate;
    function ParseCapabilityStatementRestSecurityCertificateChild(element : TFhirCapabilityStatementRestSecurityCertificate; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResource(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResource;
    function ParseCapabilityStatementRestResourceChild(element : TFhirCapabilityStatementRestResource; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResourceInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceInteraction;
    function ParseCapabilityStatementRestResourceInteractionChild(element : TFhirCapabilityStatementRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceSearchParam;
    function ParseCapabilityStatementRestResourceSearchParamChild(element : TFhirCapabilityStatementRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestInteraction;
    function ParseCapabilityStatementRestInteractionChild(element : TFhirCapabilityStatementRestInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestOperation(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestOperation;
    function ParseCapabilityStatementRestOperationChild(element : TFhirCapabilityStatementRestOperation; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessaging(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessaging;
    function ParseCapabilityStatementMessagingChild(element : TFhirCapabilityStatementMessaging; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessagingEndpoint(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEndpoint;
    function ParseCapabilityStatementMessagingEndpointChild(element : TFhirCapabilityStatementMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessagingSupportedMessage(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingSupportedMessage;
    function ParseCapabilityStatementMessagingSupportedMessageChild(element : TFhirCapabilityStatementMessagingSupportedMessage; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessagingEvent(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEvent;
    function ParseCapabilityStatementMessagingEventChild(element : TFhirCapabilityStatementMessagingEvent; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementDocument(element : TMXmlElement; path : string) : TFhirCapabilityStatementDocument;
    function ParseCapabilityStatementDocumentChild(element : TFhirCapabilityStatementDocument; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatement(element : TMXmlElement; path : string) : TFhirCapabilityStatement;
    function ParseCapabilityStatementChild(element : TFhirCapabilityStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivityChild(element : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlanActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityDetail;
    function ParseCarePlanActivityDetailChild(element : TFhirCarePlanActivityDetail; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
    function ParseCarePlanChild(element : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(element : TMXmlElement; path : string) : TFhirCareTeamParticipant;
    function ParseCareTeamParticipantChild(element : TFhirCareTeamParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseCareTeam(element : TMXmlElement; path : string) : TFhirCareTeam;
    function ParseCareTeamChild(element : TFhirCareTeam; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemParticipant(element : TMXmlElement; path : string) : TFhirChargeItemParticipant;
    function ParseChargeItemParticipantChild(element : TFhirChargeItemParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseChargeItem(element : TMXmlElement; path : string) : TFhirChargeItem;
    function ParseChargeItemChild(element : TFhirChargeItem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(element : TMXmlElement; path : string) : TFhirClaimRelated;
    function ParseClaimRelatedChild(element : TFhirClaimRelated; path : string; child : TMXmlElement) : boolean;
    function ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
    function ParseClaimPayeeChild(element : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
    function ParseClaimCareTeam(element : TMXmlElement; path : string) : TFhirClaimCareTeam;
    function ParseClaimCareTeamChild(element : TFhirClaimCareTeam; path : string; child : TMXmlElement) : boolean;
    function ParseClaimInformation(element : TMXmlElement; path : string) : TFhirClaimInformation;
    function ParseClaimInformationChild(element : TFhirClaimInformation; path : string; child : TMXmlElement) : boolean;
    function ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
    function ParseClaimDiagnosisChild(element : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseClaimProcedure(element : TMXmlElement; path : string) : TFhirClaimProcedure;
    function ParseClaimProcedureChild(element : TFhirClaimProcedure; path : string; child : TMXmlElement) : boolean;
    function ParseClaimInsurance(element : TMXmlElement; path : string) : TFhirClaimInsurance;
    function ParseClaimInsuranceChild(element : TFhirClaimInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseClaimAccident(element : TMXmlElement; path : string) : TFhirClaimAccident;
    function ParseClaimAccidentChild(element : TFhirClaimAccident; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
    function ParseClaimItemChild(element : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
    function ParseClaimItemDetailChild(element : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
    function ParseClaimItemDetailSubDetailChild(element : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
    function ParseClaimChild(element : TFhirClaim; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
    function ParseClaimResponseItemChild(element : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
    function ParseClaimResponseItemAdjudicationChild(element : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
    function ParseClaimResponseItemDetailChild(element : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
    function ParseClaimResponseItemDetailSubDetailChild(element : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
    function ParseClaimResponseAddItemChild(element : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
    function ParseClaimResponseAddItemDetailChild(element : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
    function ParseClaimResponseErrorChild(element : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponsePayment(element : TMXmlElement; path : string) : TFhirClaimResponsePayment;
    function ParseClaimResponsePaymentChild(element : TFhirClaimResponsePayment; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseProcessNote(element : TMXmlElement; path : string) : TFhirClaimResponseProcessNote;
    function ParseClaimResponseProcessNoteChild(element : TFhirClaimResponseProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseInsurance(element : TMXmlElement; path : string) : TFhirClaimResponseInsurance;
    function ParseClaimResponseInsuranceChild(element : TFhirClaimResponseInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
    function ParseClaimResponseChild(element : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigation(element : TMXmlElement; path : string) : TFhirClinicalImpressionInvestigation;
    function ParseClinicalImpressionInvestigationChild(element : TFhirClinicalImpressionInvestigation; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
    function ParseClinicalImpressionFindingChild(element : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
    function ParseClinicalImpressionChild(element : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(element : TMXmlElement; path : string) : TFhirCodeSystemFilter;
    function ParseCodeSystemFilterChild(element : TFhirCodeSystemFilter; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemProperty(element : TMXmlElement; path : string) : TFhirCodeSystemProperty;
    function ParseCodeSystemPropertyChild(element : TFhirCodeSystemProperty; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConcept(element : TMXmlElement; path : string) : TFhirCodeSystemConcept;
    function ParseCodeSystemConceptChild(element : TFhirCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirCodeSystemConceptDesignation;
    function ParseCodeSystemConceptDesignationChild(element : TFhirCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConceptProperty(element : TMXmlElement; path : string) : TFhirCodeSystemConceptProperty;
    function ParseCodeSystemConceptPropertyChild(element : TFhirCodeSystemConceptProperty; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystem(element : TMXmlElement; path : string) : TFhirCodeSystem;
    function ParseCodeSystemChild(element : TFhirCodeSystem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
    function ParseCommunicationPayloadChild(element : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
    function ParseCommunicationChild(element : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
    function ParseCommunicationRequestPayloadChild(element : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunicationRequestRequester(element : TMXmlElement; path : string) : TFhirCommunicationRequestRequester;
    function ParseCommunicationRequestRequesterChild(element : TFhirCommunicationRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
    function ParseCommunicationRequestChild(element : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(element : TMXmlElement; path : string) : TFhirCompartmentDefinitionResource;
    function ParseCompartmentDefinitionResourceChild(element : TFhirCompartmentDefinitionResource; path : string; child : TMXmlElement) : boolean;
    function ParseCompartmentDefinition(element : TMXmlElement; path : string) : TFhirCompartmentDefinition;
    function ParseCompartmentDefinitionChild(element : TFhirCompartmentDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionAttesterChild(element : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionRelatesTo(element : TMXmlElement; path : string) : TFhirCompositionRelatesTo;
    function ParseCompositionRelatesToChild(element : TFhirCompositionRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionEventChild(element : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
    function ParseCompositionSectionChild(element : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
    function ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
    function ParseCompositionChild(element : TFhirComposition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(element : TMXmlElement; path : string) : TFhirConceptMapGroup;
    function ParseConceptMapGroupChild(element : TFhirConceptMapGroup; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElement(element : TMXmlElement; path : string) : TFhirConceptMapGroupElement;
    function ParseConceptMapGroupElementChild(element : TFhirConceptMapGroupElement; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTarget;
    function ParseConceptMapGroupElementTargetChild(element : TFhirConceptMapGroupElementTarget; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTargetDependsOn;
    function ParseConceptMapGroupElementTargetDependsOnChild(element : TFhirConceptMapGroupElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupUnmapped(element : TMXmlElement; path : string) : TFhirConceptMapGroupUnmapped;
    function ParseConceptMapGroupUnmappedChild(element : TFhirConceptMapGroupUnmapped; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
    function ParseConceptMapChild(element : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
    function ParseConditionStageChild(element : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
    function ParseConditionEvidence(element : TMXmlElement; path : string) : TFhirConditionEvidence;
    function ParseConditionEvidenceChild(element : TFhirConditionEvidence; path : string; child : TMXmlElement) : boolean;
    function ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
    function ParseConditionChild(element : TFhirCondition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentActor(element : TMXmlElement; path : string) : TFhirConsentActor;
    function ParseConsentActorChild(element : TFhirConsentActor; path : string; child : TMXmlElement) : boolean;
    function ParseConsentPolicy(element : TMXmlElement; path : string) : TFhirConsentPolicy;
    function ParseConsentPolicyChild(element : TFhirConsentPolicy; path : string; child : TMXmlElement) : boolean;
    function ParseConsentData(element : TMXmlElement; path : string) : TFhirConsentData;
    function ParseConsentDataChild(element : TFhirConsentData; path : string; child : TMXmlElement) : boolean;
    function ParseConsentExcept(element : TMXmlElement; path : string) : TFhirConsentExcept;
    function ParseConsentExceptChild(element : TFhirConsentExcept; path : string; child : TMXmlElement) : boolean;
    function ParseConsentExceptActor(element : TMXmlElement; path : string) : TFhirConsentExceptActor;
    function ParseConsentExceptActorChild(element : TFhirConsentExceptActor; path : string; child : TMXmlElement) : boolean;
    function ParseConsentExceptData(element : TMXmlElement; path : string) : TFhirConsentExceptData;
    function ParseConsentExceptDataChild(element : TFhirConsentExceptData; path : string; child : TMXmlElement) : boolean;
    function ParseConsent(element : TMXmlElement; path : string) : TFhirConsent;
    function ParseConsentChild(element : TFhirConsent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractAgent(element : TMXmlElement; path : string) : TFhirContractAgent;
    function ParseContractAgentChild(element : TFhirContractAgent; path : string; child : TMXmlElement) : boolean;
    function ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
    function ParseContractSignerChild(element : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
    function ParseContractValuedItem(element : TMXmlElement; path : string) : TFhirContractValuedItem;
    function ParseContractValuedItemChild(element : TFhirContractValuedItem; path : string; child : TMXmlElement) : boolean;
    function ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
    function ParseContractTermChild(element : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermAgent(element : TMXmlElement; path : string) : TFhirContractTermAgent;
    function ParseContractTermAgentChild(element : TFhirContractTermAgent; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermValuedItem(element : TMXmlElement; path : string) : TFhirContractTermValuedItem;
    function ParseContractTermValuedItemChild(element : TFhirContractTermValuedItem; path : string; child : TMXmlElement) : boolean;
    function ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
    function ParseContractFriendlyChild(element : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
    function ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
    function ParseContractLegalChild(element : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
    function ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
    function ParseContractRuleChild(element : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
    function ParseContract(element : TMXmlElement; path : string) : TFhirContract;
    function ParseContractChild(element : TFhirContract; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverageGrouping(element : TMXmlElement; path : string) : TFhirCoverageGrouping;
    function ParseCoverageGroupingChild(element : TFhirCoverageGrouping; path : string; child : TMXmlElement) : boolean;
    function ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
    function ParseCoverageChild(element : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    function ParseDataElementMapping(element : TMXmlElement; path : string) : TFhirDataElementMapping;
    function ParseDataElementMappingChild(element : TFhirDataElementMapping; path : string; child : TMXmlElement) : boolean;
    function ParseDataElement(element : TMXmlElement; path : string) : TFhirDataElement;
    function ParseDataElementChild(element : TFhirDataElement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
    function ParseDetectedIssueMitigationChild(element : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
    function ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
    function ParseDetectedIssueChild(element : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdi(element : TMXmlElement; path : string) : TFhirDeviceUdi;
    function ParseDeviceUdiChild(element : TFhirDeviceUdi; path : string; child : TMXmlElement) : boolean;
    function ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
    function ParseDeviceChild(element : TFhirDevice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    function ParseDeviceComponentProductionSpecification(element : TMXmlElement; path : string) : TFhirDeviceComponentProductionSpecification;
    function ParseDeviceComponentProductionSpecificationChild(element : TFhirDeviceComponentProductionSpecification; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceComponent(element : TMXmlElement; path : string) : TFhirDeviceComponent;
    function ParseDeviceComponentChild(element : TFhirDeviceComponent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
    function ParseDeviceMetricCalibrationChild(element : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
    function ParseDeviceMetricChild(element : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestRequester(element : TMXmlElement; path : string) : TFhirDeviceRequestRequester;
    function ParseDeviceRequestRequesterChild(element : TFhirDeviceRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceRequest(element : TMXmlElement; path : string) : TFhirDeviceRequest;
    function ParseDeviceRequestChild(element : TFhirDeviceRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(element : TMXmlElement; path : string) : TFhirDeviceUseStatement;
    function ParseDeviceUseStatementChild(element : TFhirDeviceUseStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportPerformer(element : TMXmlElement; path : string) : TFhirDiagnosticReportPerformer;
    function ParseDiagnosticReportPerformerChild(element : TFhirDiagnosticReportPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticReportImage(element : TMXmlElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReportImageChild(element : TFhirDiagnosticReportImage; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
    function ParseDiagnosticReportChild(element : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestContent(element : TMXmlElement; path : string) : TFhirDocumentManifestContent;
    function ParseDocumentManifestContentChild(element : TFhirDocumentManifestContent; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
    function ParseDocumentManifestRelatedChild(element : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentManifestChild(element : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceRelatesToChild(element : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
    function ParseDocumentReferenceContentChild(element : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContext(element : TMXmlElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReferenceContextChild(element : TFhirDocumentReferenceContext; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContextRelated(element : TMXmlElement; path : string) : TFhirDocumentReferenceContextRelated;
    function ParseDocumentReferenceContextRelatedChild(element : TFhirDocumentReferenceContextRelated; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
    function ParseDocumentReferenceChild(element : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    function ParseEligibilityRequest(element : TMXmlElement; path : string) : TFhirEligibilityRequest;
    function ParseEligibilityRequestChild(element : TFhirEligibilityRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    function ParseEligibilityResponseInsurance(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsurance;
    function ParseEligibilityResponseInsuranceChild(element : TFhirEligibilityResponseInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseEligibilityResponseInsuranceBenefitBalance(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsuranceBenefitBalance;
    function ParseEligibilityResponseInsuranceBenefitBalanceChild(element : TFhirEligibilityResponseInsuranceBenefitBalance; path : string; child : TMXmlElement) : boolean;
    function ParseEligibilityResponseInsuranceBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
    function ParseEligibilityResponseInsuranceBenefitBalanceFinancialChild(element : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
    function ParseEligibilityResponseError(element : TMXmlElement; path : string) : TFhirEligibilityResponseError;
    function ParseEligibilityResponseErrorChild(element : TFhirEligibilityResponseError; path : string; child : TMXmlElement) : boolean;
    function ParseEligibilityResponse(element : TMXmlElement; path : string) : TFhirEligibilityResponse;
    function ParseEligibilityResponseChild(element : TFhirEligibilityResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
    function ParseEncounterStatusHistoryChild(element : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterClassHistory(element : TMXmlElement; path : string) : TFhirEncounterClassHistory;
    function ParseEncounterClassHistoryChild(element : TFhirEncounterClassHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterParticipantChild(element : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterDiagnosis(element : TMXmlElement; path : string) : TFhirEncounterDiagnosis;
    function ParseEncounterDiagnosisChild(element : TFhirEncounterDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterHospitalization(element : TMXmlElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterHospitalizationChild(element : TFhirEncounterHospitalization; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
    function ParseEncounterLocationChild(element : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
    function ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
    function ParseEncounterChild(element : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(element : TMXmlElement; path : string) : TFhirEndpoint;
    function ParseEndpointChild(element : TFhirEndpoint; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
    function ParseEnrollmentRequestChild(element : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
    function ParseEnrollmentResponseChild(element : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
    function ParseEpisodeOfCareStatusHistoryChild(element : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCareDiagnosis(element : TMXmlElement; path : string) : TFhirEpisodeOfCareDiagnosis;
    function ParseEpisodeOfCareDiagnosisChild(element : TFhirEpisodeOfCareDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
    function ParseEpisodeOfCareChild(element : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
    function ParseExpansionProfileFixedVersion(element : TMXmlElement; path : string) : TFhirExpansionProfileFixedVersion;
    function ParseExpansionProfileFixedVersionChild(element : TFhirExpansionProfileFixedVersion; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileExcludedSystem(element : TMXmlElement; path : string) : TFhirExpansionProfileExcludedSystem;
    function ParseExpansionProfileExcludedSystemChild(element : TFhirExpansionProfileExcludedSystem; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignation;
    function ParseExpansionProfileDesignationChild(element : TFhirExpansionProfileDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileDesignationInclude(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationInclude;
    function ParseExpansionProfileDesignationIncludeChild(element : TFhirExpansionProfileDesignationInclude; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileDesignationIncludeDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationIncludeDesignation;
    function ParseExpansionProfileDesignationIncludeDesignationChild(element : TFhirExpansionProfileDesignationIncludeDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileDesignationExclude(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationExclude;
    function ParseExpansionProfileDesignationExcludeChild(element : TFhirExpansionProfileDesignationExclude; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfileDesignationExcludeDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationExcludeDesignation;
    function ParseExpansionProfileDesignationExcludeDesignationChild(element : TFhirExpansionProfileDesignationExcludeDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseExpansionProfile(element : TMXmlElement; path : string) : TFhirExpansionProfile;
    function ParseExpansionProfileChild(element : TFhirExpansionProfile; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitRelated;
    function ParseExplanationOfBenefitRelatedChild(element : TFhirExplanationOfBenefitRelated; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitPayee(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayee;
    function ParseExplanationOfBenefitPayeeChild(element : TFhirExplanationOfBenefitPayee; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitInformation(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInformation;
    function ParseExplanationOfBenefitInformationChild(element : TFhirExplanationOfBenefitInformation; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitCareTeam(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitCareTeam;
    function ParseExplanationOfBenefitCareTeamChild(element : TFhirExplanationOfBenefitCareTeam; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitDiagnosis(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitDiagnosis;
    function ParseExplanationOfBenefitDiagnosisChild(element : TFhirExplanationOfBenefitDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitProcedure(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcedure;
    function ParseExplanationOfBenefitProcedureChild(element : TFhirExplanationOfBenefitProcedure; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitInsurance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInsurance;
    function ParseExplanationOfBenefitInsuranceChild(element : TFhirExplanationOfBenefitInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAccident(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAccident;
    function ParseExplanationOfBenefitAccidentChild(element : TFhirExplanationOfBenefitAccident; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItem;
    function ParseExplanationOfBenefitItemChild(element : TFhirExplanationOfBenefitItem; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemAdjudication(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemAdjudication;
    function ParseExplanationOfBenefitItemAdjudicationChild(element : TFhirExplanationOfBenefitItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetail;
    function ParseExplanationOfBenefitItemDetailChild(element : TFhirExplanationOfBenefitItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetailSubDetail;
    function ParseExplanationOfBenefitItemDetailSubDetailChild(element : TFhirExplanationOfBenefitItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItem;
    function ParseExplanationOfBenefitAddItemChild(element : TFhirExplanationOfBenefitAddItem; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetail;
    function ParseExplanationOfBenefitAddItemDetailChild(element : TFhirExplanationOfBenefitAddItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitPayment(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayment;
    function ParseExplanationOfBenefitPaymentChild(element : TFhirExplanationOfBenefitPayment; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitProcessNote(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcessNote;
    function ParseExplanationOfBenefitProcessNoteChild(element : TFhirExplanationOfBenefitProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitBenefitBalance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalance;
    function ParseExplanationOfBenefitBenefitBalanceChild(element : TFhirExplanationOfBenefitBenefitBalance; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    function ParseExplanationOfBenefitBenefitBalanceFinancialChild(element : TFhirExplanationOfBenefitBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
    function ParseExplanationOfBenefitChild(element : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
    function ParseFamilyMemberHistoryConditionChild(element : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
    function ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
    function ParseFamilyMemberHistoryChild(element : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
    function ParseFlagChild(element : TFhirFlag; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(element : TMXmlElement; path : string) : TFhirGoalTarget;
    function ParseGoalTargetChild(element : TFhirGoalTarget; path : string; child : TMXmlElement) : boolean;
    function ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
    function ParseGoalChild(element : TFhirGoal; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(element : TMXmlElement; path : string) : TFhirGraphDefinitionLink;
    function ParseGraphDefinitionLinkChild(element : TFhirGraphDefinitionLink; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinitionLinkTarget(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTarget;
    function ParseGraphDefinitionLinkTargetChild(element : TFhirGraphDefinitionLinkTarget; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinitionLinkTargetCompartment(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTargetCompartment;
    function ParseGraphDefinitionLinkTargetCompartmentChild(element : TFhirGraphDefinitionLinkTargetCompartment; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinition(element : TMXmlElement; path : string) : TFhirGraphDefinition;
    function ParseGraphDefinitionChild(element : TFhirGraphDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroupCharacteristicChild(element : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
    function ParseGroupMemberChild(element : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
    function ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
    function ParseGroupChild(element : TFhirGroup; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(element : TMXmlElement; path : string) : TFhirGuidanceResponse;
    function ParseGuidanceResponseChild(element : TFhirGuidanceResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceAvailableTime(element : TMXmlElement; path : string) : TFhirHealthcareServiceAvailableTime;
    function ParseHealthcareServiceAvailableTimeChild(element : TFhirHealthcareServiceAvailableTime; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareServiceNotAvailable(element : TMXmlElement; path : string) : TFhirHealthcareServiceNotAvailable;
    function ParseHealthcareServiceNotAvailableChild(element : TFhirHealthcareServiceNotAvailable; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
    function ParseHealthcareServiceChild(element : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
    function ParseImagingManifestStudy(element : TMXmlElement; path : string) : TFhirImagingManifestStudy;
    function ParseImagingManifestStudyChild(element : TFhirImagingManifestStudy; path : string; child : TMXmlElement) : boolean;
    function ParseImagingManifestStudySeries(element : TMXmlElement; path : string) : TFhirImagingManifestStudySeries;
    function ParseImagingManifestStudySeriesChild(element : TFhirImagingManifestStudySeries; path : string; child : TMXmlElement) : boolean;
    function ParseImagingManifestStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingManifestStudySeriesInstance;
    function ParseImagingManifestStudySeriesInstanceChild(element : TFhirImagingManifestStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingManifest(element : TMXmlElement; path : string) : TFhirImagingManifest;
    function ParseImagingManifestChild(element : TFhirImagingManifest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesChild(element : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudySeriesInstanceChild(element : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
    function ParseImagingStudyChild(element : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPractitioner(element : TMXmlElement; path : string) : TFhirImmunizationPractitioner;
    function ParseImmunizationPractitionerChild(element : TFhirImmunizationPractitioner; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationExplanation(element : TMXmlElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationExplanationChild(element : TFhirImmunizationExplanation; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationReactionChild(element : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationVaccinationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunizationVaccinationProtocolChild(element : TFhirImmunizationVaccinationProtocol; path : string; child : TMXmlElement) : boolean;
    function ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
    function ParseImmunizationChild(element : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationChild(element : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationDateCriterionChild(element : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendationRecommendationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendationRecommendationProtocolChild(element : TFhirImmunizationRecommendationRecommendationProtocol; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
    function ParseImmunizationRecommendationChild(element : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependency(element : TMXmlElement; path : string) : TFhirImplementationGuideDependency;
    function ParseImplementationGuideDependencyChild(element : TFhirImplementationGuideDependency; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePackage(element : TMXmlElement; path : string) : TFhirImplementationGuidePackage;
    function ParseImplementationGuidePackageChild(element : TFhirImplementationGuidePackage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePackageResource(element : TMXmlElement; path : string) : TFhirImplementationGuidePackageResource;
    function ParseImplementationGuidePackageResourceChild(element : TFhirImplementationGuidePackageResource; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
    function ParseImplementationGuideGlobalChild(element : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePage(element : TMXmlElement; path : string) : TFhirImplementationGuidePage;
    function ParseImplementationGuidePageChild(element : TFhirImplementationGuidePage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
    function ParseImplementationGuideChild(element : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(element : TMXmlElement; path : string) : TFhirLibrary;
    function ParseLibraryChild(element : TFhirLibrary; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(element : TMXmlElement; path : string) : TFhirLinkageItem;
    function ParseLinkageItemChild(element : TFhirLinkageItem; path : string; child : TMXmlElement) : boolean;
    function ParseLinkage(element : TMXmlElement; path : string) : TFhirLinkage;
    function ParseLinkageChild(element : TFhirLinkage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
    function ParseListEntryChild(element : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
    function ParseList(element : TMXmlElement; path : string) : TFhirList;
    function ParseListChild(element : TFhirList; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
    function ParseLocationPositionChild(element : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
    function ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
    function ParseLocationChild(element : TFhirLocation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureGroup(element : TMXmlElement; path : string) : TFhirMeasureGroup;
    function ParseMeasureGroupChild(element : TFhirMeasureGroup; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureGroupPopulation;
    function ParseMeasureGroupPopulationChild(element : TFhirMeasureGroupPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifier;
    function ParseMeasureGroupStratifierChild(element : TFhirMeasureGroupStratifier; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureSupplementalData(element : TMXmlElement; path : string) : TFhirMeasureSupplementalData;
    function ParseMeasureSupplementalDataChild(element : TFhirMeasureSupplementalData; path : string; child : TMXmlElement) : boolean;
    function ParseMeasure(element : TMXmlElement; path : string) : TFhirMeasure;
    function ParseMeasureChild(element : TFhirMeasure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(element : TMXmlElement; path : string) : TFhirMeasureReportGroup;
    function ParseMeasureReportGroupChild(element : TFhirMeasureReportGroup; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupPopulation;
    function ParseMeasureReportGroupPopulationChild(element : TFhirMeasureReportGroupPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifier;
    function ParseMeasureReportGroupStratifierChild(element : TFhirMeasureReportGroupStratifier; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifierStratum(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratum;
    function ParseMeasureReportGroupStratifierStratumChild(element : TFhirMeasureReportGroupStratifierStratum; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifierStratumPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumPopulation;
    function ParseMeasureReportGroupStratifierStratumPopulationChild(element : TFhirMeasureReportGroupStratifierStratumPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReport(element : TMXmlElement; path : string) : TFhirMeasureReport;
    function ParseMeasureReportChild(element : TFhirMeasureReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(element : TMXmlElement; path : string) : TFhirMedia;
    function ParseMediaChild(element : TFhirMedia; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(element : TMXmlElement; path : string) : TFhirMedicationIngredient;
    function ParseMedicationIngredientChild(element : TFhirMedicationIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationPackage(element : TMXmlElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageChild(element : TFhirMedicationPackage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationPackageContent(element : TMXmlElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedicationPackageContentChild(element : TFhirMedicationPackageContent; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationPackageBatch(element : TMXmlElement; path : string) : TFhirMedicationPackageBatch;
    function ParseMedicationPackageBatchChild(element : TFhirMedicationPackageBatch; path : string; child : TMXmlElement) : boolean;
    function ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
    function ParseMedicationChild(element : TFhirMedication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(element : TMXmlElement; path : string) : TFhirMedicationAdministrationPerformer;
    function ParseMedicationAdministrationPerformerChild(element : TFhirMedicationAdministrationPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministrationDosageChild(element : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationAdministrationChild(element : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(element : TMXmlElement; path : string) : TFhirMedicationDispensePerformer;
    function ParseMedicationDispensePerformerChild(element : TFhirMedicationDispensePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispenseSubstitutionChild(element : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationDispenseChild(element : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestRequester(element : TMXmlElement; path : string) : TFhirMedicationRequestRequester;
    function ParseMedicationRequestRequesterChild(element : TFhirMedicationRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequestDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequest;
    function ParseMedicationRequestDispenseRequestChild(element : TFhirMedicationRequestDispenseRequest; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequestSubstitution(element : TMXmlElement; path : string) : TFhirMedicationRequestSubstitution;
    function ParseMedicationRequestSubstitutionChild(element : TFhirMedicationRequestSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequest(element : TMXmlElement; path : string) : TFhirMedicationRequest;
    function ParseMedicationRequestChild(element : TFhirMedicationRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatement(element : TMXmlElement; path : string) : TFhirMedicationStatement;
    function ParseMedicationStatementChild(element : TFhirMedicationStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(element : TMXmlElement; path : string) : TFhirMessageDefinitionFocus;
    function ParseMessageDefinitionFocusChild(element : TFhirMessageDefinitionFocus; path : string; child : TMXmlElement) : boolean;
    function ParseMessageDefinitionAllowedResponse(element : TMXmlElement; path : string) : TFhirMessageDefinitionAllowedResponse;
    function ParseMessageDefinitionAllowedResponseChild(element : TFhirMessageDefinitionAllowedResponse; path : string; child : TMXmlElement) : boolean;
    function ParseMessageDefinition(element : TMXmlElement; path : string) : TFhirMessageDefinition;
    function ParseMessageDefinitionChild(element : TFhirMessageDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeaderDestinationChild(element : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderSourceChild(element : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderResponseChild(element : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
    function ParseMessageHeaderChild(element : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
    function ParseNamingSystemUniqueIdChild(element : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
    function ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
    function ParseNamingSystemChild(element : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
    function ParseNutritionOrderOralDietChild(element : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
    function ParseNutritionOrderOralDietNutrientChild(element : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
    function ParseNutritionOrderOralDietTextureChild(element : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
    function ParseNutritionOrderSupplementChild(element : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
    function ParseNutritionOrderEnteralFormulaChild(element : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
    function ParseNutritionOrderEnteralFormulaAdministrationChild(element : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
    function ParseNutritionOrderChild(element : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationReferenceRangeChild(element : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
    function ParseObservationRelated(element : TMXmlElement; path : string) : TFhirObservationRelated;
    function ParseObservationRelatedChild(element : TFhirObservationRelated; path : string; child : TMXmlElement) : boolean;
    function ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
    function ParseObservationComponentChild(element : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
    function ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
    function ParseObservationChild(element : TFhirObservation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinitionParameterChild(element : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
    function ParseOperationDefinitionParameterBindingChild(element : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionOverload(element : TMXmlElement; path : string) : TFhirOperationDefinitionOverload;
    function ParseOperationDefinitionOverloadChild(element : TFhirOperationDefinitionOverload; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
    function ParseOperationDefinitionChild(element : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcomeIssueChild(element : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
    function ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
    function ParseOperationOutcomeChild(element : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(element : TMXmlElement; path : string) : TFhirOrganizationContact;
    function ParseOrganizationContactChild(element : TFhirOrganizationContact; path : string; child : TMXmlElement) : boolean;
    function ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
    function ParseOrganizationChild(element : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
    function ParsePatientContactChild(element : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
    function ParsePatientAnimal(element : TMXmlElement; path : string) : TFhirPatientAnimal;
    function ParsePatientAnimalChild(element : TFhirPatientAnimal; path : string; child : TMXmlElement) : boolean;
    function ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
    function ParsePatientCommunicationChild(element : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
    function ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
    function ParsePatientLinkChild(element : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
    function ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
    function ParsePatientChild(element : TFhirPatient; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
    function ParsePaymentNoticeChild(element : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(element : TMXmlElement; path : string) : TFhirPaymentReconciliationDetail;
    function ParsePaymentReconciliationDetailChild(element : TFhirPaymentReconciliationDetail; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliationProcessNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationProcessNote;
    function ParsePaymentReconciliationProcessNoteChild(element : TFhirPaymentReconciliationProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
    function ParsePaymentReconciliationChild(element : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
    function ParsePersonLinkChild(element : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
    function ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
    function ParsePersonChild(element : TFhirPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoal;
    function ParsePlanDefinitionGoalChild(element : TFhirPlanDefinitionGoal; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionGoalTarget(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoalTarget;
    function ParsePlanDefinitionGoalTargetChild(element : TFhirPlanDefinitionGoalTarget; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionAction;
    function ParsePlanDefinitionActionChild(element : TFhirPlanDefinitionAction; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionCondition(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionCondition;
    function ParsePlanDefinitionActionConditionChild(element : TFhirPlanDefinitionActionCondition; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionRelatedAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionRelatedAction;
    function ParsePlanDefinitionActionRelatedActionChild(element : TFhirPlanDefinitionActionRelatedAction; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionParticipant(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionParticipant;
    function ParsePlanDefinitionActionParticipantChild(element : TFhirPlanDefinitionActionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionDynamicValue(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionDynamicValue;
    function ParsePlanDefinitionActionDynamicValueChild(element : TFhirPlanDefinitionActionDynamicValue; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinition(element : TMXmlElement; path : string) : TFhirPlanDefinition;
    function ParsePlanDefinitionChild(element : TFhirPlanDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitionerQualificationChild(element : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
    function ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
    function ParsePractitionerChild(element : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRoleAvailableTime(element : TMXmlElement; path : string) : TFhirPractitionerRoleAvailableTime;
    function ParsePractitionerRoleAvailableTimeChild(element : TFhirPractitionerRoleAvailableTime; path : string; child : TMXmlElement) : boolean;
    function ParsePractitionerRoleNotAvailable(element : TMXmlElement; path : string) : TFhirPractitionerRoleNotAvailable;
    function ParsePractitionerRoleNotAvailableChild(element : TFhirPractitionerRoleNotAvailable; path : string; child : TMXmlElement) : boolean;
    function ParsePractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerRole;
    function ParsePractitionerRoleChild(element : TFhirPractitionerRole; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedurePerformerChild(element : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
    function ParseProcedureFocalDeviceChild(element : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
    function ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
    function ParseProcedureChild(element : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    function ParseProcedureRequestRequester(element : TMXmlElement; path : string) : TFhirProcedureRequestRequester;
    function ParseProcedureRequestRequesterChild(element : TFhirProcedureRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseProcedureRequest(element : TMXmlElement; path : string) : TFhirProcedureRequest;
    function ParseProcedureRequestChild(element : TFhirProcedureRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    function ParseProcessRequestItem(element : TMXmlElement; path : string) : TFhirProcessRequestItem;
    function ParseProcessRequestItemChild(element : TFhirProcessRequestItem; path : string; child : TMXmlElement) : boolean;
    function ParseProcessRequest(element : TMXmlElement; path : string) : TFhirProcessRequest;
    function ParseProcessRequestChild(element : TFhirProcessRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    function ParseProcessResponseProcessNote(element : TMXmlElement; path : string) : TFhirProcessResponseProcessNote;
    function ParseProcessResponseProcessNoteChild(element : TFhirProcessResponseProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParseProcessResponse(element : TMXmlElement; path : string) : TFhirProcessResponse;
    function ParseProcessResponseChild(element : TFhirProcessResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceAgentChild(element : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
    function ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenanceEntityChild(element : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
    function ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
    function ParseProvenanceChild(element : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(element : TMXmlElement; path : string) : TFhirQuestionnaireItem;
    function ParseQuestionnaireItemChild(element : TFhirQuestionnaireItem; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireItemEnableWhen(element : TMXmlElement; path : string) : TFhirQuestionnaireItemEnableWhen;
    function ParseQuestionnaireItemEnableWhenChild(element : TFhirQuestionnaireItemEnableWhen; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireItemOption(element : TMXmlElement; path : string) : TFhirQuestionnaireItemOption;
    function ParseQuestionnaireItemOptionChild(element : TFhirQuestionnaireItemOption; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireChild(element : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItem;
    function ParseQuestionnaireResponseItemChild(element : TFhirQuestionnaireResponseItem; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponseItemAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItemAnswer;
    function ParseQuestionnaireResponseItemAnswerChild(element : TFhirQuestionnaireResponseItemAnswer; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
    function ParseQuestionnaireResponseChild(element : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    function ParseReferralRequestRequester(element : TMXmlElement; path : string) : TFhirReferralRequestRequester;
    function ParseReferralRequestRequesterChild(element : TFhirReferralRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseReferralRequest(element : TMXmlElement; path : string) : TFhirReferralRequest;
    function ParseReferralRequestChild(element : TFhirReferralRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
    function ParseRelatedPersonChild(element : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(element : TMXmlElement; path : string) : TFhirRequestGroupAction;
    function ParseRequestGroupActionChild(element : TFhirRequestGroupAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroupActionCondition(element : TMXmlElement; path : string) : TFhirRequestGroupActionCondition;
    function ParseRequestGroupActionConditionChild(element : TFhirRequestGroupActionCondition; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroupActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestGroupActionRelatedAction;
    function ParseRequestGroupActionRelatedActionChild(element : TFhirRequestGroupActionRelatedAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroup(element : TMXmlElement; path : string) : TFhirRequestGroup;
    function ParseRequestGroupChild(element : TFhirRequestGroup; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyArm(element : TMXmlElement; path : string) : TFhirResearchStudyArm;
    function ParseResearchStudyArmChild(element : TFhirResearchStudyArm; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudy(element : TMXmlElement; path : string) : TFhirResearchStudy;
    function ParseResearchStudyChild(element : TFhirResearchStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubject(element : TMXmlElement; path : string) : TFhirResearchSubject;
    function ParseResearchSubjectChild(element : TFhirResearchSubject; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessmentPredictionChild(element : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
    function ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
    function ParseRiskAssessmentChild(element : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
    function ParseScheduleChild(element : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(element : TMXmlElement; path : string) : TFhirSearchParameterComponent;
    function ParseSearchParameterComponentChild(element : TFhirSearchParameterComponent; path : string; child : TMXmlElement) : boolean;
    function ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
    function ParseSearchParameterChild(element : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
    function ParseSequenceReferenceSeq(element : TMXmlElement; path : string) : TFhirSequenceReferenceSeq;
    function ParseSequenceReferenceSeqChild(element : TFhirSequenceReferenceSeq; path : string; child : TMXmlElement) : boolean;
    function ParseSequenceVariant(element : TMXmlElement; path : string) : TFhirSequenceVariant;
    function ParseSequenceVariantChild(element : TFhirSequenceVariant; path : string; child : TMXmlElement) : boolean;
    function ParseSequenceQuality(element : TMXmlElement; path : string) : TFhirSequenceQuality;
    function ParseSequenceQualityChild(element : TFhirSequenceQuality; path : string; child : TMXmlElement) : boolean;
    function ParseSequenceRepository(element : TMXmlElement; path : string) : TFhirSequenceRepository;
    function ParseSequenceRepositoryChild(element : TFhirSequenceRepository; path : string; child : TMXmlElement) : boolean;
    function ParseSequence(element : TMXmlElement; path : string) : TFhirSequence;
    function ParseSequenceChild(element : TFhirSequence; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
    function ParseServiceDefinition(element : TMXmlElement; path : string) : TFhirServiceDefinition;
    function ParseServiceDefinitionChild(element : TFhirServiceDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
    function ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
    function ParseSlotChild(element : TFhirSlot; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenCollectionChild(element : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenProcessing(element : TMXmlElement; path : string) : TFhirSpecimenProcessing;
    function ParseSpecimenProcessingChild(element : TFhirSpecimenProcessing; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimenContainerChild(element : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
    function ParseSpecimenChild(element : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
    function ParseStructureDefinitionMappingChild(element : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
    function ParseStructureDefinitionSnapshotChild(element : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
    function ParseStructureDefinitionDifferentialChild(element : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
    function ParseStructureDefinitionChild(element : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(element : TMXmlElement; path : string) : TFhirStructureMapStructure;
    function ParseStructureMapStructureChild(element : TFhirStructureMapStructure; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroup(element : TMXmlElement; path : string) : TFhirStructureMapGroup;
    function ParseStructureMapGroupChild(element : TFhirStructureMapGroup; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupInput(element : TMXmlElement; path : string) : TFhirStructureMapGroupInput;
    function ParseStructureMapGroupInputChild(element : TFhirStructureMapGroupInput; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRule(element : TMXmlElement; path : string) : TFhirStructureMapGroupRule;
    function ParseStructureMapGroupRuleChild(element : TFhirStructureMapGroupRule; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleSource(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleSource;
    function ParseStructureMapGroupRuleSourceChild(element : TFhirStructureMapGroupRuleSource; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleTarget(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTarget;
    function ParseStructureMapGroupRuleTargetChild(element : TFhirStructureMapGroupRuleTarget; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleTargetParameter(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTargetParameter;
    function ParseStructureMapGroupRuleTargetParameterChild(element : TFhirStructureMapGroupRuleTargetParameter; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleDependent(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleDependent;
    function ParseStructureMapGroupRuleDependentChild(element : TFhirStructureMapGroupRuleDependent; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMap(element : TMXmlElement; path : string) : TFhirStructureMap;
    function ParseStructureMapChild(element : TFhirStructureMap; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(element : TMXmlElement; path : string) : TFhirSubscriptionChannel;
    function ParseSubscriptionChannelChild(element : TFhirSubscriptionChannel; path : string; child : TMXmlElement) : boolean;
    function ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
    function ParseSubscriptionChild(element : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(element : TMXmlElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceInstanceChild(element : TFhirSubstanceInstance; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstanceIngredientChild(element : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
    function ParseSubstanceChild(element : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(element : TMXmlElement; path : string) : TFhirSupplyDeliverySuppliedItem;
    function ParseSupplyDeliverySuppliedItemChild(element : TFhirSupplyDeliverySuppliedItem; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
    function ParseSupplyDeliveryChild(element : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestOrderedItem(element : TMXmlElement; path : string) : TFhirSupplyRequestOrderedItem;
    function ParseSupplyRequestOrderedItemChild(element : TFhirSupplyRequestOrderedItem; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyRequestRequester(element : TMXmlElement; path : string) : TFhirSupplyRequestRequester;
    function ParseSupplyRequestRequesterChild(element : TFhirSupplyRequestRequester; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
    function ParseSupplyRequestChild(element : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRequester(element : TMXmlElement; path : string) : TFhirTaskRequester;
    function ParseTaskRequesterChild(element : TFhirTaskRequester; path : string; child : TMXmlElement) : boolean;
    function ParseTaskRestriction(element : TMXmlElement; path : string) : TFhirTaskRestriction;
    function ParseTaskRestrictionChild(element : TFhirTaskRestriction; path : string; child : TMXmlElement) : boolean;
    function ParseTaskInput(element : TMXmlElement; path : string) : TFhirTaskInput;
    function ParseTaskInputChild(element : TFhirTaskInput; path : string; child : TMXmlElement) : boolean;
    function ParseTaskOutput(element : TMXmlElement; path : string) : TFhirTaskOutput;
    function ParseTaskOutputChild(element : TFhirTaskOutput; path : string; child : TMXmlElement) : boolean;
    function ParseTask(element : TMXmlElement; path : string) : TFhirTask;
    function ParseTaskChild(element : TFhirTask; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(element : TMXmlElement; path : string) : TFhirTestReportParticipant;
    function ParseTestReportParticipantChild(element : TFhirTestReportParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetup(element : TMXmlElement; path : string) : TFhirTestReportSetup;
    function ParseTestReportSetupChild(element : TFhirTestReportSetup; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupAction(element : TMXmlElement; path : string) : TFhirTestReportSetupAction;
    function ParseTestReportSetupActionChild(element : TFhirTestReportSetupAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestReportSetupActionOperation;
    function ParseTestReportSetupActionOperationChild(element : TFhirTestReportSetupActionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestReportSetupActionAssert;
    function ParseTestReportSetupActionAssertChild(element : TFhirTestReportSetupActionAssert; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTest(element : TMXmlElement; path : string) : TFhirTestReportTest;
    function ParseTestReportTestChild(element : TFhirTestReportTest; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTestAction(element : TMXmlElement; path : string) : TFhirTestReportTestAction;
    function ParseTestReportTestActionChild(element : TFhirTestReportTestAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTeardown(element : TMXmlElement; path : string) : TFhirTestReportTeardown;
    function ParseTestReportTeardownChild(element : TFhirTestReportTeardown; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTeardownAction(element : TMXmlElement; path : string) : TFhirTestReportTeardownAction;
    function ParseTestReportTeardownActionChild(element : TFhirTestReportTeardownAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReport(element : TMXmlElement; path : string) : TFhirTestReport;
    function ParseTestReportChild(element : TFhirTestReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(element : TMXmlElement; path : string) : TFhirTestScriptOrigin;
    function ParseTestScriptOriginChild(element : TFhirTestScriptOrigin; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptDestination(element : TMXmlElement; path : string) : TFhirTestScriptDestination;
    function ParseTestScriptDestinationChild(element : TFhirTestScriptDestination; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
    function ParseTestScriptMetadataChild(element : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
    function ParseTestScriptMetadataLinkChild(element : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
    function ParseTestScriptMetadataCapabilityChild(element : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
    function ParseTestScriptFixtureChild(element : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
    function ParseTestScriptVariableChild(element : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptRule(element : TMXmlElement; path : string) : TFhirTestScriptRule;
    function ParseTestScriptRuleChild(element : TFhirTestScriptRule; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptRuleParam;
    function ParseTestScriptRuleParamChild(element : TFhirTestScriptRuleParam; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptRuleset(element : TMXmlElement; path : string) : TFhirTestScriptRuleset;
    function ParseTestScriptRulesetChild(element : TFhirTestScriptRuleset; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptRulesetRule(element : TMXmlElement; path : string) : TFhirTestScriptRulesetRule;
    function ParseTestScriptRulesetRuleChild(element : TFhirTestScriptRulesetRule; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptRulesetRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptRulesetRuleParam;
    function ParseTestScriptRulesetRuleParamChild(element : TFhirTestScriptRulesetRuleParam; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
    function ParseTestScriptSetupChild(element : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
    function ParseTestScriptSetupActionChild(element : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
    function ParseTestScriptSetupActionOperationChild(element : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
    function ParseTestScriptSetupActionOperationRequestHeaderChild(element : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
    function ParseTestScriptSetupActionAssertChild(element : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssertRule(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRule;
    function ParseTestScriptSetupActionAssertRuleChild(element : TFhirTestScriptSetupActionAssertRule; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssertRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRuleParam;
    function ParseTestScriptSetupActionAssertRuleParamChild(element : TFhirTestScriptSetupActionAssertRuleParam; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssertRuleset(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRuleset;
    function ParseTestScriptSetupActionAssertRulesetChild(element : TFhirTestScriptSetupActionAssertRuleset; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssertRulesetRule(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRulesetRule;
    function ParseTestScriptSetupActionAssertRulesetRuleChild(element : TFhirTestScriptSetupActionAssertRulesetRule; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssertRulesetRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRulesetRuleParam;
    function ParseTestScriptSetupActionAssertRulesetRuleParamChild(element : TFhirTestScriptSetupActionAssertRulesetRuleParam; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
    function ParseTestScriptTestChild(element : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
    function ParseTestScriptTestActionChild(element : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
    function ParseTestScriptTeardownChild(element : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
    function ParseTestScriptTeardownActionChild(element : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
    function ParseTestScriptChild(element : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeChild(element : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeChild(element : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeConceptChild(element : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConceptDesignation;
    function ParseValueSetComposeIncludeConceptDesignationChild(element : TFhirValueSetComposeIncludeConceptDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetComposeIncludeFilterChild(element : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionChild(element : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
    function ParseValueSetExpansionParameterChild(element : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSetExpansionContainsChild(element : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
    function ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
    function ParseValueSetChild(element : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionDispense(element : TMXmlElement; path : string) : TFhirVisionPrescriptionDispense;
    function ParseVisionPrescriptionDispenseChild(element : TFhirVisionPrescriptionDispense; path : string; child : TMXmlElement) : boolean;
    function ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
    function ParseVisionPrescriptionChild(element : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(element : TMXmlElement; path : String) : TFhirResource; override;
    function ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(element : TMXmlElement) : TFHIRObject; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase3)
  protected
    procedure ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);

    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement); overload;
    procedure ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);

    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeXhtml(xml : TXmlBuilder; name : String; value : TFhirXhtml);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
    Procedure ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
    Procedure ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
    Procedure ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
    Procedure ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
    procedure ComposeParametersParameterChildren(xml : TXmlBuilder; elem : TFhirParametersParameter);
    procedure ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);
    procedure ComposeParametersChildren(xml : TXmlBuilder; elem : TFhirParameters);
{$ENDIF FHIR_PARAMETERS}

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeExtensionChildren(xml : TXmlBuilder; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposeNarrativeChildren(xml : TXmlBuilder; elem : TFhirNarrative);
    procedure ComposeContributor(xml : TXmlBuilder; name : string; elem : TFhirContributor);
    procedure ComposeContributorChildren(xml : TXmlBuilder; elem : TFhirContributor);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeAttachmentChildren(xml : TXmlBuilder; elem : TFhirAttachment);
    procedure ComposeDataRequirementCodeFilter(xml : TXmlBuilder; name : string; elem : TFhirDataRequirementCodeFilter);
    procedure ComposeDataRequirementCodeFilterChildren(xml : TXmlBuilder; elem : TFhirDataRequirementCodeFilter);
    procedure ComposeDataRequirementDateFilter(xml : TXmlBuilder; name : string; elem : TFhirDataRequirementDateFilter);
    procedure ComposeDataRequirementDateFilterChildren(xml : TXmlBuilder; elem : TFhirDataRequirementDateFilter);
    procedure ComposeDataRequirement(xml : TXmlBuilder; name : string; elem : TFhirDataRequirement);
    procedure ComposeDataRequirementChildren(xml : TXmlBuilder; elem : TFhirDataRequirement);
    procedure ComposeDosage(xml : TXmlBuilder; name : string; elem : TFhirDosage);
    procedure ComposeDosageChildren(xml : TXmlBuilder; elem : TFhirDosage);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeIdentifierChildren(xml : TXmlBuilder; elem : TFhirIdentifier);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeCodingChildren(xml : TXmlBuilder; elem : TFhirCoding);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeSampledDataChildren(xml : TXmlBuilder; elem : TFhirSampledData);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeRatioChildren(xml : TXmlBuilder; elem : TFhirRatio);
    procedure ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
    procedure ComposeReferenceChildren(xml : TXmlBuilder; elem : TFhirReference);
    procedure ComposeTriggerDefinition(xml : TXmlBuilder; name : string; elem : TFhirTriggerDefinition);
    procedure ComposeTriggerDefinitionChildren(xml : TXmlBuilder; elem : TFhirTriggerDefinition);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposePeriodChildren(xml : TXmlBuilder; elem : TFhirPeriod);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeQuantityChildren(xml : TXmlBuilder; elem : TFhirQuantity);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeRangeChildren(xml : TXmlBuilder; elem : TFhirRange);
    procedure ComposeRelatedArtifact(xml : TXmlBuilder; name : string; elem : TFhirRelatedArtifact);
    procedure ComposeRelatedArtifactChildren(xml : TXmlBuilder; elem : TFhirRelatedArtifact);
    procedure ComposeAnnotation(xml : TXmlBuilder; name : string; elem : TFhirAnnotation);
    procedure ComposeAnnotationChildren(xml : TXmlBuilder; elem : TFhirAnnotation);
    procedure ComposeContactDetail(xml : TXmlBuilder; name : string; elem : TFhirContactDetail);
    procedure ComposeContactDetailChildren(xml : TXmlBuilder; elem : TFhirContactDetail);
    procedure ComposeUsageContext(xml : TXmlBuilder; name : string; elem : TFhirUsageContext);
    procedure ComposeUsageContextChildren(xml : TXmlBuilder; elem : TFhirUsageContext);
    procedure ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
    procedure ComposeSignatureChildren(xml : TXmlBuilder; elem : TFhirSignature);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeCodeableConceptChildren(xml : TXmlBuilder; elem : TFhirCodeableConcept);
    procedure ComposeParameterDefinition(xml : TXmlBuilder; name : string; elem : TFhirParameterDefinition);
    procedure ComposeParameterDefinitionChildren(xml : TXmlBuilder; elem : TFhirParameterDefinition);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
    procedure ComposeContactPointChildren(xml : TXmlBuilder; elem : TFhirContactPoint);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeHumanNameChildren(xml : TXmlBuilder; elem : TFhirHumanName);
    procedure ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
    procedure ComposeMetaChildren(xml : TXmlBuilder; elem : TFhirMeta);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeAddressChildren(xml : TXmlBuilder; elem : TFhirAddress);
    procedure ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionSlicingDiscriminator(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicingDiscriminator);
    procedure ComposeElementDefinitionSlicingDiscriminatorChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicingDiscriminator);
    procedure ComposeElementDefinitionBase(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionExample(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionExample);
    procedure ComposeElementDefinitionExampleChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionExample);
    procedure ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
    procedure ComposeElementDefinitionChildren(xml : TXmlBuilder; elem : TFhirElementDefinition);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTimingRepeatChildren(xml : TXmlBuilder; elem : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
    procedure ComposeTimingChildren(xml : TXmlBuilder; elem : TFhirTiming);
    procedure ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
    procedure ComposeCountChildren(xml : TXmlBuilder; elem : TFhirCount);
    procedure ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
    procedure ComposeMoneyChildren(xml : TXmlBuilder; elem : TFhirMoney);
    procedure ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
    procedure ComposeAgeChildren(xml : TXmlBuilder; elem : TFhirAge);
    procedure ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
    procedure ComposeDistanceChildren(xml : TXmlBuilder; elem : TFhirDistance);
    procedure ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);
    procedure ComposeDurationChildren(xml : TXmlBuilder; elem : TFhirDuration);

{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(xml : TXmlBuilder; name : string; elem : TFhirAccountCoverage);
    procedure ComposeAccountCoverageChildren(xml : TXmlBuilder; elem : TFhirAccountCoverage);
    procedure ComposeAccountGuarantor(xml : TXmlBuilder; name : string; elem : TFhirAccountGuarantor);
    procedure ComposeAccountGuarantorChildren(xml : TXmlBuilder; elem : TFhirAccountGuarantor);
    procedure ComposeAccount(xml : TXmlBuilder; name : string; elem : TFhirAccount);
    procedure ComposeAccountChildren(xml : TXmlBuilder; elem : TFhirAccount);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(xml : TXmlBuilder; name : string; elem : TFhirActivityDefinitionParticipant);
    procedure ComposeActivityDefinitionParticipantChildren(xml : TXmlBuilder; elem : TFhirActivityDefinitionParticipant);
    procedure ComposeActivityDefinitionDynamicValue(xml : TXmlBuilder; name : string; elem : TFhirActivityDefinitionDynamicValue);
    procedure ComposeActivityDefinitionDynamicValueChildren(xml : TXmlBuilder; elem : TFhirActivityDefinitionDynamicValue);
    procedure ComposeActivityDefinition(xml : TXmlBuilder; name : string; elem : TFhirActivityDefinition);
    procedure ComposeActivityDefinitionChildren(xml : TXmlBuilder; elem : TFhirActivityDefinition);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventSuspectEntity(xml : TXmlBuilder; name : string; elem : TFhirAdverseEventSuspectEntity);
    procedure ComposeAdverseEventSuspectEntityChildren(xml : TXmlBuilder; elem : TFhirAdverseEventSuspectEntity);
    procedure ComposeAdverseEvent(xml : TXmlBuilder; name : string; elem : TFhirAdverseEvent);
    procedure ComposeAdverseEventChildren(xml : TXmlBuilder; elem : TFhirAdverseEvent);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; elem : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; elem : TFhirAllergyIntolerance);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointmentParticipantChildren(xml : TXmlBuilder; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentChildren(xml : TXmlBuilder; elem : TFhirAppointment);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAppointmentResponseChildren(xml : TXmlBuilder; elem : TFhirAppointmentResponse);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventAgent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventAgent);
    procedure ComposeAuditEventAgentChildren(xml : TXmlBuilder; elem : TFhirAuditEventAgent);
    procedure ComposeAuditEventAgentNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventAgentNetwork);
    procedure ComposeAuditEventAgentNetworkChildren(xml : TXmlBuilder; elem : TFhirAuditEventAgentNetwork);
    procedure ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventSourceChildren(xml : TXmlBuilder; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventEntity(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEntity);
    procedure ComposeAuditEventEntityChildren(xml : TXmlBuilder; elem : TFhirAuditEventEntity);
    procedure ComposeAuditEventEntityDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEntityDetail);
    procedure ComposeAuditEventEntityDetailChildren(xml : TXmlBuilder; elem : TFhirAuditEventEntityDetail);
    procedure ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
    procedure ComposeAuditEventChildren(xml : TXmlBuilder; elem : TFhirAuditEvent);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
    procedure ComposeBasicChildren(xml : TXmlBuilder; elem : TFhirBasic);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
    procedure ComposeBinaryChildren(xml : TXmlBuilder; elem : TFhirBinary);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    procedure ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
    procedure ComposeBodySiteChildren(xml : TXmlBuilder; elem : TFhirBodySite);
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
    procedure ComposeBundleLinkChildren(xml : TXmlBuilder; elem : TFhirBundleLink);
    procedure ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
    procedure ComposeBundleEntryChildren(xml : TXmlBuilder; elem : TFhirBundleEntry);
    procedure ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntrySearchChildren(xml : TXmlBuilder; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntryRequest(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryRequestChildren(xml : TXmlBuilder; elem : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryResponse);
    procedure ComposeBundleEntryResponseChildren(xml : TXmlBuilder; elem : TFhirBundleEntryResponse);
    procedure ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
    procedure ComposeBundleChildren(xml : TXmlBuilder; elem : TFhirBundle);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementSoftware);
    procedure ComposeCapabilityStatementSoftwareChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementSoftware);
    procedure ComposeCapabilityStatementImplementation(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementImplementation);
    procedure ComposeCapabilityStatementImplementationChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementImplementation);
    procedure ComposeCapabilityStatementRest(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRest);
    procedure ComposeCapabilityStatementRestChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRest);
    procedure ComposeCapabilityStatementRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestSecurity);
    procedure ComposeCapabilityStatementRestSecurityChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestSecurity);
    procedure ComposeCapabilityStatementRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestSecurityCertificate);
    procedure ComposeCapabilityStatementRestSecurityCertificateChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestSecurityCertificate);
    procedure ComposeCapabilityStatementRestResource(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestResource);
    procedure ComposeCapabilityStatementRestResourceChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResource);
    procedure ComposeCapabilityStatementRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestResourceInteraction);
    procedure ComposeCapabilityStatementRestResourceInteractionChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResourceInteraction);
    procedure ComposeCapabilityStatementRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestResourceSearchParam);
    procedure ComposeCapabilityStatementRestResourceSearchParamChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResourceSearchParam);
    procedure ComposeCapabilityStatementRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestInteraction);
    procedure ComposeCapabilityStatementRestInteractionChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestInteraction);
    procedure ComposeCapabilityStatementRestOperation(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementRestOperation);
    procedure ComposeCapabilityStatementRestOperationChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestOperation);
    procedure ComposeCapabilityStatementMessaging(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementMessaging);
    procedure ComposeCapabilityStatementMessagingChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessaging);
    procedure ComposeCapabilityStatementMessagingEndpoint(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementMessagingEndpoint);
    procedure ComposeCapabilityStatementMessagingEndpointChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingEndpoint);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementMessagingSupportedMessage);
    procedure ComposeCapabilityStatementMessagingSupportedMessageChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingSupportedMessage);
    procedure ComposeCapabilityStatementMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementMessagingEvent);
    procedure ComposeCapabilityStatementMessagingEventChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingEvent);
    procedure ComposeCapabilityStatementDocument(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatementDocument);
    procedure ComposeCapabilityStatementDocumentChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementDocument);
    procedure ComposeCapabilityStatement(xml : TXmlBuilder; name : string; elem : TFhirCapabilityStatement);
    procedure ComposeCapabilityStatementChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatement);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlanActivityDetailChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeCarePlanChildren(xml : TXmlBuilder; elem : TFhirCarePlan);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(xml : TXmlBuilder; name : string; elem : TFhirCareTeamParticipant);
    procedure ComposeCareTeamParticipantChildren(xml : TXmlBuilder; elem : TFhirCareTeamParticipant);
    procedure ComposeCareTeam(xml : TXmlBuilder; name : string; elem : TFhirCareTeam);
    procedure ComposeCareTeamChildren(xml : TXmlBuilder; elem : TFhirCareTeam);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemParticipant(xml : TXmlBuilder; name : string; elem : TFhirChargeItemParticipant);
    procedure ComposeChargeItemParticipantChildren(xml : TXmlBuilder; elem : TFhirChargeItemParticipant);
    procedure ComposeChargeItem(xml : TXmlBuilder; name : string; elem : TFhirChargeItem);
    procedure ComposeChargeItemChildren(xml : TXmlBuilder; elem : TFhirChargeItem);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(xml : TXmlBuilder; name : string; elem : TFhirClaimRelated);
    procedure ComposeClaimRelatedChildren(xml : TXmlBuilder; elem : TFhirClaimRelated);
    procedure ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
    procedure ComposeClaimPayeeChildren(xml : TXmlBuilder; elem : TFhirClaimPayee);
    procedure ComposeClaimCareTeam(xml : TXmlBuilder; name : string; elem : TFhirClaimCareTeam);
    procedure ComposeClaimCareTeamChildren(xml : TXmlBuilder; elem : TFhirClaimCareTeam);
    procedure ComposeClaimInformation(xml : TXmlBuilder; name : string; elem : TFhirClaimInformation);
    procedure ComposeClaimInformationChildren(xml : TXmlBuilder; elem : TFhirClaimInformation);
    procedure ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimDiagnosisChildren(xml : TXmlBuilder; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimProcedure(xml : TXmlBuilder; name : string; elem : TFhirClaimProcedure);
    procedure ComposeClaimProcedureChildren(xml : TXmlBuilder; elem : TFhirClaimProcedure);
    procedure ComposeClaimInsurance(xml : TXmlBuilder; name : string; elem : TFhirClaimInsurance);
    procedure ComposeClaimInsuranceChildren(xml : TXmlBuilder; elem : TFhirClaimInsurance);
    procedure ComposeClaimAccident(xml : TXmlBuilder; name : string; elem : TFhirClaimAccident);
    procedure ComposeClaimAccidentChildren(xml : TXmlBuilder; elem : TFhirClaimAccident);
    procedure ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
    procedure ComposeClaimItemChildren(xml : TXmlBuilder; elem : TFhirClaimItem);
    procedure ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
    procedure ComposeClaimChildren(xml : TXmlBuilder; elem : TFhirClaim);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponseErrorChildren(xml : TXmlBuilder; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponsePayment(xml : TXmlBuilder; name : string; elem : TFhirClaimResponsePayment);
    procedure ComposeClaimResponsePaymentChildren(xml : TXmlBuilder; elem : TFhirClaimResponsePayment);
    procedure ComposeClaimResponseProcessNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseProcessNote);
    procedure ComposeClaimResponseProcessNoteChildren(xml : TXmlBuilder; elem : TFhirClaimResponseProcessNote);
    procedure ComposeClaimResponseInsurance(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseInsurance);
    procedure ComposeClaimResponseInsuranceChildren(xml : TXmlBuilder; elem : TFhirClaimResponseInsurance);
    procedure ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
    procedure ComposeClaimResponseChildren(xml : TXmlBuilder; elem : TFhirClaimResponse);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigation(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigation);
    procedure ComposeClinicalImpressionInvestigationChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionInvestigation);
    procedure ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
    procedure ComposeClinicalImpressionChildren(xml : TXmlBuilder; elem : TFhirClinicalImpression);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(xml : TXmlBuilder; name : string; elem : TFhirCodeSystemFilter);
    procedure ComposeCodeSystemFilterChildren(xml : TXmlBuilder; elem : TFhirCodeSystemFilter);
    procedure ComposeCodeSystemProperty(xml : TXmlBuilder; name : string; elem : TFhirCodeSystemProperty);
    procedure ComposeCodeSystemPropertyChildren(xml : TXmlBuilder; elem : TFhirCodeSystemProperty);
    procedure ComposeCodeSystemConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeSystemConcept);
    procedure ComposeCodeSystemConceptChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConcept);
    procedure ComposeCodeSystemConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirCodeSystemConceptDesignation);
    procedure ComposeCodeSystemConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConceptDesignation);
    procedure ComposeCodeSystemConceptProperty(xml : TXmlBuilder; name : string; elem : TFhirCodeSystemConceptProperty);
    procedure ComposeCodeSystemConceptPropertyChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConceptProperty);
    procedure ComposeCodeSystem(xml : TXmlBuilder; name : string; elem : TFhirCodeSystem);
    procedure ComposeCodeSystemChildren(xml : TXmlBuilder; elem : TFhirCodeSystem);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
    procedure ComposeCommunicationPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationPayload);
    procedure ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
    procedure ComposeCommunicationChildren(xml : TXmlBuilder; elem : TFhirCommunication);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestRequester);
    procedure ComposeCommunicationRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestRequester);
    procedure ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
    procedure ComposeCommunicationRequestChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequest);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(xml : TXmlBuilder; name : string; elem : TFhirCompartmentDefinitionResource);
    procedure ComposeCompartmentDefinitionResourceChildren(xml : TXmlBuilder; elem : TFhirCompartmentDefinitionResource);
    procedure ComposeCompartmentDefinition(xml : TXmlBuilder; name : string; elem : TFhirCompartmentDefinition);
    procedure ComposeCompartmentDefinitionChildren(xml : TXmlBuilder; elem : TFhirCompartmentDefinition);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionAttesterChildren(xml : TXmlBuilder; elem : TFhirCompositionAttester);
    procedure ComposeCompositionRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirCompositionRelatesTo);
    procedure ComposeCompositionRelatesToChildren(xml : TXmlBuilder; elem : TFhirCompositionRelatesTo);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionEventChildren(xml : TXmlBuilder; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeCompositionSectionChildren(xml : TXmlBuilder; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeCompositionChildren(xml : TXmlBuilder; elem : TFhirComposition);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(xml : TXmlBuilder; name : string; elem : TFhirConceptMapGroup);
    procedure ComposeConceptMapGroupChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroup);
    procedure ComposeConceptMapGroupElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapGroupElement);
    procedure ComposeConceptMapGroupElementChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElement);
    procedure ComposeConceptMapGroupElementTarget(xml : TXmlBuilder; name : string; elem : TFhirConceptMapGroupElementTarget);
    procedure ComposeConceptMapGroupElementTargetChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElementTarget);
    procedure ComposeConceptMapGroupElementTargetDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapGroupElementTargetDependsOn);
    procedure ComposeConceptMapGroupElementTargetDependsOnChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElementTargetDependsOn);
    procedure ComposeConceptMapGroupUnmapped(xml : TXmlBuilder; name : string; elem : TFhirConceptMapGroupUnmapped);
    procedure ComposeConceptMapGroupUnmappedChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupUnmapped);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConceptMapChildren(xml : TXmlBuilder; elem : TFhirConceptMap);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionStageChildren(xml : TXmlBuilder; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionEvidenceChildren(xml : TXmlBuilder; elem : TFhirConditionEvidence);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConditionChildren(xml : TXmlBuilder; elem : TFhirCondition);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentActor(xml : TXmlBuilder; name : string; elem : TFhirConsentActor);
    procedure ComposeConsentActorChildren(xml : TXmlBuilder; elem : TFhirConsentActor);
    procedure ComposeConsentPolicy(xml : TXmlBuilder; name : string; elem : TFhirConsentPolicy);
    procedure ComposeConsentPolicyChildren(xml : TXmlBuilder; elem : TFhirConsentPolicy);
    procedure ComposeConsentData(xml : TXmlBuilder; name : string; elem : TFhirConsentData);
    procedure ComposeConsentDataChildren(xml : TXmlBuilder; elem : TFhirConsentData);
    procedure ComposeConsentExcept(xml : TXmlBuilder; name : string; elem : TFhirConsentExcept);
    procedure ComposeConsentExceptChildren(xml : TXmlBuilder; elem : TFhirConsentExcept);
    procedure ComposeConsentExceptActor(xml : TXmlBuilder; name : string; elem : TFhirConsentExceptActor);
    procedure ComposeConsentExceptActorChildren(xml : TXmlBuilder; elem : TFhirConsentExceptActor);
    procedure ComposeConsentExceptData(xml : TXmlBuilder; name : string; elem : TFhirConsentExceptData);
    procedure ComposeConsentExceptDataChildren(xml : TXmlBuilder; elem : TFhirConsentExceptData);
    procedure ComposeConsent(xml : TXmlBuilder; name : string; elem : TFhirConsent);
    procedure ComposeConsentChildren(xml : TXmlBuilder; elem : TFhirConsent);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractAgent(xml : TXmlBuilder; name : string; elem : TFhirContractAgent);
    procedure ComposeContractAgentChildren(xml : TXmlBuilder; elem : TFhirContractAgent);
    procedure ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
    procedure ComposeContractSignerChildren(xml : TXmlBuilder; elem : TFhirContractSigner);
    procedure ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
    procedure ComposeContractValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractValuedItem);
    procedure ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
    procedure ComposeContractTermChildren(xml : TXmlBuilder; elem : TFhirContractTerm);
    procedure ComposeContractTermAgent(xml : TXmlBuilder; name : string; elem : TFhirContractTermAgent);
    procedure ComposeContractTermAgentChildren(xml : TXmlBuilder; elem : TFhirContractTermAgent);
    procedure ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
    procedure ComposeContractTermValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractTermValuedItem);
    procedure ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
    procedure ComposeContractFriendlyChildren(xml : TXmlBuilder; elem : TFhirContractFriendly);
    procedure ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
    procedure ComposeContractLegalChildren(xml : TXmlBuilder; elem : TFhirContractLegal);
    procedure ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
    procedure ComposeContractRuleChildren(xml : TXmlBuilder; elem : TFhirContractRule);
    procedure ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
    procedure ComposeContractChildren(xml : TXmlBuilder; elem : TFhirContract);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverageGrouping(xml : TXmlBuilder; name : string; elem : TFhirCoverageGrouping);
    procedure ComposeCoverageGroupingChildren(xml : TXmlBuilder; elem : TFhirCoverageGrouping);
    procedure ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
    procedure ComposeCoverageChildren(xml : TXmlBuilder; elem : TFhirCoverage);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    procedure ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElementMappingChildren(xml : TXmlBuilder; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
    procedure ComposeDataElementChildren(xml : TXmlBuilder; elem : TFhirDataElement);
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; elem : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssue(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssue);
    procedure ComposeDetectedIssueChildren(xml : TXmlBuilder; elem : TFhirDetectedIssue);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdi(xml : TXmlBuilder; name : string; elem : TFhirDeviceUdi);
    procedure ComposeDeviceUdiChildren(xml : TXmlBuilder; elem : TFhirDeviceUdi);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceChildren(xml : TXmlBuilder; elem : TFhirDevice);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    procedure ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponentProductionSpecificationChildren(xml : TXmlBuilder; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
    procedure ComposeDeviceComponentChildren(xml : TXmlBuilder; elem : TFhirDeviceComponent);
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
    procedure ComposeDeviceMetricChildren(xml : TXmlBuilder; elem : TFhirDeviceMetric);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirDeviceRequestRequester);
    procedure ComposeDeviceRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirDeviceRequestRequester);
    procedure ComposeDeviceRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceRequest);
    procedure ComposeDeviceRequestChildren(xml : TXmlBuilder; elem : TFhirDeviceRequest);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
    procedure ComposeDeviceUseStatementChildren(xml : TXmlBuilder; elem : TFhirDeviceUseStatement);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportPerformer(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportPerformer);
    procedure ComposeDiagnosticReportPerformerChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportPerformer);
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReportImageChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDiagnosticReportChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReport);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestContentChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentManifestChildren(xml : TXmlBuilder; elem : TFhirDocumentManifest);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReferenceContextRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeDocumentReferenceChildren(xml : TXmlBuilder; elem : TFhirDocumentReference);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    procedure ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
    procedure ComposeEligibilityRequestChildren(xml : TXmlBuilder; elem : TFhirEligibilityRequest);
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    procedure ComposeEligibilityResponseInsurance(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponseInsurance);
    procedure ComposeEligibilityResponseInsuranceChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsurance);
    procedure ComposeEligibilityResponseInsuranceBenefitBalance(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponseInsuranceBenefitBalance);
    procedure ComposeEligibilityResponseInsuranceBenefitBalanceChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsuranceBenefitBalance);
    procedure ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
    procedure ComposeEligibilityResponseInsuranceBenefitBalanceFinancialChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
    procedure ComposeEligibilityResponseError(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponseError);
    procedure ComposeEligibilityResponseErrorChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseError);
    procedure ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
    procedure ComposeEligibilityResponseChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponse);
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterClassHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterClassHistory);
    procedure ComposeEncounterClassHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterClassHistory);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterParticipantChildren(xml : TXmlBuilder; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirEncounterDiagnosis);
    procedure ComposeEncounterDiagnosisChildren(xml : TXmlBuilder; elem : TFhirEncounterDiagnosis);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationChildren(xml : TXmlBuilder; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounterLocationChildren(xml : TXmlBuilder; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeEncounterChildren(xml : TXmlBuilder; elem : TFhirEncounter);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(xml : TXmlBuilder; name : string; elem : TFhirEndpoint);
    procedure ComposeEndpointChildren(xml : TXmlBuilder; elem : TFhirEndpoint);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
    procedure ComposeEnrollmentRequestChildren(xml : TXmlBuilder; elem : TFhirEnrollmentRequest);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
    procedure ComposeEnrollmentResponseChildren(xml : TXmlBuilder; elem : TFhirEnrollmentResponse);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareDiagnosis);
    procedure ComposeEpisodeOfCareDiagnosisChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareDiagnosis);
    procedure ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
    procedure ComposeEpisodeOfCareChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCare);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
    procedure ComposeExpansionProfileFixedVersion(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileFixedVersion);
    procedure ComposeExpansionProfileFixedVersionChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileFixedVersion);
    procedure ComposeExpansionProfileExcludedSystem(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileExcludedSystem);
    procedure ComposeExpansionProfileExcludedSystemChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileExcludedSystem);
    procedure ComposeExpansionProfileDesignation(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileDesignation);
    procedure ComposeExpansionProfileDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignation);
    procedure ComposeExpansionProfileDesignationInclude(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileDesignationInclude);
    procedure ComposeExpansionProfileDesignationIncludeChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationInclude);
    procedure ComposeExpansionProfileDesignationIncludeDesignation(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileDesignationIncludeDesignation);
    procedure ComposeExpansionProfileDesignationIncludeDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationIncludeDesignation);
    procedure ComposeExpansionProfileDesignationExclude(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileDesignationExclude);
    procedure ComposeExpansionProfileDesignationExcludeChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationExclude);
    procedure ComposeExpansionProfileDesignationExcludeDesignation(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfileDesignationExcludeDesignation);
    procedure ComposeExpansionProfileDesignationExcludeDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationExcludeDesignation);
    procedure ComposeExpansionProfile(xml : TXmlBuilder; name : string; elem : TFhirExpansionProfile);
    procedure ComposeExpansionProfileChildren(xml : TXmlBuilder; elem : TFhirExpansionProfile);
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitRelated);
    procedure ComposeExplanationOfBenefitRelatedChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitRelated);
    procedure ComposeExplanationOfBenefitPayee(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitPayee);
    procedure ComposeExplanationOfBenefitPayeeChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitPayee);
    procedure ComposeExplanationOfBenefitInformation(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitInformation);
    procedure ComposeExplanationOfBenefitInformationChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitInformation);
    procedure ComposeExplanationOfBenefitCareTeam(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitCareTeam);
    procedure ComposeExplanationOfBenefitCareTeamChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitCareTeam);
    procedure ComposeExplanationOfBenefitDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitDiagnosis);
    procedure ComposeExplanationOfBenefitDiagnosisChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitDiagnosis);
    procedure ComposeExplanationOfBenefitProcedure(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitProcedure);
    procedure ComposeExplanationOfBenefitProcedureChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitProcedure);
    procedure ComposeExplanationOfBenefitInsurance(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitInsurance);
    procedure ComposeExplanationOfBenefitInsuranceChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitInsurance);
    procedure ComposeExplanationOfBenefitAccident(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitAccident);
    procedure ComposeExplanationOfBenefitAccidentChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAccident);
    procedure ComposeExplanationOfBenefitItem(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitItem);
    procedure ComposeExplanationOfBenefitItemChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItem);
    procedure ComposeExplanationOfBenefitItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitItemAdjudication);
    procedure ComposeExplanationOfBenefitItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemAdjudication);
    procedure ComposeExplanationOfBenefitItemDetail(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitItemDetail);
    procedure ComposeExplanationOfBenefitItemDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemDetail);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitAddItem(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitAddItem);
    procedure ComposeExplanationOfBenefitAddItemChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAddItem);
    procedure ComposeExplanationOfBenefitAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitAddItemDetail);
    procedure ComposeExplanationOfBenefitAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAddItemDetail);
    procedure ComposeExplanationOfBenefitPayment(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitPayment);
    procedure ComposeExplanationOfBenefitPaymentChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitPayment);
    procedure ComposeExplanationOfBenefitProcessNote(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitProcessNote);
    procedure ComposeExplanationOfBenefitProcessNoteChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitProcessNote);
    procedure ComposeExplanationOfBenefitBenefitBalance(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitBenefitBalance);
    procedure ComposeExplanationOfBenefitBenefitBalanceChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitBenefitBalance);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancialChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    procedure ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
    procedure ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefit);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
    procedure ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistory);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
    procedure ComposeFlagChildren(xml : TXmlBuilder; elem : TFhirFlag);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(xml : TXmlBuilder; name : string; elem : TFhirGoalTarget);
    procedure ComposeGoalTargetChildren(xml : TXmlBuilder; elem : TFhirGoalTarget);
    procedure ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
    procedure ComposeGoalChildren(xml : TXmlBuilder; elem : TFhirGoal);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(xml : TXmlBuilder; name : string; elem : TFhirGraphDefinitionLink);
    procedure ComposeGraphDefinitionLinkChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLink);
    procedure ComposeGraphDefinitionLinkTarget(xml : TXmlBuilder; name : string; elem : TFhirGraphDefinitionLinkTarget);
    procedure ComposeGraphDefinitionLinkTargetChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLinkTarget);
    procedure ComposeGraphDefinitionLinkTargetCompartment(xml : TXmlBuilder; name : string; elem : TFhirGraphDefinitionLinkTargetCompartment);
    procedure ComposeGraphDefinitionLinkTargetCompartmentChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLinkTargetCompartment);
    procedure ComposeGraphDefinition(xml : TXmlBuilder; name : string; elem : TFhirGraphDefinition);
    procedure ComposeGraphDefinitionChildren(xml : TXmlBuilder; elem : TFhirGraphDefinition);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroupCharacteristicChildren(xml : TXmlBuilder; elem : TFhirGroupCharacteristic);
    procedure ComposeGroupMember(xml : TXmlBuilder; name : string; elem : TFhirGroupMember);
    procedure ComposeGroupMemberChildren(xml : TXmlBuilder; elem : TFhirGroupMember);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeGroupChildren(xml : TXmlBuilder; elem : TFhirGroup);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(xml : TXmlBuilder; name : string; elem : TFhirGuidanceResponse);
    procedure ComposeGuidanceResponseChildren(xml : TXmlBuilder; elem : TFhirGuidanceResponse);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareServiceNotAvailableChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
    procedure ComposeHealthcareServiceChildren(xml : TXmlBuilder; elem : TFhirHealthcareService);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
    procedure ComposeImagingManifestStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingManifestStudy);
    procedure ComposeImagingManifestStudyChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudy);
    procedure ComposeImagingManifestStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingManifestStudySeries);
    procedure ComposeImagingManifestStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudySeries);
    procedure ComposeImagingManifestStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingManifestStudySeriesInstance);
    procedure ComposeImagingManifestStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudySeriesInstance);
    procedure ComposeImagingManifest(xml : TXmlBuilder; name : string; elem : TFhirImagingManifest);
    procedure ComposeImagingManifestChildren(xml : TXmlBuilder; elem : TFhirImagingManifest);
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImagingStudyChildren(xml : TXmlBuilder; elem : TFhirImagingStudy);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPractitioner(xml : TXmlBuilder; name : string; elem : TFhirImmunizationPractitioner);
    procedure ComposeImmunizationPractitionerChildren(xml : TXmlBuilder; elem : TFhirImmunizationPractitioner);
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationExplanationChildren(xml : TXmlBuilder; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationReactionChildren(xml : TXmlBuilder; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunizationVaccinationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationChildren(xml : TXmlBuilder; elem : TFhirImmunization);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendationRecommendationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendation);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependency(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideDependency);
    procedure ComposeImplementationGuideDependencyChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideDependency);
    procedure ComposeImplementationGuidePackage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackage);
    procedure ComposeImplementationGuidePackageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackage);
    procedure ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackageResource);
    procedure ComposeImplementationGuidePackageResourceChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackageResource);
    procedure ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuidePage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePage);
    procedure ComposeImplementationGuidePageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePage);
    procedure ComposeImplementationGuide(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuide);
    procedure ComposeImplementationGuideChildren(xml : TXmlBuilder; elem : TFhirImplementationGuide);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(xml : TXmlBuilder; name : string; elem : TFhirLibrary);
    procedure ComposeLibraryChildren(xml : TXmlBuilder; elem : TFhirLibrary);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(xml : TXmlBuilder; name : string; elem : TFhirLinkageItem);
    procedure ComposeLinkageItemChildren(xml : TXmlBuilder; elem : TFhirLinkageItem);
    procedure ComposeLinkage(xml : TXmlBuilder; name : string; elem : TFhirLinkage);
    procedure ComposeLinkageChildren(xml : TXmlBuilder; elem : TFhirLinkage);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeListEntryChildren(xml : TXmlBuilder; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeListChildren(xml : TXmlBuilder; elem : TFhirList);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocationPositionChildren(xml : TXmlBuilder; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeLocationChildren(xml : TXmlBuilder; elem : TFhirLocation);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureGroup(xml : TXmlBuilder; name : string; elem : TFhirMeasureGroup);
    procedure ComposeMeasureGroupChildren(xml : TXmlBuilder; elem : TFhirMeasureGroup);
    procedure ComposeMeasureGroupPopulation(xml : TXmlBuilder; name : string; elem : TFhirMeasureGroupPopulation);
    procedure ComposeMeasureGroupPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureGroupPopulation);
    procedure ComposeMeasureGroupStratifier(xml : TXmlBuilder; name : string; elem : TFhirMeasureGroupStratifier);
    procedure ComposeMeasureGroupStratifierChildren(xml : TXmlBuilder; elem : TFhirMeasureGroupStratifier);
    procedure ComposeMeasureSupplementalData(xml : TXmlBuilder; name : string; elem : TFhirMeasureSupplementalData);
    procedure ComposeMeasureSupplementalDataChildren(xml : TXmlBuilder; elem : TFhirMeasureSupplementalData);
    procedure ComposeMeasure(xml : TXmlBuilder; name : string; elem : TFhirMeasure);
    procedure ComposeMeasureChildren(xml : TXmlBuilder; elem : TFhirMeasure);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(xml : TXmlBuilder; name : string; elem : TFhirMeasureReportGroup);
    procedure ComposeMeasureReportGroupChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroup);
    procedure ComposeMeasureReportGroupPopulation(xml : TXmlBuilder; name : string; elem : TFhirMeasureReportGroupPopulation);
    procedure ComposeMeasureReportGroupPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupPopulation);
    procedure ComposeMeasureReportGroupStratifier(xml : TXmlBuilder; name : string; elem : TFhirMeasureReportGroupStratifier);
    procedure ComposeMeasureReportGroupStratifierChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifier);
    procedure ComposeMeasureReportGroupStratifierStratum(xml : TXmlBuilder; name : string; elem : TFhirMeasureReportGroupStratifierStratum);
    procedure ComposeMeasureReportGroupStratifierStratumChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifierStratum);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(xml : TXmlBuilder; name : string; elem : TFhirMeasureReportGroupStratifierStratumPopulation);
    procedure ComposeMeasureReportGroupStratifierStratumPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifierStratumPopulation);
    procedure ComposeMeasureReport(xml : TXmlBuilder; name : string; elem : TFhirMeasureReport);
    procedure ComposeMeasureReportChildren(xml : TXmlBuilder; elem : TFhirMeasureReport);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMediaChildren(xml : TXmlBuilder; elem : TFhirMedia);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationIngredient);
    procedure ComposeMedicationIngredientChildren(xml : TXmlBuilder; elem : TFhirMedicationIngredient);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageChildren(xml : TXmlBuilder; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedicationPackageContentChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageContent);
    procedure ComposeMedicationPackageBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageBatch);
    procedure ComposeMedicationPackageBatchChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageBatch);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationChildren(xml : TXmlBuilder; elem : TFhirMedication);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationPerformer);
    procedure ComposeMedicationAdministrationPerformerChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationPerformer);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationAdministrationChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministration);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispensePerformer);
    procedure ComposeMedicationDispensePerformerChildren(xml : TXmlBuilder; elem : TFhirMedicationDispensePerformer);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationDispenseChildren(xml : TXmlBuilder; elem : TFhirMedicationDispense);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirMedicationRequestRequester);
    procedure ComposeMedicationRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestRequester);
    procedure ComposeMedicationRequestDispenseRequest(xml : TXmlBuilder; name : string; elem : TFhirMedicationRequestDispenseRequest);
    procedure ComposeMedicationRequestDispenseRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestDispenseRequest);
    procedure ComposeMedicationRequestSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationRequestSubstitution);
    procedure ComposeMedicationRequestSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestSubstitution);
    procedure ComposeMedicationRequest(xml : TXmlBuilder; name : string; elem : TFhirMedicationRequest);
    procedure ComposeMedicationRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationRequest);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMedicationStatementChildren(xml : TXmlBuilder; elem : TFhirMedicationStatement);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(xml : TXmlBuilder; name : string; elem : TFhirMessageDefinitionFocus);
    procedure ComposeMessageDefinitionFocusChildren(xml : TXmlBuilder; elem : TFhirMessageDefinitionFocus);
    procedure ComposeMessageDefinitionAllowedResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageDefinitionAllowedResponse);
    procedure ComposeMessageDefinitionAllowedResponseChildren(xml : TXmlBuilder; elem : TFhirMessageDefinitionAllowedResponse);
    procedure ComposeMessageDefinition(xml : TXmlBuilder; name : string; elem : TFhirMessageDefinition);
    procedure ComposeMessageDefinitionChildren(xml : TXmlBuilder; elem : TFhirMessageDefinition);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeMessageHeaderChildren(xml : TXmlBuilder; elem : TFhirMessageHeader);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
    procedure ComposeNamingSystemChildren(xml : TXmlBuilder; elem : TFhirNamingSystem);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
    procedure ComposeNutritionOrderChildren(xml : TXmlBuilder; elem : TFhirNutritionOrder);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservationRelatedChildren(xml : TXmlBuilder; elem : TFhirObservationRelated);
    procedure ComposeObservationComponent(xml : TXmlBuilder; name : string; elem : TFhirObservationComponent);
    procedure ComposeObservationComponentChildren(xml : TXmlBuilder; elem : TFhirObservationComponent);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeObservationChildren(xml : TXmlBuilder; elem : TFhirObservation);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinitionOverload(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionOverload);
    procedure ComposeOperationDefinitionOverloadChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionOverload);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationDefinitionChildren(xml : TXmlBuilder; elem : TFhirOperationDefinition);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOperationOutcomeChildren(xml : TXmlBuilder; elem : TFhirOperationOutcome);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganizationContactChildren(xml : TXmlBuilder; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposeOrganizationChildren(xml : TXmlBuilder; elem : TFhirOrganization);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientContactChildren(xml : TXmlBuilder; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientAnimalChildren(xml : TXmlBuilder; elem : TFhirPatientAnimal);
    procedure ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
    procedure ComposePatientCommunicationChildren(xml : TXmlBuilder; elem : TFhirPatientCommunication);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatientLinkChildren(xml : TXmlBuilder; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePatientChildren(xml : TXmlBuilder; elem : TFhirPatient);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
    procedure ComposePaymentNoticeChildren(xml : TXmlBuilder; elem : TFhirPaymentNotice);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationDetailChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationProcessNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationProcessNote);
    procedure ComposePaymentReconciliationProcessNoteChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationProcessNote);
    procedure ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
    procedure ComposePaymentReconciliationChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliation);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
    procedure ComposePersonLinkChildren(xml : TXmlBuilder; elem : TFhirPersonLink);
    procedure ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
    procedure ComposePersonChildren(xml : TXmlBuilder; elem : TFhirPerson);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionGoal);
    procedure ComposePlanDefinitionGoalChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionGoal);
    procedure ComposePlanDefinitionGoalTarget(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionGoalTarget);
    procedure ComposePlanDefinitionGoalTargetChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionGoalTarget);
    procedure ComposePlanDefinitionAction(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionAction);
    procedure ComposePlanDefinitionActionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionAction);
    procedure ComposePlanDefinitionActionCondition(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionActionCondition);
    procedure ComposePlanDefinitionActionConditionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionCondition);
    procedure ComposePlanDefinitionActionRelatedAction(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionActionRelatedAction);
    procedure ComposePlanDefinitionActionRelatedActionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionRelatedAction);
    procedure ComposePlanDefinitionActionParticipant(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionActionParticipant);
    procedure ComposePlanDefinitionActionParticipantChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionParticipant);
    procedure ComposePlanDefinitionActionDynamicValue(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinitionActionDynamicValue);
    procedure ComposePlanDefinitionActionDynamicValueChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionDynamicValue);
    procedure ComposePlanDefinition(xml : TXmlBuilder; name : string; elem : TFhirPlanDefinition);
    procedure ComposePlanDefinitionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinition);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitionerQualificationChildren(xml : TXmlBuilder; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposePractitionerChildren(xml : TXmlBuilder; elem : TFhirPractitioner);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRoleAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirPractitionerRoleAvailableTime);
    procedure ComposePractitionerRoleAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirPractitionerRoleAvailableTime);
    procedure ComposePractitionerRoleNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirPractitionerRoleNotAvailable);
    procedure ComposePractitionerRoleNotAvailableChildren(xml : TXmlBuilder; elem : TFhirPractitionerRoleNotAvailable);
    procedure ComposePractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerRole);
    procedure ComposePractitionerRoleChildren(xml : TXmlBuilder; elem : TFhirPractitionerRole);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedurePerformerChildren(xml : TXmlBuilder; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureFocalDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureFocalDevice);
    procedure ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; elem : TFhirProcedureFocalDevice);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProcedureChildren(xml : TXmlBuilder; elem : TFhirProcedure);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    procedure ComposeProcedureRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequestRequester);
    procedure ComposeProcedureRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirProcedureRequestRequester);
    procedure ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
    procedure ComposeProcedureRequestChildren(xml : TXmlBuilder; elem : TFhirProcedureRequest);
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    procedure ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequestItemChildren(xml : TXmlBuilder; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
    procedure ComposeProcessRequestChildren(xml : TXmlBuilder; elem : TFhirProcessRequest);
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    procedure ComposeProcessResponseProcessNote(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseProcessNote);
    procedure ComposeProcessResponseProcessNoteChildren(xml : TXmlBuilder; elem : TFhirProcessResponseProcessNote);
    procedure ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
    procedure ComposeProcessResponseChildren(xml : TXmlBuilder; elem : TFhirProcessResponse);
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenanceEntityChildren(xml : TXmlBuilder; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeProvenanceChildren(xml : TXmlBuilder; elem : TFhirProvenance);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireItem);
    procedure ComposeQuestionnaireItemChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItem);
    procedure ComposeQuestionnaireItemEnableWhen(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireItemEnableWhen);
    procedure ComposeQuestionnaireItemEnableWhenChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItemEnableWhen);
    procedure ComposeQuestionnaireItemOption(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireItemOption);
    procedure ComposeQuestionnaireItemOptionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItemOption);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireChildren(xml : TXmlBuilder; elem : TFhirQuestionnaire);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseItem);
    procedure ComposeQuestionnaireResponseItemChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseItem);
    procedure ComposeQuestionnaireResponseItemAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseItemAnswer);
    procedure ComposeQuestionnaireResponseItemAnswerChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseItemAnswer);
    procedure ComposeQuestionnaireResponse(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponse);
    procedure ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponse);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    procedure ComposeReferralRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirReferralRequestRequester);
    procedure ComposeReferralRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirReferralRequestRequester);
    procedure ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
    procedure ComposeReferralRequestChildren(xml : TXmlBuilder; elem : TFhirReferralRequest);
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRelatedPersonChildren(xml : TXmlBuilder; elem : TFhirRelatedPerson);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(xml : TXmlBuilder; name : string; elem : TFhirRequestGroupAction);
    procedure ComposeRequestGroupActionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupAction);
    procedure ComposeRequestGroupActionCondition(xml : TXmlBuilder; name : string; elem : TFhirRequestGroupActionCondition);
    procedure ComposeRequestGroupActionConditionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupActionCondition);
    procedure ComposeRequestGroupActionRelatedAction(xml : TXmlBuilder; name : string; elem : TFhirRequestGroupActionRelatedAction);
    procedure ComposeRequestGroupActionRelatedActionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupActionRelatedAction);
    procedure ComposeRequestGroup(xml : TXmlBuilder; name : string; elem : TFhirRequestGroup);
    procedure ComposeRequestGroupChildren(xml : TXmlBuilder; elem : TFhirRequestGroup);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyArm(xml : TXmlBuilder; name : string; elem : TFhirResearchStudyArm);
    procedure ComposeResearchStudyArmChildren(xml : TXmlBuilder; elem : TFhirResearchStudyArm);
    procedure ComposeResearchStudy(xml : TXmlBuilder; name : string; elem : TFhirResearchStudy);
    procedure ComposeResearchStudyChildren(xml : TXmlBuilder; elem : TFhirResearchStudy);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubject(xml : TXmlBuilder; name : string; elem : TFhirResearchSubject);
    procedure ComposeResearchSubjectChildren(xml : TXmlBuilder; elem : TFhirResearchSubject);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
    procedure ComposeRiskAssessmentChildren(xml : TXmlBuilder; elem : TFhirRiskAssessment);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
    procedure ComposeScheduleChildren(xml : TXmlBuilder; elem : TFhirSchedule);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterComponent);
    procedure ComposeSearchParameterComponentChildren(xml : TXmlBuilder; elem : TFhirSearchParameterComponent);
    procedure ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
    procedure ComposeSearchParameterChildren(xml : TXmlBuilder; elem : TFhirSearchParameter);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
    procedure ComposeSequenceReferenceSeq(xml : TXmlBuilder; name : string; elem : TFhirSequenceReferenceSeq);
    procedure ComposeSequenceReferenceSeqChildren(xml : TXmlBuilder; elem : TFhirSequenceReferenceSeq);
    procedure ComposeSequenceVariant(xml : TXmlBuilder; name : string; elem : TFhirSequenceVariant);
    procedure ComposeSequenceVariantChildren(xml : TXmlBuilder; elem : TFhirSequenceVariant);
    procedure ComposeSequenceQuality(xml : TXmlBuilder; name : string; elem : TFhirSequenceQuality);
    procedure ComposeSequenceQualityChildren(xml : TXmlBuilder; elem : TFhirSequenceQuality);
    procedure ComposeSequenceRepository(xml : TXmlBuilder; name : string; elem : TFhirSequenceRepository);
    procedure ComposeSequenceRepositoryChildren(xml : TXmlBuilder; elem : TFhirSequenceRepository);
    procedure ComposeSequence(xml : TXmlBuilder; name : string; elem : TFhirSequence);
    procedure ComposeSequenceChildren(xml : TXmlBuilder; elem : TFhirSequence);
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
    procedure ComposeServiceDefinition(xml : TXmlBuilder; name : string; elem : TFhirServiceDefinition);
    procedure ComposeServiceDefinitionChildren(xml : TXmlBuilder; elem : TFhirServiceDefinition);
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
    procedure ComposeSlotChildren(xml : TXmlBuilder; elem : TFhirSlot);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenCollectionChildren(xml : TXmlBuilder; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenProcessing(xml : TXmlBuilder; name : string; elem : TFhirSpecimenProcessing);
    procedure ComposeSpecimenProcessingChildren(xml : TXmlBuilder; elem : TFhirSpecimenProcessing);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimenContainerChildren(xml : TXmlBuilder; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeSpecimenChildren(xml : TXmlBuilder; elem : TFhirSpecimen);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
    procedure ComposeStructureDefinitionChildren(xml : TXmlBuilder; elem : TFhirStructureDefinition);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(xml : TXmlBuilder; name : string; elem : TFhirStructureMapStructure);
    procedure ComposeStructureMapStructureChildren(xml : TXmlBuilder; elem : TFhirStructureMapStructure);
    procedure ComposeStructureMapGroup(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroup);
    procedure ComposeStructureMapGroupChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroup);
    procedure ComposeStructureMapGroupInput(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupInput);
    procedure ComposeStructureMapGroupInputChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupInput);
    procedure ComposeStructureMapGroupRule(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupRule);
    procedure ComposeStructureMapGroupRuleChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRule);
    procedure ComposeStructureMapGroupRuleSource(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupRuleSource);
    procedure ComposeStructureMapGroupRuleSourceChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleSource);
    procedure ComposeStructureMapGroupRuleTarget(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupRuleTarget);
    procedure ComposeStructureMapGroupRuleTargetChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleTarget);
    procedure ComposeStructureMapGroupRuleTargetParameter(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupRuleTargetParameter);
    procedure ComposeStructureMapGroupRuleTargetParameterChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleTargetParameter);
    procedure ComposeStructureMapGroupRuleDependent(xml : TXmlBuilder; name : string; elem : TFhirStructureMapGroupRuleDependent);
    procedure ComposeStructureMapGroupRuleDependentChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleDependent);
    procedure ComposeStructureMap(xml : TXmlBuilder; name : string; elem : TFhirStructureMap);
    procedure ComposeStructureMapChildren(xml : TXmlBuilder; elem : TFhirStructureMap);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscriptionChannelChildren(xml : TXmlBuilder; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
    procedure ComposeSubscriptionChildren(xml : TXmlBuilder; elem : TFhirSubscription);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceInstanceChildren(xml : TXmlBuilder; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstanceIngredientChildren(xml : TXmlBuilder; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSubstanceChildren(xml : TXmlBuilder; elem : TFhirSubstance);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(xml : TXmlBuilder; name : string; elem : TFhirSupplyDeliverySuppliedItem);
    procedure ComposeSupplyDeliverySuppliedItemChildren(xml : TXmlBuilder; elem : TFhirSupplyDeliverySuppliedItem);
    procedure ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
    procedure ComposeSupplyDeliveryChildren(xml : TXmlBuilder; elem : TFhirSupplyDelivery);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestOrderedItem(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequestOrderedItem);
    procedure ComposeSupplyRequestOrderedItemChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestOrderedItem);
    procedure ComposeSupplyRequestRequester(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequestRequester);
    procedure ComposeSupplyRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestRequester);
    procedure ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
    procedure ComposeSupplyRequestChildren(xml : TXmlBuilder; elem : TFhirSupplyRequest);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRequester(xml : TXmlBuilder; name : string; elem : TFhirTaskRequester);
    procedure ComposeTaskRequesterChildren(xml : TXmlBuilder; elem : TFhirTaskRequester);
    procedure ComposeTaskRestriction(xml : TXmlBuilder; name : string; elem : TFhirTaskRestriction);
    procedure ComposeTaskRestrictionChildren(xml : TXmlBuilder; elem : TFhirTaskRestriction);
    procedure ComposeTaskInput(xml : TXmlBuilder; name : string; elem : TFhirTaskInput);
    procedure ComposeTaskInputChildren(xml : TXmlBuilder; elem : TFhirTaskInput);
    procedure ComposeTaskOutput(xml : TXmlBuilder; name : string; elem : TFhirTaskOutput);
    procedure ComposeTaskOutputChildren(xml : TXmlBuilder; elem : TFhirTaskOutput);
    procedure ComposeTask(xml : TXmlBuilder; name : string; elem : TFhirTask);
    procedure ComposeTaskChildren(xml : TXmlBuilder; elem : TFhirTask);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(xml : TXmlBuilder; name : string; elem : TFhirTestReportParticipant);
    procedure ComposeTestReportParticipantChildren(xml : TXmlBuilder; elem : TFhirTestReportParticipant);
    procedure ComposeTestReportSetup(xml : TXmlBuilder; name : string; elem : TFhirTestReportSetup);
    procedure ComposeTestReportSetupChildren(xml : TXmlBuilder; elem : TFhirTestReportSetup);
    procedure ComposeTestReportSetupAction(xml : TXmlBuilder; name : string; elem : TFhirTestReportSetupAction);
    procedure ComposeTestReportSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupAction);
    procedure ComposeTestReportSetupActionOperation(xml : TXmlBuilder; name : string; elem : TFhirTestReportSetupActionOperation);
    procedure ComposeTestReportSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupActionOperation);
    procedure ComposeTestReportSetupActionAssert(xml : TXmlBuilder; name : string; elem : TFhirTestReportSetupActionAssert);
    procedure ComposeTestReportSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupActionAssert);
    procedure ComposeTestReportTest(xml : TXmlBuilder; name : string; elem : TFhirTestReportTest);
    procedure ComposeTestReportTestChildren(xml : TXmlBuilder; elem : TFhirTestReportTest);
    procedure ComposeTestReportTestAction(xml : TXmlBuilder; name : string; elem : TFhirTestReportTestAction);
    procedure ComposeTestReportTestActionChildren(xml : TXmlBuilder; elem : TFhirTestReportTestAction);
    procedure ComposeTestReportTeardown(xml : TXmlBuilder; name : string; elem : TFhirTestReportTeardown);
    procedure ComposeTestReportTeardownChildren(xml : TXmlBuilder; elem : TFhirTestReportTeardown);
    procedure ComposeTestReportTeardownAction(xml : TXmlBuilder; name : string; elem : TFhirTestReportTeardownAction);
    procedure ComposeTestReportTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestReportTeardownAction);
    procedure ComposeTestReport(xml : TXmlBuilder; name : string; elem : TFhirTestReport);
    procedure ComposeTestReportChildren(xml : TXmlBuilder; elem : TFhirTestReport);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(xml : TXmlBuilder; name : string; elem : TFhirTestScriptOrigin);
    procedure ComposeTestScriptOriginChildren(xml : TXmlBuilder; elem : TFhirTestScriptOrigin);
    procedure ComposeTestScriptDestination(xml : TXmlBuilder; name : string; elem : TFhirTestScriptDestination);
    procedure ComposeTestScriptDestinationChildren(xml : TXmlBuilder; elem : TFhirTestScriptDestination);
    procedure ComposeTestScriptMetadata(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptFixture(xml : TXmlBuilder; name : string; elem : TFhirTestScriptFixture);
    procedure ComposeTestScriptFixtureChildren(xml : TXmlBuilder; elem : TFhirTestScriptFixture);
    procedure ComposeTestScriptVariable(xml : TXmlBuilder; name : string; elem : TFhirTestScriptVariable);
    procedure ComposeTestScriptVariableChildren(xml : TXmlBuilder; elem : TFhirTestScriptVariable);
    procedure ComposeTestScriptRule(xml : TXmlBuilder; name : string; elem : TFhirTestScriptRule);
    procedure ComposeTestScriptRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptRule);
    procedure ComposeTestScriptRuleParam(xml : TXmlBuilder; name : string; elem : TFhirTestScriptRuleParam);
    procedure ComposeTestScriptRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptRuleParam);
    procedure ComposeTestScriptRuleset(xml : TXmlBuilder; name : string; elem : TFhirTestScriptRuleset);
    procedure ComposeTestScriptRulesetChildren(xml : TXmlBuilder; elem : TFhirTestScriptRuleset);
    procedure ComposeTestScriptRulesetRule(xml : TXmlBuilder; name : string; elem : TFhirTestScriptRulesetRule);
    procedure ComposeTestScriptRulesetRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptRulesetRule);
    procedure ComposeTestScriptRulesetRuleParam(xml : TXmlBuilder; name : string; elem : TFhirTestScriptRulesetRuleParam);
    procedure ComposeTestScriptRulesetRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptRulesetRuleParam);
    procedure ComposeTestScriptSetup(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptSetupActionAssertRule(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssertRule);
    procedure ComposeTestScriptSetupActionAssertRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRule);
    procedure ComposeTestScriptSetupActionAssertRuleParam(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssertRuleParam);
    procedure ComposeTestScriptSetupActionAssertRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRuleParam);
    procedure ComposeTestScriptSetupActionAssertRuleset(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssertRuleset);
    procedure ComposeTestScriptSetupActionAssertRulesetChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRuleset);
    procedure ComposeTestScriptSetupActionAssertRulesetRule(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssertRulesetRule);
    procedure ComposeTestScriptSetupActionAssertRulesetRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRulesetRule);
    procedure ComposeTestScriptSetupActionAssertRulesetRuleParam(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam);
    procedure ComposeTestScriptSetupActionAssertRulesetRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam);
    procedure ComposeTestScriptTest(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTest);
    procedure ComposeTestScriptTestChildren(xml : TXmlBuilder; elem : TFhirTestScriptTest);
    procedure ComposeTestScriptTestAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTestActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTeardown(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardownAction);
    procedure ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardownAction);
    procedure ComposeTestScript(xml : TXmlBuilder; name : string; elem : TFhirTestScript);
    procedure ComposeTestScriptChildren(xml : TXmlBuilder; elem : TFhirTestScript);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeChildren(xml : TXmlBuilder; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConceptDesignation);
    procedure ComposeValueSetComposeIncludeConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConceptDesignation);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeValueSetChildren(xml : TXmlBuilder; elem : TFhirValueSet);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescriptionDispenseChildren(xml : TXmlBuilder; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
    procedure ComposeVisionPrescriptionChildren(xml : TXmlBuilder; elem : TFhirVisionPrescription);
{$ENDIF FHIR_VISIONPRESCRIPTION}
  public
    procedure ComposeResource(xml : TXmlBuilder; resource : TFhirResource); override;
    procedure ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject); override;
  end;

implementation

{ TFHIRXmlParser }

function TFHIRXmlParser.ParseElement(element : TMXmlElement; path : string) : TFhirElement;
var
  child : TMXmlElement;
begin
  result := TFhirElement.create;
  try
    parseElementAttributes(result, path, element);
    result.id := GetAttribute(element, 'id');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElement(xml : TXmlBuilder; name : String; elem : TFhirElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'id', elem.id  );
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
begin
  TakeCommentsStart(value);
  GetObjectLocation(value, element);
  value.Id := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.Id);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensionList then
    for i := 0 to element.extensionList.count - 1 do
      ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensionList then
    for i := 0 to element.modifierExtensionList.count - 1 do
      ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

function TFHIRXmlParser.ParseBackboneElement(element : TMXmlElement; path : string) : TFhirBackboneElement;
var
  child : TMXmlElement;
begin
  result := TFhirBackboneElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBackboneElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBackboneElement(xml : TXmlBuilder; name : String; elem : TFhirBackboneElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : TMXmlElement) : TFhirEnum;
var
  child : TMXmlElement;
  i : integer;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    i := StringArrayIndexOfSensitive(aNames, result.value);
    if i < 0 then
      raise EXmlException.create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    result.system := aSystems[i];
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDate(element : TMXmlElement; path : string) : TFhirDate;
var
  child : TMXmlElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
var
  child : TMXmlElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseString(element : TMXmlElement; path : string) : TFhirString;
var
  child : TMXmlElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
var
  child : TMXmlElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUri(element : TMXmlElement; path : string) : TFhirUri;
var
  child : TMXmlElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
var
  child : TMXmlElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseXhtml(element : TMXmlElement; path : string) : TFhirXhtml;
var
  child : TMXmlElement;
begin
  result := TFhirXhtml.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeXhtml(xml : TXmlBuilder; name : String; value : TFhirXhtml);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
var
  child : TMXmlElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
var
  child : TMXmlElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTBytes(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or ((value.value = nil) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value <> nil) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseTime(element : TMXmlElement; path : string) : TFhirTime;
var
  child : TMXmlElement;
begin
  result := TFhirTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
var
  child : TMXmlElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseCode(element : TMXmlElement; path : string) : TFhirCode;
var
  child : TMXmlElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseOid(element : TMXmlElement; path : string) : TFhirOid;
var
  child : TMXmlElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
var
  child : TMXmlElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
var
  child : TMXmlElement;
begin
  result := TFhirMarkdown.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
var
  child : TMXmlElement;
begin
  result := TFhirUnsignedInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseId(element : TMXmlElement; path : string) : TFhirId;
var
  child : TMXmlElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;
var
  child : TMXmlElement;
begin
  result := TFhirPositiveInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : TMXmlElement);
begin
  GetObjectLocation(resource, element);
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'id') then
    resource.idElement := ParseId(child, path+'/id') {b}
  else if (child.localName = 'meta') then
    resource.meta := ParseMeta(child, path+'/meta') {b}
  else if (child.localName = 'implicitRules') then
    resource.implicitRulesElement := ParseUri(child, path+'/implicitRules') {b}
  else if (child.localName = 'language') then
    resource.languageElement := ParseCode(child, path+'/language') {b}
  else
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'id', elem.idElement);{x.2b}
  if (true) {(SummaryOption in [soFull, soSummary, soData]) and doCompose('meta')} then
    ComposeMeta(xml, 'meta', elem.meta);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUri(xml, 'implicitRules', elem.implicitRulesElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
end;

Procedure TFHIRXmlParser.ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : TMXmlElement);
begin
  ParseResourceAttributes(resource, path, element);
end;

Function TFHIRXmlParser.ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'text') then
    resource.text := ParseNarrative(child, path+'/text') {b}
  else if (child.localName = 'contained') then
    resource.containedList.Add(ParseInnerResource(child, path+'/contained')){y.2}
  else if (child.localName = 'extension') then
    resource.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
  else if (child.localName = 'modifierExtension') then
    resource.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
  else if not parseResourceChild(resource, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
begin
  ComposeResourceAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
var
  i : integer;{z.a}
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(xml, 'text', elem.text);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(xml, 'contained', elem, elem.containedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('extension') then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', elem.extensionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
end;

{$IFDEF FHIR_PARAMETERS}
function TFHIRXmlParser.ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
var
  child : TMXmlElement;
begin
  result := TFhirParametersParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersParameterChild(element : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'/valueMarkdown'){x.3}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'/valueOid'){x.3}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'/valuePositiveInt'){x.3}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'/valueUnsignedInt'){x.3}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress'){x.3}
      else if (child.localName = 'valueAge') then
        element.value := ParseAge(child, path+'/valueAge'){x.3}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'/valueAnnotation'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint'){x.3}
      else if (child.localName = 'valueCount') then
        element.value := ParseCount(child, path+'/valueCount'){x.3}
      else if (child.localName = 'valueDistance') then
        element.value := ParseDistance(child, path+'/valueDistance'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName'){x.3}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'/valueIdentifier'){x.3}
      else if (child.localName = 'valueMoney') then
        element.value := ParseMoney(child, path+'/valueMoney'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'/valueSignature'){x.3}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming'){x.3}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta'){x.3}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'/valueBase64Binary'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.localName = 'resource') then
        element.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.localName = 'part') then
        element.partList.Add(ParseParametersParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParametersParameter(xml : TXmlBuilder; name : String; elem : TFhirParametersParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersParameterChildren(xml : TXmlBuilder; elem : TFhirParametersParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(xml, 'part', elem.partList[i]);
end;

function TFHIRXmlParser.ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
var
  child : TMXmlElement;
begin
  result := TFhirParameters.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersChild(element : TFhirParameters; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'parameter') then
        element.parameterList.Add(ParseParametersParameter(child, path+'/parameter')){y.2}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParameters(xml : TXmlBuilder; name : String; elem : TFhirParameters);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersChildren(xml : TXmlBuilder; elem : TFhirParameters);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(xml, 'parameter', elem.parameterList[i]);
end;

{$ENDIF FHIR_PARAMETERS}
function TFHIRXmlParser.ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
var
  child : TMXmlElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExtensionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExtensionChild(element : TFhirExtension; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'/valueMarkdown'){x.3}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'/valueOid'){x.3}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'/valuePositiveInt'){x.3}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'/valueUnsignedInt'){x.3}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress'){x.3}
      else if (child.localName = 'valueAge') then
        element.value := ParseAge(child, path+'/valueAge'){x.3}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'/valueAnnotation'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint'){x.3}
      else if (child.localName = 'valueCount') then
        element.value := ParseCount(child, path+'/valueCount'){x.3}
      else if (child.localName = 'valueDistance') then
        element.value := ParseDistance(child, path+'/valueDistance'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName'){x.3}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'/valueIdentifier'){x.3}
      else if (child.localName = 'valueMoney') then
        element.value := ParseMoney(child, path+'/valueMoney'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'/valueSignature'){x.3}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming'){x.3}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta'){x.3}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'/valueBase64Binary'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : String; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.url  );
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExtensionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExtensionChildren(xml : TXmlBuilder; elem : TFhirExtension);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
var
  child : TMXmlElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNarrativeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrativeChild(element : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'div') then
        element.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : String; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNarrativeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNarrativeChildren(xml : TXmlBuilder; elem : TFhirNarrative);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum);
  ComposeXHtmlNode(xml, 'div', elem.div_);{x.2a}
end;

function TFHIRXmlParser.ParseContributor(element : TMXmlElement; path : string) : TFhirContributor;
var
  child : TMXmlElement;
begin
  result := TFhirContributor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContributorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContributorChild(element : TFhirContributor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContributor(xml : TXmlBuilder; name : String; elem : TFhirContributor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContributorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContributorChildren(xml : TXmlBuilder; elem : TFhirContributor);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirContributorTypeEnum);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
end;

function TFHIRXmlParser.ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
var
  child : TMXmlElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAttachmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAttachmentChild(element : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'data') then
        element.dataElement := ParseBase64Binary(child, path+'/data') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'size') then
        element.sizeElement := ParseUnsignedInt(child, path+'/size') {b}
      else if (child.localName = 'hash') then
        element.hashElement := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'creation') then
        element.creationElement := ParseDateTime(child, path+'/creation') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : String; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAttachmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAttachmentChildren(xml : TXmlBuilder; elem : TFhirAttachment);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'data', elem.dataElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(xml, 'size', elem.sizeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'hash', elem.hashElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'creation', elem.creationElement);{x.2b}
end;

function TFHIRXmlParser.ParseDataRequirementCodeFilter(element : TMXmlElement; path : string) : TFhirDataRequirementCodeFilter;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementCodeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementCodeFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementCodeFilterChild(element : TFhirDataRequirementCodeFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'valueSetReference') then
        element.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if (child.localName = 'valueSetString') then
        element.valueSet := ParseString(child, path+'/valueSetString'){x.3}
      else if (child.localName = 'valueCode') then
        element.valueCodeList.Add(ParseCode(child, path+'/valueCode')){y.2}
      else if (child.localName = 'valueCoding') then
        element.valueCodingList.Add(ParseCoding(child, path+'/valueCoding')){y.2}
      else if (child.localName = 'valueCodeableConcept') then
        element.valueCodeableConceptList.Add(ParseCodeableConcept(child, path+'/valueCodeableConcept')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementCodeFilter(xml : TXmlBuilder; name : String; elem : TFhirDataRequirementCodeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementCodeFilterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementCodeFilterChildren(xml : TXmlBuilder; elem : TFhirDataRequirementCodeFilter);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirString) {6} then
    ComposeString(xml, 'valueSetString', TFhirString(elem.valueSet));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCode(xml, 'valueCode', elem.valueCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodingList.Count - 1 do
      ComposeCoding(xml, 'valueCoding', elem.valueCodingList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(xml, 'valueCodeableConcept', elem.valueCodeableConceptList[i]);
end;

function TFHIRXmlParser.ParseDataRequirementDateFilter(element : TMXmlElement; path : string) : TFhirDataRequirementDateFilter;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementDateFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementDateFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementDateFilterChild(element : TFhirDataRequirementDateFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementDateFilter(xml : TXmlBuilder; name : String; elem : TFhirDataRequirementDateFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementDateFilterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementDateFilterChildren(xml : TXmlBuilder; elem : TFhirDataRequirementDateFilter);
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
end;

function TFHIRXmlParser.ParseDataRequirement(element : TMXmlElement; path : string) : TFhirDataRequirement;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementChild(element : TFhirDataRequirement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.localName = 'mustSupport') then
        element.mustSupportList.Add(ParseString(child, path+'/mustSupport')){y.2}
      else if (child.localName = 'codeFilter') then
        element.codeFilterList.Add(ParseDataRequirementCodeFilter(child, path+'/codeFilter')){y.2}
      else if (child.localName = 'dateFilter') then
        element.dateFilterList.Add(ParseDataRequirementDateFilter(child, path+'/dateFilter')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirement(xml : TXmlBuilder; name : String; elem : TFhirDataRequirement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementChildren(xml : TXmlBuilder; elem : TFhirDataRequirement);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mustSupportList.Count - 1 do
      ComposeString(xml, 'mustSupport', elem.mustSupportList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(xml, 'codeFilter', elem.codeFilterList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(xml, 'dateFilter', elem.dateFilterList[i]);
end;

function TFHIRXmlParser.ParseDosage(element : TMXmlElement; path : string) : TFhirDosage;
var
  child : TMXmlElement;
begin
  result := TFhirDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDosageChild(element : TFhirDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParseInteger(child, path+'/sequence') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'additionalInstruction') then
        element.additionalInstructionList.Add(ParseCodeableConcept(child, path+'/additionalInstruction')){y.2}
      else if (child.localName = 'patientInstruction') then
        element.patientInstructionElement := ParseString(child, path+'/patientInstruction') {b}
      else if (child.localName = 'timing') then
        element.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'site') then
        element.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'doseRange') then
        element.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.localName = 'doseQuantity') then
        element.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.localName = 'maxDosePerPeriod') then
        element.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if (child.localName = 'maxDosePerAdministration') then
        element.maxDosePerAdministration := ParseQuantity(child, path+'/maxDosePerAdministration') {b}
      else if (child.localName = 'maxDosePerLifetime') then
        element.maxDosePerLifetime := ParseQuantity(child, path+'/maxDosePerLifetime') {b}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateRange') then
        element.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.localName = 'rateQuantity') then
        element.rate := ParseQuantity(child, path+'/rateQuantity'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDosage(xml : TXmlBuilder; name : String; elem : TFhirDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDosageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDosageChildren(xml : TXmlBuilder; elem : TFhirDosage);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(xml, 'additionalInstruction', elem.additionalInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'patientInstruction', elem.patientInstructionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'site', elem.site);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'maxDosePerAdministration', elem.maxDosePerAdministration);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'maxDosePerLifetime', elem.maxDosePerLifetime);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(elem.rate));
end;

function TFHIRXmlParser.ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
var
  child : TMXmlElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIdentifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIdentifierChild(element : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, path+'/use', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'assigner') then
        element.assigner := ParseReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : String; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIdentifierChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIdentifierChildren(xml : TXmlBuilder; elem : TFhirIdentifier);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'assigner', elem.assigner);{x.2a}
end;

function TFHIRXmlParser.ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
var
  child : TMXmlElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodingChild(element : TFhirCoding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'userSelected') then
        element.userSelectedElement := ParseBoolean(child, path+'/userSelected') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : String; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodingChildren(xml : TXmlBuilder; elem : TFhirCoding);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'userSelected', elem.userSelectedElement);{x.2b}
end;

function TFHIRXmlParser.ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
var
  child : TMXmlElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSampledDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSampledDataChild(element : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'origin') then
        element.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.localName = 'period') then
        element.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'lowerLimit') then
        element.lowerLimitElement := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.localName = 'upperLimit') then
        element.upperLimitElement := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.localName = 'dimensions') then
        element.dimensionsElement := ParsePositiveInt(child, path+'/dimensions') {b}
      else if (child.localName = 'data') then
        element.dataElement := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : String; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSampledDataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSampledDataChildren(xml : TXmlBuilder; elem : TFhirSampledData);
begin
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'origin', elem.origin);{x.2a}
  ComposeDecimal(xml, 'period', elem.periodElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'lowerLimit', elem.lowerLimitElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'upperLimit', elem.upperLimitElement);{x.2b}
  ComposePositiveInt(xml, 'dimensions', elem.dimensionsElement);{x.2b}
  ComposeString(xml, 'data', elem.dataElement);{x.2b}
end;

function TFHIRXmlParser.ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
var
  child : TMXmlElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRatioChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRatioChild(element : TFhirRatio; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'numerator') then
        element.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.localName = 'denominator') then
        element.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : String; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRatioChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRatioChildren(xml : TXmlBuilder; elem : TFhirRatio);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'numerator', elem.numerator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'denominator', elem.denominator);{x.2a}
end;

function TFHIRXmlParser.ParseReference(element : TMXmlElement; path : string) : TFhirReference;
var
  child : TMXmlElement;
begin
  result := TFhirReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferenceChild(element : TFhirReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        element.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : String; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferenceChildren(xml : TXmlBuilder; elem : TFhirReference);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
end;

function TFHIRXmlParser.ParseTriggerDefinition(element : TMXmlElement; path : string) : TFhirTriggerDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirTriggerDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTriggerDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTriggerDefinitionChild(element : TFhirTriggerDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'eventName') then
        element.eventNameElement := ParseString(child, path+'/eventName') {b}
      else if (child.localName = 'eventTimingTiming') then
        element.eventTiming := ParseTiming(child, path+'/eventTimingTiming'){x.3}
      else if (child.localName = 'eventTimingReference') then
        element.eventTiming := ParseReference(child, path+'/eventTimingReference') {a}
      else if (child.localName = 'eventTimingDate') then
        element.eventTiming := ParseDate(child, path+'/eventTimingDate'){x.3}
      else if (child.localName = 'eventTimingDateTime') then
        element.eventTiming := ParseDateTime(child, path+'/eventTimingDateTime'){x.3}
      else if (child.localName = 'eventData') then
        element.eventData := ParseDataRequirement(child, path+'/eventData') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTriggerDefinition(xml : TXmlBuilder; name : String; elem : TFhirTriggerDefinition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTriggerDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTriggerDefinitionChildren(xml : TXmlBuilder; elem : TFhirTriggerDefinition);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirTriggerTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'eventName', elem.eventNameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirTiming) {6} then
    ComposeTiming(xml, 'eventTimingTiming', TFhirTiming(elem.eventTiming))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirReference) {2} then
    ComposeReference(xml, 'eventTimingReference', TFhirReference(elem.eventTiming))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirDate) {6} then
    ComposeDate(xml, 'eventTimingDate', TFhirDate(elem.eventTiming))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'eventTimingDateTime', TFhirDateTime(elem.eventTiming));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDataRequirement(xml, 'eventData', elem.eventData);{x.2a}
end;

function TFHIRXmlParser.ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
var
  child : TMXmlElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePeriodChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePeriodChild(element : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'start') then
        element.startElement := ParseDateTime(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : String; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePeriodChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePeriodChildren(xml : TXmlBuilder; elem : TFhirPeriod);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'end', elem.end_Element);{x.2b}
end;

function TFHIRXmlParser.ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
var
  child : TMXmlElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuantityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuantityChild(element : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if (child.localName = 'comparator') then
        element.comparatorElement := ParseEnum(CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, path+'/comparator', child){1a}
      else if (child.localName = 'unit') then
        element.unit_Element := ParseString(child, path+'/unit') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : String; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuantityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuantityChildren(xml : TXmlBuilder; elem : TFhirQuantity);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'unit', elem.unit_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
end;

function TFHIRXmlParser.ParseRange(element : TMXmlElement; path : string) : TFhirRange;
var
  child : TMXmlElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRangeChild(element : TFhirRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        element.low := ParseQuantity(child, path+'/low') {b}
      else if (child.localName = 'high') then
        element.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : String; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRangeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRangeChildren(xml : TXmlBuilder; elem : TFhirRange);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2a}
end;

function TFHIRXmlParser.ParseRelatedArtifact(element : TMXmlElement; path : string) : TFhirRelatedArtifact;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedArtifact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedArtifactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedArtifactChild(element : TFhirRelatedArtifact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'citation') then
        element.citationElement := ParseString(child, path+'/citation') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'document') then
        element.document := ParseAttachment(child, path+'/document') {b}
      else if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedArtifact(xml : TXmlBuilder; name : String; elem : TFhirRelatedArtifact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedArtifactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedArtifactChildren(xml : TXmlBuilder; elem : TFhirRelatedArtifact);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirRelatedArtifactTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'citation', elem.citationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeAttachment(xml, 'document', elem.document);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
end;

function TFHIRXmlParser.ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
var
  child : TMXmlElement;
begin
  result := TFhirAnnotation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAnnotationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAnnotationChild(element : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authorReference') then
        element.author := ParseReference(child, path+'/authorReference') {a}
      else if (child.localName = 'authorString') then
        element.author := ParseString(child, path+'/authorString'){x.3}
      else if (child.localName = 'time') then
        element.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAnnotation(xml : TXmlBuilder; name : String; elem : TFhirAnnotation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAnnotationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAnnotationChildren(xml : TXmlBuilder; elem : TFhirAnnotation);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(xml, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(xml, 'authorString', TFhirString(elem.author));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2b}
  ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseContactDetail(element : TMXmlElement; path : string) : TFhirContactDetail;
var
  child : TMXmlElement;
begin
  result := TFhirContactDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContactDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContactDetailChild(element : TFhirContactDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContactDetail(xml : TXmlBuilder; name : String; elem : TFhirContactDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContactDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContactDetailChildren(xml : TXmlBuilder; elem : TFhirContactDetail);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseUsageContext(element : TMXmlElement; path : string) : TFhirUsageContext;
var
  child : TMXmlElement;
begin
  result := TFhirUsageContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseUsageContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseUsageContextChild(element : TFhirUsageContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeUsageContext(xml : TXmlBuilder; name : String; elem : TFhirUsageContext);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeUsageContextChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeUsageContextChildren(xml : TXmlBuilder; elem : TFhirUsageContext);
begin
  composeElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value));
end;

function TFHIRXmlParser.ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
var
  child : TMXmlElement;
begin
  result := TFhirSignature.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSignatureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSignatureChild(element : TFhirSignature; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if (child.localName = 'when') then
        element.whenElement := ParseInstant(child, path+'/when') {b}
      else if (child.localName = 'whoReference') then
        element.who := ParseReference(child, path+'/whoReference') {a}
      else if (child.localName = 'whoUri') then
        element.who := ParseUri(child, path+'/whoUri'){x.3}
      else if (child.localName = 'onBehalfOfReference') then
        element.onBehalfOf := ParseReference(child, path+'/onBehalfOfReference') {a}
      else if (child.localName = 'onBehalfOfUri') then
        element.onBehalfOf := ParseUri(child, path+'/onBehalfOfUri'){x.3}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'blob') then
        element.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSignature(xml : TXmlBuilder; name : String; elem : TFhirSignature);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSignatureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSignatureChildren(xml : TXmlBuilder; elem : TFhirSignature);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
  ComposeInstant(xml, 'when', elem.whenElement);{x.2b}
  if (elem.who is TFhirReference) {2} then
    ComposeReference(xml, 'whoReference', TFhirReference(elem.who))
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(xml, 'whoUri', TFhirUri(elem.who));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.onBehalfOf is TFhirReference) {2} then
    ComposeReference(xml, 'onBehalfOfReference', TFhirReference(elem.onBehalfOf))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.onBehalfOf is TFhirUri) {6} then
    ComposeUri(xml, 'onBehalfOfUri', TFhirUri(elem.onBehalfOf));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2b}
end;

function TFHIRXmlParser.ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
var
  child : TMXmlElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeableConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableConceptChild(element : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coding') then
        element.codingList.Add(ParseCoding(child, path+'/coding')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : String; elem : TFhirCodeableConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeableConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeableConceptChildren(xml : TXmlBuilder; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(xml, 'coding', elem.codingList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseParameterDefinition(element : TMXmlElement; path : string) : TFhirParameterDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirParameterDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParameterDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParameterDefinitionChild(element : TFhirParameterDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, path+'/use', child){1a}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParameterDefinition(xml : TXmlBuilder; name : String; elem : TFhirParameterDefinition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParameterDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParameterDefinitionChildren(xml : TXmlBuilder; elem : TFhirParameterDefinition);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
var
  child : TMXmlElement;
begin
  result := TFhirContactPoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContactPointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContactPointChild(element : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseEnum(CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, path+'/system', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, path+'/use', child){1a}
      else if (child.localName = 'rank') then
        element.rankElement := ParsePositiveInt(child, path+'/rank') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : String; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContactPointChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContactPointChildren(xml : TXmlBuilder; elem : TFhirContactPoint);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(xml, 'rank', elem.rankElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
var
  child : TMXmlElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHumanNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanNameChild(element : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, path+'/use', child){1a}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'family') then
        element.familyElement := ParseString(child, path+'/family') {b}
      else if (child.localName = 'given') then
        element.givenList.Add(ParseString(child, path+'/given')){y.2}
      else if (child.localName = 'prefix') then
        element.prefixList.Add(ParseString(child, path+'/prefix')){y.2}
      else if (child.localName = 'suffix') then
        element.suffixList.Add(ParseString(child, path+'/suffix')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : String; elem : TFhirHumanName);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHumanNameChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHumanNameChildren(xml : TXmlBuilder; elem : TFhirHumanName);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirNameUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'family', elem.familyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(xml, 'given', elem.givenList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(xml, 'prefix', elem.prefixList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(xml, 'suffix', elem.suffixList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
var
  child : TMXmlElement;
begin
  result := TFhirMeta.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMetaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMetaChild(element : TFhirMeta; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'versionId') then
        element.versionIdElement := ParseId(child, path+'/versionId') {b}
      else if (child.localName = 'lastUpdated') then
        element.lastUpdatedElement := ParseInstant(child, path+'/lastUpdated') {b}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.localName = 'security') then
        element.securityList.Add(ParseCoding(child, path+'/security')){y.2}
      else if (child.localName = 'tag') then
        element.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeta(xml : TXmlBuilder; name : String; elem : TFhirMeta);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMetaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMetaChildren(xml : TXmlBuilder; elem : TFhirMeta);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'versionId', elem.versionIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastUpdated', elem.lastUpdatedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(xml, 'security', elem.securityList[i]);
  for i := 0 to elem.tagList.Count - 1 do
    if (SummaryOption in [soFull, soSummary, soData]) or isSubsettedTag(elem.tagList[i]) then
      ComposeCoding(xml, 'tag', elem.tagList[i]);
end;

function TFHIRXmlParser.ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
var
  child : TMXmlElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAddressChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAddressChild(element : TFhirAddress; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, path+'/use', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'line') then
        element.lineList.Add(ParseString(child, path+'/line')){y.2}
      else if (child.localName = 'city') then
        element.cityElement := ParseString(child, path+'/city') {b}
      else if (child.localName = 'district') then
        element.districtElement := ParseString(child, path+'/district') {b}
      else if (child.localName = 'state') then
        element.stateElement := ParseString(child, path+'/state') {b}
      else if (child.localName = 'postalCode') then
        element.postalCodeElement := ParseString(child, path+'/postalCode') {b}
      else if (child.localName = 'country') then
        element.countryElement := ParseString(child, path+'/country') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : String; elem : TFhirAddress);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAddressChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAddressChildren(xml : TXmlBuilder; elem : TFhirAddress);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirAddressUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(xml, 'line', elem.lineList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'city', elem.cityElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'district', elem.districtElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'state', elem.stateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'postalCode', elem.postalCodeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'country', elem.countryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionSlicingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingChild(element : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'discriminator') then
        element.discriminatorList.Add(ParseElementDefinitionSlicingDiscriminator(child, path+'/discriminator')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'ordered') then
        element.orderedElement := ParseBoolean(child, path+'/ordered') {b}
      else if (child.localName = 'rules') then
        element.rulesElement := ParseEnum(CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, path+'/rules', child){1a}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionSlicing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionSlicingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicing);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(xml, 'discriminator', elem.discriminatorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBoolean(xml, 'ordered', elem.orderedElement);{x.2b}
  ComposeEnum(xml, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingDiscriminator(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicingDiscriminator;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionSlicingDiscriminatorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingDiscriminatorChild(element : TFhirElementDefinitionSlicingDiscriminator; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingDiscriminator(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionSlicingDiscriminator);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionSlicingDiscriminatorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingDiscriminatorChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicingDiscriminator);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirDiscriminatorTypeEnum);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBase.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBaseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBaseChild(element : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'min') then
        element.minElement := ParseUnsignedInt(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBase(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionBase);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBaseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBase);
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  ComposeUnsignedInt(xml, 'min', elem.minElement);{x.2b}
  ComposeString(xml, 'max', elem.maxElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionTypeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionTypeChild(element : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseUri(child, path+'/code') {b}
      else if (child.localName = 'profile') then
        element.profileElement := ParseUri(child, path+'/profile') {b}
      else if (child.localName = 'targetProfile') then
        element.targetProfileElement := ParseUri(child, path+'/targetProfile') {b}
      else if (child.localName = 'aggregation') then
        element.aggregationList.Add(ParseEnum(CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, path+'/aggregation', child)){y.1}
      else if (child.localName = 'versioning') then
        element.versioningElement := ParseEnum(CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum, path+'/versioning', child){1a}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionType(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionType);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionTypeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionType);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeUri(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'profile', elem.profileElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'targetProfile', elem.targetProfileElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(xml, 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.versioningElement <> nil) and (elem.versioningElement.primitiveValue <> 'either')) then
    ComposeEnum(xml, 'versioning', elem.VersioningElement, CODES_TFhirReferenceVersionRulesEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionExample(element : TMXmlElement; path : string) : TFhirElementDefinitionExample;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionExample.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionExampleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionExampleChild(element : TFhirElementDefinitionExample; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'/valueMarkdown'){x.3}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'/valueOid'){x.3}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'/valuePositiveInt'){x.3}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'/valueUnsignedInt'){x.3}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress'){x.3}
      else if (child.localName = 'valueAge') then
        element.value := ParseAge(child, path+'/valueAge'){x.3}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'/valueAnnotation'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint'){x.3}
      else if (child.localName = 'valueCount') then
        element.value := ParseCount(child, path+'/valueCount'){x.3}
      else if (child.localName = 'valueDistance') then
        element.value := ParseDistance(child, path+'/valueDistance'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName'){x.3}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'/valueIdentifier'){x.3}
      else if (child.localName = 'valueMoney') then
        element.value := ParseMoney(child, path+'/valueMoney'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'/valueSignature'){x.3}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming'){x.3}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta'){x.3}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'/valueBase64Binary'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionExample(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionExample);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionExampleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionExampleChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionExample);
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(elem.value))
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(elem.value))
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(elem.value))
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionConstraintChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionConstraintChild(element : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        element.keyElement := ParseId(child, path+'/key') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'human') then
        element.humanElement := ParseString(child, path+'/human') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if (child.localName = 'xpath') then
        element.xpathElement := ParseString(child, path+'/xpath') {b}
      else if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionConstraintChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionConstraint);
begin
  composeElementChildren(xml, elem);
  ComposeId(xml, 'key', elem.keyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum);
  ComposeString(xml, 'human', elem.humanElement);{x.2b}
  ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'xpath', elem.xpathElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBindingChild(element : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        element.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'valueSetReference') then
        element.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if (child.localName = 'valueSetUri') then
        element.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBinding(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBinding);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet));
end;

function TFHIRXmlParser.ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionMappingChild(element : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'map') then
        element.mapElement := ParseString(child, path+'/map') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMapping(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionMapping);
begin
  composeElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  ComposeString(xml, 'map', elem.mapElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionChild(element : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'representation') then
        element.representationList.Add(ParseEnum(CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, path+'/representation', child)){y.1}
      else if (child.localName = 'sliceName') then
        element.sliceNameElement := ParseString(child, path+'/sliceName') {b}
      else if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'slicing') then
        element.slicing := ParseElementDefinitionSlicing(child, path+'/slicing') {b}
      else if (child.localName = 'short') then
        element.shortElement := ParseString(child, path+'/short') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseMarkdown(child, path+'/definition') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseMarkdown(child, path+'/comment') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseMarkdown(child, path+'/requirements') {b}
      else if (child.localName = 'alias') then
        element.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.localName = 'min') then
        element.minElement := ParseUnsignedInt(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'base') then
        element.base := ParseElementDefinitionBase(child, path+'/base') {b}
      else if (child.localName = 'contentReference') then
        element.contentReferenceElement := ParseUri(child, path+'/contentReference') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseElementDefinitionType(child, path+'/type')){y.2}
      else if (child.localName = 'defaultValueCode') then
        element.defaultValue := ParseCode(child, path+'/defaultValueCode'){x.3}
      else if (child.localName = 'defaultValueId') then
        element.defaultValue := ParseId(child, path+'/defaultValueId'){x.3}
      else if (child.localName = 'defaultValueMarkdown') then
        element.defaultValue := ParseMarkdown(child, path+'/defaultValueMarkdown'){x.3}
      else if (child.localName = 'defaultValueOid') then
        element.defaultValue := ParseOid(child, path+'/defaultValueOid'){x.3}
      else if (child.localName = 'defaultValuePositiveInt') then
        element.defaultValue := ParsePositiveInt(child, path+'/defaultValuePositiveInt'){x.3}
      else if (child.localName = 'defaultValueUnsignedInt') then
        element.defaultValue := ParseUnsignedInt(child, path+'/defaultValueUnsignedInt'){x.3}
      else if (child.localName = 'defaultValueAddress') then
        element.defaultValue := ParseAddress(child, path+'/defaultValueAddress'){x.3}
      else if (child.localName = 'defaultValueAge') then
        element.defaultValue := ParseAge(child, path+'/defaultValueAge'){x.3}
      else if (child.localName = 'defaultValueAnnotation') then
        element.defaultValue := ParseAnnotation(child, path+'/defaultValueAnnotation'){x.3}
      else if (child.localName = 'defaultValueAttachment') then
        element.defaultValue := ParseAttachment(child, path+'/defaultValueAttachment'){x.3}
      else if (child.localName = 'defaultValueCodeableConcept') then
        element.defaultValue := ParseCodeableConcept(child, path+'/defaultValueCodeableConcept'){x.3}
      else if (child.localName = 'defaultValueCoding') then
        element.defaultValue := ParseCoding(child, path+'/defaultValueCoding'){x.3}
      else if (child.localName = 'defaultValueContactPoint') then
        element.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint'){x.3}
      else if (child.localName = 'defaultValueCount') then
        element.defaultValue := ParseCount(child, path+'/defaultValueCount'){x.3}
      else if (child.localName = 'defaultValueDistance') then
        element.defaultValue := ParseDistance(child, path+'/defaultValueDistance'){x.3}
      else if (child.localName = 'defaultValueDuration') then
        element.defaultValue := ParseDuration(child, path+'/defaultValueDuration'){x.3}
      else if (child.localName = 'defaultValueHumanName') then
        element.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName'){x.3}
      else if (child.localName = 'defaultValueIdentifier') then
        element.defaultValue := ParseIdentifier(child, path+'/defaultValueIdentifier'){x.3}
      else if (child.localName = 'defaultValueMoney') then
        element.defaultValue := ParseMoney(child, path+'/defaultValueMoney'){x.3}
      else if (child.localName = 'defaultValuePeriod') then
        element.defaultValue := ParsePeriod(child, path+'/defaultValuePeriod'){x.3}
      else if (child.localName = 'defaultValueQuantity') then
        element.defaultValue := ParseQuantity(child, path+'/defaultValueQuantity'){x.3}
      else if (child.localName = 'defaultValueRange') then
        element.defaultValue := ParseRange(child, path+'/defaultValueRange'){x.3}
      else if (child.localName = 'defaultValueRatio') then
        element.defaultValue := ParseRatio(child, path+'/defaultValueRatio'){x.3}
      else if (child.localName = 'defaultValueReference') then
        element.defaultValue := ParseReference(child, path+'/defaultValueReference'){x.3}
      else if (child.localName = 'defaultValueSampledData') then
        element.defaultValue := ParseSampledData(child, path+'/defaultValueSampledData'){x.3}
      else if (child.localName = 'defaultValueSignature') then
        element.defaultValue := ParseSignature(child, path+'/defaultValueSignature'){x.3}
      else if (child.localName = 'defaultValueTiming') then
        element.defaultValue := ParseTiming(child, path+'/defaultValueTiming'){x.3}
      else if (child.localName = 'defaultValueMeta') then
        element.defaultValue := ParseMeta(child, path+'/defaultValueMeta'){x.3}
      else if (child.localName = 'defaultValueBase64Binary') then
        element.defaultValue := ParseBase64Binary(child, path+'/defaultValueBase64Binary'){x.3}
      else if (child.localName = 'defaultValueBoolean') then
        element.defaultValue := ParseBoolean(child, path+'/defaultValueBoolean'){x.3}
      else if (child.localName = 'defaultValueDate') then
        element.defaultValue := ParseDate(child, path+'/defaultValueDate'){x.3}
      else if (child.localName = 'defaultValueDateTime') then
        element.defaultValue := ParseDateTime(child, path+'/defaultValueDateTime'){x.3}
      else if (child.localName = 'defaultValueDecimal') then
        element.defaultValue := ParseDecimal(child, path+'/defaultValueDecimal'){x.3}
      else if (child.localName = 'defaultValueInstant') then
        element.defaultValue := ParseInstant(child, path+'/defaultValueInstant'){x.3}
      else if (child.localName = 'defaultValueInteger') then
        element.defaultValue := ParseInteger(child, path+'/defaultValueInteger'){x.3}
      else if (child.localName = 'defaultValueString') then
        element.defaultValue := ParseString(child, path+'/defaultValueString'){x.3}
      else if (child.localName = 'defaultValueTime') then
        element.defaultValue := ParseTime(child, path+'/defaultValueTime'){x.3}
      else if (child.localName = 'defaultValueUri') then
        element.defaultValue := ParseUri(child, path+'/defaultValueUri'){x.3}
      else if (child.localName = 'meaningWhenMissing') then
        element.meaningWhenMissingElement := ParseMarkdown(child, path+'/meaningWhenMissing') {b}
      else if (child.localName = 'orderMeaning') then
        element.orderMeaningElement := ParseString(child, path+'/orderMeaning') {b}
      else if (child.localName = 'fixedCode') then
        element.fixed := ParseCode(child, path+'/fixedCode'){x.3}
      else if (child.localName = 'fixedId') then
        element.fixed := ParseId(child, path+'/fixedId'){x.3}
      else if (child.localName = 'fixedMarkdown') then
        element.fixed := ParseMarkdown(child, path+'/fixedMarkdown'){x.3}
      else if (child.localName = 'fixedOid') then
        element.fixed := ParseOid(child, path+'/fixedOid'){x.3}
      else if (child.localName = 'fixedPositiveInt') then
        element.fixed := ParsePositiveInt(child, path+'/fixedPositiveInt'){x.3}
      else if (child.localName = 'fixedUnsignedInt') then
        element.fixed := ParseUnsignedInt(child, path+'/fixedUnsignedInt'){x.3}
      else if (child.localName = 'fixedAddress') then
        element.fixed := ParseAddress(child, path+'/fixedAddress'){x.3}
      else if (child.localName = 'fixedAge') then
        element.fixed := ParseAge(child, path+'/fixedAge'){x.3}
      else if (child.localName = 'fixedAnnotation') then
        element.fixed := ParseAnnotation(child, path+'/fixedAnnotation'){x.3}
      else if (child.localName = 'fixedAttachment') then
        element.fixed := ParseAttachment(child, path+'/fixedAttachment'){x.3}
      else if (child.localName = 'fixedCodeableConcept') then
        element.fixed := ParseCodeableConcept(child, path+'/fixedCodeableConcept'){x.3}
      else if (child.localName = 'fixedCoding') then
        element.fixed := ParseCoding(child, path+'/fixedCoding'){x.3}
      else if (child.localName = 'fixedContactPoint') then
        element.fixed := ParseContactPoint(child, path+'/fixedContactPoint'){x.3}
      else if (child.localName = 'fixedCount') then
        element.fixed := ParseCount(child, path+'/fixedCount'){x.3}
      else if (child.localName = 'fixedDistance') then
        element.fixed := ParseDistance(child, path+'/fixedDistance'){x.3}
      else if (child.localName = 'fixedDuration') then
        element.fixed := ParseDuration(child, path+'/fixedDuration'){x.3}
      else if (child.localName = 'fixedHumanName') then
        element.fixed := ParseHumanName(child, path+'/fixedHumanName'){x.3}
      else if (child.localName = 'fixedIdentifier') then
        element.fixed := ParseIdentifier(child, path+'/fixedIdentifier'){x.3}
      else if (child.localName = 'fixedMoney') then
        element.fixed := ParseMoney(child, path+'/fixedMoney'){x.3}
      else if (child.localName = 'fixedPeriod') then
        element.fixed := ParsePeriod(child, path+'/fixedPeriod'){x.3}
      else if (child.localName = 'fixedQuantity') then
        element.fixed := ParseQuantity(child, path+'/fixedQuantity'){x.3}
      else if (child.localName = 'fixedRange') then
        element.fixed := ParseRange(child, path+'/fixedRange'){x.3}
      else if (child.localName = 'fixedRatio') then
        element.fixed := ParseRatio(child, path+'/fixedRatio'){x.3}
      else if (child.localName = 'fixedReference') then
        element.fixed := ParseReference(child, path+'/fixedReference'){x.3}
      else if (child.localName = 'fixedSampledData') then
        element.fixed := ParseSampledData(child, path+'/fixedSampledData'){x.3}
      else if (child.localName = 'fixedSignature') then
        element.fixed := ParseSignature(child, path+'/fixedSignature'){x.3}
      else if (child.localName = 'fixedTiming') then
        element.fixed := ParseTiming(child, path+'/fixedTiming'){x.3}
      else if (child.localName = 'fixedMeta') then
        element.fixed := ParseMeta(child, path+'/fixedMeta'){x.3}
      else if (child.localName = 'fixedBase64Binary') then
        element.fixed := ParseBase64Binary(child, path+'/fixedBase64Binary'){x.3}
      else if (child.localName = 'fixedBoolean') then
        element.fixed := ParseBoolean(child, path+'/fixedBoolean'){x.3}
      else if (child.localName = 'fixedDate') then
        element.fixed := ParseDate(child, path+'/fixedDate'){x.3}
      else if (child.localName = 'fixedDateTime') then
        element.fixed := ParseDateTime(child, path+'/fixedDateTime'){x.3}
      else if (child.localName = 'fixedDecimal') then
        element.fixed := ParseDecimal(child, path+'/fixedDecimal'){x.3}
      else if (child.localName = 'fixedInstant') then
        element.fixed := ParseInstant(child, path+'/fixedInstant'){x.3}
      else if (child.localName = 'fixedInteger') then
        element.fixed := ParseInteger(child, path+'/fixedInteger'){x.3}
      else if (child.localName = 'fixedString') then
        element.fixed := ParseString(child, path+'/fixedString'){x.3}
      else if (child.localName = 'fixedTime') then
        element.fixed := ParseTime(child, path+'/fixedTime'){x.3}
      else if (child.localName = 'fixedUri') then
        element.fixed := ParseUri(child, path+'/fixedUri'){x.3}
      else if (child.localName = 'patternCode') then
        element.pattern := ParseCode(child, path+'/patternCode'){x.3}
      else if (child.localName = 'patternId') then
        element.pattern := ParseId(child, path+'/patternId'){x.3}
      else if (child.localName = 'patternMarkdown') then
        element.pattern := ParseMarkdown(child, path+'/patternMarkdown'){x.3}
      else if (child.localName = 'patternOid') then
        element.pattern := ParseOid(child, path+'/patternOid'){x.3}
      else if (child.localName = 'patternPositiveInt') then
        element.pattern := ParsePositiveInt(child, path+'/patternPositiveInt'){x.3}
      else if (child.localName = 'patternUnsignedInt') then
        element.pattern := ParseUnsignedInt(child, path+'/patternUnsignedInt'){x.3}
      else if (child.localName = 'patternAddress') then
        element.pattern := ParseAddress(child, path+'/patternAddress'){x.3}
      else if (child.localName = 'patternAge') then
        element.pattern := ParseAge(child, path+'/patternAge'){x.3}
      else if (child.localName = 'patternAnnotation') then
        element.pattern := ParseAnnotation(child, path+'/patternAnnotation'){x.3}
      else if (child.localName = 'patternAttachment') then
        element.pattern := ParseAttachment(child, path+'/patternAttachment'){x.3}
      else if (child.localName = 'patternCodeableConcept') then
        element.pattern := ParseCodeableConcept(child, path+'/patternCodeableConcept'){x.3}
      else if (child.localName = 'patternCoding') then
        element.pattern := ParseCoding(child, path+'/patternCoding'){x.3}
      else if (child.localName = 'patternContactPoint') then
        element.pattern := ParseContactPoint(child, path+'/patternContactPoint'){x.3}
      else if (child.localName = 'patternCount') then
        element.pattern := ParseCount(child, path+'/patternCount'){x.3}
      else if (child.localName = 'patternDistance') then
        element.pattern := ParseDistance(child, path+'/patternDistance'){x.3}
      else if (child.localName = 'patternDuration') then
        element.pattern := ParseDuration(child, path+'/patternDuration'){x.3}
      else if (child.localName = 'patternHumanName') then
        element.pattern := ParseHumanName(child, path+'/patternHumanName'){x.3}
      else if (child.localName = 'patternIdentifier') then
        element.pattern := ParseIdentifier(child, path+'/patternIdentifier'){x.3}
      else if (child.localName = 'patternMoney') then
        element.pattern := ParseMoney(child, path+'/patternMoney'){x.3}
      else if (child.localName = 'patternPeriod') then
        element.pattern := ParsePeriod(child, path+'/patternPeriod'){x.3}
      else if (child.localName = 'patternQuantity') then
        element.pattern := ParseQuantity(child, path+'/patternQuantity'){x.3}
      else if (child.localName = 'patternRange') then
        element.pattern := ParseRange(child, path+'/patternRange'){x.3}
      else if (child.localName = 'patternRatio') then
        element.pattern := ParseRatio(child, path+'/patternRatio'){x.3}
      else if (child.localName = 'patternReference') then
        element.pattern := ParseReference(child, path+'/patternReference'){x.3}
      else if (child.localName = 'patternSampledData') then
        element.pattern := ParseSampledData(child, path+'/patternSampledData'){x.3}
      else if (child.localName = 'patternSignature') then
        element.pattern := ParseSignature(child, path+'/patternSignature'){x.3}
      else if (child.localName = 'patternTiming') then
        element.pattern := ParseTiming(child, path+'/patternTiming'){x.3}
      else if (child.localName = 'patternMeta') then
        element.pattern := ParseMeta(child, path+'/patternMeta'){x.3}
      else if (child.localName = 'patternBase64Binary') then
        element.pattern := ParseBase64Binary(child, path+'/patternBase64Binary'){x.3}
      else if (child.localName = 'patternBoolean') then
        element.pattern := ParseBoolean(child, path+'/patternBoolean'){x.3}
      else if (child.localName = 'patternDate') then
        element.pattern := ParseDate(child, path+'/patternDate'){x.3}
      else if (child.localName = 'patternDateTime') then
        element.pattern := ParseDateTime(child, path+'/patternDateTime'){x.3}
      else if (child.localName = 'patternDecimal') then
        element.pattern := ParseDecimal(child, path+'/patternDecimal'){x.3}
      else if (child.localName = 'patternInstant') then
        element.pattern := ParseInstant(child, path+'/patternInstant'){x.3}
      else if (child.localName = 'patternInteger') then
        element.pattern := ParseInteger(child, path+'/patternInteger'){x.3}
      else if (child.localName = 'patternString') then
        element.pattern := ParseString(child, path+'/patternString'){x.3}
      else if (child.localName = 'patternTime') then
        element.pattern := ParseTime(child, path+'/patternTime'){x.3}
      else if (child.localName = 'patternUri') then
        element.pattern := ParseUri(child, path+'/patternUri'){x.3}
      else if (child.localName = 'example') then
        element.exampleList.Add(ParseElementDefinitionExample(child, path+'/example')){y.2}
      else if (child.localName = 'minValuePositiveInt') then
        element.minValue := ParsePositiveInt(child, path+'/minValuePositiveInt'){x.3}
      else if (child.localName = 'minValueUnsignedInt') then
        element.minValue := ParseUnsignedInt(child, path+'/minValueUnsignedInt'){x.3}
      else if (child.localName = 'minValueQuantity') then
        element.minValue := ParseQuantity(child, path+'/minValueQuantity'){x.3}
      else if (child.localName = 'minValueDate') then
        element.minValue := ParseDate(child, path+'/minValueDate'){x.3}
      else if (child.localName = 'minValueDateTime') then
        element.minValue := ParseDateTime(child, path+'/minValueDateTime'){x.3}
      else if (child.localName = 'minValueInstant') then
        element.minValue := ParseInstant(child, path+'/minValueInstant'){x.3}
      else if (child.localName = 'minValueTime') then
        element.minValue := ParseTime(child, path+'/minValueTime'){x.3}
      else if (child.localName = 'minValueDecimal') then
        element.minValue := ParseDecimal(child, path+'/minValueDecimal'){x.3}
      else if (child.localName = 'minValueInteger') then
        element.minValue := ParseInteger(child, path+'/minValueInteger'){x.3}
      else if (child.localName = 'maxValuePositiveInt') then
        element.maxValue := ParsePositiveInt(child, path+'/maxValuePositiveInt'){x.3}
      else if (child.localName = 'maxValueUnsignedInt') then
        element.maxValue := ParseUnsignedInt(child, path+'/maxValueUnsignedInt'){x.3}
      else if (child.localName = 'maxValueQuantity') then
        element.maxValue := ParseQuantity(child, path+'/maxValueQuantity'){x.3}
      else if (child.localName = 'maxValueDate') then
        element.maxValue := ParseDate(child, path+'/maxValueDate'){x.3}
      else if (child.localName = 'maxValueDateTime') then
        element.maxValue := ParseDateTime(child, path+'/maxValueDateTime'){x.3}
      else if (child.localName = 'maxValueInstant') then
        element.maxValue := ParseInstant(child, path+'/maxValueInstant'){x.3}
      else if (child.localName = 'maxValueTime') then
        element.maxValue := ParseTime(child, path+'/maxValueTime'){x.3}
      else if (child.localName = 'maxValueDecimal') then
        element.maxValue := ParseDecimal(child, path+'/maxValueDecimal'){x.3}
      else if (child.localName = 'maxValueInteger') then
        element.maxValue := ParseInteger(child, path+'/maxValueInteger'){x.3}
      else if (child.localName = 'maxLength') then
        element.maxLengthElement := ParseInteger(child, path+'/maxLength') {b}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseId(child, path+'/condition')){y.2}
      else if (child.localName = 'constraint') then
        element.constraintList.Add(ParseElementDefinitionConstraint(child, path+'/constraint')){y.2}
      else if (child.localName = 'mustSupport') then
        element.mustSupportElement := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.localName = 'isModifier') then
        element.isModifierElement := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.localName = 'isSummary') then
        element.isSummaryElement := ParseBoolean(child, path+'/isSummary') {b}
      else if (child.localName = 'binding') then
        element.binding := ParseElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseElementDefinitionMapping(child, path+'/mapping')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinition(xml : TXmlBuilder; name : String; elem : TFhirElementDefinition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionChildren(xml : TXmlBuilder; elem : TFhirElementDefinition);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(xml, 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'sliceName', elem.sliceNameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(xml, 'slicing', elem.slicing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'short', elem.shortElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(xml, 'alias', elem.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(xml, 'base', elem.base);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'contentReference', elem.contentReferenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(xml, 'defaultValueId', TFhirId(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(xml, 'defaultValueAge', TFhirAge(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(xml, 'defaultValueCount', TFhirCount(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(xml, 'defaultValueDistance', TFhirDistance(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(xml, 'defaultValueDuration', TFhirDuration(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(xml, 'defaultValueMoney', TFhirMoney(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMeta) {6} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(xml, 'defaultValueString', TFhirString(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'meaningWhenMissing', elem.meaningWhenMissingElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'orderMeaning', elem.orderMeaningElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {6} then
    ComposeCode(xml, 'fixedCode', TFhirCode(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {6} then
    ComposeId(xml, 'fixedId', TFhirId(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'fixedMarkdown', TFhirMarkdown(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {6} then
    ComposeOid(xml, 'fixedOid', TFhirOid(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) {6} then
    ComposeAddress(xml, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAge) {6} then
    ComposeAge(xml, 'fixedAge', TFhirAge(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'fixedAnnotation', TFhirAnnotation(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) {6} then
    ComposeCoding(xml, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'fixedContactPoint', TFhirContactPoint(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCount) {6} then
    ComposeCount(xml, 'fixedCount', TFhirCount(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDistance) {6} then
    ComposeDistance(xml, 'fixedDistance', TFhirDistance(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDuration) {6} then
    ComposeDuration(xml, 'fixedDuration', TFhirDuration(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMoney) {6} then
    ComposeMoney(xml, 'fixedMoney', TFhirMoney(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) {6} then
    ComposeRange(xml, 'fixedRange', TFhirRange(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) {6} then
    ComposeRatio(xml, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) {6} then
    ComposeReference(xml, 'fixedReference', TFhirReference(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) {6} then
    ComposeSignature(xml, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) {6} then
    ComposeTiming(xml, 'fixedTiming', TFhirTiming(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMeta) {6} then
    ComposeMeta(xml, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'fixedBoolean', TFhirBoolean(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {6} then
    ComposeDate(xml, 'fixedDate', TFhirDate(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'fixedDateTime', TFhirDateTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'fixedDecimal', TFhirDecimal(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {6} then
    ComposeInstant(xml, 'fixedInstant', TFhirInstant(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {6} then
    ComposeInteger(xml, 'fixedInteger', TFhirInteger(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {6} then
    ComposeString(xml, 'fixedString', TFhirString(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {6} then
    ComposeTime(xml, 'fixedTime', TFhirTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {6} then
    ComposeUri(xml, 'fixedUri', TFhirUri(elem.fixed));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {6} then
    ComposeCode(xml, 'patternCode', TFhirCode(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {6} then
    ComposeId(xml, 'patternId', TFhirId(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'patternMarkdown', TFhirMarkdown(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {6} then
    ComposeOid(xml, 'patternOid', TFhirOid(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'patternPositiveInt', TFhirPositiveInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) {6} then
    ComposeAddress(xml, 'patternAddress', TFhirAddress(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAge) {6} then
    ComposeAge(xml, 'patternAge', TFhirAge(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'patternAnnotation', TFhirAnnotation(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) {6} then
    ComposeCoding(xml, 'patternCoding', TFhirCoding(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'patternContactPoint', TFhirContactPoint(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCount) {6} then
    ComposeCount(xml, 'patternCount', TFhirCount(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDistance) {6} then
    ComposeDistance(xml, 'patternDistance', TFhirDistance(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDuration) {6} then
    ComposeDuration(xml, 'patternDuration', TFhirDuration(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMoney) {6} then
    ComposeMoney(xml, 'patternMoney', TFhirMoney(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) {6} then
    ComposePeriod(xml, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) {6} then
    ComposeRange(xml, 'patternRange', TFhirRange(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) {6} then
    ComposeRatio(xml, 'patternRatio', TFhirRatio(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) {6} then
    ComposeReference(xml, 'patternReference', TFhirReference(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) {6} then
    ComposeSignature(xml, 'patternSignature', TFhirSignature(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) {6} then
    ComposeTiming(xml, 'patternTiming', TFhirTiming(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMeta) {6} then
    ComposeMeta(xml, 'patternMeta', TFhirMeta(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'patternBase64Binary', TFhirBase64Binary(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'patternBoolean', TFhirBoolean(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {6} then
    ComposeDate(xml, 'patternDate', TFhirDate(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'patternDateTime', TFhirDateTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'patternDecimal', TFhirDecimal(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {6} then
    ComposeInstant(xml, 'patternInstant', TFhirInstant(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {6} then
    ComposeInteger(xml, 'patternInteger', TFhirInteger(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {6} then
    ComposeString(xml, 'patternString', TFhirString(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {6} then
    ComposeTime(xml, 'patternTime', TFhirTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {6} then
    ComposeUri(xml, 'patternUri', TFhirUri(elem.pattern));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.exampleList.Count - 1 do
      ComposeElementDefinitionExample(xml, 'example', elem.exampleList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'minValueQuantity', TFhirQuantity(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {6} then
    ComposeDate(xml, 'minValueDate', TFhirDate(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'minValueDateTime', TFhirDateTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'minValueInstant', TFhirInstant(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {6} then
    ComposeTime(xml, 'minValueTime', TFhirTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'minValueDecimal', TFhirDecimal(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'minValueInteger', TFhirInteger(elem.minValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'maxValueQuantity', TFhirQuantity(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {6} then
    ComposeDate(xml, 'maxValueDate', TFhirDate(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'maxValueDateTime', TFhirDateTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'maxValueInstant', TFhirInstant(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {6} then
    ComposeTime(xml, 'maxValueTime', TFhirTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'maxValueDecimal', TFhirDecimal(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'maxValueInteger', TFhirInteger(elem.maxValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'maxLength', elem.maxLengthElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBoolean(xml, 'mustSupport', elem.mustSupportElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBoolean(xml, 'isModifier', elem.isModifierElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBoolean(xml, 'isSummary', elem.isSummaryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(xml, 'binding', elem.binding);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
end;

function TFHIRXmlParser.ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
var
  child : TMXmlElement;
begin
  result := TFhirTimingRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingRepeatChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingRepeatChild(element : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'boundsDuration') then
        element.bounds := ParseDuration(child, path+'/boundsDuration'){x.3}
      else if (child.localName = 'boundsRange') then
        element.bounds := ParseRange(child, path+'/boundsRange'){x.3}
      else if (child.localName = 'boundsPeriod') then
        element.bounds := ParsePeriod(child, path+'/boundsPeriod'){x.3}
      else if (child.localName = 'count') then
        element.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.localName = 'countMax') then
        element.countMaxElement := ParseInteger(child, path+'/countMax') {b}
      else if (child.localName = 'duration') then
        element.durationElement := ParseDecimal(child, path+'/duration') {b}
      else if (child.localName = 'durationMax') then
        element.durationMaxElement := ParseDecimal(child, path+'/durationMax') {b}
      else if (child.localName = 'durationUnit') then
        element.durationUnitElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/durationUnit', child){1a}
      else if (child.localName = 'frequency') then
        element.frequencyElement := ParseInteger(child, path+'/frequency') {b}
      else if (child.localName = 'frequencyMax') then
        element.frequencyMaxElement := ParseInteger(child, path+'/frequencyMax') {b}
      else if (child.localName = 'period') then
        element.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.localName = 'periodMax') then
        element.periodMaxElement := ParseDecimal(child, path+'/periodMax') {b}
      else if (child.localName = 'periodUnit') then
        element.periodUnitElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/periodUnit', child){1a}
      else if (child.localName = 'dayOfWeek') then
        element.dayOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, path+'/dayOfWeek', child)){y.1}
      else if (child.localName = 'timeOfDay') then
        element.timeOfDayList.Add(ParseTime(child, path+'/timeOfDay')){y.2}
      else if (child.localName = 'when') then
        element.whenList.Add(ParseEnum(CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, path+'/when', child)){y.1}
      else if (child.localName = 'offset') then
        element.offsetElement := ParseUnsignedInt(child, path+'/offset') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : String; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingRepeatChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeatChildren(xml : TXmlBuilder; elem : TFhirTimingRepeat);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirDuration) {6} then
    ComposeDuration(xml, 'boundsDuration', TFhirDuration(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(xml, 'boundsRange', TFhirRange(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(xml, 'boundsPeriod', TFhirPeriod(elem.bounds));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'count', elem.countElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'countMax', elem.countMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'duration', elem.durationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'durationMax', elem.durationMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'durationUnit', elem.DurationUnitElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeInteger(xml, 'frequency', elem.frequencyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'frequencyMax', elem.frequencyMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'period', elem.periodElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'periodMax', elem.periodMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'periodUnit', elem.PeriodUnitElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dayOfWeekList.Count - 1 do
      ComposeEnum(xml, 'dayOfWeek', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.timeOfDayList.Count - 1 do
      ComposeTime(xml, 'timeOfDay', elem.timeOfDayList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.whenList.Count - 1 do
      ComposeEnum(xml, 'when', elem.whenList[i], CODES_TFhirEventTimingEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'offset', elem.offsetElement);{x.2b}
end;

function TFHIRXmlParser.ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
var
  child : TMXmlElement;
begin
  result := TFhirTiming.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingChild(element : TFhirTiming; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'event') then
        element.eventList.Add(ParseDateTime(child, path+'/event')){y.2}
      else if (child.localName = 'repeat') then
        element.repeat_ := ParseTimingRepeat(child, path+'/repeat') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : String; elem : TFhirTiming);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingChildren(xml : TXmlBuilder; elem : TFhirTiming);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(xml, 'repeat', elem.repeat_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
end;

function TFHIRXmlParser.ParseCount(element : TMXmlElement; path : string) : TFhirCount;
var
  child : TMXmlElement;
begin
  result := TFhirCount.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCountChild(element : TFhirCount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCount(xml : TXmlBuilder; name : String; elem : TFhirCount);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCountChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCountChildren(xml : TXmlBuilder; elem : TFhirCount);
begin
  composeQuantityChildren(xml, elem);
end;

function TFHIRXmlParser.ParseMoney(element : TMXmlElement; path : string) : TFhirMoney;
var
  child : TMXmlElement;
begin
  result := TFhirMoney.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMoneyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMoneyChild(element : TFhirMoney; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMoney(xml : TXmlBuilder; name : String; elem : TFhirMoney);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMoneyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMoneyChildren(xml : TXmlBuilder; elem : TFhirMoney);
begin
  composeQuantityChildren(xml, elem);
end;

function TFHIRXmlParser.ParseAge(element : TMXmlElement; path : string) : TFhirAge;
var
  child : TMXmlElement;
begin
  result := TFhirAge.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAgeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAgeChild(element : TFhirAge; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAge(xml : TXmlBuilder; name : String; elem : TFhirAge);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAgeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAgeChildren(xml : TXmlBuilder; elem : TFhirAge);
begin
  composeQuantityChildren(xml, elem);
end;

function TFHIRXmlParser.ParseDistance(element : TMXmlElement; path : string) : TFhirDistance;
var
  child : TMXmlElement;
begin
  result := TFhirDistance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDistanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDistanceChild(element : TFhirDistance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDistance(xml : TXmlBuilder; name : String; elem : TFhirDistance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDistanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDistanceChildren(xml : TXmlBuilder; elem : TFhirDistance);
begin
  composeQuantityChildren(xml, elem);
end;

function TFHIRXmlParser.ParseDuration(element : TMXmlElement; path : string) : TFhirDuration;
var
  child : TMXmlElement;
begin
  result := TFhirDuration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDurationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDurationChild(element : TFhirDuration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDuration(xml : TXmlBuilder; name : String; elem : TFhirDuration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDurationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDurationChildren(xml : TXmlBuilder; elem : TFhirDuration);
begin
  composeQuantityChildren(xml, elem);
end;

{$IFDEF FHIR_ACCOUNT}
function TFHIRXmlParser.ParseAccountCoverage(element : TMXmlElement; path : string) : TFhirAccountCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirAccountCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountCoverageChild(element : TFhirAccountCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParsePositiveInt(child, path+'/priority') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountCoverage(xml : TXmlBuilder; name : String; elem : TFhirAccountCoverage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountCoverageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountCoverageChildren(xml : TXmlBuilder; elem : TFhirAccountCoverage);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'priority', elem.priorityElement);{x.2b}
end;

function TFHIRXmlParser.ParseAccountGuarantor(element : TMXmlElement; path : string) : TFhirAccountGuarantor;
var
  child : TMXmlElement;
begin
  result := TFhirAccountGuarantor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountGuarantorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountGuarantorChild(element : TFhirAccountGuarantor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if (child.localName = 'onHold') then
        element.onHoldElement := ParseBoolean(child, path+'/onHold') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountGuarantor(xml : TXmlBuilder; name : String; elem : TFhirAccountGuarantor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountGuarantorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountGuarantorChildren(xml : TXmlBuilder; elem : TFhirAccountGuarantor);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'onHold', elem.onHoldElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
var
  child : TMXmlElement;
begin
  result := TFhirAccount.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountChild(element : TFhirAccount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'active') then
        element.active := ParsePeriod(child, path+'/active') {b}
      else if (child.localName = 'balance') then
        element.balance := ParseMoney(child, path+'/balance') {b}
      else if (child.localName = 'coverage') then
        element.coverageList.Add(ParseAccountCoverage(child, path+'/coverage')){y.2}
      else if (child.localName = 'owner') then
        element.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'guarantor') then
        element.guarantorList.Add(ParseAccountGuarantor(child, path+'/guarantor')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccount(xml : TXmlBuilder; name : String; elem : TFhirAccount);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountChildren(xml : TXmlBuilder; elem : TFhirAccount);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAccountStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposePeriod(xml, 'active', elem.active);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('balance') then
    ComposeMoney(xml, 'balance', elem.balance);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeAccountCoverage(xml, 'coverage', elem.coverageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('guarantor') then
    for i := 0 to elem.guarantorList.Count - 1 do
      ComposeAccountGuarantor(xml, 'guarantor', elem.guarantorList[i]);
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
function TFHIRXmlParser.ParseActivityDefinitionParticipant(element : TMXmlElement; path : string) : TFhirActivityDefinitionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionParticipantChild(element : TFhirActivityDefinitionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionParticipant(xml : TXmlBuilder; name : String; elem : TFhirActivityDefinitionParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionParticipantChildren(xml : TXmlBuilder; elem : TFhirActivityDefinitionParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
end;

function TFHIRXmlParser.ParseActivityDefinitionDynamicValue(element : TMXmlElement; path : string) : TFhirActivityDefinitionDynamicValue;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionDynamicValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionDynamicValueChild(element : TFhirActivityDefinitionDynamicValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseString(child, path+'/language') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionDynamicValue(xml : TXmlBuilder; name : String; elem : TFhirActivityDefinitionDynamicValue);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionDynamicValueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionDynamicValueChildren(xml : TXmlBuilder; elem : TFhirActivityDefinitionDynamicValue);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
end;

function TFHIRXmlParser.ParseActivityDefinition(element : TMXmlElement; path : string) : TFhirActivityDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionChild(element : TFhirActivityDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseCodeableConcept(child, path+'/topic')){y.2}
      else if (child.localName = 'contributor') then
        element.contributorList.Add(ParseContributor(child, path+'/contributor')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'library') then
        element.library_List.Add(ParseReference{TFhirLibrary}(child, path+'/library')){y.2}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/kind', child){1a}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingRange') then
        element.timing := ParseRange(child, path+'/timingRange'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseActivityDefinitionParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'productReference') then
        element.product := ParseReference(child, path+'/productReference') {a}
      else if (child.localName = 'productCodeableConcept') then
        element.product := ParseCodeableConcept(child, path+'/productCodeableConcept'){x.3}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'dosage') then
        element.dosageList.Add(ParseDosage(child, path+'/dosage')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'transform') then
        element.transform := ParseReference{TFhirStructureMap}(child, path+'/transform') {b}
      else if (child.localName = 'dynamicValue') then
        element.dynamicValueList.Add(ParseActivityDefinitionDynamicValue(child, path+'/dynamicValue')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinition(xml : TXmlBuilder; name : String; elem : TFhirActivityDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionChildren(xml : TXmlBuilder; elem : TFhirActivityDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(xml, 'contributor', elem.contributorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(xml, 'library', elem.library_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('kind') then
    ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(elem.product));
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(xml, 'dosage', elem.dosageList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('transform') then
    ComposeReference{TFhirStructureMap}(xml, 'transform', elem.transform);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('dynamicValue') then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(xml, 'dynamicValue', elem.dynamicValueList[i]);
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
function TFHIRXmlParser.ParseAdverseEventSuspectEntity(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntity;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventSuspectEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventSuspectEntityChild(element : TFhirAdverseEventSuspectEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'instance') then
        element.instance := ParseReference{Resource}(child, path+'/instance') {b}
      else if (child.localName = 'causality') then
        element.causalityElement := ParseEnum(CODES_TFhirAdverseEventCausalityEnum, SYSTEMS_TFhirAdverseEventCausalityEnum, path+'/causality', child){1a}
      else if (child.localName = 'causalityAssessment') then
        element.causalityAssessment := ParseCodeableConcept(child, path+'/causalityAssessment') {b}
      else if (child.localName = 'causalityProductRelatedness') then
        element.causalityProductRelatednessElement := ParseString(child, path+'/causalityProductRelatedness') {b}
      else if (child.localName = 'causalityMethod') then
        element.causalityMethod := ParseCodeableConcept(child, path+'/causalityMethod') {b}
      else if (child.localName = 'causalityAuthor') then
        element.causalityAuthor := ParseReference{Resource}(child, path+'/causalityAuthor') {b}
      else if (child.localName = 'causalityResult') then
        element.causalityResult := ParseCodeableConcept(child, path+'/causalityResult') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntity(xml : TXmlBuilder; name : String; elem : TFhirAdverseEventSuspectEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventSuspectEntityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntityChildren(xml : TXmlBuilder; elem : TFhirAdverseEventSuspectEntity);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'instance', elem.instance);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'causality', elem.CausalityElement, CODES_TFhirAdverseEventCausalityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'causalityAssessment', elem.causalityAssessment);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'causalityProductRelatedness', elem.causalityProductRelatednessElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'causalityMethod', elem.causalityMethod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'causalityAuthor', elem.causalityAuthor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'causalityResult', elem.causalityResult);{x.2a}
end;

function TFHIRXmlParser.ParseAdverseEvent(element : TMXmlElement; path : string) : TFhirAdverseEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEvent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventChild(element : TFhirAdverseEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirAdverseEventCategoryEnum, SYSTEMS_TFhirAdverseEventCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'reaction') then
        element.reactionList.Add(ParseReference{TFhirCondition}(child, path+'/reaction')){y.2}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'seriousness') then
        element.seriousness := ParseCodeableConcept(child, path+'/seriousness') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'recorder') then
        element.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.localName = 'eventParticipant') then
        element.eventParticipant := ParseReference{Resource}(child, path+'/eventParticipant') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'suspectEntity') then
        element.suspectEntityList.Add(ParseAdverseEventSuspectEntity(child, path+'/suspectEntity')){y.2}
      else if (child.localName = 'subjectMedicalHistory') then
        element.subjectMedicalHistoryList.Add(ParseReference{Resource}(child, path+'/subjectMedicalHistory')){y.2}
      else if (child.localName = 'referenceDocument') then
        element.referenceDocumentList.Add(ParseReference{TFhirDocumentReference}(child, path+'/referenceDocument')){y.2}
      else if (child.localName = 'study') then
        element.studyList.Add(ParseReference{TFhirResearchStudy}(child, path+'/study')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEvent(xml : TXmlBuilder; name : String; elem : TFhirAdverseEvent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventChildren(xml : TXmlBuilder; elem : TFhirAdverseEvent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirAdverseEventCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'reaction', elem.reactionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('seriousness') then
    ComposeCodeableConcept(xml, 'seriousness', elem.seriousness);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('eventParticipant') then
    ComposeReference{Resource}(xml, 'eventParticipant', elem.eventParticipant);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suspectEntity') then
    for i := 0 to elem.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(xml, 'suspectEntity', elem.suspectEntityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectMedicalHistory') then
    for i := 0 to elem.subjectMedicalHistoryList.Count - 1 do
      ComposeReference{Resource}(xml, 'subjectMedicalHistory', elem.subjectMedicalHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceDocument') then
    for i := 0 to elem.referenceDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(xml, 'referenceDocument', elem.referenceDocumentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('study') then
    for i := 0 to elem.studyList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(xml, 'study', elem.studyList[i]);
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRXmlParser.ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceReactionChild(element : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substance') then
        element.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.localName = 'manifestation') then
        element.manifestationList.Add(ParseCodeableConcept(child, path+'/manifestation')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'onset') then
        element.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'exposureRoute') then
        element.exposureRoute := ParseCodeableConcept(child, path+'/exposureRoute') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : String; elem : TFhirAllergyIntoleranceReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceReactionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; elem : TFhirAllergyIntoleranceReaction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2a}
  for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(xml, 'manifestation', elem.manifestationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'exposureRoute', elem.exposureRoute);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceChild(element : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'clinicalStatus') then
        element.clinicalStatusElement := ParseEnum(CODES_TFhirAllergyClinicalStatusEnum, SYSTEMS_TFhirAllergyClinicalStatusEnum, path+'/clinicalStatus', child){1a}
      else if (child.localName = 'verificationStatus') then
        element.verificationStatusElement := ParseEnum(CODES_TFhirAllergyVerificationStatusEnum, SYSTEMS_TFhirAllergyVerificationStatusEnum, path+'/verificationStatus', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseEnum(CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, path+'/category', child)){y.1}
      else if (child.localName = 'criticality') then
        element.criticalityElement := ParseEnum(CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, path+'/criticality', child){1a}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'onsetAge') then
        element.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.localName = 'onsetPeriod') then
        element.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.localName = 'onsetRange') then
        element.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.localName = 'onsetDateTime') then
        element.onset := ParseDateTime(child, path+'/onsetDateTime'){x.3}
      else if (child.localName = 'onsetString') then
        element.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.localName = 'assertedDate') then
        element.assertedDateElement := ParseDateTime(child, path+'/assertedDate') {b}
      else if (child.localName = 'recorder') then
        element.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.localName = 'asserter') then
        element.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.localName = 'lastOccurrence') then
        element.lastOccurrenceElement := ParseDateTime(child, path+'/lastOccurrence') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'reaction') then
        element.reactionList.Add(ParseAllergyIntoleranceReaction(child, path+'/reaction')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : String; elem : TFhirAllergyIntolerance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeEnum(xml, 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirAllergyClinicalStatusEnum);
  ComposeEnum(xml, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirAllergyVerificationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeEnum(xml, 'category', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnum(xml, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soData]) and doCompose('assertedDate') then
    ComposeDateTime(xml, 'assertedDate', elem.assertedDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('lastOccurrence') then
    ComposeDateTime(xml, 'lastOccurrence', elem.lastOccurrenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(xml, 'reaction', elem.reactionList[i]);
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRXmlParser.ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentParticipantChild(element : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'required') then
        element.requiredElement := ParseEnum(CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, path+'/required', child){1a}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, path+'/status', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : String; elem : TFhirAppointmentParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipantChildren(xml : TXmlBuilder; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum);
end;

function TFHIRXmlParser.ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
var
  child : TMXmlElement;
begin
  result := TFhirAppointment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentChild(element : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, path+'/status', child){1a}
      else if (child.localName = 'serviceCategory') then
        element.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.localName = 'serviceType') then
        element.serviceTypeList.Add(ParseCodeableConcept(child, path+'/serviceType')){y.2}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'appointmentType') then
        element.appointmentType := ParseCodeableConcept(child, path+'/appointmentType') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'indication') then
        element.indicationList.Add(ParseReference{Resource}(child, path+'/indication')){y.2}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseUnsignedInt(child, path+'/priority') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'minutesDuration') then
        element.minutesDurationElement := ParsePositiveInt(child, path+'/minutesDuration') {b}
      else if (child.localName = 'slot') then
        element.slotList.Add(ParseReference{TFhirSlot}(child, path+'/slot')){y.2}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'incomingReferral') then
        element.incomingReferralList.Add(ParseReference{TFhirReferralRequest}(child, path+'/incomingReferral')){y.2}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseAppointmentParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'requestedPeriod') then
        element.requestedPeriodList.Add(ParsePeriod(child, path+'/requestedPeriod')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : String; elem : TFhirAppointment);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentChildren(xml : TXmlBuilder; elem : TFhirAppointment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceType', elem.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(xml, 'appointmentType', elem.appointmentType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedInt(xml, 'priority', elem.priorityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveInt(xml, 'minutesDuration', elem.minutesDurationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('slot') then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(xml, 'slot', elem.slotList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'incomingReferral', elem.incomingReferralList[i]);
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('requestedPeriod') then
    for i := 0 to elem.requestedPeriodList.Count - 1 do
      ComposePeriod(xml, 'requestedPeriod', elem.requestedPeriodList[i]);
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRXmlParser.ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentResponseChild(element : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'appointment') then
        element.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'participantType') then
        element.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType')){y.2}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'participantStatus') then
        element.participantStatusElement := ParseEnum(CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, path+'/participantStatus', child){1a}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : String; elem : TFhirAppointmentResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponseChildren(xml : TXmlBuilder; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'participantType', elem.participantTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  ComposeEnum(xml, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipationstatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRXmlParser.ParseAuditEventAgent(element : TMXmlElement; path : string) : TFhirAuditEventAgent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventAgentChild(element : TFhirAuditEventAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.localName = 'userId') then
        element.userId := ParseIdentifier(child, path+'/userId') {b}
      else if (child.localName = 'altId') then
        element.altIdElement := ParseString(child, path+'/altId') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'requestor') then
        element.requestorElement := ParseBoolean(child, path+'/requestor') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'policy') then
        element.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.localName = 'media') then
        element.media := ParseCoding(child, path+'/media') {b}
      else if (child.localName = 'network') then
        element.network := ParseAuditEventAgentNetwork(child, path+'/network') {b}
      else if (child.localName = 'purposeOfUse') then
        element.purposeOfUseList.Add(ParseCodeableConcept(child, path+'/purposeOfUse')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgent(xml : TXmlBuilder; name : String; elem : TFhirAuditEventAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgentChildren(xml : TXmlBuilder; elem : TFhirAuditEventAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'userId', elem.userId);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'altId', elem.altIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeBoolean(xml, 'requestor', elem.requestorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'media', elem.media);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventAgentNetwork(xml, 'network', elem.network);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCodeableConcept(xml, 'purposeOfUse', elem.purposeOfUseList[i]);
end;

function TFHIRXmlParser.ParseAuditEventAgentNetwork(element : TMXmlElement; path : string) : TFhirAuditEventAgentNetwork;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventAgentNetworkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventAgentNetworkChild(element : TFhirAuditEventAgentNetwork; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'address') then
        element.addressElement := ParseString(child, path+'/address') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgentNetwork(xml : TXmlBuilder; name : String; elem : TFhirAuditEventAgentNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventAgentNetworkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgentNetworkChildren(xml : TXmlBuilder; elem : TFhirAuditEventAgentNetwork);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'address', elem.addressElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum);
end;

function TFHIRXmlParser.ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventSourceChild(element : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        element.siteElement := ParseString(child, path+'/site') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSource(xml : TXmlBuilder; name : String; elem : TFhirAuditEventSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventSourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSourceChildren(xml : TXmlBuilder; elem : TFhirAuditEventSource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'site', elem.siteElement);{x.2b}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
end;

function TFHIRXmlParser.ParseAuditEventEntity(element : TMXmlElement; path : string) : TFhirAuditEventEntity;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventEntityChild(element : TFhirAuditEventEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'role') then
        element.role := ParseCoding(child, path+'/role') {b}
      else if (child.localName = 'lifecycle') then
        element.lifecycle := ParseCoding(child, path+'/lifecycle') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'query') then
        element.queryElement := ParseBase64Binary(child, path+'/query') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseAuditEventEntityDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntity(xml : TXmlBuilder; name : String; elem : TFhirAuditEventEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventEntityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityChildren(xml : TXmlBuilder; elem : TFhirAuditEventEntity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'lifecycle', elem.lifecycle);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'query', elem.queryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseAuditEventEntityDetail(element : TMXmlElement; path : string) : TFhirAuditEventEntityDetail;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventEntityDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventEntityDetailChild(element : TFhirAuditEventEntityDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseString(child, path+'/type') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityDetail(xml : TXmlBuilder; name : String; elem : TFhirAuditEventEntityDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventEntityDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityDetailChildren(xml : TXmlBuilder; elem : TFhirAuditEventEntityDetail);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'type', elem.type_Element);{x.2b}
  ComposeBase64Binary(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEvent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventChild(element : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'subtype') then
        element.subtypeList.Add(ParseCoding(child, path+'/subtype')){y.2}
      else if (child.localName = 'action') then
        element.actionElement := ParseEnum(CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, path+'/action', child){1a}
      else if (child.localName = 'recorded') then
        element.recordedElement := ParseInstant(child, path+'/recorded') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'outcomeDesc') then
        element.outcomeDescElement := ParseString(child, path+'/outcomeDesc') {b}
      else if (child.localName = 'purposeOfEvent') then
        element.purposeOfEventList.Add(ParseCodeableConcept(child, path+'/purposeOfEvent')){y.2}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseAuditEventAgent(child, path+'/agent')){y.2}
      else if (child.localName = 'source') then
        element.source := ParseAuditEventSource(child, path+'/source') {b}
      else if (child.localName = 'entity') then
        element.entityList.Add(ParseAuditEventEntity(child, path+'/entity')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEvent(xml : TXmlBuilder; name : String; elem : TFhirAuditEvent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventChildren(xml : TXmlBuilder; elem : TFhirAuditEvent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(xml, 'subtype', elem.subtypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum);
  ComposeInstant(xml, 'recorded', elem.recordedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcomeDesc') then
    ComposeString(xml, 'outcomeDesc', elem.outcomeDescElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purposeOfEvent') then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCodeableConcept(xml, 'purposeOfEvent', elem.purposeOfEventList[i]);
  for i := 0 to elem.agentList.Count - 1 do
      ComposeAuditEventAgent(xml, 'agent', elem.agentList[i]);
  ComposeAuditEventSource(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeAuditEventEntity(xml, 'entity', elem.entityList[i]);
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRXmlParser.ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
var
  child : TMXmlElement;
begin
  result := TFhirBasic.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBasicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBasicChild(element : TFhirBasic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDate(child, path+'/created') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBasic(xml : TXmlBuilder; name : String; elem : TFhirBasic);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBasicChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBasicChildren(xml : TXmlBuilder; elem : TFhirBasic);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDate(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRXmlParser.ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
var
  child : TMXmlElement;
begin
  result := TFhirBinary.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBinaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBinaryChild(element : TFhirBinary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'securityContext') then
        element.securityContext := ParseReference{TFhirReference}(child, path+'/securityContext') {b}
      else if (child.localName = 'content') then
        element.contentElement := ParseBase64Binary(child, path+'/content') {b}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBinary(xml : TXmlBuilder; name : String; elem : TFhirBinary);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBinaryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBinaryChildren(xml : TXmlBuilder; elem : TFhirBinary);
begin
  composeResourceChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityContext') then
    ComposeReference{TFhirReference}(xml, 'securityContext', elem.securityContext);{x.2a}
  ComposeBase64Binary(xml, 'content', elem.contentElement);{x.2b}
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
function TFHIRXmlParser.ParseBodySite(element : TMXmlElement; path : string) : TFhirBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirBodySite.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBodySiteChild(element : TFhirBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'qualifier') then
        element.qualifierList.Add(ParseCodeableConcept(child, path+'/qualifier')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'image') then
        element.imageList.Add(ParseAttachment(child, path+'/image')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBodySite(xml : TXmlBuilder; name : String; elem : TFhirBodySite);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBodySiteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBodySiteChildren(xml : TXmlBuilder; elem : TFhirBodySite);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('qualifier') then
    for i := 0 to elem.qualifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'qualifier', elem.qualifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(xml, 'image', elem.imageList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
end;

{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
function TFHIRXmlParser.ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
var
  child : TMXmlElement;
begin
  result := TFhirBundleLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleLinkChild(element : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relation') then
        element.relationElement := ParseString(child, path+'/relation') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleLink(xml : TXmlBuilder; name : String; elem : TFhirBundleLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleLinkChildren(xml : TXmlBuilder; elem : TFhirBundleLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'relation', elem.relationElement);{x.2b}
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryChild(element : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        element.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.localName = 'fullUrl') then
        element.fullUrlElement := ParseUri(child, path+'/fullUrl') {b}
      else if (child.localName = 'resource') then
        element.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.localName = 'search') then
        element.search := ParseBundleEntrySearch(child, path+'/search') {b}
      else if (child.localName = 'request') then
        element.request := ParseBundleEntryRequest(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseBundleEntryResponse(child, path+'/response') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntry(xml : TXmlBuilder; name : String; elem : TFhirBundleEntry);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryChildren(xml : TXmlBuilder; elem : TFhirBundleEntry);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'fullUrl', elem.fullUrlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(xml, 'search', elem.search);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(xml, 'response', elem.response);{x.2a}
end;

function TFHIRXmlParser.ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntrySearch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntrySearchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntrySearchChild(element : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'score') then
        element.scoreElement := ParseDecimal(child, path+'/score') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearch(xml : TXmlBuilder; name : String; elem : TFhirBundleEntrySearch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntrySearchChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearchChildren(xml : TXmlBuilder; elem : TFhirBundleEntrySearch);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'score', elem.scoreElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryRequestChild(element : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'method') then
        element.methodElement := ParseEnum(CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, path+'/method', child){1a}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'ifNoneMatch') then
        element.ifNoneMatchElement := ParseString(child, path+'/ifNoneMatch') {b}
      else if (child.localName = 'ifModifiedSince') then
        element.ifModifiedSinceElement := ParseInstant(child, path+'/ifModifiedSince') {b}
      else if (child.localName = 'ifMatch') then
        element.ifMatchElement := ParseString(child, path+'/ifMatch') {b}
      else if (child.localName = 'ifNoneExist') then
        element.ifNoneExistElement := ParseString(child, path+'/ifNoneExist') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequest(xml : TXmlBuilder; name : String; elem : TFhirBundleEntryRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequestChildren(xml : TXmlBuilder; elem : TFhirBundleEntryRequest);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneMatch', elem.ifNoneMatchElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'ifModifiedSince', elem.ifModifiedSinceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifMatch', elem.ifMatchElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneExist', elem.ifNoneExistElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryResponseChild(element : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseString(child, path+'/status') {b}
      else if (child.localName = 'location') then
        element.locationElement := ParseUri(child, path+'/location') {b}
      else if (child.localName = 'etag') then
        element.etagElement := ParseString(child, path+'/etag') {b}
      else if (child.localName = 'lastModified') then
        element.lastModifiedElement := ParseInstant(child, path+'/lastModified') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseInnerResource(child, path+'/outcome') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponse(xml : TXmlBuilder; name : String; elem : TFhirBundleEntryResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponseChildren(xml : TXmlBuilder; elem : TFhirBundleEntryResponse);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'status', elem.statusElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'location', elem.locationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'etag', elem.etagElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastModified', elem.lastModifiedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'outcome', elem, elem.outcome);{x.2a}
end;

function TFHIRXmlParser.ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
var
  child : TMXmlElement;
begin
  result := TFhirBundle.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleChild(element : TFhirBundle; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'total') then
        element.totalElement := ParseUnsignedInt(child, path+'/total') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseBundleEntry(child, path+'/entry')){y.2}
      else if (child.localName = 'signature') then
        element.signature := ParseSignature(child, path+'/signature') {b}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundle(xml : TXmlBuilder; name : String; elem : TFhirBundle);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleChildren(xml : TXmlBuilder; elem : TFhirBundle);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(xml, 'total', elem.totalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(xml, 'signature', elem.signature);{x.2a}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
function TFHIRXmlParser.ParseCapabilityStatementSoftware(element : TMXmlElement; path : string) : TFhirCapabilityStatementSoftware;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementSoftwareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementSoftwareChild(element : TFhirCapabilityStatementSoftware; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'releaseDate') then
        element.releaseDateElement := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementSoftware(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementSoftwareChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementSoftwareChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementSoftware);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'releaseDate', elem.releaseDateElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementImplementation(element : TMXmlElement; path : string) : TFhirCapabilityStatementImplementation;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementImplementationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementImplementationChild(element : TFhirCapabilityStatementImplementation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementImplementation(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementImplementationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementImplementationChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementImplementation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementRest(element : TMXmlElement; path : string) : TFhirCapabilityStatementRest;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestChild(element : TFhirCapabilityStatementRest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'security') then
        element.security := ParseCapabilityStatementRestSecurity(child, path+'/security') {b}
      else if (child.localName = 'resource') then
        element.resourceList.Add(ParseCapabilityStatementRestResource(child, path+'/resource')){y.2}
      else if (child.localName = 'interaction') then
        element.interactionList.Add(ParseCapabilityStatementRestInteraction(child, path+'/interaction')){y.2}
      else if (child.localName = 'searchParam') then
        element.searchParamList.Add(ParseCapabilityStatementRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if (child.localName = 'operation') then
        element.operationList.Add(ParseCapabilityStatementRestOperation(child, path+'/operation')){y.2}
      else if (child.localName = 'compartment') then
        element.compartmentList.Add(ParseUri(child, path+'/compartment')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRest(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirRestfulCapabilityModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(xml, 'security', elem.security);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(xml, 'resource', elem.resourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestOperation(xml, 'operation', elem.operationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(xml, 'compartment', elem.compartmentList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurity(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurity;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestSecurityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurityChild(element : TFhirCapabilityStatementRestSecurity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'cors') then
        element.corsElement := ParseBoolean(child, path+'/cors') {b}
      else if (child.localName = 'service') then
        element.serviceList.Add(ParseCodeableConcept(child, path+'/service')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'certificate') then
        element.certificateList.Add(ParseCapabilityStatementRestSecurityCertificate(child, path+'/certificate')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurity(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestSecurity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestSecurityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurityChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestSecurity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'cors', elem.corsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeCapabilityStatementRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurityCertificate(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurityCertificate;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestSecurityCertificateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurityCertificateChild(element : TFhirCapabilityStatementRestSecurityCertificate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.localName = 'blob') then
        element.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurityCertificate(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestSecurityCertificateChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurityCertificateChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestSecurityCertificate);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'type', elem.type_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResource(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResource;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceChild(element : TFhirCapabilityStatementRestResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseMarkdown(child, path+'/documentation') {b}
      else if (child.localName = 'interaction') then
        element.interactionList.Add(ParseCapabilityStatementRestResourceInteraction(child, path+'/interaction')){y.2}
      else if (child.localName = 'versioning') then
        element.versioningElement := ParseEnum(CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, path+'/versioning', child){1a}
      else if (child.localName = 'readHistory') then
        element.readHistoryElement := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.localName = 'updateCreate') then
        element.updateCreateElement := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.localName = 'conditionalCreate') then
        element.conditionalCreateElement := ParseBoolean(child, path+'/conditionalCreate') {b}
      else if (child.localName = 'conditionalRead') then
        element.conditionalReadElement := ParseEnum(CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum, path+'/conditionalRead', child){1a}
      else if (child.localName = 'conditionalUpdate') then
        element.conditionalUpdateElement := ParseBoolean(child, path+'/conditionalUpdate') {b}
      else if (child.localName = 'conditionalDelete') then
        element.conditionalDeleteElement := ParseEnum(CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, path+'/conditionalDelete', child){1a}
      else if (child.localName = 'referencePolicy') then
        element.referencePolicyList.Add(ParseEnum(CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, path+'/referencePolicy', child)){y.1}
      else if (child.localName = 'searchInclude') then
        element.searchIncludeList.Add(ParseString(child, path+'/searchInclude')){y.2}
      else if (child.localName = 'searchRevInclude') then
        element.searchRevIncludeList.Add(ParseString(child, path+'/searchRevInclude')){y.2}
      else if (child.localName = 'searchParam') then
        element.searchParamList.Add(ParseCapabilityStatementRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResource(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', elem.documentationElement);{x.2b}
  for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readHistory', elem.readHistoryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'updateCreate', elem.updateCreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalCreate', elem.conditionalCreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'conditionalRead', elem.ConditionalReadElement, CODES_TFhirConditionalReadStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalUpdate', elem.conditionalUpdateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencePolicyList.Count - 1 do
      ComposeEnum(xml, 'referencePolicy', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(xml, 'searchRevInclude', elem.searchRevIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceInteractionChild(element : TFhirCapabilityStatementRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceInteraction(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceInteractionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceInteractionChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResourceInteraction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceSearchParam;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceSearchParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceSearchParamChild(element : TFhirCapabilityStatementRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceSearchParam(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestResourceSearchParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceSearchParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceSearchParamChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestResourceSearchParam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', elem.definitionElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementRestInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestInteractionChild(element : TFhirCapabilityStatementRestInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestInteraction(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestInteractionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestInteractionChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestInteraction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementRestOperation(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestOperation;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestOperationChild(element : TFhirCapabilityStatementRestOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'definition') then
        element.definition := ParseReference{TFhirOperationDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestOperation(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestOperationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestOperationChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementRestOperation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeReference{TFhirOperationDefinition}(xml, 'definition', elem.definition);{x.2a}
end;

function TFHIRXmlParser.ParseCapabilityStatementMessaging(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessaging;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingChild(element : TFhirCapabilityStatementMessaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseCapabilityStatementMessagingEndpoint(child, path+'/endpoint')){y.2}
      else if (child.localName = 'reliableCache') then
        element.reliableCacheElement := ParseUnsignedInt(child, path+'/reliableCache') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'supportedMessage') then
        element.supportedMessageList.Add(ParseCapabilityStatementMessagingSupportedMessage(child, path+'/supportedMessage')){y.2}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseCapabilityStatementMessagingEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessaging(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementMessaging);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(xml, 'endpoint', elem.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'reliableCache', elem.reliableCacheElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(xml, 'supportedMessage', elem.supportedMessageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCapabilityStatementMessagingEvent(xml, 'event', elem.eventList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEndpoint(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEndpoint;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingEndpointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEndpointChild(element : TFhirCapabilityStatementMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'protocol') then
        element.protocol := ParseCoding(child, path+'/protocol') {b}
      else if (child.localName = 'address') then
        element.addressElement := ParseUri(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEndpoint(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementMessagingEndpoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingEndpointChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEndpointChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingEndpoint);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'protocol', elem.protocol);{x.2a}
  ComposeUri(xml, 'address', elem.addressElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingSupportedMessage(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingSupportedMessage;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingSupportedMessageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingSupportedMessageChild(element : TFhirCapabilityStatementMessagingSupportedMessage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'definition') then
        element.definition := ParseReference{TFhirMessageDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingSupportedMessage(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementMessagingSupportedMessage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingSupportedMessageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingSupportedMessageChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingSupportedMessage);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum);
  ComposeReference{TFhirMessageDefinition}(xml, 'definition', elem.definition);{x.2a}
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEvent(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEvent;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEventChild(element : TFhirCapabilityStatementMessagingEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'focus') then
        element.focusElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/focus', child){1a}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirStructureDefinition}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirStructureDefinition}(child, path+'/response') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEvent(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementMessagingEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEventChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementMessagingEvent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum);
  ComposeEnum(xml, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum);
  ComposeReference{TFhirStructureDefinition}(xml, 'request', elem.request);{x.2a}
  ComposeReference{TFhirStructureDefinition}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseCapabilityStatementDocument(element : TMXmlElement; path : string) : TFhirCapabilityStatementDocument;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementDocumentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementDocumentChild(element : TFhirCapabilityStatementDocument; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementDocument(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatementDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementDocumentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementDocumentChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatementDocument);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseCapabilityStatement(element : TMXmlElement; path : string) : TFhirCapabilityStatement;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementChild(element : TFhirCapabilityStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'instantiates') then
        element.instantiatesList.Add(ParseUri(child, path+'/instantiates')){y.2}
      else if (child.localName = 'software') then
        element.software := ParseCapabilityStatementSoftware(child, path+'/software') {b}
      else if (child.localName = 'implementation') then
        element.implementation_ := ParseCapabilityStatementImplementation(child, path+'/implementation') {b}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'acceptUnknown') then
        element.acceptUnknownElement := ParseEnum(CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, path+'/acceptUnknown', child){1a}
      else if (child.localName = 'format') then
        element.formatList.Add(ParseCode(child, path+'/format')){y.2}
      else if (child.localName = 'patchFormat') then
        element.patchFormatList.Add(ParseCode(child, path+'/patchFormat')){y.2}
      else if (child.localName = 'implementationGuide') then
        element.implementationGuideList.Add(ParseUri(child, path+'/implementationGuide')){y.2}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseReference{TFhirStructureDefinition}(child, path+'/profile')){y.2}
      else if (child.localName = 'rest') then
        element.restList.Add(ParseCapabilityStatementRest(child, path+'/rest')){y.2}
      else if (child.localName = 'messaging') then
        element.messagingList.Add(ParseCapabilityStatementMessaging(child, path+'/messaging')){y.2}
      else if (child.localName = 'document') then
        element.documentList.Add(ParseCapabilityStatementDocument(child, path+'/document')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatement(xml : TXmlBuilder; name : String; elem : TFhirCapabilityStatement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementChildren(xml : TXmlBuilder; elem : TFhirCapabilityStatement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') then
    for i := 0 to elem.instantiatesList.Count - 1 do
      ComposeUri(xml, 'instantiates', elem.instantiatesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeCapabilityStatementSoftware(xml, 'software', elem.software);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeCapabilityStatementImplementation(xml, 'implementation', elem.implementation_);{x.2a}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  ComposeEnum(xml, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum);
  for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(xml, 'format', elem.formatList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patchFormat') then
    for i := 0 to elem.patchFormatList.Count - 1 do
      ComposeCode(xml, 'patchFormat', elem.patchFormatList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementationGuide') then
    for i := 0 to elem.implementationGuideList.Count - 1 do
      ComposeUri(xml, 'implementationGuide', elem.implementationGuideList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') then
    for i := 0 to elem.restList.Count - 1 do
      ComposeCapabilityStatementRest(xml, 'rest', elem.restList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('messaging') then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(xml, 'messaging', elem.messagingList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('document') then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(xml, 'document', elem.documentList[i]);
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
function TFHIRXmlParser.ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityChild(element : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'outcomeCodeableConcept') then
        element.outcomeCodeableConceptList.Add(ParseCodeableConcept(child, path+'/outcomeCodeableConcept')){y.2}
      else if (child.localName = 'outcomeReference') then
        element.outcomeReferenceList.Add(ParseReference{TFhirReference}(child, path+'/outcomeReference')){y.2}
      else if (child.localName = 'progress') then
        element.progressList.Add(ParseAnnotation(child, path+'/progress')){y.2}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.localName = 'detail') then
        element.detail := ParseCarePlanActivityDetail(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : String; elem : TFhirCarePlanActivity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(xml, 'outcomeCodeableConcept', elem.outcomeCodeableConceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'outcomeReference', elem.outcomeReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(xml, 'progress', elem.progressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(xml, 'detail', elem.detail);{x.2a}
end;

function TFHIRXmlParser.ParseCarePlanActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityDetail;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityDetailChild(element : TFhirCarePlanActivityDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'definition') then
        element.definition := ParseReference{Resource}(child, path+'/definition') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{TFhirCondition}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'goal') then
        element.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusReason') then
        element.statusReasonElement := ParseString(child, path+'/statusReason') {b}
      else if (child.localName = 'prohibited') then
        element.prohibitedElement := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.localName = 'scheduledTiming') then
        element.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.localName = 'scheduledPeriod') then
        element.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.localName = 'scheduledString') then
        element.scheduled := ParseString(child, path+'/scheduledString'){x.3}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.localName = 'productCodeableConcept') then
        element.product := ParseCodeableConcept(child, path+'/productCodeableConcept'){x.3}
      else if (child.localName = 'productReference') then
        element.product := ParseReference(child, path+'/productReference') {a}
      else if (child.localName = 'dailyAmount') then
        element.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : String; elem : TFhirCarePlanActivityDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetailChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivityDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'definition', elem.definition);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'statusReason', elem.statusReasonElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.prohibited <> false)) then
    ComposeBoolean(xml, 'prohibited', elem.prohibitedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(elem.scheduled));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlan.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanChild(element : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirCarePlan}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirCarePlan}(child, path+'/replaces')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirCarePlan}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'careTeam') then
        element.careTeamList.Add(ParseReference{TFhirCareTeam}(child, path+'/careTeam')){y.2}
      else if (child.localName = 'addresses') then
        element.addressesList.Add(ParseReference{TFhirCondition}(child, path+'/addresses')){y.2}
      else if (child.localName = 'supportingInfo') then
        element.supportingInfoList.Add(ParseReference{TFhirReference}(child, path+'/supportingInfo')){y.2}
      else if (child.localName = 'goal') then
        element.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.localName = 'activity') then
        element.activityList.Add(ParseCarePlanActivity(child, path+'/activity')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : String; elem : TFhirCarePlan);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanChildren(xml : TXmlBuilder; elem : TFhirCarePlan);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCarePlan}(xml, 'replaces', elem.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirCarePlan}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum);
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirCarePlanIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(xml, 'careTeam', elem.careTeamList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'addresses', elem.addressesList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInfo', elem.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
function TFHIRXmlParser.ParseCareTeamParticipant(element : TMXmlElement; path : string) : TFhirCareTeamParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirCareTeamParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCareTeamParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCareTeamParticipantChild(element : TFhirCareTeamParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'member') then
        element.member := ParseReference{Resource}(child, path+'/member') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCareTeamParticipant(xml : TXmlBuilder; name : String; elem : TFhirCareTeamParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCareTeamParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCareTeamParticipantChildren(xml : TXmlBuilder; elem : TFhirCareTeamParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'member', elem.member);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseCareTeam(element : TMXmlElement; path : string) : TFhirCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirCareTeam.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCareTeamChild(element : TFhirCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseCareTeamParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{TFhirCondition}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganizationList.Add(ParseReference{TFhirOrganization}(child, path+'/managingOrganization')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCareTeam(xml : TXmlBuilder; name : String; elem : TFhirCareTeam);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCareTeamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCareTeamChildren(xml : TXmlBuilder; elem : TFhirCareTeam);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCareTeamStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCareTeamParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    for i := 0 to elem.managingOrganizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganizationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
function TFHIRXmlParser.ParseChargeItemParticipant(element : TMXmlElement; path : string) : TFhirChargeItemParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItemParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemParticipantChild(element : TFhirChargeItemParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItemParticipant(xml : TXmlBuilder; name : String; elem : TFhirChargeItemParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemParticipantChildren(xml : TXmlBuilder; elem : TFhirChargeItemParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
end;

function TFHIRXmlParser.ParseChargeItem(element : TMXmlElement; path : string) : TFhirChargeItem;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemChild(element : TFhirChargeItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseUri(child, path+'/definition')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirChargeItem}(child, path+'/partOf')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceTiming') then
        element.occurrence := ParseTiming(child, path+'/occurrenceTiming'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseChargeItemParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'performingOrganization') then
        element.performingOrganization := ParseReference{TFhirOrganization}(child, path+'/performingOrganization') {b}
      else if (child.localName = 'requestingOrganization') then
        element.requestingOrganization := ParseReference{TFhirOrganization}(child, path+'/requestingOrganization') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'bodysite') then
        element.bodysiteList.Add(ParseCodeableConcept(child, path+'/bodysite')){y.2}
      else if (child.localName = 'factorOverride') then
        element.factorOverrideElement := ParseDecimal(child, path+'/factorOverride') {b}
      else if (child.localName = 'priceOverride') then
        element.priceOverride := ParseMoney(child, path+'/priceOverride') {b}
      else if (child.localName = 'overrideReason') then
        element.overrideReasonElement := ParseString(child, path+'/overrideReason') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{Resource}(child, path+'/enterer') {b}
      else if (child.localName = 'enteredDate') then
        element.enteredDateElement := ParseDateTime(child, path+'/enteredDate') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'service') then
        element.serviceList.Add(ParseReference{Resource}(child, path+'/service')){y.2}
      else if (child.localName = 'account') then
        element.accountList.Add(ParseReference{TFhirAccount}(child, path+'/account')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItem(xml : TXmlBuilder; name : String; elem : TFhirChargeItem);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemChildren(xml : TXmlBuilder; elem : TFhirChargeItem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeUri(xml, 'definition', elem.definitionList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirChargeitemStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirChargeItem}(xml, 'partOf', elem.partOfList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeChargeItemParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('performingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'performingOrganization', elem.performingOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestingOrganization', elem.requestingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodysite') then
    for i := 0 to elem.bodysiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodysite', elem.bodysiteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('factorOverride') then
    ComposeDecimal(xml, 'factorOverride', elem.factorOverrideElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('priceOverride') then
    ComposeMoney(xml, 'priceOverride', elem.priceOverride);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('overrideReason') then
    ComposeString(xml, 'overrideReason', elem.overrideReasonElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{Resource}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enteredDate') then
    ComposeDateTime(xml, 'enteredDate', elem.enteredDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('service') then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeReference{Resource}(xml, 'service', elem.serviceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(xml, 'account', elem.accountList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
function TFHIRXmlParser.ParseClaimRelated(element : TMXmlElement; path : string) : TFhirClaimRelated;
var
  child : TMXmlElement;
begin
  result := TFhirClaimRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimRelatedChild(element : TFhirClaimRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'claim') then
        element.claim := ParseReference{TFhirClaim}(child, path+'/claim') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseIdentifier(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimRelated(xml : TXmlBuilder; name : String; elem : TFhirClaimRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimRelatedChildren(xml : TXmlBuilder; elem : TFhirClaimRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(xml, 'claim', elem.claim);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
var
  child : TMXmlElement;
begin
  result := TFhirClaimPayee.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimPayeeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimPayeeChild(element : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'resourceType') then
        element.resourceType := ParseCoding(child, path+'/resourceType') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimPayee(xml : TXmlBuilder; name : String; elem : TFhirClaimPayee);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimPayeeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimPayeeChildren(xml : TXmlBuilder; elem : TFhirClaimPayee);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'resourceType', elem.resourceType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
end;

function TFHIRXmlParser.ParseClaimCareTeam(element : TMXmlElement; path : string) : TFhirClaimCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirClaimCareTeam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimCareTeamChild(element : TFhirClaimCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{Resource}(child, path+'/provider') {b}
      else if (child.localName = 'responsible') then
        element.responsibleElement := ParseBoolean(child, path+'/responsible') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'qualification') then
        element.qualification := ParseCodeableConcept(child, path+'/qualification') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimCareTeam(xml : TXmlBuilder; name : String; elem : TFhirClaimCareTeam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimCareTeamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimCareTeamChildren(xml : TXmlBuilder; elem : TFhirClaimCareTeam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeReference{Resource}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'responsible', elem.responsibleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'qualification', elem.qualification);{x.2a}
end;

function TFHIRXmlParser.ParseClaimInformation(element : TMXmlElement; path : string) : TFhirClaimInformation;
var
  child : TMXmlElement;
begin
  result := TFhirClaimInformation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimInformationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimInformationChild(element : TFhirClaimInformation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDate') then
        element.timing := ParseDate(child, path+'/timingDate'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference') {a}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimInformation(xml : TXmlBuilder; name : String; elem : TFhirClaimInformation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimInformationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimInformationChildren(xml : TXmlBuilder; elem : TFhirClaimInformation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(xml, 'timingDate', TFhirDate(elem.timing));
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
end;

function TFHIRXmlParser.ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirClaimDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimDiagnosisChild(element : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'diagnosisCodeableConcept') then
        element.diagnosis := ParseCodeableConcept(child, path+'/diagnosisCodeableConcept'){x.3}
      else if (child.localName = 'diagnosisReference') then
        element.diagnosis := ParseReference(child, path+'/diagnosisReference') {a}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'packageCode') then
        element.packageCode := ParseCodeableConcept(child, path+'/packageCode') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosis(xml : TXmlBuilder; name : String; elem : TFhirClaimDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimDiagnosisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosisChildren(xml : TXmlBuilder; elem : TFhirClaimDiagnosis);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis))
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(xml, 'diagnosisReference', TFhirReference(elem.diagnosis));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'packageCode', elem.packageCode);{x.2a}
end;

function TFHIRXmlParser.ParseClaimProcedure(element : TMXmlElement; path : string) : TFhirClaimProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirClaimProcedure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimProcedureChild(element : TFhirClaimProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'procedureCodeableConcept') then
        element.procedure_ := ParseCodeableConcept(child, path+'/procedureCodeableConcept'){x.3}
      else if (child.localName = 'procedureReference') then
        element.procedure_ := ParseReference(child, path+'/procedureReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimProcedure(xml : TXmlBuilder; name : String; elem : TFhirClaimProcedure);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimProcedureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimProcedureChildren(xml : TXmlBuilder; elem : TFhirClaimProcedure);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_))
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(xml, 'procedureReference', TFhirReference(elem.procedure_));
end;

function TFHIRXmlParser.ParseClaimInsurance(element : TMXmlElement; path : string) : TFhirClaimInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirClaimInsurance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimInsuranceChild(element : TFhirClaimInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'focal') then
        element.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'businessArrangement') then
        element.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.localName = 'preAuthRef') then
        element.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.localName = 'claimResponse') then
        element.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimInsurance(xml : TXmlBuilder; name : String; elem : TFhirClaimInsurance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimInsuranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimInsuranceChildren(xml : TXmlBuilder; elem : TFhirClaimInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2b}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2a}
end;

function TFHIRXmlParser.ParseClaimAccident(element : TMXmlElement; path : string) : TFhirClaimAccident;
var
  child : TMXmlElement;
begin
  result := TFhirClaimAccident.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimAccidentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimAccidentChild(element : TFhirClaimAccident; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'locationAddress') then
        element.location := ParseAddress(child, path+'/locationAddress'){x.3}
      else if (child.localName = 'locationReference') then
        element.location := ParseReference(child, path+'/locationReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimAccident(xml : TXmlBuilder; name : String; elem : TFhirClaimAccident);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimAccidentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimAccidentChildren(xml : TXmlBuilder; elem : TFhirClaimAccident);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(elem.location));
end;

function TFHIRXmlParser.ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemChild(element : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'careTeamLinkId') then
        element.careTeamLinkIdList.Add(ParsePositiveInt(child, path+'/careTeamLinkId')){y.2}
      else if (child.localName = 'diagnosisLinkId') then
        element.diagnosisLinkIdList.Add(ParsePositiveInt(child, path+'/diagnosisLinkId')){y.2}
      else if (child.localName = 'procedureLinkId') then
        element.procedureLinkIdList.Add(ParsePositiveInt(child, path+'/procedureLinkId')){y.2}
      else if (child.localName = 'informationLinkId') then
        element.informationLinkIdList.Add(ParsePositiveInt(child, path+'/informationLinkId')){y.2}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'servicedPeriod') then
        element.serviced := ParsePeriod(child, path+'/servicedPeriod'){x.3}
      else if (child.localName = 'servicedDate') then
        element.serviced := ParseDate(child, path+'/servicedDate'){x.3}
      else if (child.localName = 'locationCodeableConcept') then
        element.location := ParseCodeableConcept(child, path+'/locationCodeableConcept'){x.3}
      else if (child.localName = 'locationAddress') then
        element.location := ParseAddress(child, path+'/locationAddress'){x.3}
      else if (child.localName = 'locationReference') then
        element.location := ParseReference(child, path+'/locationReference') {a}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'subSite') then
        element.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite')){y.2}
      else if (child.localName = 'encounter') then
        element.encounterList.Add(ParseReference{TFhirEncounter}(child, path+'/encounter')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItem(xml : TXmlBuilder; name : String; elem : TFhirClaimItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemChildren(xml : TXmlBuilder; elem : TFhirClaimItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'careTeamLinkId', elem.careTeamLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisLinkId', elem.diagnosisLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'procedureLinkId', elem.procedureLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'informationLinkId', elem.informationLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(elem.serviced))
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(elem.serviced));
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', elem.subSiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailChild(element : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if (child.localName = 'subDetail') then
        element.subDetailList.Add(ParseClaimItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetailChild(element : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailSubDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
end;

function TFHIRXmlParser.ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
var
  child : TMXmlElement;
begin
  result := TFhirClaim.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimChild(element : TFhirClaim; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum, path+'/use', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'billablePeriod') then
        element.billablePeriod := ParsePeriod(child, path+'/billablePeriod') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'fundsReserve') then
        element.fundsReserve := ParseCodeableConcept(child, path+'/fundsReserve') {b}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseClaimRelated(child, path+'/related')){y.2}
      else if (child.localName = 'prescription') then
        element.prescription := ParseReference{Resource}(child, path+'/prescription') {b}
      else if (child.localName = 'originalPrescription') then
        element.originalPrescription := ParseReference{TFhirMedicationRequest}(child, path+'/originalPrescription') {b}
      else if (child.localName = 'payee') then
        element.payee := ParseClaimPayee(child, path+'/payee') {b}
      else if (child.localName = 'referral') then
        element.referral := ParseReference{TFhirReferralRequest}(child, path+'/referral') {b}
      else if (child.localName = 'facility') then
        element.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.localName = 'careTeam') then
        element.careTeamList.Add(ParseClaimCareTeam(child, path+'/careTeam')){y.2}
      else if (child.localName = 'information') then
        element.informationList.Add(ParseClaimInformation(child, path+'/information')){y.2}
      else if (child.localName = 'diagnosis') then
        element.diagnosisList.Add(ParseClaimDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.localName = 'procedure') then
        element.procedure_List.Add(ParseClaimProcedure(child, path+'/procedure')){y.2}
      else if (child.localName = 'insurance') then
        element.insuranceList.Add(ParseClaimInsurance(child, path+'/insurance')){y.2}
      else if (child.localName = 'accident') then
        element.accident := ParseClaimAccident(child, path+'/accident') {b}
      else if (child.localName = 'employmentImpacted') then
        element.employmentImpacted := ParsePeriod(child, path+'/employmentImpacted') {b}
      else if (child.localName = 'hospitalization') then
        element.hospitalization := ParsePeriod(child, path+'/hospitalization') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseClaimItem(child, path+'/item')){y.2}
      else if (child.localName = 'total') then
        element.total := ParseMoney(child, path+'/total') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaim(xml : TXmlBuilder; name : String; elem : TFhirClaim);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimChildren(xml : TXmlBuilder; elem : TFhirClaim);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('use') then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirClaimUseEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('billablePeriod') then
    ComposePeriod(xml, 'billablePeriod', elem.billablePeriod);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(xml, 'fundsReserve', elem.fundsReserve);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeClaimRelated(xml, 'related', elem.relatedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(xml, 'prescription', elem.prescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(xml, 'originalPrescription', elem.originalPrescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeClaimPayee(xml, 'payee', elem.payee);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(xml, 'referral', elem.referral);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeClaimCareTeam(xml, 'careTeam', elem.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('information') then
    for i := 0 to elem.informationList.Count - 1 do
      ComposeClaimInformation(xml, 'information', elem.informationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeClaimProcedure(xml, 'procedure', elem.procedure_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimInsurance(xml, 'insurance', elem.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeClaimAccident(xml, 'accident', elem.accident);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('employmentImpacted') then
    ComposePeriod(xml, 'employmentImpacted', elem.employmentImpacted);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposePeriod(xml, 'hospitalization', elem.hospitalization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(xml, 'total', elem.total);{x.2a}
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRXmlParser.ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemChild(element : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimResponseItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItem(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudicationChild(element : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseMoney(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailChild(element : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'subDetail') then
        element.subDetailList.Add(ParseClaimResponseItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailChild(element : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailSubDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemChild(element : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdList.Add(ParsePositiveInt(child, path+'/sequenceLinkId')){y.2}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'fee') then
        element.fee := ParseMoney(child, path+'/fee') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimResponseAddItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItem(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailChild(element : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'fee') then
        element.fee := ParseMoney(child, path+'/fee') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseError.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseErrorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseErrorChild(element : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'detailSequenceLinkId') then
        element.detailSequenceLinkIdElement := ParsePositiveInt(child, path+'/detailSequenceLinkId') {b}
      else if (child.localName = 'subdetailSequenceLinkId') then
        element.subdetailSequenceLinkIdElement := ParsePositiveInt(child, path+'/subdetailSequenceLinkId') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseError(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseError);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseErrorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseErrorChildren(xml : TXmlBuilder; elem : TFhirClaimResponseError);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement);{x.2b}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponsePayment(element : TMXmlElement; path : string) : TFhirClaimResponsePayment;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponsePayment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponsePaymentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponsePaymentChild(element : TFhirClaimResponsePayment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'adjustment') then
        element.adjustment := ParseMoney(child, path+'/adjustment') {b}
      else if (child.localName = 'adjustmentReason') then
        element.adjustmentReason := ParseCodeableConcept(child, path+'/adjustmentReason') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseMoney(child, path+'/amount') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponsePayment(xml : TXmlBuilder; name : String; elem : TFhirClaimResponsePayment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponsePaymentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponsePaymentChildren(xml : TXmlBuilder; elem : TFhirClaimResponsePayment);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'adjustment', elem.adjustment);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'adjustmentReason', elem.adjustmentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponseProcessNote(element : TMXmlElement; path : string) : TFhirClaimResponseProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseProcessNoteChild(element : TFhirClaimResponseProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        element.numberElement := ParsePositiveInt(child, path+'/number') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'language') then
        element.language := ParseCodeableConcept(child, path+'/language') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseProcessNote(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseProcessNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseProcessNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseProcessNoteChildren(xml : TXmlBuilder; elem : TFhirClaimResponseProcessNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'number', elem.numberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', elem.language);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponseInsurance(element : TMXmlElement; path : string) : TFhirClaimResponseInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseInsuranceChild(element : TFhirClaimResponseInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'focal') then
        element.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'businessArrangement') then
        element.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.localName = 'preAuthRef') then
        element.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.localName = 'claimResponse') then
        element.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseInsurance(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseInsurance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseInsuranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseInsuranceChildren(xml : TXmlBuilder; elem : TFhirClaimResponseInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2b}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseChild(element : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'payeeType') then
        element.payeeType := ParseCodeableConcept(child, path+'/payeeType') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseClaimResponseItem(child, path+'/item')){y.2}
      else if (child.localName = 'addItem') then
        element.addItemList.Add(ParseClaimResponseAddItem(child, path+'/addItem')){y.2}
      else if (child.localName = 'error') then
        element.errorList.Add(ParseClaimResponseError(child, path+'/error')){y.2}
      else if (child.localName = 'totalCost') then
        element.totalCost := ParseMoney(child, path+'/totalCost') {b}
      else if (child.localName = 'unallocDeductable') then
        element.unallocDeductable := ParseMoney(child, path+'/unallocDeductable') {b}
      else if (child.localName = 'totalBenefit') then
        element.totalBenefit := ParseMoney(child, path+'/totalBenefit') {b}
      else if (child.localName = 'payment') then
        element.payment := ParseClaimResponsePayment(child, path+'/payment') {b}
      else if (child.localName = 'reserved') then
        element.reserved := ParseCoding(child, path+'/reserved') {b}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'processNote') then
        element.processNoteList.Add(ParseClaimResponseProcessNote(child, path+'/processNote')){y.2}
      else if (child.localName = 'communicationRequest') then
        element.communicationRequestList.Add(ParseReference{TFhirCommunicationRequest}(child, path+'/communicationRequest')){y.2}
      else if (child.localName = 'insurance') then
        element.insuranceList.Add(ParseClaimResponseInsurance(child, path+'/insurance')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponse(xml : TXmlBuilder; name : String; elem : TFhirClaimResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseChildren(xml : TXmlBuilder; elem : TFhirClaimResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('payeeType') then
    ComposeCodeableConcept(xml, 'payeeType', elem.payeeType);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(xml, 'addItem', elem.addItemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(xml, 'error', elem.errorList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('totalCost') then
    ComposeMoney(xml, 'totalCost', elem.totalCost);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('unallocDeductable') then
    ComposeMoney(xml, 'unallocDeductable', elem.unallocDeductable);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('totalBenefit') then
    ComposeMoney(xml, 'totalBenefit', elem.totalBenefit);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeClaimResponsePayment(xml, 'payment', elem.payment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reserved') then
    ComposeCoding(xml, 'reserved', elem.reserved);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(xml, 'processNote', elem.processNoteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') then
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(xml, 'communicationRequest', elem.communicationRequestList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(xml, 'insurance', elem.insuranceList[i]);
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRXmlParser.ParseClinicalImpressionInvestigation(element : TMXmlElement; path : string) : TFhirClinicalImpressionInvestigation;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionInvestigationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionInvestigationChild(element : TFhirClinicalImpressionInvestigation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseReference{Resource}(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigation(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpressionInvestigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionInvestigationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigationChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionInvestigation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(xml, 'item', elem.itemList[i]);
end;

function TFHIRXmlParser.ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionFindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionFindingChild(element : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemCodeableConcept') then
        element.item := ParseCodeableConcept(child, path+'/itemCodeableConcept'){x.3}
      else if (child.localName = 'itemReference') then
        element.item := ParseReference(child, path+'/itemReference') {a}
      else if (child.localName = 'basis') then
        element.basisElement := ParseString(child, path+'/basis') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpressionFinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionFindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionFinding);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(elem.item))
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(elem.item));
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'basis', elem.basisElement);{x.2b}
end;

function TFHIRXmlParser.ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpression.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionChild(element : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'assessor') then
        element.assessor := ParseReference{TFhirPractitioner}(child, path+'/assessor') {b}
      else if (child.localName = 'previous') then
        element.previous := ParseReference{TFhirClinicalImpression}(child, path+'/previous') {b}
      else if (child.localName = 'problem') then
        element.problemList.Add(ParseReference{Resource}(child, path+'/problem')){y.2}
      else if (child.localName = 'investigation') then
        element.investigationList.Add(ParseClinicalImpressionInvestigation(child, path+'/investigation')){y.2}
      else if (child.localName = 'protocol') then
        element.protocolList.Add(ParseUri(child, path+'/protocol')){y.2}
      else if (child.localName = 'summary') then
        element.summaryElement := ParseString(child, path+'/summary') {b}
      else if (child.localName = 'finding') then
        element.findingList.Add(ParseClinicalImpressionFinding(child, path+'/finding')){y.2}
      else if (child.localName = 'prognosisCodeableConcept') then
        element.prognosisCodeableConceptList.Add(ParseCodeableConcept(child, path+'/prognosisCodeableConcept')){y.2}
      else if (child.localName = 'prognosisReference') then
        element.prognosisReferenceList.Add(ParseReference{TFhirRiskAssessment}(child, path+'/prognosisReference')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseReference{Resource}(child, path+'/action')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpression(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpression);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionChildren(xml : TXmlBuilder; elem : TFhirClinicalImpression);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(xml, 'assessor', elem.assessor);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(xml, 'previous', elem.previous);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(xml, 'problem', elem.problemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('investigation') then
    for i := 0 to elem.investigationList.Count - 1 do
      ComposeClinicalImpressionInvestigation(xml, 'investigation', elem.investigationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeUri(xml, 'protocol', elem.protocolList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeString(xml, 'summary', elem.summaryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('finding') then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(xml, 'finding', elem.findingList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisCodeableConcept') then
    for i := 0 to elem.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(xml, 'prognosisCodeableConcept', elem.prognosisCodeableConceptList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisReference') then
    for i := 0 to elem.prognosisReferenceList.Count - 1 do
      ComposeReference{TFhirRiskAssessment}(xml, 'prognosisReference', elem.prognosisReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
function TFHIRXmlParser.ParseCodeSystemFilter(element : TMXmlElement; path : string) : TFhirCodeSystemFilter;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemFilterChild(element : TFhirCodeSystemFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'operator') then
        element.operatorList.Add(ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, path+'/operator', child)){y.1}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemFilter(xml : TXmlBuilder; name : String; elem : TFhirCodeSystemFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemFilterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemFilterChildren(xml : TXmlBuilder; elem : TFhirCodeSystemFilter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.operatorList.Count - 1 do
      ComposeEnum(xml, 'operator', elem.operatorList[i], CODES_TFhirFilterOperatorEnum);
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseCodeSystemProperty(element : TMXmlElement; path : string) : TFhirCodeSystemProperty;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemProperty.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemPropertyChild(element : TFhirCodeSystemProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemProperty(xml : TXmlBuilder; name : String; elem : TFhirCodeSystemProperty);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemPropertyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemPropertyChildren(xml : TXmlBuilder; elem : TFhirCodeSystemProperty);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirConceptPropertyTypeEnum);
end;

function TFHIRXmlParser.ParseCodeSystemConcept(element : TMXmlElement; path : string) : TFhirCodeSystemConcept;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptChild(element : TFhirCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.localName = 'designation') then
        element.designationList.Add(ParseCodeSystemConceptDesignation(child, path+'/designation')){y.2}
      else if (child.localName = 'property') then
        element.property_List.Add(ParseCodeSystemConceptProperty(child, path+'/property')){y.2}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConcept(xml : TXmlBuilder; name : String; elem : TFhirCodeSystemConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(xml, 'designation', elem.designationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(xml, 'property', elem.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
end;

function TFHIRXmlParser.ParseCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirCodeSystemConceptDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptDesignationChild(element : TFhirCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'use') then
        element.use := ParseCoding(child, path+'/use') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptDesignation(xml : TXmlBuilder; name : String; elem : TFhirCodeSystemConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConceptDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2a}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseCodeSystemConceptProperty(element : TMXmlElement; path : string) : TFhirCodeSystemConceptProperty;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptPropertyChild(element : TFhirCodeSystemConceptProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptProperty(xml : TXmlBuilder; name : String; elem : TFhirCodeSystemConceptProperty);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptPropertyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptPropertyChildren(xml : TXmlBuilder; elem : TFhirCodeSystemConceptProperty);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
end;

function TFHIRXmlParser.ParseCodeSystem(element : TMXmlElement; path : string) : TFhirCodeSystem;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemChild(element : TFhirCodeSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'caseSensitive') then
        element.caseSensitiveElement := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.localName = 'valueSet') then
        element.valueSetElement := ParseUri(child, path+'/valueSet') {b}
      else if (child.localName = 'hierarchyMeaning') then
        element.hierarchyMeaningElement := ParseEnum(CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum, path+'/hierarchyMeaning', child){1a}
      else if (child.localName = 'compositional') then
        element.compositionalElement := ParseBoolean(child, path+'/compositional') {b}
      else if (child.localName = 'versionNeeded') then
        element.versionNeededElement := ParseBoolean(child, path+'/versionNeeded') {b}
      else if (child.localName = 'content') then
        element.contentElement := ParseEnum(CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum, path+'/content', child){1a}
      else if (child.localName = 'count') then
        element.countElement := ParseUnsignedInt(child, path+'/count') {b}
      else if (child.localName = 'filter') then
        element.filterList.Add(ParseCodeSystemFilter(child, path+'/filter')){y.2}
      else if (child.localName = 'property') then
        element.property_List.Add(ParseCodeSystemProperty(child, path+'/property')){y.2}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystem(xml : TXmlBuilder; name : String; elem : TFhirCodeSystem);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemChildren(xml : TXmlBuilder; elem : TFhirCodeSystem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('caseSensitive') then
    ComposeBoolean(xml, 'caseSensitive', elem.caseSensitiveElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('valueSet') then
    ComposeUri(xml, 'valueSet', elem.valueSetElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hierarchyMeaning') then
    ComposeEnum(xml, 'hierarchyMeaning', elem.HierarchyMeaningElement, CODES_TFhirCodesystemHierarchyMeaningEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositional') then
    ComposeBoolean(xml, 'compositional', elem.compositionalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('versionNeeded') then
    ComposeBoolean(xml, 'versionNeeded', elem.versionNeededElement);{x.2b}
  ComposeEnum(xml, 'content', elem.ContentElement, CODES_TFhirCodesystemContentModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('count') then
    ComposeUnsignedInt(xml, 'count', elem.countElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('filter') then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeCodeSystemFilter(xml, 'filter', elem.filterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemProperty(xml, 'property', elem.property_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('concept') then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRXmlParser.ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationPayloadChild(element : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if (child.localName = 'contentString') then
        element.content := ParseString(child, path+'/contentString'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayload(xml : TXmlBuilder; name : String; elem : TFhirCommunicationPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationPayloadChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationPayload);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content));
end;

function TFHIRXmlParser.ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirCommunication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationChild(element : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirReference}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'notDone') then
        element.notDoneElement := ParseBoolean(child, path+'/notDone') {b}
      else if (child.localName = 'notDoneReason') then
        element.notDoneReason := ParseCodeableConcept(child, path+'/notDoneReason') {b}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'medium') then
        element.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseReference{TFhirReference}(child, path+'/topic')){y.2}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'sent') then
        element.sentElement := ParseDateTime(child, path+'/sent') {b}
      else if (child.localName = 'received') then
        element.receivedElement := ParseDateTime(child, path+'/received') {b}
      else if (child.localName = 'sender') then
        element.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'payload') then
        element.payloadList.Add(ParseCommunicationPayload(child, path+'/payload')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunication(xml : TXmlBuilder; name : String; elem : TFhirCommunication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationChildren(xml : TXmlBuilder; elem : TFhirCommunication);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDone') then
    ComposeBoolean(xml, 'notDone', elem.notDoneElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(xml, 'notDoneReason', elem.notDoneReason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('sent') then
    ComposeDateTime(xml, 'sent', elem.sentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('received') then
    ComposeDateTime(xml, 'received', elem.receivedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(xml, 'payload', elem.payloadList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRXmlParser.ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestPayloadChild(element : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if (child.localName = 'contentString') then
        element.content := ParseString(child, path+'/contentString'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : String; elem : TFhirCommunicationRequestPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestPayloadChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestPayload);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content));
end;

function TFHIRXmlParser.ParseCommunicationRequestRequester(element : TMXmlElement; path : string) : TFhirCommunicationRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestRequesterChild(element : TFhirCommunicationRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirCommunicationRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestChild(element : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirCommunicationRequest}(child, path+'/replaces')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'medium') then
        element.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseReference{TFhirReference}(child, path+'/topic')){y.2}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'payload') then
        element.payloadList.Add(ParseCommunicationRequestPayload(child, path+'/payload')){y.2}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'sender') then
        element.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseCommunicationRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequest(xml : TXmlBuilder; name : String; elem : TFhirCommunicationRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(xml, 'replaces', elem.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(xml, 'payload', elem.payloadList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeCommunicationRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
function TFHIRXmlParser.ParseCompartmentDefinitionResource(element : TMXmlElement; path : string) : TFhirCompartmentDefinitionResource;
var
  child : TMXmlElement;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompartmentDefinitionResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompartmentDefinitionResourceChild(element : TFhirCompartmentDefinitionResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/code', child){1a}
      else if (child.localName = 'param') then
        element.paramList.Add(ParseString(child, path+'/param')){y.2}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionResource(xml : TXmlBuilder; name : String; elem : TFhirCompartmentDefinitionResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompartmentDefinitionResourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionResourceChildren(xml : TXmlBuilder; elem : TFhirCompartmentDefinitionResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeString(xml, 'param', elem.paramList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseCompartmentDefinition(element : TMXmlElement; path : string) : TFhirCompartmentDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirCompartmentDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompartmentDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompartmentDefinitionChild(element : TFhirCompartmentDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'search') then
        element.searchElement := ParseBoolean(child, path+'/search') {b}
      else if (child.localName = 'resource') then
        element.resourceList.Add(ParseCompartmentDefinitionResource(child, path+'/resource')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinition(xml : TXmlBuilder; name : String; elem : TFhirCompartmentDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompartmentDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionChildren(xml : TXmlBuilder; elem : TFhirCompartmentDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum);
  ComposeBoolean(xml, 'search', elem.searchElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(xml, 'resource', elem.resourceList[i]);
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
function TFHIRXmlParser.ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionAttesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionAttesterChild(element : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeList.Add(ParseEnum(CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, path+'/mode', child)){y.1}
      else if (child.localName = 'time') then
        element.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : String; elem : TFhirCompositionAttester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionAttesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttesterChildren(xml : TXmlBuilder; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(xml, 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
end;

function TFHIRXmlParser.ParseCompositionRelatesTo(element : TMXmlElement; path : string) : TFhirCompositionRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionRelatesToChild(element : TFhirCompositionRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'targetIdentifier') then
        element.target := ParseIdentifier(child, path+'/targetIdentifier'){x.3}
      else if (child.localName = 'targetReference') then
        element.target := ParseReference(child, path+'/targetReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionRelatesTo(xml : TXmlBuilder; name : String; elem : TFhirCompositionRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionRelatesToChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionRelatesToChildren(xml : TXmlBuilder; elem : TFhirCompositionRelatesTo);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum);
  if (elem.target is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'targetIdentifier', TFhirIdentifier(elem.target))
  else if (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target));
end;

function TFHIRXmlParser.ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionEventChild(element : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : String; elem : TFhirCompositionEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionEventChildren(xml : TXmlBuilder; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionSectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionSectionChild(element : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'text') then
        element.text := ParseNarrative(child, path+'/text') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'orderedBy') then
        element.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseReference{TFhirReference}(child, path+'/entry')){y.2}
      else if (child.localName = 'emptyReason') then
        element.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if (child.localName = 'section') then
        element.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : String; elem : TFhirCompositionSection);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionSectionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionSectionChildren(xml : TXmlBuilder; elem : TFhirCompositionSection);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', elem.text);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
end;

function TFHIRXmlParser.ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
var
  child : TMXmlElement;
begin
  result := TFhirComposition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionChild(element : TFhirComposition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'class') then
        element.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'confidentiality') then
        element.confidentialityElement := ParseEnum(CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum, path+'/confidentiality', child){1a}
      else if (child.localName = 'attester') then
        element.attesterList.Add(ParseCompositionAttester(child, path+'/attester')){y.2}
      else if (child.localName = 'custodian') then
        element.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.localName = 'relatesTo') then
        element.relatesToList.Add(ParseCompositionRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseCompositionEvent(child, path+'/event')){y.2}
      else if (child.localName = 'section') then
        element.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : String; elem : TFhirComposition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionChildren(xml : TXmlBuilder; elem : TFhirComposition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2a}
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnum(xml, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityClassificationEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attester') then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeCompositionRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('section') then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRXmlParser.ParseConceptMapGroup(element : TMXmlElement; path : string) : TFhirConceptMapGroup;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupChild(element : TFhirConceptMapGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.localName = 'sourceVersion') then
        element.sourceVersionElement := ParseString(child, path+'/sourceVersion') {b}
      else if (child.localName = 'target') then
        element.targetElement := ParseUri(child, path+'/target') {b}
      else if (child.localName = 'targetVersion') then
        element.targetVersionElement := ParseString(child, path+'/targetVersion') {b}
      else if (child.localName = 'element') then
        element.elementList.Add(ParseConceptMapGroupElement(child, path+'/element')){y.2}
      else if (child.localName = 'unmapped') then
        element.unmapped := ParseConceptMapGroupUnmapped(child, path+'/unmapped') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroup(xml : TXmlBuilder; name : String; elem : TFhirConceptMapGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'sourceVersion', elem.sourceVersionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'target', elem.targetElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'targetVersion', elem.targetVersionElement);{x.2b}
  for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapGroupElement(xml, 'element', elem.elementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(xml, 'unmapped', elem.unmapped);{x.2a}
end;

function TFHIRXmlParser.ParseConceptMapGroupElement(element : TMXmlElement; path : string) : TFhirConceptMapGroupElement;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementChild(element : TFhirConceptMapGroupElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'target') then
        element.targetList.Add(ParseConceptMapGroupElementTarget(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElement(xml : TXmlBuilder; name : String; elem : TFhirConceptMapGroupElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(xml, 'target', elem.targetList[i]);
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTarget;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetChild(element : TFhirConceptMapGroupElementTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'equivalence') then
        element.equivalenceElement := ParseEnum(CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, path+'/equivalence', child){1a}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'dependsOn') then
        element.dependsOnList.Add(ParseConceptMapGroupElementTargetDependsOn(child, path+'/dependsOn')){y.2}
      else if (child.localName = 'product') then
        element.productList.Add(ParseConceptMapGroupElementTargetDependsOn(child, path+'/product')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTarget(xml : TXmlBuilder; name : String; elem : TFhirConceptMapGroupElementTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElementTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.equivalenceElement <> nil) and (elem.equivalenceElement.primitiveValue <> 'equivalent')) then
    ComposeEnum(xml, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(xml, 'product', elem.productList[i]);
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTargetDependsOn;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementTargetDependsOnChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetDependsOnChild(element : TFhirConceptMapGroupElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'property') then
        element.property_Element := ParseUri(child, path+'/property') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseString(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetDependsOn(xml : TXmlBuilder; name : String; elem : TFhirConceptMapGroupElementTargetDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementTargetDependsOnChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetDependsOnChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupElementTargetDependsOn);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'property', elem.property_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  ComposeString(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
end;

function TFHIRXmlParser.ParseConceptMapGroupUnmapped(element : TMXmlElement; path : string) : TFhirConceptMapGroupUnmapped;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupUnmappedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupUnmappedChild(element : TFhirConceptMapGroupUnmapped; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupUnmapped(xml : TXmlBuilder; name : String; elem : TFhirConceptMapGroupUnmapped);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupUnmappedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupUnmappedChildren(xml : TXmlBuilder; elem : TFhirConceptMapGroupUnmapped);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirConceptmapUnmappedModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMap.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapChild(element : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'sourceReference') then
        element.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.localName = 'sourceUri') then
        element.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.localName = 'targetReference') then
        element.target := ParseReference(child, path+'/targetReference') {a}
      else if (child.localName = 'targetUri') then
        element.target := ParseUri(child, path+'/targetUri'){x.3}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseConceptMapGroup(child, path+'/group')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : String; elem : TFhirConceptMap);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapChildren(xml : TXmlBuilder; elem : TFhirConceptMap);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) {6} then
    ComposeUri(xml, 'targetUri', TFhirUri(elem.target));
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeConceptMapGroup(xml, 'group', elem.groupList[i]);
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRXmlParser.ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
var
  child : TMXmlElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionStageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionStageChild(element : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'summary') then
        element.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.localName = 'assessment') then
        element.assessmentList.Add(ParseReference{Resource}(child, path+'/assessment')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : String; elem : TFhirConditionStage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionStageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionStageChildren(xml : TXmlBuilder; elem : TFhirConditionStage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'summary', elem.summary);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(xml, 'assessment', elem.assessmentList[i]);
end;

function TFHIRXmlParser.ParseConditionEvidence(element : TMXmlElement; path : string) : TFhirConditionEvidence;
var
  child : TMXmlElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionEvidenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionEvidenceChild(element : TFhirConditionEvidence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : String; elem : TFhirConditionEvidence);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionEvidenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidenceChildren(xml : TXmlBuilder; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
var
  child : TMXmlElement;
begin
  result := TFhirCondition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionChild(element : TFhirCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'clinicalStatus') then
        element.clinicalStatusElement := ParseEnum(CODES_TFhirConditionClinicalEnum, SYSTEMS_TFhirConditionClinicalEnum, path+'/clinicalStatus', child){1a}
      else if (child.localName = 'verificationStatus') then
        element.verificationStatusElement := ParseEnum(CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, path+'/verificationStatus', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'severity') then
        element.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'onsetAge') then
        element.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.localName = 'onsetPeriod') then
        element.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.localName = 'onsetRange') then
        element.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.localName = 'onsetDateTime') then
        element.onset := ParseDateTime(child, path+'/onsetDateTime'){x.3}
      else if (child.localName = 'onsetString') then
        element.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.localName = 'abatementAge') then
        element.abatement := ParseAge(child, path+'/abatementAge'){x.3}
      else if (child.localName = 'abatementPeriod') then
        element.abatement := ParsePeriod(child, path+'/abatementPeriod'){x.3}
      else if (child.localName = 'abatementRange') then
        element.abatement := ParseRange(child, path+'/abatementRange'){x.3}
      else if (child.localName = 'abatementDateTime') then
        element.abatement := ParseDateTime(child, path+'/abatementDateTime'){x.3}
      else if (child.localName = 'abatementBoolean') then
        element.abatement := ParseBoolean(child, path+'/abatementBoolean'){x.3}
      else if (child.localName = 'abatementString') then
        element.abatement := ParseString(child, path+'/abatementString'){x.3}
      else if (child.localName = 'assertedDate') then
        element.assertedDateElement := ParseDateTime(child, path+'/assertedDate') {b}
      else if (child.localName = 'asserter') then
        element.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.localName = 'stage') then
        element.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.localName = 'evidence') then
        element.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : String; elem : TFhirCondition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionChildren(xml : TXmlBuilder; elem : TFhirCondition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeEnum(xml, 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirConditionClinicalEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.verificationStatusElement <> nil) and (elem.verificationStatusElement.primitiveValue <> 'unknown')) and doCompose('verificationStatus') then
    ComposeEnum(xml, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('severity') then
    ComposeCodeableConcept(xml, 'severity', elem.severity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirAge) {6} then
    ComposeAge(xml, 'abatementAge', TFhirAge(elem.abatement))
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(xml, 'abatementPeriod', TFhirPeriod(elem.abatement))
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(xml, 'abatementRange', TFhirRange(elem.abatement))
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'abatementDateTime', TFhirDateTime(elem.abatement))
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement))
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(xml, 'abatementString', TFhirString(elem.abatement));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assertedDate') then
    ComposeDateTime(xml, 'assertedDate', elem.assertedDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('stage') then
    ComposeConditionStage(xml, 'stage', elem.stage);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
function TFHIRXmlParser.ParseConsentActor(element : TMXmlElement; path : string) : TFhirConsentActor;
var
  child : TMXmlElement;
begin
  result := TFhirConsentActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentActorChild(element : TFhirConsentActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentActor(xml : TXmlBuilder; name : String; elem : TFhirConsentActor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentActorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentActorChildren(xml : TXmlBuilder; elem : TFhirConsentActor);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseConsentPolicy(element : TMXmlElement; path : string) : TFhirConsentPolicy;
var
  child : TMXmlElement;
begin
  result := TFhirConsentPolicy.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentPolicyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentPolicyChild(element : TFhirConsentPolicy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authority') then
        element.authorityElement := ParseUri(child, path+'/authority') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentPolicy(xml : TXmlBuilder; name : String; elem : TFhirConsentPolicy);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentPolicyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentPolicyChildren(xml : TXmlBuilder; elem : TFhirConsentPolicy);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'authority', elem.authorityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
end;

function TFHIRXmlParser.ParseConsentData(element : TMXmlElement; path : string) : TFhirConsentData;
var
  child : TMXmlElement;
begin
  result := TFhirConsentData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentDataChild(element : TFhirConsentData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'meaning') then
        element.meaningElement := ParseEnum(CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, path+'/meaning', child){1a}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentData(xml : TXmlBuilder; name : String; elem : TFhirConsentData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentDataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentDataChildren(xml : TXmlBuilder; elem : TFhirConsentData);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum);
  ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseConsentExcept(element : TMXmlElement; path : string) : TFhirConsentExcept;
var
  child : TMXmlElement;
begin
  result := TFhirConsentExcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentExceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentExceptChild(element : TFhirConsentExcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirConsentExceptTypeEnum, SYSTEMS_TFhirConsentExceptTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'actor') then
        element.actorList.Add(ParseConsentExceptActor(child, path+'/actor')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeList.Add(ParseCoding(child, path+'/purpose')){y.2}
      else if (child.localName = 'class') then
        element.class_List.Add(ParseCoding(child, path+'/class')){y.2}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'dataPeriod') then
        element.dataPeriod := ParsePeriod(child, path+'/dataPeriod') {b}
      else if (child.localName = 'data') then
        element.dataList.Add(ParseConsentExceptData(child, path+'/data')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentExcept(xml : TXmlBuilder; name : String; elem : TFhirConsentExcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentExceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentExceptChildren(xml : TXmlBuilder; elem : TFhirConsentExcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirConsentExceptTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentExceptActor(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(xml, 'purpose', elem.purposeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoding(xml, 'class', elem.class_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'dataPeriod', elem.dataPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentExceptData(xml, 'data', elem.dataList[i]);
end;

function TFHIRXmlParser.ParseConsentExceptActor(element : TMXmlElement; path : string) : TFhirConsentExceptActor;
var
  child : TMXmlElement;
begin
  result := TFhirConsentExceptActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentExceptActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentExceptActorChild(element : TFhirConsentExceptActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentExceptActor(xml : TXmlBuilder; name : String; elem : TFhirConsentExceptActor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentExceptActorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentExceptActorChildren(xml : TXmlBuilder; elem : TFhirConsentExceptActor);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseConsentExceptData(element : TMXmlElement; path : string) : TFhirConsentExceptData;
var
  child : TMXmlElement;
begin
  result := TFhirConsentExceptData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentExceptDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentExceptDataChild(element : TFhirConsentExceptData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'meaning') then
        element.meaningElement := ParseEnum(CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, path+'/meaning', child){1a}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentExceptData(xml : TXmlBuilder; name : String; elem : TFhirConsentExceptData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentExceptDataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentExceptDataChildren(xml : TXmlBuilder; elem : TFhirConsentExceptData);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum);
  ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseConsent(element : TMXmlElement; path : string) : TFhirConsent;
var
  child : TMXmlElement;
begin
  result := TFhirConsent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentChild(element : TFhirConsent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'dateTime') then
        element.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.localName = 'consentingParty') then
        element.consentingPartyList.Add(ParseReference{Resource}(child, path+'/consentingParty')){y.2}
      else if (child.localName = 'actor') then
        element.actorList.Add(ParseConsentActor(child, path+'/actor')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'organization') then
        element.organizationList.Add(ParseReference{TFhirOrganization}(child, path+'/organization')){y.2}
      else if (child.localName = 'sourceAttachment') then
        element.source := ParseAttachment(child, path+'/sourceAttachment'){x.3}
      else if (child.localName = 'sourceIdentifier') then
        element.source := ParseIdentifier(child, path+'/sourceIdentifier'){x.3}
      else if (child.localName = 'sourceReference') then
        element.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.localName = 'policy') then
        element.policyList.Add(ParseConsentPolicy(child, path+'/policy')){y.2}
      else if (child.localName = 'policyRule') then
        element.policyRuleElement := ParseUri(child, path+'/policyRule') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeList.Add(ParseCoding(child, path+'/purpose')){y.2}
      else if (child.localName = 'dataPeriod') then
        element.dataPeriod := ParsePeriod(child, path+'/dataPeriod') {b}
      else if (child.localName = 'data') then
        element.dataList.Add(ParseConsentData(child, path+'/data')){y.2}
      else if (child.localName = 'except') then
        element.except_List.Add(ParseConsentExcept(child, path+'/except')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsent(xml : TXmlBuilder; name : String; elem : TFhirConsent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentChildren(xml : TXmlBuilder; elem : TFhirConsent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConsentStateCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateTime') then
    ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('consentingParty') then
    for i := 0 to elem.consentingPartyList.Count - 1 do
      ComposeReference{Resource}(xml, 'consentingParty', elem.consentingPartyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentActor(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    for i := 0 to elem.organizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'organization', elem.organizationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'sourceAttachment', TFhirAttachment(elem.source))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'sourceIdentifier', TFhirIdentifier(elem.source))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeConsentPolicy(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyRule') then
    ComposeUri(xml, 'policyRule', elem.policyRuleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(xml, 'purpose', elem.purposeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataPeriod') then
    ComposePeriod(xml, 'dataPeriod', elem.dataPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('data') then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentData(xml, 'data', elem.dataList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('except_') then
    for i := 0 to elem.except_List.Count - 1 do
      ComposeConsentExcept(xml, 'except', elem.except_List[i]);
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
function TFHIRXmlParser.ParseContractAgent(element : TMXmlElement; path : string) : TFhirContractAgent;
var
  child : TMXmlElement;
begin
  result := TFhirContractAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractAgentChild(element : TFhirContractAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractAgent(xml : TXmlBuilder; name : String; elem : TFhirContractAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractAgentChildren(xml : TXmlBuilder; elem : TFhirContractAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
end;

function TFHIRXmlParser.ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
var
  child : TMXmlElement;
begin
  result := TFhirContractSigner.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractSignerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractSignerChild(element : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if (child.localName = 'signature') then
        element.signatureList.Add(ParseSignature(child, path+'/signature')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractSigner(xml : TXmlBuilder; name : String; elem : TFhirContractSigner);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractSignerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractSignerChildren(xml : TXmlBuilder; elem : TFhirContractSigner);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
  for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', elem.signatureList[i]);
end;

function TFHIRXmlParser.ParseContractValuedItem(element : TMXmlElement; path : string) : TFhirContractValuedItem;
var
  child : TMXmlElement;
begin
  result := TFhirContractValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractValuedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractValuedItemChild(element : TFhirContractValuedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entityCodeableConcept') then
        element.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.localName = 'entityReference') then
        element.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'effectiveTime') then
        element.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItem(xml : TXmlBuilder; name : String; elem : TFhirContractValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractValuedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractValuedItem);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
end;

function TFHIRXmlParser.ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
var
  child : TMXmlElement;
begin
  result := TFhirContractTerm.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermChild(element : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.localName = 'applies') then
        element.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subType := ParseCodeableConcept(child, path+'/subType') {b}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseReference{TFhirReference}(child, path+'/topic')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'actionReason') then
        element.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseContractTermAgent(child, path+'/agent')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'valuedItem') then
        element.valuedItemList.Add(ParseContractTermValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseContractTerm(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTerm(xml : TXmlBuilder; name : String; elem : TFhirContractTerm);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermChildren(xml : TXmlBuilder; elem : TFhirContractTerm);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', elem.applies);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', elem.subType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeContractTermAgent(xml, 'agent', elem.agentList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(xml, 'group', elem.groupList[i]);
end;

function TFHIRXmlParser.ParseContractTermAgent(element : TMXmlElement; path : string) : TFhirContractTermAgent;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermAgentChild(element : TFhirContractTermAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermAgent(xml : TXmlBuilder; name : String; elem : TFhirContractTermAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermAgentChildren(xml : TXmlBuilder; elem : TFhirContractTermAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
end;

function TFHIRXmlParser.ParseContractTermValuedItem(element : TMXmlElement; path : string) : TFhirContractTermValuedItem;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermValuedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermValuedItemChild(element : TFhirContractTermValuedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entityCodeableConcept') then
        element.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.localName = 'entityReference') then
        element.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'effectiveTime') then
        element.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItem(xml : TXmlBuilder; name : String; elem : TFhirContractTermValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermValuedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractTermValuedItem);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
end;

function TFHIRXmlParser.ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
var
  child : TMXmlElement;
begin
  result := TFhirContractFriendly.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractFriendlyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractFriendlyChild(element : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractFriendly(xml : TXmlBuilder; name : String; elem : TFhirContractFriendly);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractFriendlyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractFriendlyChildren(xml : TXmlBuilder; elem : TFhirContractFriendly);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
var
  child : TMXmlElement;
begin
  result := TFhirContractLegal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractLegalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractLegalChild(element : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractLegal(xml : TXmlBuilder; name : String; elem : TFhirContractLegal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractLegalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractLegalChildren(xml : TXmlBuilder; elem : TFhirContractLegal);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
var
  child : TMXmlElement;
begin
  result := TFhirContractRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractRuleChild(element : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractRule(xml : TXmlBuilder; name : String; elem : TFhirContractRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractRuleChildren(xml : TXmlBuilder; elem : TFhirContractRule);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContract(element : TMXmlElement; path : string) : TFhirContract;
var
  child : TMXmlElement;
begin
  result := TFhirContract.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractChild(element : TFhirContract; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.localName = 'applies') then
        element.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.localName = 'subject') then
        element.subjectList.Add(ParseReference{TFhirReference}(child, path+'/subject')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseReference{TFhirReference}(child, path+'/topic')){y.2}
      else if (child.localName = 'authority') then
        element.authorityList.Add(ParseReference{TFhirOrganization}(child, path+'/authority')){y.2}
      else if (child.localName = 'domain') then
        element.domainList.Add(ParseReference{TFhirLocation}(child, path+'/domain')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'actionReason') then
        element.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.localName = 'decisionType') then
        element.decisionType := ParseCodeableConcept(child, path+'/decisionType') {b}
      else if (child.localName = 'contentDerivative') then
        element.contentDerivative := ParseCodeableConcept(child, path+'/contentDerivative') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseContractAgent(child, path+'/agent')){y.2}
      else if (child.localName = 'signer') then
        element.signerList.Add(ParseContractSigner(child, path+'/signer')){y.2}
      else if (child.localName = 'valuedItem') then
        element.valuedItemList.Add(ParseContractValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.localName = 'term') then
        element.termList.Add(ParseContractTerm(child, path+'/term')){y.2}
      else if (child.localName = 'bindingAttachment') then
        element.binding := ParseAttachment(child, path+'/bindingAttachment'){x.3}
      else if (child.localName = 'bindingReference') then
        element.binding := ParseReference(child, path+'/bindingReference') {a}
      else if (child.localName = 'friendly') then
        element.friendlyList.Add(ParseContractFriendly(child, path+'/friendly')){y.2}
      else if (child.localName = 'legal') then
        element.legalList.Add(ParseContractLegal(child, path+'/legal')){y.2}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseContractRule(child, path+'/rule')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContract(xml : TXmlBuilder; name : String; elem : TFhirContract);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractChildren(xml : TXmlBuilder; elem : TFhirContract);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirContractStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(xml, 'applies', elem.applies);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'subject', elem.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'authority', elem.authorityList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('domain') then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'domain', elem.domainList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('actionReason') then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('decisionType') then
    ComposeCodeableConcept(xml, 'decisionType', elem.decisionType);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contentDerivative') then
    ComposeCodeableConcept(xml, 'contentDerivative', elem.contentDerivative);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('agent') then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeContractAgent(xml, 'agent', elem.agentList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('signer') then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(xml, 'signer', elem.signerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('valuedItem') then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('term') then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(xml, 'term', elem.termList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'bindingAttachment', TFhirAttachment(elem.binding))
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(xml, 'bindingReference', TFhirReference(elem.binding));
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(xml, 'friendly', elem.friendlyList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('legal') then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(xml, 'legal', elem.legalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(xml, 'rule', elem.ruleList[i]);
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRXmlParser.ParseCoverageGrouping(element : TMXmlElement; path : string) : TFhirCoverageGrouping;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageGrouping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageGroupingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageGroupingChild(element : TFhirCoverageGrouping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'group') then
        element.groupElement := ParseString(child, path+'/group') {b}
      else if (child.localName = 'groupDisplay') then
        element.groupDisplayElement := ParseString(child, path+'/groupDisplay') {b}
      else if (child.localName = 'subGroup') then
        element.subGroupElement := ParseString(child, path+'/subGroup') {b}
      else if (child.localName = 'subGroupDisplay') then
        element.subGroupDisplayElement := ParseString(child, path+'/subGroupDisplay') {b}
      else if (child.localName = 'plan') then
        element.planElement := ParseString(child, path+'/plan') {b}
      else if (child.localName = 'planDisplay') then
        element.planDisplayElement := ParseString(child, path+'/planDisplay') {b}
      else if (child.localName = 'subPlan') then
        element.subPlanElement := ParseString(child, path+'/subPlan') {b}
      else if (child.localName = 'subPlanDisplay') then
        element.subPlanDisplayElement := ParseString(child, path+'/subPlanDisplay') {b}
      else if (child.localName = 'class') then
        element.class_Element := ParseString(child, path+'/class') {b}
      else if (child.localName = 'classDisplay') then
        element.classDisplayElement := ParseString(child, path+'/classDisplay') {b}
      else if (child.localName = 'subClass') then
        element.subClassElement := ParseString(child, path+'/subClass') {b}
      else if (child.localName = 'subClassDisplay') then
        element.subClassDisplayElement := ParseString(child, path+'/subClassDisplay') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageGrouping(xml : TXmlBuilder; name : String; elem : TFhirCoverageGrouping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageGroupingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageGroupingChildren(xml : TXmlBuilder; elem : TFhirCoverageGrouping);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'group', elem.groupElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'groupDisplay', elem.groupDisplayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subGroup', elem.subGroupElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subGroupDisplay', elem.subGroupDisplayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'plan', elem.planElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'planDisplay', elem.planDisplayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subPlan', elem.subPlanElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subPlanDisplay', elem.subPlanDisplayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'class', elem.class_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'classDisplay', elem.classDisplayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subClass', elem.subClassElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'subClassDisplay', elem.subClassDisplayElement);{x.2b}
end;

function TFHIRXmlParser.ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirCoverage.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageChild(element : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'policyHolder') then
        element.policyHolder := ParseReference{Resource}(child, path+'/policyHolder') {b}
      else if (child.localName = 'subscriber') then
        element.subscriber := ParseReference{Resource}(child, path+'/subscriber') {b}
      else if (child.localName = 'subscriberId') then
        element.subscriberIdElement := ParseString(child, path+'/subscriberId') {b}
      else if (child.localName = 'beneficiary') then
        element.beneficiary := ParseReference{TFhirPatient}(child, path+'/beneficiary') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'payor') then
        element.payorList.Add(ParseReference{Resource}(child, path+'/payor')){y.2}
      else if (child.localName = 'grouping') then
        element.grouping := ParseCoverageGrouping(child, path+'/grouping') {b}
      else if (child.localName = 'dependent') then
        element.dependentElement := ParseString(child, path+'/dependent') {b}
      else if (child.localName = 'sequence') then
        element.sequenceElement := ParseString(child, path+'/sequence') {b}
      else if (child.localName = 'order') then
        element.orderElement := ParsePositiveInt(child, path+'/order') {b}
      else if (child.localName = 'network') then
        element.networkElement := ParseString(child, path+'/network') {b}
      else if (child.localName = 'contract') then
        element.contractList.Add(ParseReference{TFhirContract}(child, path+'/contract')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverage(xml : TXmlBuilder; name : String; elem : TFhirCoverage);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageChildren(xml : TXmlBuilder; elem : TFhirCoverage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyHolder') then
    ComposeReference{Resource}(xml, 'policyHolder', elem.policyHolder);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriber') then
    ComposeReference{Resource}(xml, 'subscriber', elem.subscriber);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeString(xml, 'subscriberId', elem.subscriberIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('beneficiary') then
    ComposeReference{TFhirPatient}(xml, 'beneficiary', elem.beneficiary);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payor') then
    for i := 0 to elem.payorList.Count - 1 do
      ComposeReference{Resource}(xml, 'payor', elem.payorList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('grouping') then
    ComposeCoverageGrouping(xml, 'grouping', elem.grouping);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposeString(xml, 'dependent', elem.dependentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposeString(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    ComposePositiveInt(xml, 'order', elem.orderElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeString(xml, 'network', elem.networkElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(xml, 'contract', elem.contractList[i]);
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
function TFHIRXmlParser.ParseDataElementMapping(element : TMXmlElement; path : string) : TFhirDataElementMapping;
var
  child : TMXmlElement;
begin
  result := TFhirDataElementMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataElementMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataElementMappingChild(element : TFhirDataElementMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataElementMapping(xml : TXmlBuilder; name : String; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataElementMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataElementMappingChildren(xml : TXmlBuilder; elem : TFhirDataElementMapping);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

function TFHIRXmlParser.ParseDataElement(element : TMXmlElement; path : string) : TFhirDataElement;
var
  child : TMXmlElement;
begin
  result := TFhirDataElement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataElementChild(element : TFhirDataElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'stringency') then
        element.stringencyElement := ParseEnum(CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, path+'/stringency', child){1a}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseDataElementMapping(child, path+'/mapping')){y.2}
      else if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataElement(xml : TXmlBuilder; name : String; elem : TFhirDataElement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataElementChildren(xml : TXmlBuilder; elem : TFhirDataElement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnum(xml, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(xml, 'mapping', elem.mappingList[i]);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRXmlParser.ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueMitigationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueMitigationChild(element : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : String; elem : TFhirDetectedIssueMitigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueMitigationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; elem : TFhirDetectedIssueMitigation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'action', elem.action);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2a}
end;

function TFHIRXmlParser.ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssue.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueChild(element : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'implicated') then
        element.implicatedList.Add(ParseReference{TFhirReference}(child, path+'/implicated')){y.2}
      else if (child.localName = 'detail') then
        element.detailElement := ParseString(child, path+'/detail') {b}
      else if (child.localName = 'reference') then
        element.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.localName = 'mitigation') then
        element.mitigationList.Add(ParseDetectedIssueMitigation(child, path+'/mitigation')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssue(xml : TXmlBuilder; name : String; elem : TFhirDetectedIssue);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueChildren(xml : TXmlBuilder; elem : TFhirDetectedIssue);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'implicated', elem.implicatedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeString(xml, 'detail', elem.detailElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUri(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(xml, 'mitigation', elem.mitigationList[i]);
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRXmlParser.ParseDeviceUdi(element : TMXmlElement; path : string) : TFhirDeviceUdi;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUdi.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUdiChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUdiChild(element : TFhirDeviceUdi; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'deviceIdentifier') then
        element.deviceIdentifierElement := ParseString(child, path+'/deviceIdentifier') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionElement := ParseUri(child, path+'/jurisdiction') {b}
      else if (child.localName = 'carrierHRF') then
        element.carrierHRFElement := ParseString(child, path+'/carrierHRF') {b}
      else if (child.localName = 'carrierAIDC') then
        element.carrierAIDCElement := ParseBase64Binary(child, path+'/carrierAIDC') {b}
      else if (child.localName = 'issuer') then
        element.issuerElement := ParseUri(child, path+'/issuer') {b}
      else if (child.localName = 'entryType') then
        element.entryTypeElement := ParseEnum(CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum, path+'/entryType', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUdi(xml : TXmlBuilder; name : String; elem : TFhirDeviceUdi);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUdiChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUdiChildren(xml : TXmlBuilder; elem : TFhirDeviceUdi);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'deviceIdentifier', elem.deviceIdentifierElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'jurisdiction', elem.jurisdictionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'carrierHRF', elem.carrierHRFElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'carrierAIDC', elem.carrierAIDCElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'issuer', elem.issuerElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'entryType', elem.EntryTypeElement, CODES_TFhirUdiEntryTypeEnum);
end;

function TFHIRXmlParser.ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
var
  child : TMXmlElement;
begin
  result := TFhirDevice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceChild(element : TFhirDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'udi') then
        element.udi := ParseDeviceUdi(child, path+'/udi') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'manufacturer') then
        element.manufacturerElement := ParseString(child, path+'/manufacturer') {b}
      else if (child.localName = 'manufactureDate') then
        element.manufactureDateElement := ParseDateTime(child, path+'/manufactureDate') {b}
      else if (child.localName = 'expirationDate') then
        element.expirationDateElement := ParseDateTime(child, path+'/expirationDate') {b}
      else if (child.localName = 'model') then
        element.modelElement := ParseString(child, path+'/model') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'owner') then
        element.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'safety') then
        element.safetyList.Add(ParseCodeableConcept(child, path+'/safety')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : String; elem : TFhirDevice);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceChildren(xml : TXmlBuilder; elem : TFhirDevice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('udi') then
    ComposeDeviceUdi(xml, 'udi', elem.udi);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDeviceStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeString(xml, 'manufacturer', elem.manufacturerElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTime(xml, 'manufactureDate', elem.manufactureDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateTime(xml, 'expirationDate', elem.expirationDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeString(xml, 'model', elem.modelElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') then
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(xml, 'safety', elem.safetyList[i]);
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
function TFHIRXmlParser.ParseDeviceComponentProductionSpecification(element : TMXmlElement; path : string) : TFhirDeviceComponentProductionSpecification;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceComponentProductionSpecificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceComponentProductionSpecificationChild(element : TFhirDeviceComponentProductionSpecification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'specType') then
        element.specType := ParseCodeableConcept(child, path+'/specType') {b}
      else if (child.localName = 'componentId') then
        element.componentId := ParseIdentifier(child, path+'/componentId') {b}
      else if (child.localName = 'productionSpec') then
        element.productionSpecElement := ParseString(child, path+'/productionSpec') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : String; elem : TFhirDeviceComponentProductionSpecification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceComponentProductionSpecificationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecificationChildren(xml : TXmlBuilder; elem : TFhirDeviceComponentProductionSpecification);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'specType', elem.specType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'componentId', elem.componentId);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'productionSpec', elem.productionSpecElement);{x.2b}
end;

function TFHIRXmlParser.ParseDeviceComponent(element : TMXmlElement; path : string) : TFhirDeviceComponent;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceComponent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceComponentChild(element : TFhirDeviceComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'lastSystemChange') then
        element.lastSystemChangeElement := ParseInstant(child, path+'/lastSystemChange') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.localName = 'parent') then
        element.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.localName = 'operationalStatus') then
        element.operationalStatusList.Add(ParseCodeableConcept(child, path+'/operationalStatus')){y.2}
      else if (child.localName = 'parameterGroup') then
        element.parameterGroup := ParseCodeableConcept(child, path+'/parameterGroup') {b}
      else if (child.localName = 'measurementPrinciple') then
        element.measurementPrincipleElement := ParseEnum(CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, path+'/measurementPrinciple', child){1a}
      else if (child.localName = 'productionSpecification') then
        element.productionSpecificationList.Add(ParseDeviceComponentProductionSpecification(child, path+'/productionSpecification')){y.2}
      else if (child.localName = 'languageCode') then
        element.languageCode := ParseCodeableConcept(child, path+'/languageCode') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponent(xml : TXmlBuilder; name : String; elem : TFhirDeviceComponent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceComponentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentChildren(xml : TXmlBuilder; elem : TFhirDeviceComponent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastSystemChange') then
    ComposeInstant(xml, 'lastSystemChange', elem.lastSystemChangeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(xml, 'operationalStatus', elem.operationalStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parameterGroup') then
    ComposeCodeableConcept(xml, 'parameterGroup', elem.parameterGroup);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnum(xml, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productionSpecification') then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(xml, 'productionSpecification', elem.productionSpecificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('languageCode') then
    ComposeCodeableConcept(xml, 'languageCode', elem.languageCode);{x.2a}
end;

{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRXmlParser.ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricCalibrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricCalibrationChild(element : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'state') then
        element.stateElement := ParseEnum(CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, path+'/state', child){1a}
      else if (child.localName = 'time') then
        element.timeElement := ParseInstant(child, path+'/time') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : String; elem : TFhirDeviceMetricCalibration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricCalibrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; elem : TFhirDeviceMetricCalibration);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'time', elem.timeElement);{x.2b}
end;

function TFHIRXmlParser.ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetric.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricChild(element : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'unit') then
        element.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.localName = 'parent') then
        element.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.localName = 'operationalStatus') then
        element.operationalStatusElement := ParseEnum(CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, path+'/operationalStatus', child){1a}
      else if (child.localName = 'color') then
        element.colorElement := ParseEnum(CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, path+'/color', child){1a}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'measurementPeriod') then
        element.measurementPeriod := ParseTiming(child, path+'/measurementPeriod') {b}
      else if (child.localName = 'calibration') then
        element.calibrationList.Add(ParseDeviceMetricCalibration(child, path+'/calibration')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetric(xml : TXmlBuilder; name : String; elem : TFhirDeviceMetric);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricChildren(xml : TXmlBuilder; elem : TFhirDeviceMetric);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnum(xml, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnum(xml, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum);
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(xml, 'measurementPeriod', elem.measurementPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(xml, 'calibration', elem.calibrationList[i]);
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
function TFHIRXmlParser.ParseDeviceRequestRequester(element : TMXmlElement; path : string) : TFhirDeviceRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceRequestRequesterChild(element : TFhirDeviceRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirDeviceRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirDeviceRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseDeviceRequest(element : TMXmlElement; path : string) : TFhirDeviceRequest;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceRequestChild(element : TFhirDeviceRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'priorRequest') then
        element.priorRequestList.Add(ParseReference{TFhirReference}(child, path+'/priorRequest')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intent := ParseCodeableConcept(child, path+'/intent') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'codeReference') then
        element.code := ParseReference(child, path+'/codeReference') {a}
      else if (child.localName = 'codeCodeableConcept') then
        element.code := ParseCodeableConcept(child, path+'/codeCodeableConcept'){x.3}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceTiming') then
        element.occurrence := ParseTiming(child, path+'/occurrenceTiming'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseDeviceRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'performerType') then
        element.performerType := ParseCodeableConcept(child, path+'/performerType') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{TFhirReference}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'supportingInfo') then
        element.supportingInfoList.Add(ParseReference{TFhirReference}(child, path+'/supportingInfo')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'relevantHistory') then
        element.relevantHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/relevantHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequest(xml : TXmlBuilder; name : String; elem : TFhirDeviceRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestChildren(xml : TXmlBuilder; elem : TFhirDeviceRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorRequest') then
    for i := 0 to elem.priorRequestList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'priorRequest', elem.priorRequestList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum);
  ComposeCodeableConcept(xml, 'intent', elem.intent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.priorityElement <> nil) and (elem.priorityElement.primitiveValue <> 'If missing, normal priority')) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (elem.code is TFhirReference) {2} then
    ComposeReference(xml, 'codeReference', TFhirReference(elem.code))
  else if (elem.code is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'codeCodeableConcept', TFhirCodeableConcept(elem.code));
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeDeviceRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(xml, 'performerType', elem.performerType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInfo', elem.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'relevantHistory', elem.relevantHistoryList[i]);
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
function TFHIRXmlParser.ParseDeviceUseStatement(element : TMXmlElement; path : string) : TFhirDeviceUseStatement;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUseStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUseStatementChild(element : TFhirDeviceUseStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'whenUsed') then
        element.whenUsed := ParsePeriod(child, path+'/whenUsed') {b}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.localName = 'recordedOn') then
        element.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.localName = 'indication') then
        element.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatement(xml : TXmlBuilder; name : String; elem : TFhirDeviceUseStatement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUseStatementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatementChildren(xml : TXmlBuilder; elem : TFhirDeviceUseStatement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDeviceStatementStatusEnum);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('whenUsed') then
    ComposePeriod(xml, 'whenUsed', elem.whenUsed);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soData]) and doCompose('recordedOn') then
    ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRXmlParser.ParseDiagnosticReportPerformer(element : TMXmlElement; path : string) : TFhirDiagnosticReportPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReportPerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportPerformerChild(element : TFhirDiagnosticReportPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportPerformer(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticReportPerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportPerformerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportPerformerChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportPerformer);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
end;

function TFHIRXmlParser.ParseDiagnosticReportImage(element : TMXmlElement; path : string) : TFhirDiagnosticReportImage;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportImageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportImageChild(element : TFhirDiagnosticReportImage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'link') then
        element.link_ := ParseReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportImageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImageChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportImage);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  ComposeReference{TFhirMedia}(xml, 'link', elem.link_);{x.2a}
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportChild(element : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseDiagnosticReportPerformer(child, path+'/performer')){y.2}
      else if (child.localName = 'specimen') then
        element.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.localName = 'result') then
        element.resultList.Add(ParseReference{TFhirObservation}(child, path+'/result')){y.2}
      else if (child.localName = 'imagingStudy') then
        element.imagingStudyList.Add(ParseReference{Resource}(child, path+'/imagingStudy')){y.2}
      else if (child.localName = 'image') then
        element.imageList.Add(ParseDiagnosticReportImage(child, path+'/image')){y.2}
      else if (child.localName = 'conclusion') then
        element.conclusionElement := ParseString(child, path+'/conclusion') {b}
      else if (child.localName = 'codedDiagnosis') then
        element.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis')){y.2}
      else if (child.localName = 'presentedForm') then
        element.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticReport);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeDiagnosticReportPerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeString(xml, 'conclusion', elem.conclusionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('codedDiagnosis') then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRXmlParser.ParseDocumentManifestContent(element : TMXmlElement; path : string) : TFhirDocumentManifestContent;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifestContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestContentChild(element : TFhirDocumentManifestContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'pAttachment') then
        element.p := ParseAttachment(child, path+'/pAttachment'){x.3}
      else if (child.localName = 'pReference') then
        element.p := ParseReference(child, path+'/pReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContent(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifestContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContentChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestContent);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'pAttachment', TFhirAttachment(elem.p))
  else if (elem.p is TFhirReference) {2} then
    ComposeReference(xml, 'pReference', TFhirReference(elem.p));
end;

function TFHIRXmlParser.ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestRelatedChild(element : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'ref') then
        element.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelated(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifestRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestChild(element : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'masterIdentifier') then
        element.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseDocumentManifestContent(child, path+'/content')){y.2}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseDocumentManifestRelated(child, path+'/related')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestChildren(xml : TXmlBuilder; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(xml, 'related', elem.relatedList[i]);
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesToChild(element : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceRelatesToChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceRelatesTo);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum);
  ComposeReference{TFhirDocumentReference}(xml, 'target', elem.target);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContentChild(element : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'attachment') then
        element.attachment := ParseAttachment(child, path+'/attachment') {b}
      else if (child.localName = 'format') then
        element.format := ParseCoding(child, path+'/format') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContent(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeAttachment(xml, 'attachment', elem.attachment);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'format', elem.format);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : TMXmlElement; path : string) : TFhirDocumentReferenceContext;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContextChild(element : TFhirDocumentReferenceContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseCodeableConcept(child, path+'/event')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'facilityType') then
        element.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if (child.localName = 'practiceSetting') then
        element.practiceSetting := ParseCodeableConcept(child, path+'/practiceSetting') {b}
      else if (child.localName = 'sourcePatientInfo') then
        element.sourcePatientInfo := ParseReference{TFhirPatient}(child, path+'/sourcePatientInfo') {b}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseDocumentReferenceContextRelated(child, path+'/related')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContext);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContextChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'practiceSetting', elem.practiceSetting);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'sourcePatientInfo', elem.sourcePatientInfo);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(xml, 'related', elem.relatedList[i]);
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelated(element : TMXmlElement; path : string) : TFhirDocumentReferenceContextRelated;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContextRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelatedChild(element : TFhirDocumentReferenceContextRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'ref') then
        element.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContextRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContextRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContextRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceChild(element : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'masterIdentifier') then
        element.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'docStatus') then
        element.docStatusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, path+'/docStatus', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'class') then
        element.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'indexed') then
        element.indexedElement := ParseInstant(child, path+'/indexed') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'authenticator') then
        element.authenticator := ParseReference{Resource}(child, path+'/authenticator') {b}
      else if (child.localName = 'custodian') then
        element.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.localName = 'relatesTo') then
        element.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCodeableConcept(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseDocumentReferenceContent(child, path+'/content')){y.2}
      else if (child.localName = 'context') then
        element.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : String; elem : TFhirDocumentReference);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceChildren(xml : TXmlBuilder; elem : TFhirDocumentReference);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeEnum(xml, 'docStatus', elem.DocStatusElement, CODES_TFhirCompositionStatusEnum);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  ComposeInstant(xml, 'indexed', elem.indexedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authenticator') then
    ComposeReference{Resource}(xml, 'authenticator', elem.authenticator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(xml, 'securityLabel', elem.securityLabelList[i]);
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(xml, 'context', elem.context);{x.2a}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
function TFHIRXmlParser.ParseEligibilityRequest(element : TMXmlElement; path : string) : TFhirEligibilityRequest;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityRequestChild(element : TFhirEligibilityRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'servicedPeriod') then
        element.serviced := ParsePeriod(child, path+'/servicedPeriod'){x.3}
      else if (child.localName = 'servicedDate') then
        element.serviced := ParseDate(child, path+'/servicedDate'){x.3}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'facility') then
        element.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'businessArrangement') then
        element.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.localName = 'benefitCategory') then
        element.benefitCategory := ParseCodeableConcept(child, path+'/benefitCategory') {b}
      else if (child.localName = 'benefitSubCategory') then
        element.benefitSubCategory := ParseCodeableConcept(child, path+'/benefitSubCategory') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequest(xml : TXmlBuilder; name : String; elem : TFhirEligibilityRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequestChildren(xml : TXmlBuilder; elem : TFhirEligibilityRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(elem.serviced))
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(elem.serviced));
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('businessArrangement') then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitCategory') then
    ComposeCodeableConcept(xml, 'benefitCategory', elem.benefitCategory);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitSubCategory') then
    ComposeCodeableConcept(xml, 'benefitSubCategory', elem.benefitSubCategory);{x.2a}
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
function TFHIRXmlParser.ParseEligibilityResponseInsurance(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponseInsurance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseInsuranceChild(element : TFhirEligibilityResponseInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'contract') then
        element.contract := ParseReference{TFhirContract}(child, path+'/contract') {b}
      else if (child.localName = 'benefitBalance') then
        element.benefitBalanceList.Add(ParseEligibilityResponseInsuranceBenefitBalance(child, path+'/benefitBalance')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsurance(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponseInsurance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseInsuranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsuranceChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirContract}(xml, 'contract', elem.contract);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeEligibilityResponseInsuranceBenefitBalance(xml, 'benefitBalance', elem.benefitBalanceList[i]);
end;

function TFHIRXmlParser.ParseEligibilityResponseInsuranceBenefitBalance(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsuranceBenefitBalance;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseInsuranceBenefitBalanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseInsuranceBenefitBalanceChild(element : TFhirEligibilityResponseInsuranceBenefitBalance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'subCategory') then
        element.subCategory := ParseCodeableConcept(child, path+'/subCategory') {b}
      else if (child.localName = 'excluded') then
        element.excludedElement := ParseBoolean(child, path+'/excluded') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'network') then
        element.network := ParseCodeableConcept(child, path+'/network') {b}
      else if (child.localName = 'unit') then
        element.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.localName = 'term') then
        element.term := ParseCodeableConcept(child, path+'/term') {b}
      else if (child.localName = 'financial') then
        element.financialList.Add(ParseEligibilityResponseInsuranceBenefitBalanceFinancial(child, path+'/financial')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsuranceBenefitBalance(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseInsuranceBenefitBalanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsuranceBenefitBalanceChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsuranceBenefitBalance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subCategory', elem.subCategory);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'excluded', elem.excludedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'network', elem.network);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', elem.term);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.financialList.Count - 1 do
      ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(xml, 'financial', elem.financialList[i]);
end;

function TFHIRXmlParser.ParseEligibilityResponseInsuranceBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseInsuranceBenefitBalanceFinancialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseInsuranceBenefitBalanceFinancialChild(element : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'allowedUnsignedInt') then
        element.allowed := ParseUnsignedInt(child, path+'/allowedUnsignedInt'){x.3}
      else if (child.localName = 'allowedMoney') then
        element.allowed := ParseMoney(child, path+'/allowedMoney'){x.3}
      else if (child.localName = 'allowedString') then
        element.allowed := ParseString(child, path+'/allowedString'){x.3}
      else if (child.localName = 'usedUnsignedInt') then
        element.used := ParseUnsignedInt(child, path+'/usedUnsignedInt'){x.3}
      else if (child.localName = 'usedMoney') then
        element.used := ParseMoney(child, path+'/usedMoney'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseInsuranceBenefitBalanceFinancialChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseInsuranceBenefitBalanceFinancialChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed))
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(xml, 'allowedMoney', TFhirMoney(elem.allowed))
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(xml, 'allowedString', TFhirString(elem.allowed));
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'usedUnsignedInt', TFhirUnsignedInt(elem.used))
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(xml, 'usedMoney', TFhirMoney(elem.used));
end;

function TFHIRXmlParser.ParseEligibilityResponseError(element : TMXmlElement; path : string) : TFhirEligibilityResponseError;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponseError.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseErrorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseErrorChild(element : TFhirEligibilityResponseError; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseError(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponseError);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseErrorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseErrorChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponseError);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
end;

function TFHIRXmlParser.ParseEligibilityResponse(element : TMXmlElement; path : string) : TFhirEligibilityResponse;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseChild(element : TFhirEligibilityResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirEligibilityRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'inforce') then
        element.inforceElement := ParseBoolean(child, path+'/inforce') {b}
      else if (child.localName = 'insurance') then
        element.insuranceList.Add(ParseEligibilityResponseInsurance(child, path+'/insurance')){y.2}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'error') then
        element.errorList.Add(ParseEligibilityResponseError(child, path+'/error')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponse(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEligibilityRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('inforce') then
    ComposeBoolean(xml, 'inforce', elem.inforceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeEligibilityResponseInsurance(xml, 'insurance', elem.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeEligibilityResponseError(xml, 'error', elem.errorList[i]);
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRXmlParser.ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterStatusHistoryChild(element : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistory(xml : TXmlBuilder; name : String; elem : TFhirEncounterStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterStatusHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterStatusHistory);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum);
  ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterClassHistory(element : TMXmlElement; path : string) : TFhirEncounterClassHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterClassHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterClassHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterClassHistoryChild(element : TFhirEncounterClassHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'class') then
        element.class_ := ParseCoding(child, path+'/class') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterClassHistory(xml : TXmlBuilder; name : String; elem : TFhirEncounterClassHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterClassHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterClassHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterClassHistory);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'class', elem.class_);{x.2a}
  ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterParticipantChild(element : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'individual') then
        element.individual := ParseReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : String; elem : TFhirEncounterParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipantChildren(xml : TXmlBuilder; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'individual', elem.individual);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterDiagnosis(element : TMXmlElement; path : string) : TFhirEncounterDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterDiagnosisChild(element : TFhirEncounterDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'condition') then
        element.condition := ParseReference{Resource}(child, path+'/condition') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'rank') then
        element.rankElement := ParsePositiveInt(child, path+'/rank') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterDiagnosis(xml : TXmlBuilder; name : String; elem : TFhirEncounterDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterDiagnosisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterDiagnosisChildren(xml : TXmlBuilder; elem : TFhirEncounterDiagnosis);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'condition', elem.condition);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'rank', elem.rankElement);{x.2b}
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : TMXmlElement; path : string) : TFhirEncounterHospitalization;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterHospitalizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterHospitalizationChild(element : TFhirEncounterHospitalization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'preAdmissionIdentifier') then
        element.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.localName = 'origin') then
        element.origin := ParseReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.localName = 'admitSource') then
        element.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.localName = 'reAdmission') then
        element.reAdmission := ParseCodeableConcept(child, path+'/reAdmission') {b}
      else if (child.localName = 'dietPreference') then
        element.dietPreferenceList.Add(ParseCodeableConcept(child, path+'/dietPreference')){y.2}
      else if (child.localName = 'specialCourtesy') then
        element.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy')){y.2}
      else if (child.localName = 'specialArrangement') then
        element.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement')){y.2}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'dischargeDisposition') then
        element.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : String; elem : TFhirEncounterHospitalization);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterHospitalizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalizationChildren(xml : TXmlBuilder; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'origin', elem.origin);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reAdmission', elem.reAdmission);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(xml, 'dietPreference', elem.dietPreferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterLocationChild(element : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : String; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterLocationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocationChildren(xml : TXmlBuilder; elem : TFhirEncounterLocation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
var
  child : TMXmlElement;
begin
  result := TFhirEncounter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterChild(element : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusHistory') then
        element.statusHistoryList.Add(ParseEncounterStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.localName = 'class') then
        element.class_ := ParseCoding(child, path+'/class') {b}
      else if (child.localName = 'classHistory') then
        element.classHistoryList.Add(ParseEncounterClassHistory(child, path+'/classHistory')){y.2}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'episodeOfCare') then
        element.episodeOfCareList.Add(ParseReference{TFhirEpisodeOfCare}(child, path+'/episodeOfCare')){y.2}
      else if (child.localName = 'incomingReferral') then
        element.incomingReferralList.Add(ParseReference{TFhirReferralRequest}(child, path+'/incomingReferral')){y.2}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseEncounterParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'appointment') then
        element.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'length') then
        element.length := ParseDuration(child, path+'/length') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'diagnosis') then
        element.diagnosisList.Add(ParseEncounterDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.localName = 'account') then
        element.accountList.Add(ParseReference{TFhirAccount}(child, path+'/account')){y.2}
      else if (child.localName = 'hospitalization') then
        element.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseEncounterLocation(child, path+'/location')){y.2}
      else if (child.localName = 'serviceProvider') then
        element.serviceProvider := ParseReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : String; elem : TFhirEncounter);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterChildren(xml : TXmlBuilder; elem : TFhirEncounter);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCoding(xml, 'class', elem.class_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('classHistory') then
    for i := 0 to elem.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(xml, 'classHistory', elem.classHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(xml, 'episodeOfCare', elem.episodeOfCareList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'incomingReferral', elem.incomingReferralList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeDuration(xml, 'length', elem.length);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(xml, 'account', elem.accountList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(xml, 'partOf', elem.partOf);{x.2a}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
function TFHIRXmlParser.ParseEndpoint(element : TMXmlElement; path : string) : TFhirEndpoint;
var
  child : TMXmlElement;
begin
  result := TFhirEndpoint.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEndpointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEndpointChild(element : TFhirEndpoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'connectionType') then
        element.connectionType := ParseCoding(child, path+'/connectionType') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'payloadType') then
        element.payloadTypeList.Add(ParseCodeableConcept(child, path+'/payloadType')){y.2}
      else if (child.localName = 'payloadMimeType') then
        element.payloadMimeTypeList.Add(ParseCode(child, path+'/payloadMimeType')){y.2}
      else if (child.localName = 'address') then
        element.addressElement := ParseUri(child, path+'/address') {b}
      else if (child.localName = 'header') then
        element.headerList.Add(ParseString(child, path+'/header')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEndpoint(xml : TXmlBuilder; name : String; elem : TFhirEndpoint);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEndpointChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEndpointChildren(xml : TXmlBuilder; elem : TFhirEndpoint);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEndpointStatusEnum);
  ComposeCoding(xml, 'connectionType', elem.connectionType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  for i := 0 to elem.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'payloadType', elem.payloadTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payloadMimeType') then
    for i := 0 to elem.payloadMimeTypeList.Count - 1 do
      ComposeCode(xml, 'payloadMimeType', elem.payloadMimeTypeList[i]);
  ComposeUri(xml, 'address', elem.addressElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('header') then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(xml, 'header', elem.headerList[i]);
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRXmlParser.ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentRequestChild(element : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequest(xml : TXmlBuilder; name : String; elem : TFhirEnrollmentRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequestChildren(xml : TXmlBuilder; elem : TFhirEnrollmentRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRXmlParser.ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentResponseChild(element : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirEnrollmentRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponse(xml : TXmlBuilder; name : String; elem : TFhirEnrollmentResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponseChildren(xml : TXmlBuilder; elem : TFhirEnrollmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRXmlParser.ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareStatusHistoryChild(element : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCareStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareStatusHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareStatusHistory);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEpisodeOfCareDiagnosis(element : TMXmlElement; path : string) : TFhirEpisodeOfCareDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareDiagnosisChild(element : TFhirEpisodeOfCareDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'condition') then
        element.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'rank') then
        element.rankElement := ParsePositiveInt(child, path+'/rank') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareDiagnosis(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCareDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareDiagnosisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareDiagnosisChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareDiagnosis);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'rank', elem.rankElement);{x.2b}
end;

function TFHIRXmlParser.ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCare.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareChild(element : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusHistory') then
        element.statusHistoryList.Add(ParseEpisodeOfCareStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'diagnosis') then
        element.diagnosisList.Add(ParseEpisodeOfCareDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'referralRequest') then
        element.referralRequestList.Add(ParseReference{TFhirReferralRequest}(child, path+'/referralRequest')){y.2}
      else if (child.localName = 'careManager') then
        element.careManager := ParseReference{TFhirPractitioner}(child, path+'/careManager') {b}
      else if (child.localName = 'team') then
        element.teamList.Add(ParseReference{TFhirCareTeam}(child, path+'/team')){y.2}
      else if (child.localName = 'account') then
        element.accountList.Add(ParseReference{TFhirAccount}(child, path+'/account')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCare(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCare);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCare);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'referralRequest', elem.referralRequestList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(xml, 'careManager', elem.careManager);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('team') then
    for i := 0 to elem.teamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(xml, 'team', elem.teamList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(xml, 'account', elem.accountList[i]);
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
function TFHIRXmlParser.ParseExpansionProfileFixedVersion(element : TMXmlElement; path : string) : TFhirExpansionProfileFixedVersion;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileFixedVersion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileFixedVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileFixedVersionChild(element : TFhirExpansionProfileFixedVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirSystemVersionProcessingModeEnum, SYSTEMS_TFhirSystemVersionProcessingModeEnum, path+'/mode', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileFixedVersion(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileFixedVersion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileFixedVersionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileFixedVersionChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileFixedVersion);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirSystemVersionProcessingModeEnum);
end;

function TFHIRXmlParser.ParseExpansionProfileExcludedSystem(element : TMXmlElement; path : string) : TFhirExpansionProfileExcludedSystem;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileExcludedSystem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileExcludedSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileExcludedSystemChild(element : TFhirExpansionProfileExcludedSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileExcludedSystem(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileExcludedSystem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileExcludedSystemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileExcludedSystemChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileExcludedSystem);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
end;

function TFHIRXmlParser.ParseExpansionProfileDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationChild(element : TFhirExpansionProfileDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'include') then
        element.include := ParseExpansionProfileDesignationInclude(child, path+'/include') {b}
      else if (child.localName = 'exclude') then
        element.exclude := ParseExpansionProfileDesignationExclude(child, path+'/exclude') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignation(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpansionProfileDesignationInclude(xml, 'include', elem.include);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpansionProfileDesignationExclude(xml, 'exclude', elem.exclude);{x.2a}
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationInclude(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationInclude;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileDesignationInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileDesignationIncludeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationIncludeChild(element : TFhirExpansionProfileDesignationInclude; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'designation') then
        element.designationList.Add(ParseExpansionProfileDesignationIncludeDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationInclude(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileDesignationInclude);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileDesignationIncludeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationIncludeChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationInclude);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeExpansionProfileDesignationIncludeDesignation(xml, 'designation', elem.designationList[i]);
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationIncludeDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationIncludeDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileDesignationIncludeDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationIncludeDesignationChild(element : TFhirExpansionProfileDesignationIncludeDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'use') then
        element.use := ParseCoding(child, path+'/use') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationIncludeDesignation(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileDesignationIncludeDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileDesignationIncludeDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationIncludeDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationIncludeDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2a}
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationExclude(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationExclude;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileDesignationExclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileDesignationExcludeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationExcludeChild(element : TFhirExpansionProfileDesignationExclude; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'designation') then
        element.designationList.Add(ParseExpansionProfileDesignationExcludeDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationExclude(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileDesignationExclude);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileDesignationExcludeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationExcludeChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationExclude);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeExpansionProfileDesignationExcludeDesignation(xml, 'designation', elem.designationList[i]);
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationExcludeDesignation(element : TMXmlElement; path : string) : TFhirExpansionProfileDesignationExcludeDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileDesignationExcludeDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileDesignationExcludeDesignationChild(element : TFhirExpansionProfileDesignationExcludeDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'use') then
        element.use := ParseCoding(child, path+'/use') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationExcludeDesignation(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfileDesignationExcludeDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileDesignationExcludeDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileDesignationExcludeDesignationChildren(xml : TXmlBuilder; elem : TFhirExpansionProfileDesignationExcludeDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2a}
end;

function TFHIRXmlParser.ParseExpansionProfile(element : TMXmlElement; path : string) : TFhirExpansionProfile;
var
  child : TMXmlElement;
begin
  result := TFhirExpansionProfile.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpansionProfileChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpansionProfileChild(element : TFhirExpansionProfile; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'fixedVersion') then
        element.fixedVersionList.Add(ParseExpansionProfileFixedVersion(child, path+'/fixedVersion')){y.2}
      else if (child.localName = 'excludedSystem') then
        element.excludedSystem := ParseExpansionProfileExcludedSystem(child, path+'/excludedSystem') {b}
      else if (child.localName = 'includeDesignations') then
        element.includeDesignationsElement := ParseBoolean(child, path+'/includeDesignations') {b}
      else if (child.localName = 'designation') then
        element.designation := ParseExpansionProfileDesignation(child, path+'/designation') {b}
      else if (child.localName = 'includeDefinition') then
        element.includeDefinitionElement := ParseBoolean(child, path+'/includeDefinition') {b}
      else if (child.localName = 'activeOnly') then
        element.activeOnlyElement := ParseBoolean(child, path+'/activeOnly') {b}
      else if (child.localName = 'excludeNested') then
        element.excludeNestedElement := ParseBoolean(child, path+'/excludeNested') {b}
      else if (child.localName = 'excludeNotForUI') then
        element.excludeNotForUIElement := ParseBoolean(child, path+'/excludeNotForUI') {b}
      else if (child.localName = 'excludePostCoordinated') then
        element.excludePostCoordinatedElement := ParseBoolean(child, path+'/excludePostCoordinated') {b}
      else if (child.localName = 'displayLanguage') then
        element.displayLanguageElement := ParseCode(child, path+'/displayLanguage') {b}
      else if (child.localName = 'limitedExpansion') then
        element.limitedExpansionElement := ParseBoolean(child, path+'/limitedExpansion') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfile(xml : TXmlBuilder; name : String; elem : TFhirExpansionProfile);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpansionProfileChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpansionProfileChildren(xml : TXmlBuilder; elem : TFhirExpansionProfile);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fixedVersion') then
    for i := 0 to elem.fixedVersionList.Count - 1 do
      ComposeExpansionProfileFixedVersion(xml, 'fixedVersion', elem.fixedVersionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludedSystem') then
    ComposeExpansionProfileExcludedSystem(xml, 'excludedSystem', elem.excludedSystem);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('includeDesignations') then
    ComposeBoolean(xml, 'includeDesignations', elem.includeDesignationsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('designation') then
    ComposeExpansionProfileDesignation(xml, 'designation', elem.designation);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.includeDefinition <> false)) and doCompose('includeDefinition') then
    ComposeBoolean(xml, 'includeDefinition', elem.includeDefinitionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.activeOnly <> false)) and doCompose('activeOnly') then
    ComposeBoolean(xml, 'activeOnly', elem.activeOnlyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludeNested') then
    ComposeBoolean(xml, 'excludeNested', elem.excludeNestedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludeNotForUI') then
    ComposeBoolean(xml, 'excludeNotForUI', elem.excludeNotForUIElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludePostCoordinated') then
    ComposeBoolean(xml, 'excludePostCoordinated', elem.excludePostCoordinatedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('displayLanguage') then
    ComposeCode(xml, 'displayLanguage', elem.displayLanguageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('limitedExpansion') then
    ComposeBoolean(xml, 'limitedExpansion', elem.limitedExpansionElement);{x.2b}
end;

{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRXmlParser.ParseExplanationOfBenefitRelated(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitRelated;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitRelatedChild(element : TFhirExplanationOfBenefitRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'claim') then
        element.claim := ParseReference{TFhirClaim}(child, path+'/claim') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseIdentifier(child, path+'/reference') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitRelated(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitRelatedChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(xml, 'claim', elem.claim);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'reference', elem.reference);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayee(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayee;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitPayeeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayeeChild(element : TFhirExplanationOfBenefitPayee; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'resourceType') then
        element.resourceType := ParseCodeableConcept(child, path+'/resourceType') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayee(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitPayee);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitPayeeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayeeChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitPayee);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'resourceType', elem.resourceType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInformation(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInformation;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitInformation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitInformationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInformationChild(element : TFhirExplanationOfBenefitInformation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDate') then
        element.timing := ParseDate(child, path+'/timingDate'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference') {a}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'reason') then
        element.reason := ParseCoding(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInformation(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitInformation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitInformationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInformationChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitInformation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(xml, 'timingDate', TFhirDate(elem.timing));
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'reason', elem.reason);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitCareTeam(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitCareTeamChild(element : TFhirExplanationOfBenefitCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{Resource}(child, path+'/provider') {b}
      else if (child.localName = 'responsible') then
        element.responsibleElement := ParseBoolean(child, path+'/responsible') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'qualification') then
        element.qualification := ParseCodeableConcept(child, path+'/qualification') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitCareTeam(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitCareTeam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitCareTeamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitCareTeamChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitCareTeam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeReference{Resource}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'responsible', elem.responsibleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'qualification', elem.qualification);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitDiagnosis(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitDiagnosisChild(element : TFhirExplanationOfBenefitDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'diagnosisCodeableConcept') then
        element.diagnosis := ParseCodeableConcept(child, path+'/diagnosisCodeableConcept'){x.3}
      else if (child.localName = 'diagnosisReference') then
        element.diagnosis := ParseReference(child, path+'/diagnosisReference') {a}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'packageCode') then
        element.packageCode := ParseCodeableConcept(child, path+'/packageCode') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitDiagnosis(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitDiagnosisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitDiagnosisChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitDiagnosis);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis))
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(xml, 'diagnosisReference', TFhirReference(elem.diagnosis));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'packageCode', elem.packageCode);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcedure(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcedureChild(element : TFhirExplanationOfBenefitProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'procedureCodeableConcept') then
        element.procedure_ := ParseCodeableConcept(child, path+'/procedureCodeableConcept'){x.3}
      else if (child.localName = 'procedureReference') then
        element.procedure_ := ParseReference(child, path+'/procedureReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcedure(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitProcedure);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitProcedureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcedureChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitProcedure);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_))
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(xml, 'procedureReference', TFhirReference(elem.procedure_));
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInsurance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInsuranceChild(element : TFhirExplanationOfBenefitInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'preAuthRef') then
        element.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInsurance(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitInsurance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitInsuranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInsuranceChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAccident(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAccident;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAccidentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAccidentChild(element : TFhirExplanationOfBenefitAccident; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'locationAddress') then
        element.location := ParseAddress(child, path+'/locationAddress'){x.3}
      else if (child.localName = 'locationReference') then
        element.location := ParseReference(child, path+'/locationReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAccident(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitAccident);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAccidentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAccidentChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAccident);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(elem.location));
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItem;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemChild(element : TFhirExplanationOfBenefitItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'careTeamLinkId') then
        element.careTeamLinkIdList.Add(ParsePositiveInt(child, path+'/careTeamLinkId')){y.2}
      else if (child.localName = 'diagnosisLinkId') then
        element.diagnosisLinkIdList.Add(ParsePositiveInt(child, path+'/diagnosisLinkId')){y.2}
      else if (child.localName = 'procedureLinkId') then
        element.procedureLinkIdList.Add(ParsePositiveInt(child, path+'/procedureLinkId')){y.2}
      else if (child.localName = 'informationLinkId') then
        element.informationLinkIdList.Add(ParsePositiveInt(child, path+'/informationLinkId')){y.2}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'servicedPeriod') then
        element.serviced := ParsePeriod(child, path+'/servicedPeriod'){x.3}
      else if (child.localName = 'servicedDate') then
        element.serviced := ParseDate(child, path+'/servicedDate'){x.3}
      else if (child.localName = 'locationCodeableConcept') then
        element.location := ParseCodeableConcept(child, path+'/locationCodeableConcept'){x.3}
      else if (child.localName = 'locationAddress') then
        element.location := ParseAddress(child, path+'/locationAddress'){x.3}
      else if (child.localName = 'locationReference') then
        element.location := ParseReference(child, path+'/locationReference') {a}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'subSite') then
        element.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite')){y.2}
      else if (child.localName = 'encounter') then
        element.encounterList.Add(ParseReference{TFhirEncounter}(child, path+'/encounter')){y.2}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseExplanationOfBenefitItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItem(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'careTeamLinkId', elem.careTeamLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisLinkId', elem.diagnosisLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'procedureLinkId', elem.procedureLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'informationLinkId', elem.informationLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(elem.serviced))
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(elem.serviced));
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(elem.location))
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', elem.subSiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemAdjudication(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemAdjudicationChild(element : TFhirExplanationOfBenefitItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseMoney(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemAdjudication(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailChild(element : TFhirExplanationOfBenefitItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'subDetail') then
        element.subDetailList.Add(ParseExplanationOfBenefitItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetail(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailSubDetailChild(element : TFhirExplanationOfBenefitItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'programCode') then
        element.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseMoney(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'net') then
        element.net := ParseMoney(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udiList.Add(ParseReference{TFhirDevice}(child, path+'/udi')){y.2}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailSubDetail(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemDetailSubDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', elem.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'udi', elem.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItem;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemChild(element : TFhirExplanationOfBenefitAddItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdList.Add(ParsePositiveInt(child, path+'/sequenceLinkId')){y.2}
      else if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'fee') then
        element.fee := ParseMoney(child, path+'/fee') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseExplanationOfBenefitAddItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItem(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitAddItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAddItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetailChild(element : TFhirExplanationOfBenefitAddItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        element.revenue := ParseCodeableConcept(child, path+'/revenue') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'service') then
        element.service := ParseCodeableConcept(child, path+'/service') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'fee') then
        element.fee := ParseMoney(child, path+'/fee') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetail(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitAddItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitAddItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', elem.revenue);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayment(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayment;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitPaymentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPaymentChild(element : TFhirExplanationOfBenefitPayment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'adjustment') then
        element.adjustment := ParseMoney(child, path+'/adjustment') {b}
      else if (child.localName = 'adjustmentReason') then
        element.adjustmentReason := ParseCodeableConcept(child, path+'/adjustmentReason') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseMoney(child, path+'/amount') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayment(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitPayment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitPaymentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPaymentChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitPayment);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'adjustment', elem.adjustment);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'adjustmentReason', elem.adjustmentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcessNote(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcessNoteChild(element : TFhirExplanationOfBenefitProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        element.numberElement := ParsePositiveInt(child, path+'/number') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'language') then
        element.language := ParseCodeableConcept(child, path+'/language') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcessNote(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitProcessNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitProcessNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcessNoteChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitProcessNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'number', elem.numberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', elem.language);{x.2a}
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalance;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitBenefitBalanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceChild(element : TFhirExplanationOfBenefitBenefitBalance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'subCategory') then
        element.subCategory := ParseCodeableConcept(child, path+'/subCategory') {b}
      else if (child.localName = 'excluded') then
        element.excludedElement := ParseBoolean(child, path+'/excluded') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'network') then
        element.network := ParseCodeableConcept(child, path+'/network') {b}
      else if (child.localName = 'unit') then
        element.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.localName = 'term') then
        element.term := ParseCodeableConcept(child, path+'/term') {b}
      else if (child.localName = 'financial') then
        element.financialList.Add(ParseExplanationOfBenefitBenefitBalanceFinancial(child, path+'/financial')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalance(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitBenefitBalance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitBenefitBalanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitBenefitBalance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subCategory', elem.subCategory);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'excluded', elem.excludedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'network', elem.network);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', elem.term);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(xml, 'financial', elem.financialList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitBenefitBalanceFinancialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceFinancialChild(element : TFhirExplanationOfBenefitBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'allowedUnsignedInt') then
        element.allowed := ParseUnsignedInt(child, path+'/allowedUnsignedInt'){x.3}
      else if (child.localName = 'allowedMoney') then
        element.allowed := ParseMoney(child, path+'/allowedMoney'){x.3}
      else if (child.localName = 'allowedString') then
        element.allowed := ParseString(child, path+'/allowedString'){x.3}
      else if (child.localName = 'usedUnsignedInt') then
        element.used := ParseUnsignedInt(child, path+'/usedUnsignedInt'){x.3}
      else if (child.localName = 'usedMoney') then
        element.used := ParseMoney(child, path+'/usedMoney'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitBenefitBalanceFinancialChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceFinancialChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed))
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(xml, 'allowedMoney', TFhirMoney(elem.allowed))
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(xml, 'allowedString', TFhirString(elem.allowed));
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'usedUnsignedInt', TFhirUnsignedInt(elem.used))
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(xml, 'usedMoney', TFhirMoney(elem.used));
end;

function TFHIRXmlParser.ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitChild(element : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'billablePeriod') then
        element.billablePeriod := ParsePeriod(child, path+'/billablePeriod') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'insurer') then
        element.insurer := ParseReference{TFhirOrganization}(child, path+'/insurer') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'referral') then
        element.referral := ParseReference{TFhirReferralRequest}(child, path+'/referral') {b}
      else if (child.localName = 'facility') then
        element.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.localName = 'claim') then
        element.claim := ParseReference{TFhirClaim}(child, path+'/claim') {b}
      else if (child.localName = 'claimResponse') then
        element.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseExplanationOfBenefitRelated(child, path+'/related')){y.2}
      else if (child.localName = 'prescription') then
        element.prescription := ParseReference{Resource}(child, path+'/prescription') {b}
      else if (child.localName = 'originalPrescription') then
        element.originalPrescription := ParseReference{TFhirMedicationRequest}(child, path+'/originalPrescription') {b}
      else if (child.localName = 'payee') then
        element.payee := ParseExplanationOfBenefitPayee(child, path+'/payee') {b}
      else if (child.localName = 'information') then
        element.informationList.Add(ParseExplanationOfBenefitInformation(child, path+'/information')){y.2}
      else if (child.localName = 'careTeam') then
        element.careTeamList.Add(ParseExplanationOfBenefitCareTeam(child, path+'/careTeam')){y.2}
      else if (child.localName = 'diagnosis') then
        element.diagnosisList.Add(ParseExplanationOfBenefitDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.localName = 'procedure') then
        element.procedure_List.Add(ParseExplanationOfBenefitProcedure(child, path+'/procedure')){y.2}
      else if (child.localName = 'precedence') then
        element.precedenceElement := ParsePositiveInt(child, path+'/precedence') {b}
      else if (child.localName = 'insurance') then
        element.insurance := ParseExplanationOfBenefitInsurance(child, path+'/insurance') {b}
      else if (child.localName = 'accident') then
        element.accident := ParseExplanationOfBenefitAccident(child, path+'/accident') {b}
      else if (child.localName = 'employmentImpacted') then
        element.employmentImpacted := ParsePeriod(child, path+'/employmentImpacted') {b}
      else if (child.localName = 'hospitalization') then
        element.hospitalization := ParsePeriod(child, path+'/hospitalization') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseExplanationOfBenefitItem(child, path+'/item')){y.2}
      else if (child.localName = 'addItem') then
        element.addItemList.Add(ParseExplanationOfBenefitAddItem(child, path+'/addItem')){y.2}
      else if (child.localName = 'totalCost') then
        element.totalCost := ParseMoney(child, path+'/totalCost') {b}
      else if (child.localName = 'unallocDeductable') then
        element.unallocDeductable := ParseMoney(child, path+'/unallocDeductable') {b}
      else if (child.localName = 'totalBenefit') then
        element.totalBenefit := ParseMoney(child, path+'/totalBenefit') {b}
      else if (child.localName = 'payment') then
        element.payment := ParseExplanationOfBenefitPayment(child, path+'/payment') {b}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'processNote') then
        element.processNoteList.Add(ParseExplanationOfBenefitProcessNote(child, path+'/processNote')){y.2}
      else if (child.localName = 'benefitBalance') then
        element.benefitBalanceList.Add(ParseExplanationOfBenefitBenefitBalance(child, path+'/benefitBalance')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefit(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefit);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefit);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirExplanationofbenefitStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('billablePeriod') then
    ComposePeriod(xml, 'billablePeriod', elem.billablePeriod);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(xml, 'insurer', elem.insurer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(xml, 'referral', elem.referral);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('claim') then
    ComposeReference{TFhirClaim}(xml, 'claim', elem.claim);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('claimResponse') then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(xml, 'related', elem.relatedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(xml, 'prescription', elem.prescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(xml, 'originalPrescription', elem.originalPrescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeExplanationOfBenefitPayee(xml, 'payee', elem.payee);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('information') then
    for i := 0 to elem.informationList.Count - 1 do
      ComposeExplanationOfBenefitInformation(xml, 'information', elem.informationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(xml, 'careTeam', elem.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(xml, 'procedure', elem.procedure_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('precedence') then
    ComposePositiveInt(xml, 'precedence', elem.precedenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    ComposeExplanationOfBenefitInsurance(xml, 'insurance', elem.insurance);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeExplanationOfBenefitAccident(xml, 'accident', elem.accident);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('employmentImpacted') then
    ComposePeriod(xml, 'employmentImpacted', elem.employmentImpacted);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposePeriod(xml, 'hospitalization', elem.hospitalization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(xml, 'addItem', elem.addItemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('totalCost') then
    ComposeMoney(xml, 'totalCost', elem.totalCost);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('unallocDeductable') then
    ComposeMoney(xml, 'unallocDeductable', elem.unallocDeductable);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('totalBenefit') then
    ComposeMoney(xml, 'totalBenefit', elem.totalBenefit);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeExplanationOfBenefitPayment(xml, 'payment', elem.payment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(xml, 'processNote', elem.processNoteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('benefitBalance') then
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(xml, 'benefitBalance', elem.benefitBalanceList[i]);
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRXmlParser.ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryConditionChild(element : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'onsetAge') then
        element.onset := ParseAge(child, path+'/onsetAge'){x.3}
      else if (child.localName = 'onsetRange') then
        element.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.localName = 'onsetPeriod') then
        element.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.localName = 'onsetString') then
        element.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : String; elem : TFhirFamilyMemberHistoryCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistoryCondition);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

function TFHIRXmlParser.ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryChild(element : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'notDone') then
        element.notDoneElement := ParseBoolean(child, path+'/notDone') {b}
      else if (child.localName = 'notDoneReason') then
        element.notDoneReason := ParseCodeableConcept(child, path+'/notDoneReason') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'bornPeriod') then
        element.born := ParsePeriod(child, path+'/bornPeriod'){x.3}
      else if (child.localName = 'bornDate') then
        element.born := ParseDate(child, path+'/bornDate'){x.3}
      else if (child.localName = 'bornString') then
        element.born := ParseString(child, path+'/bornString'){x.3}
      else if (child.localName = 'ageAge') then
        element.age := ParseAge(child, path+'/ageAge'){x.3}
      else if (child.localName = 'ageRange') then
        element.age := ParseRange(child, path+'/ageRange'){x.3}
      else if (child.localName = 'ageString') then
        element.age := ParseString(child, path+'/ageString'){x.3}
      else if (child.localName = 'estimatedAge') then
        element.estimatedAgeElement := ParseBoolean(child, path+'/estimatedAge') {b}
      else if (child.localName = 'deceasedAge') then
        element.deceased := ParseAge(child, path+'/deceasedAge'){x.3}
      else if (child.localName = 'deceasedRange') then
        element.deceased := ParseRange(child, path+'/deceasedRange'){x.3}
      else if (child.localName = 'deceasedBoolean') then
        element.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.localName = 'deceasedDate') then
        element.deceased := ParseDate(child, path+'/deceasedDate'){x.3}
      else if (child.localName = 'deceasedString') then
        element.deceased := ParseString(child, path+'/deceasedString'){x.3}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseFamilyMemberHistoryCondition(child, path+'/condition')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistory(xml : TXmlBuilder; name : String; elem : TFhirFamilyMemberHistory);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistory);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.notDone <> false)) and doCompose('notDone') then
    ComposeBoolean(xml, 'notDone', elem.notDoneElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(xml, 'notDoneReason', elem.notDoneReason);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirAge) {6} then
    ComposeAge(xml, 'ageAge', TFhirAge(elem.age))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(elem.age))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(elem.age));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('estimatedAge') then
    ComposeBoolean(xml, 'estimatedAge', elem.estimatedAgeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirAge) {6} then
    ComposeAge(xml, 'deceasedAge', TFhirAge(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(xml, 'condition', elem.conditionList[i]);
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRXmlParser.ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
var
  child : TMXmlElement;
begin
  result := TFhirFlag.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFlagChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFlagChild(element : TFhirFlag; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFlag(xml : TXmlBuilder; name : String; elem : TFhirFlag);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFlagChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFlagChildren(xml : TXmlBuilder; elem : TFhirFlag);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
function TFHIRXmlParser.ParseGoalTarget(element : TMXmlElement; path : string) : TFhirGoalTarget;
var
  child : TMXmlElement;
begin
  result := TFhirGoalTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalTargetChild(element : TFhirGoalTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'measure') then
        element.measure := ParseCodeableConcept(child, path+'/measure') {b}
      else if (child.localName = 'detailQuantity') then
        element.detail := ParseQuantity(child, path+'/detailQuantity'){x.3}
      else if (child.localName = 'detailRange') then
        element.detail := ParseRange(child, path+'/detailRange'){x.3}
      else if (child.localName = 'detailCodeableConcept') then
        element.detail := ParseCodeableConcept(child, path+'/detailCodeableConcept'){x.3}
      else if (child.localName = 'dueDuration') then
        element.due := ParseDuration(child, path+'/dueDuration'){x.3}
      else if (child.localName = 'dueDate') then
        element.due := ParseDate(child, path+'/dueDate'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoalTarget(xml : TXmlBuilder; name : String; elem : TFhirGoalTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalTargetChildren(xml : TXmlBuilder; elem : TFhirGoalTarget);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'measure', elem.measure);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'detailQuantity', TFhirQuantity(elem.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(xml, 'detailRange', TFhirRange(elem.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'detailCodeableConcept', TFhirCodeableConcept(elem.detail));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDuration) {6} then
    ComposeDuration(xml, 'dueDuration', TFhirDuration(elem.due))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDate) {6} then
    ComposeDate(xml, 'dueDate', TFhirDate(elem.due));
end;

function TFHIRXmlParser.ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
var
  child : TMXmlElement;
begin
  result := TFhirGoal.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalChild(element : TFhirGoal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'description') then
        element.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'startCodeableConcept') then
        element.start := ParseCodeableConcept(child, path+'/startCodeableConcept'){x.3}
      else if (child.localName = 'startDate') then
        element.start := ParseDate(child, path+'/startDate'){x.3}
      else if (child.localName = 'target') then
        element.target := ParseGoalTarget(child, path+'/target') {b}
      else if (child.localName = 'statusDate') then
        element.statusDateElement := ParseDate(child, path+'/statusDate') {b}
      else if (child.localName = 'statusReason') then
        element.statusReasonElement := ParseString(child, path+'/statusReason') {b}
      else if (child.localName = 'expressedBy') then
        element.expressedBy := ParseReference{Resource}(child, path+'/expressedBy') {b}
      else if (child.localName = 'addresses') then
        element.addressesList.Add(ParseReference{Resource}(child, path+'/addresses')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'outcomeCode') then
        element.outcomeCodeList.Add(ParseCodeableConcept(child, path+'/outcomeCode')){y.2}
      else if (child.localName = 'outcomeReference') then
        element.outcomeReferenceList.Add(ParseReference{TFhirObservation}(child, path+'/outcomeReference')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoal(xml : TXmlBuilder; name : String; elem : TFhirGoal);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalChildren(xml : TXmlBuilder; elem : TFhirGoal);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  ComposeCodeableConcept(xml, 'description', elem.description);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'startCodeableConcept', TFhirCodeableConcept(elem.start))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(xml, 'startDate', TFhirDate(elem.start));
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeGoalTarget(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDate(xml, 'statusDate', elem.statusDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeString(xml, 'statusReason', elem.statusReasonElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('expressedBy') then
    ComposeReference{Resource}(xml, 'expressedBy', elem.expressedBy);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(xml, 'addresses', elem.addressesList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeCode') then
    for i := 0 to elem.outcomeCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'outcomeCode', elem.outcomeCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeReference') then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirObservation}(xml, 'outcomeReference', elem.outcomeReferenceList[i]);
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
function TFHIRXmlParser.ParseGraphDefinitionLink(element : TMXmlElement; path : string) : TFhirGraphDefinitionLink;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkChild(element : TFhirGraphDefinitionLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'sliceName') then
        element.sliceNameElement := ParseString(child, path+'/sliceName') {b}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'target') then
        element.targetList.Add(ParseGraphDefinitionLinkTarget(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLink(xml : TXmlBuilder; name : String; elem : TFhirGraphDefinitionLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLink);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'sliceName', elem.sliceNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(xml, 'target', elem.targetList[i]);
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTarget(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTarget;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetChild(element : TFhirGraphDefinitionLinkTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profileElement := ParseUri(child, path+'/profile') {b}
      else if (child.localName = 'compartment') then
        element.compartmentList.Add(ParseGraphDefinitionLinkTargetCompartment(child, path+'/compartment')){y.2}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseGraphDefinitionLink(child, path+'/link')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTarget(xml : TXmlBuilder; name : String; elem : TFhirGraphDefinitionLinkTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLinkTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'profile', elem.profileElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(xml, 'compartment', elem.compartmentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(xml, 'link', elem.link_List[i]);
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetCompartment(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTargetCompartment;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkTargetCompartmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetCompartmentChild(element : TFhirGraphDefinitionLinkTargetCompartment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'rule') then
        element.ruleElement := ParseEnum(CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum, path+'/rule', child){1a}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetCompartment(xml : TXmlBuilder; name : String; elem : TFhirGraphDefinitionLinkTargetCompartment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkTargetCompartmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetCompartmentChildren(xml : TXmlBuilder; elem : TFhirGraphDefinitionLinkTargetCompartment);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum);
  ComposeEnum(xml, 'rule', elem.RuleElement, CODES_TFhirGraphCompartmentRuleEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseGraphDefinition(element : TMXmlElement; path : string) : TFhirGraphDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionChild(element : TFhirGraphDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'start') then
        element.startElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/start', child){1a}
      else if (child.localName = 'profile') then
        element.profileElement := ParseUri(child, path+'/profile') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseGraphDefinitionLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinition(xml : TXmlBuilder; name : String; elem : TFhirGraphDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionChildren(xml : TXmlBuilder; elem : TFhirGraphDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  ComposeEnum(xml, 'start', elem.StartElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeUri(xml, 'profile', elem.profileElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(xml, 'link', elem.link_List[i]);
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
function TFHIRXmlParser.ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristicChild(element : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'exclude') then
        element.excludeElement := ParseBoolean(child, path+'/exclude') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : String; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupCharacteristicChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristicChildren(xml : TXmlBuilder; elem : TFhirGroupCharacteristic);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value));
  ComposeBoolean(xml, 'exclude', elem.excludeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
var
  child : TMXmlElement;
begin
  result := TFhirGroupMember.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupMemberChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupMemberChild(element : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entity') then
        element.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'inactive') then
        element.inactiveElement := ParseBoolean(child, path+'/inactive') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupMember(xml : TXmlBuilder; name : String; elem : TFhirGroupMember);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupMemberChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupMemberChildren(xml : TXmlBuilder; elem : TFhirGroupMember);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(xml, 'inactive', elem.inactiveElement);{x.2b}
end;

function TFHIRXmlParser.ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
var
  child : TMXmlElement;
begin
  result := TFhirGroup.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupChild(element : TFhirGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'actual') then
        element.actualElement := ParseBoolean(child, path+'/actual') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'quantity') then
        element.quantityElement := ParseUnsignedInt(child, path+'/quantity') {b}
      else if (child.localName = 'characteristic') then
        element.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic')){y.2}
      else if (child.localName = 'member') then
        element.memberList.Add(ParseGroupMember(child, path+'/member')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : String; elem : TFhirGroup);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupChildren(xml : TXmlBuilder; elem : TFhirGroup);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum);
  ComposeBoolean(xml, 'actual', elem.actualElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedInt(xml, 'quantity', elem.quantityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('member') then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(xml, 'member', elem.memberList[i]);
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
function TFHIRXmlParser.ParseGuidanceResponse(element : TMXmlElement; path : string) : TFhirGuidanceResponse;
var
  child : TMXmlElement;
begin
  result := TFhirGuidanceResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGuidanceResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGuidanceResponseChild(element : TFhirGuidanceResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'requestId') then
        element.requestIdElement := ParseId(child, path+'/requestId') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'module') then
        element.module := ParseReference{TFhirServiceDefinition}(child, path+'/module') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrenceDateTimeElement := ParseDateTime(child, path+'/occurrenceDateTime') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{TFhirDevice}(child, path+'/performer') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'evaluationMessage') then
        element.evaluationMessageList.Add(ParseReference{TFhirOperationOutcome}(child, path+'/evaluationMessage')){y.2}
      else if (child.localName = 'outputParameters') then
        element.outputParameters := ParseReference{TFhirParameters}(child, path+'/outputParameters') {b}
      else if (child.localName = 'result') then
        element.result := ParseReference{Resource}(child, path+'/result') {b}
      else if (child.localName = 'dataRequirement') then
        element.dataRequirementList.Add(ParseDataRequirement(child, path+'/dataRequirement')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGuidanceResponse(xml : TXmlBuilder; name : String; elem : TFhirGuidanceResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGuidanceResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGuidanceResponseChildren(xml : TXmlBuilder; elem : TFhirGuidanceResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestId') then
    ComposeId(xml, 'requestId', elem.requestIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeReference{TFhirServiceDefinition}(xml, 'module', elem.module);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirGuidanceResponseStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('occurrenceDateTime') then
    ComposeDateTime(xml, 'occurrenceDateTime', elem.occurrenceDateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirDevice}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('evaluationMessage') then
    for i := 0 to elem.evaluationMessageList.Count - 1 do
      ComposeReference{TFhirOperationOutcome}(xml, 'evaluationMessage', elem.evaluationMessageList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('outputParameters') then
    ComposeReference{TFhirParameters}(xml, 'outputParameters', elem.outputParameters);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    ComposeReference{Resource}(xml, 'result', elem.result);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(xml, 'dataRequirement', elem.dataRequirementList[i]);
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRXmlParser.ParseHealthcareServiceAvailableTime(element : TMXmlElement; path : string) : TFhirHealthcareServiceAvailableTime;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceAvailableTimeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceAvailableTimeChild(element : TFhirHealthcareServiceAvailableTime; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'daysOfWeek') then
        element.daysOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, path+'/daysOfWeek', child)){y.1}
      else if (child.localName = 'allDay') then
        element.allDayElement := ParseBoolean(child, path+'/allDay') {b}
      else if (child.localName = 'availableStartTime') then
        element.availableStartTimeElement := ParseTime(child, path+'/availableStartTime') {b}
      else if (child.localName = 'availableEndTime') then
        element.availableEndTimeElement := ParseTime(child, path+'/availableEndTime') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : String; elem : TFhirHealthcareServiceAvailableTime);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceAvailableTimeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceAvailableTime);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(xml, 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'allDay', elem.allDayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableStartTime', elem.availableStartTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableEndTime', elem.availableEndTimeElement);{x.2b}
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailable(element : TMXmlElement; path : string) : TFhirHealthcareServiceNotAvailable;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceNotAvailableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailableChild(element : TFhirHealthcareServiceNotAvailable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'during') then
        element.during := ParsePeriod(child, path+'/during') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : String; elem : TFhirHealthcareServiceNotAvailable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceNotAvailableChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailableChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceNotAvailable);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'during', elem.during);{x.2a}
end;

function TFHIRXmlParser.ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareService.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceChild(element : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'providedBy') then
        element.providedBy := ParseReference{TFhirOrganization}(child, path+'/providedBy') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'extraDetails') then
        element.extraDetailsElement := ParseString(child, path+'/extraDetails') {b}
      else if (child.localName = 'photo') then
        element.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'coverageArea') then
        element.coverageAreaList.Add(ParseReference{TFhirLocation}(child, path+'/coverageArea')){y.2}
      else if (child.localName = 'serviceProvisionCode') then
        element.serviceProvisionCodeList.Add(ParseCodeableConcept(child, path+'/serviceProvisionCode')){y.2}
      else if (child.localName = 'eligibility') then
        element.eligibility := ParseCodeableConcept(child, path+'/eligibility') {b}
      else if (child.localName = 'eligibilityNote') then
        element.eligibilityNoteElement := ParseString(child, path+'/eligibilityNote') {b}
      else if (child.localName = 'programName') then
        element.programNameList.Add(ParseString(child, path+'/programName')){y.2}
      else if (child.localName = 'characteristic') then
        element.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic')){y.2}
      else if (child.localName = 'referralMethod') then
        element.referralMethodList.Add(ParseCodeableConcept(child, path+'/referralMethod')){y.2}
      else if (child.localName = 'appointmentRequired') then
        element.appointmentRequiredElement := ParseBoolean(child, path+'/appointmentRequired') {b}
      else if (child.localName = 'availableTime') then
        element.availableTimeList.Add(ParseHealthcareServiceAvailableTime(child, path+'/availableTime')){y.2}
      else if (child.localName = 'notAvailable') then
        element.notAvailableList.Add(ParseHealthcareServiceNotAvailable(child, path+'/notAvailable')){y.2}
      else if (child.localName = 'availabilityExceptions') then
        element.availabilityExceptionsElement := ParseString(child, path+'/availabilityExceptions') {b}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareService(xml : TXmlBuilder; name : String; elem : TFhirHealthcareService);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceChildren(xml : TXmlBuilder; elem : TFhirHealthcareService);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(xml, 'providedBy', elem.providedBy);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeString(xml, 'extraDetails', elem.extraDetailsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'coverageArea', elem.coverageAreaList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceProvisionCode', elem.serviceProvisionCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    ComposeCodeableConcept(xml, 'eligibility', elem.eligibility);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeString(xml, 'eligibilityNote', elem.eligibilityNoteElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('programName') then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(xml, 'programName', elem.programNameList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', elem.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(xml, 'referralMethod', elem.referralMethodList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBoolean(xml, 'appointmentRequired', elem.appointmentRequiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(xml, 'availableTime', elem.availableTimeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(xml, 'notAvailable', elem.notAvailableList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(xml, 'availabilityExceptions', elem.availabilityExceptionsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
function TFHIRXmlParser.ParseImagingManifestStudy(element : TMXmlElement; path : string) : TFhirImagingManifestStudy;
var
  child : TMXmlElement;
begin
  result := TFhirImagingManifestStudy.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingManifestStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingManifestStudyChild(element : TFhirImagingManifestStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'imagingStudy') then
        element.imagingStudy := ParseReference{TFhirImagingStudy}(child, path+'/imagingStudy') {b}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if (child.localName = 'series') then
        element.seriesList.Add(ParseImagingManifestStudySeries(child, path+'/series')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudy(xml : TXmlBuilder; name : String; elem : TFhirImagingManifestStudy);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingManifestStudyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudyChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudy);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudy);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
  for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingManifestStudySeries(xml, 'series', elem.seriesList[i]);
end;

function TFHIRXmlParser.ParseImagingManifestStudySeries(element : TMXmlElement; path : string) : TFhirImagingManifestStudySeries;
var
  child : TMXmlElement;
begin
  result := TFhirImagingManifestStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingManifestStudySeriesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingManifestStudySeriesChild(element : TFhirImagingManifestStudySeries; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseImagingManifestStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudySeries(xml : TXmlBuilder; name : String; elem : TFhirImagingManifestStudySeries);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingManifestStudySeriesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudySeries);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
  for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingManifestStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
end;

function TFHIRXmlParser.ParseImagingManifestStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingManifestStudySeriesInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingManifestStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingManifestStudySeriesInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingManifestStudySeriesInstanceChild(element : TFhirImagingManifestStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sopClass') then
        element.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudySeriesInstance(xml : TXmlBuilder; name : String; elem : TFhirImagingManifestStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingManifestStudySeriesInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingManifestStudySeriesInstance);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2b}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
end;

function TFHIRXmlParser.ParseImagingManifest(element : TMXmlElement; path : string) : TFhirImagingManifest;
var
  child : TMXmlElement;
begin
  result := TFhirImagingManifest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingManifestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingManifestChild(element : TFhirImagingManifest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'authoringTime') then
        element.authoringTimeElement := ParseDateTime(child, path+'/authoringTime') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'study') then
        element.studyList.Add(ParseImagingManifestStudy(child, path+'/study')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingManifest(xml : TXmlBuilder; name : String; elem : TFhirImagingManifest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingManifestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingManifestChildren(xml : TXmlBuilder; elem : TFhirImagingManifest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTime(xml, 'authoringTime', elem.authoringTimeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingManifestStudy(xml, 'study', elem.studyList[i]);
end;

{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRXmlParser.ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesChild(element : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'number') then
        element.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.localName = 'modality') then
        element.modality := ParseCoding(child, path+'/modality') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'numberOfInstances') then
        element.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.localName = 'availability') then
        element.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.localName = 'laterality') then
        element.laterality := ParseCoding(child, path+'/laterality') {b}
      else if (child.localName = 'started') then
        element.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseReference{TFhirPractitioner}(child, path+'/performer')){y.2}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : String; elem : TFhirImagingStudySeries);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2b}
  ComposeCoding(xml, 'modality', elem.modality);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'laterality', elem.laterality);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstanceChild(element : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'number') then
        element.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.localName = 'sopClass') then
        element.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : String; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeriesInstance);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2b}
  ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
end;

function TFHIRXmlParser.ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudyChild(element : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'accession') then
        element.accession := ParseIdentifier(child, path+'/accession') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'availability') then
        element.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.localName = 'modalityList') then
        element.modalityListList.Add(ParseCoding(child, path+'/modalityList')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'started') then
        element.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'referrer') then
        element.referrer := ParseReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.localName = 'interpreter') then
        element.interpreterList.Add(ParseReference{TFhirPractitioner}(child, path+'/interpreter')){y.2}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if (child.localName = 'numberOfSeries') then
        element.numberOfSeriesElement := ParseUnsignedInt(child, path+'/numberOfSeries') {b}
      else if (child.localName = 'numberOfInstances') then
        element.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.localName = 'procedureReference') then
        element.procedureReferenceList.Add(ParseReference{TFhirProcedure}(child, path+'/procedureReference')){y.2}
      else if (child.localName = 'procedureCode') then
        element.procedureCodeList.Add(ParseCodeableConcept(child, path+'/procedureCode')){y.2}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'series') then
        element.seriesList.Add(ParseImagingStudySeries(child, path+'/series')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : String; elem : TFhirImagingStudy);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudyChildren(xml : TXmlBuilder; elem : TFhirImagingStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accession') then
    ComposeIdentifier(xml, 'accession', elem.accession);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modalityList') then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(xml, 'modalityList', elem.modalityListList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    for i := 0 to elem.interpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSeries') then
    ComposeUnsignedInt(xml, 'numberOfSeries', elem.numberOfSeriesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfInstances') then
    ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureReference') then
    for i := 0 to elem.procedureReferenceList.Count - 1 do
      ComposeReference{TFhirProcedure}(xml, 'procedureReference', elem.procedureReferenceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureCode') then
    for i := 0 to elem.procedureCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'procedureCode', elem.procedureCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRXmlParser.ParseImmunizationPractitioner(element : TMXmlElement; path : string) : TFhirImmunizationPractitioner;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationPractitioner.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationPractitionerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationPractitionerChild(element : TFhirImmunizationPractitioner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{TFhirPractitioner}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationPractitioner(xml : TXmlBuilder; name : String; elem : TFhirImmunizationPractitioner);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationPractitionerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationPractitionerChildren(xml : TXmlBuilder; elem : TFhirImmunizationPractitioner);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{TFhirPractitioner}(xml, 'actor', elem.actor);{x.2a}
end;

function TFHIRXmlParser.ParseImmunizationExplanation(element : TMXmlElement; path : string) : TFhirImmunizationExplanation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationExplanationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationExplanationChild(element : TFhirImmunizationExplanation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'reasonNotGiven') then
        element.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationExplanation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationExplanationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanationChildren(xml : TXmlBuilder; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationReactionChild(element : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'detail') then
        element.detail := ParseReference{TFhirObservation}(child, path+'/detail') {b}
      else if (child.localName = 'reported') then
        element.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : String; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationReactionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReactionChildren(xml : TXmlBuilder; elem : TFhirImmunizationReaction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(xml, 'detail', elem.detail);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationVaccinationProtocolChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocolChild(element : TFhirImmunizationVaccinationProtocol; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'doseSequence') then
        element.doseSequenceElement := ParsePositiveInt(child, path+'/doseSequence') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'authority') then
        element.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.localName = 'series') then
        element.seriesElement := ParseString(child, path+'/series') {b}
      else if (child.localName = 'seriesDoses') then
        element.seriesDosesElement := ParsePositiveInt(child, path+'/seriesDoses') {b}
      else if (child.localName = 'targetDisease') then
        element.targetDiseaseList.Add(ParseCodeableConcept(child, path+'/targetDisease')){y.2}
      else if (child.localName = 'doseStatus') then
        element.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.localName = 'doseStatusReason') then
        element.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : String; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationVaccinationProtocolChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationVaccinationProtocol);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'doseSequence', elem.doseSequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'seriesDoses', elem.seriesDosesElement);{x.2b}
  for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(xml, 'targetDisease', elem.targetDiseaseList[i]);
  ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);{x.2a}
end;

function TFHIRXmlParser.ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
var
  child : TMXmlElement;
begin
  result := TFhirImmunization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationChild(element : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'notGiven') then
        element.notGivenElement := ParseBoolean(child, path+'/notGiven') {b}
      else if (child.localName = 'vaccineCode') then
        element.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'primarySource') then
        element.primarySourceElement := ParseBoolean(child, path+'/primarySource') {b}
      else if (child.localName = 'reportOrigin') then
        element.reportOrigin := ParseCodeableConcept(child, path+'/reportOrigin') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'manufacturer') then
        element.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'expirationDate') then
        element.expirationDateElement := ParseDate(child, path+'/expirationDate') {b}
      else if (child.localName = 'site') then
        element.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'doseQuantity') then
        element.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.localName = 'practitioner') then
        element.practitionerList.Add(ParseImmunizationPractitioner(child, path+'/practitioner')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'explanation') then
        element.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.localName = 'reaction') then
        element.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction')){y.2}
      else if (child.localName = 'vaccinationProtocol') then
        element.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : String; elem : TFhirImmunization);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationChildren(xml : TXmlBuilder; elem : TFhirImmunization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirImmunizationStatusEnum);
  ComposeBoolean(xml, 'notGiven', elem.notGivenElement);{x.2b}
  ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeBoolean(xml, 'primarySource', elem.primarySourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reportOrigin') then
    ComposeCodeableConcept(xml, 'reportOrigin', elem.reportOrigin);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDate(xml, 'expirationDate', elem.expirationDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(xml, 'site', elem.site);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    for i := 0 to elem.practitionerList.Count - 1 do
      ComposeImmunizationPractitioner(xml, 'practitioner', elem.practitionerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('explanation') then
    ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('vaccinationProtocol') then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationChild(element : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'vaccineCode') then
        element.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.localName = 'targetDisease') then
        element.targetDisease := ParseCodeableConcept(child, path+'/targetDisease') {b}
      else if (child.localName = 'doseNumber') then
        element.doseNumberElement := ParsePositiveInt(child, path+'/doseNumber') {b}
      else if (child.localName = 'forecastStatus') then
        element.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.localName = 'dateCriterion') then
        element.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion')){y.2}
      else if (child.localName = 'protocol') then
        element.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.localName = 'supportingImmunization') then
        element.supportingImmunizationList.Add(ParseReference{TFhirImmunization}(child, path+'/supportingImmunization')){y.2}
      else if (child.localName = 'supportingPatientInformation') then
        element.supportingPatientInformationList.Add(ParseReference{Resource}(child, path+'/supportingPatientInformation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'targetDisease', elem.targetDisease);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'doseNumber', elem.doseNumberElement);{x.2b}
  ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationDateCriterionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterionChild(element : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationDateCriterionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeDateTime(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationProtocolChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocolChild(element : TFhirImmunizationRecommendationRecommendationProtocol; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'doseSequence') then
        element.doseSequenceElement := ParsePositiveInt(child, path+'/doseSequence') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'authority') then
        element.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.localName = 'series') then
        element.seriesElement := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationProtocolChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'doseSequence', elem.doseSequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationChild(element : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'recommendation') then
        element.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRXmlParser.ParseImplementationGuideDependency(element : TMXmlElement; path : string) : TFhirImplementationGuideDependency;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDependencyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDependencyChild(element : TFhirImplementationGuideDependency; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependency(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuideDependency);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDependencyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependencyChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideDependency);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum);
  ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
end;

function TFHIRXmlParser.ParseImplementationGuidePackage(element : TMXmlElement; path : string) : TFhirImplementationGuidePackage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePackageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePackageChild(element : TFhirImplementationGuidePackage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'resource') then
        element.resourceList.Add(ParseImplementationGuidePackageResource(child, path+'/resource')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackage(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePackage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePackageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(xml, 'resource', elem.resourceList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuidePackageResource(element : TMXmlElement; path : string) : TFhirImplementationGuidePackageResource;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePackageResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePackageResourceChild(element : TFhirImplementationGuidePackageResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'example') then
        element.exampleElement := ParseBoolean(child, path+'/example') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'acronym') then
        element.acronymElement := ParseString(child, path+'/acronym') {b}
      else if (child.localName = 'sourceReference') then
        element.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.localName = 'sourceUri') then
        element.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.localName = 'exampleFor') then
        element.exampleFor := ParseReference{TFhirStructureDefinition}(child, path+'/exampleFor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePackageResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePackageResourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageResourceChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackageResource);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'example', elem.exampleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'acronym', elem.acronymElement);{x.2b}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source))
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'exampleFor', elem.exampleFor);{x.2a}
end;

function TFHIRXmlParser.ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideGlobalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideGlobalChild(element : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuideGlobal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideGlobalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideGlobal);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseImplementationGuidePage(element : TMXmlElement; path : string) : TFhirImplementationGuidePage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePageChild(element : TFhirImplementationGuidePage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'type') then
        element.type_.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child)){y.1}
      else if (child.localName = 'package') then
        element.packageList.Add(ParseString(child, path+'/package')){y.2}
      else if (child.localName = 'format') then
        element.formatElement := ParseCode(child, path+'/format') {b}
      else if (child.localName = 'page') then
        element.pageList.Add(ParseImplementationGuidePage(child, path+'/page')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePage(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
  ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(xml, 'type', elem.type_[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(xml, 'package', elem.packageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'format', elem.formatElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(xml, 'page', elem.pageList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuide.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideChild(element : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'dependency') then
        element.dependencyList.Add(ParseImplementationGuideDependency(child, path+'/dependency')){y.2}
      else if (child.localName = 'package') then
        element.packageList.Add(ParseImplementationGuidePackage(child, path+'/package')){y.2}
      else if (child.localName = 'global') then
        element.globalList.Add(ParseImplementationGuideGlobal(child, path+'/global')){y.2}
      else if (child.localName = 'binary') then
        element.binaryList.Add(ParseUri(child, path+'/binary')){y.2}
      else if (child.localName = 'page') then
        element.page := ParseImplementationGuidePage(child, path+'/page') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuide(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuide);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideChildren(xml : TXmlBuilder; elem : TFhirImplementationGuide);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependency') then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(xml, 'dependency', elem.dependencyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('package') then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(xml, 'package', elem.packageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(xml, 'global', elem.globalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('binary') then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(xml, 'binary', elem.binaryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('page') then
    ComposeImplementationGuidePage(xml, 'page', elem.page);{x.2a}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
function TFHIRXmlParser.ParseLibrary(element : TMXmlElement; path : string) : TFhirLibrary;
var
  child : TMXmlElement;
begin
  result := TFhirLibrary.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLibraryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLibraryChild(element : TFhirLibrary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseCodeableConcept(child, path+'/topic')){y.2}
      else if (child.localName = 'contributor') then
        element.contributorList.Add(ParseContributor(child, path+'/contributor')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseParameterDefinition(child, path+'/parameter')){y.2}
      else if (child.localName = 'dataRequirement') then
        element.dataRequirementList.Add(ParseDataRequirement(child, path+'/dataRequirement')){y.2}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseAttachment(child, path+'/content')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLibrary(xml : TXmlBuilder; name : String; elem : TFhirLibrary);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLibraryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLibraryChildren(xml : TXmlBuilder; elem : TFhirLibrary);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(xml, 'contributor', elem.contributorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParameterDefinition(xml, 'parameter', elem.parameterList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(xml, 'dataRequirement', elem.dataRequirementList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('content') then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(xml, 'content', elem.contentList[i]);
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
function TFHIRXmlParser.ParseLinkageItem(element : TMXmlElement; path : string) : TFhirLinkageItem;
var
  child : TMXmlElement;
begin
  result := TFhirLinkageItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLinkageItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLinkageItemChild(element : TFhirLinkageItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'resource') then
        element.resource := ParseReference(child, path+'/resource') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLinkageItem(xml : TXmlBuilder; name : String; elem : TFhirLinkageItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLinkageItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLinkageItemChildren(xml : TXmlBuilder; elem : TFhirLinkageItem);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirLinkageTypeEnum);
  ComposeReference(xml, 'resource', elem.resource);{x.2a}
end;

function TFHIRXmlParser.ParseLinkage(element : TMXmlElement; path : string) : TFhirLinkage;
var
  child : TMXmlElement;
begin
  result := TFhirLinkage.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLinkageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLinkageChild(element : TFhirLinkage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseLinkageItem(child, path+'/item')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLinkage(xml : TXmlBuilder; name : String; elem : TFhirLinkage);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLinkageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLinkageChildren(xml : TXmlBuilder; elem : TFhirLinkage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  for i := 0 to elem.itemList.Count - 1 do
      ComposeLinkageItem(xml, 'item', elem.itemList[i]);
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
function TFHIRXmlParser.ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
var
  child : TMXmlElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListEntryChild(element : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'flag') then
        element.flag := ParseCodeableConcept(child, path+'/flag') {b}
      else if (child.localName = 'deleted') then
        element.deletedElement := ParseBoolean(child, path+'/deleted') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'item') then
        element.item := ParseReference{TFhirReference}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : String; elem : TFhirListEntry);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListEntryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListEntryChildren(xml : TXmlBuilder; elem : TFhirListEntry);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'flag', elem.flag);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBoolean(xml, 'deleted', elem.deletedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeReference{TFhirReference}(xml, 'item', elem.item);{x.2a}
end;

function TFHIRXmlParser.ParseList(element : TMXmlElement; path : string) : TFhirList;
var
  child : TMXmlElement;
begin
  result := TFhirList.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListChild(element : TFhirList; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'orderedBy') then
        element.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseListEntry(child, path+'/entry')){y.2}
      else if (child.localName = 'emptyReason') then
        element.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : String; elem : TFhirList);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListChildren(xml : TXmlBuilder; elem : TFhirList);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirListStatusEnum);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('entry') then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2a}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRXmlParser.ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
var
  child : TMXmlElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationPositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationPositionChild(element : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'longitude') then
        element.longitudeElement := ParseDecimal(child, path+'/longitude') {b}
      else if (child.localName = 'latitude') then
        element.latitudeElement := ParseDecimal(child, path+'/latitude') {b}
      else if (child.localName = 'altitude') then
        element.altitudeElement := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : String; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationPositionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationPositionChildren(xml : TXmlBuilder; elem : TFhirLocationPosition);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeDecimal(xml, 'longitude', elem.longitudeElement);{x.2b}
  ComposeDecimal(xml, 'latitude', elem.latitudeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'altitude', elem.altitudeElement);{x.2b}
end;

function TFHIRXmlParser.ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
var
  child : TMXmlElement;
begin
  result := TFhirLocation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationChild(element : TFhirLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'operationalStatus') then
        element.operationalStatus := ParseCoding(child, path+'/operationalStatus') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'alias') then
        element.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if (child.localName = 'physicalType') then
        element.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.localName = 'position') then
        element.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirLocation}(child, path+'/partOf') {b}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : String; elem : TFhirLocation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationChildren(xml : TXmlBuilder; elem : TFhirLocation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeCoding(xml, 'operationalStatus', elem.operationalStatus);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(xml, 'alias', elem.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(xml, 'position', elem.position);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(xml, 'partOf', elem.partOf);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
function TFHIRXmlParser.ParseMeasureGroup(element : TMXmlElement; path : string) : TFhirMeasureGroup;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupChild(element : TFhirMeasureGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'population') then
        element.populationList.Add(ParseMeasureGroupPopulation(child, path+'/population')){y.2}
      else if (child.localName = 'stratifier') then
        element.stratifierList.Add(ParseMeasureGroupStratifier(child, path+'/stratifier')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroup(xml : TXmlBuilder; name : String; elem : TFhirMeasureGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupChildren(xml : TXmlBuilder; elem : TFhirMeasureGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(xml, 'population', elem.populationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(xml, 'stratifier', elem.stratifierList[i]);
end;

function TFHIRXmlParser.ParseMeasureGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureGroupPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupPopulationChild(element : TFhirMeasureGroupPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'criteria') then
        element.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupPopulation(xml : TXmlBuilder; name : String; elem : TFhirMeasureGroupPopulation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupPopulationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureGroupPopulation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeString(xml, 'criteria', elem.criteriaElement);{x.2b}
end;

function TFHIRXmlParser.ParseMeasureGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifier;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupStratifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupStratifierChild(element : TFhirMeasureGroupStratifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'criteria') then
        element.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifier(xml : TXmlBuilder; name : String; elem : TFhirMeasureGroupStratifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupStratifierChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifierChildren(xml : TXmlBuilder; elem : TFhirMeasureGroupStratifier);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'criteria', elem.criteriaElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
end;

function TFHIRXmlParser.ParseMeasureSupplementalData(element : TMXmlElement; path : string) : TFhirMeasureSupplementalData;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureSupplementalDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureSupplementalDataChild(element : TFhirMeasureSupplementalData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'usage') then
        element.usageList.Add(ParseCodeableConcept(child, path+'/usage')){y.2}
      else if (child.localName = 'criteria') then
        element.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureSupplementalData(xml : TXmlBuilder; name : String; elem : TFhirMeasureSupplementalData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureSupplementalDataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureSupplementalDataChildren(xml : TXmlBuilder; elem : TFhirMeasureSupplementalData);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usageList.Count - 1 do
      ComposeCodeableConcept(xml, 'usage', elem.usageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'criteria', elem.criteriaElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
end;

function TFHIRXmlParser.ParseMeasure(element : TMXmlElement; path : string) : TFhirMeasure;
var
  child : TMXmlElement;
begin
  result := TFhirMeasure.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureChild(element : TFhirMeasure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseCodeableConcept(child, path+'/topic')){y.2}
      else if (child.localName = 'contributor') then
        element.contributorList.Add(ParseContributor(child, path+'/contributor')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'library') then
        element.library_List.Add(ParseReference{TFhirLibrary}(child, path+'/library')){y.2}
      else if (child.localName = 'disclaimer') then
        element.disclaimerElement := ParseMarkdown(child, path+'/disclaimer') {b}
      else if (child.localName = 'scoring') then
        element.scoring := ParseCodeableConcept(child, path+'/scoring') {b}
      else if (child.localName = 'compositeScoring') then
        element.compositeScoring := ParseCodeableConcept(child, path+'/compositeScoring') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'riskAdjustment') then
        element.riskAdjustmentElement := ParseString(child, path+'/riskAdjustment') {b}
      else if (child.localName = 'rateAggregation') then
        element.rateAggregationElement := ParseString(child, path+'/rateAggregation') {b}
      else if (child.localName = 'rationale') then
        element.rationaleElement := ParseMarkdown(child, path+'/rationale') {b}
      else if (child.localName = 'clinicalRecommendationStatement') then
        element.clinicalRecommendationStatementElement := ParseMarkdown(child, path+'/clinicalRecommendationStatement') {b}
      else if (child.localName = 'improvementNotation') then
        element.improvementNotationElement := ParseString(child, path+'/improvementNotation') {b}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseMarkdown(child, path+'/definition')){y.2}
      else if (child.localName = 'guidance') then
        element.guidanceElement := ParseMarkdown(child, path+'/guidance') {b}
      else if (child.localName = 'set') then
        element.set_Element := ParseString(child, path+'/set') {b}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseMeasureGroup(child, path+'/group')){y.2}
      else if (child.localName = 'supplementalData') then
        element.supplementalDataList.Add(ParseMeasureSupplementalData(child, path+'/supplementalData')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasure(xml : TXmlBuilder; name : String; elem : TFhirMeasure);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureChildren(xml : TXmlBuilder; elem : TFhirMeasure);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(xml, 'contributor', elem.contributorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(xml, 'library', elem.library_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disclaimer') then
    ComposeMarkdown(xml, 'disclaimer', elem.disclaimerElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('scoring') then
    ComposeCodeableConcept(xml, 'scoring', elem.scoring);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositeScoring') then
    ComposeCodeableConcept(xml, 'compositeScoring', elem.compositeScoring);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskAdjustment') then
    ComposeString(xml, 'riskAdjustment', elem.riskAdjustmentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rateAggregation') then
    ComposeString(xml, 'rateAggregation', elem.rateAggregationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rationale') then
    ComposeMarkdown(xml, 'rationale', elem.rationaleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalRecommendationStatement') then
    ComposeMarkdown(xml, 'clinicalRecommendationStatement', elem.clinicalRecommendationStatementElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeString(xml, 'improvementNotation', elem.improvementNotationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeMarkdown(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('guidance') then
    ComposeMarkdown(xml, 'guidance', elem.guidanceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('set_') then
    ComposeString(xml, 'set', elem.set_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureGroup(xml, 'group', elem.groupList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supplementalData') then
    for i := 0 to elem.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(xml, 'supplementalData', elem.supplementalDataList[i]);
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
function TFHIRXmlParser.ParseMeasureReportGroup(element : TMXmlElement; path : string) : TFhirMeasureReportGroup;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupChild(element : TFhirMeasureReportGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'population') then
        element.populationList.Add(ParseMeasureReportGroupPopulation(child, path+'/population')){y.2}
      else if (child.localName = 'measureScore') then
        element.measureScoreElement := ParseDecimal(child, path+'/measureScore') {b}
      else if (child.localName = 'stratifier') then
        element.stratifierList.Add(ParseMeasureReportGroupStratifier(child, path+'/stratifier')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroup(xml : TXmlBuilder; name : String; elem : TFhirMeasureReportGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(xml, 'population', elem.populationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'measureScore', elem.measureScoreElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(xml, 'stratifier', elem.stratifierList[i]);
end;

function TFHIRXmlParser.ParseMeasureReportGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupPopulationChild(element : TFhirMeasureReportGroupPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'count') then
        element.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.localName = 'patients') then
        element.patients := ParseReference{TFhirList}(child, path+'/patients') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupPopulation(xml : TXmlBuilder; name : String; elem : TFhirMeasureReportGroupPopulation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupPopulationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupPopulation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', elem.countElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(xml, 'patients', elem.patients);{x.2a}
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifier;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierChild(element : TFhirMeasureReportGroupStratifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'stratum') then
        element.stratumList.Add(ParseMeasureReportGroupStratifierStratum(child, path+'/stratum')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifier(xml : TXmlBuilder; name : String; elem : TFhirMeasureReportGroupStratifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifier);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(xml, 'stratum', elem.stratumList[i]);
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratum(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratum;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierStratumChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumChild(element : TFhirMeasureReportGroupStratifierStratum; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'population') then
        element.populationList.Add(ParseMeasureReportGroupStratifierStratumPopulation(child, path+'/population')){y.2}
      else if (child.localName = 'measureScore') then
        element.measureScoreElement := ParseDecimal(child, path+'/measureScore') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratum(xml : TXmlBuilder; name : String; elem : TFhirMeasureReportGroupStratifierStratum);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierStratumChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifierStratum);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(xml, 'population', elem.populationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'measureScore', elem.measureScoreElement);{x.2b}
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierStratumPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumPopulationChild(element : TFhirMeasureReportGroupStratifierStratumPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'count') then
        element.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.localName = 'patients') then
        element.patients := ParseReference{TFhirList}(child, path+'/patients') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumPopulation(xml : TXmlBuilder; name : String; elem : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierStratumPopulationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumPopulationChildren(xml : TXmlBuilder; elem : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', elem.countElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(xml, 'patients', elem.patients);{x.2a}
end;

function TFHIRXmlParser.ParseMeasureReport(element : TMXmlElement; path : string) : TFhirMeasureReport;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportChild(element : TFhirMeasureReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'measure') then
        element.measure := ParseReference{TFhirMeasure}(child, path+'/measure') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'reportingOrganization') then
        element.reportingOrganization := ParseReference{TFhirOrganization}(child, path+'/reportingOrganization') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseMeasureReportGroup(child, path+'/group')){y.2}
      else if (child.localName = 'evaluatedResources') then
        element.evaluatedResources := ParseReference{TFhirBundle}(child, path+'/evaluatedResources') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReport(xml : TXmlBuilder; name : String; elem : TFhirMeasureReport);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportChildren(xml : TXmlBuilder; elem : TFhirMeasureReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMeasureReportStatusEnum);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirMeasureReportTypeEnum);
  ComposeReference{TFhirMeasure}(xml, 'measure', elem.measure);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reportingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'reportingOrganization', elem.reportingOrganization);{x.2a}
  ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureReportGroup(xml, 'group', elem.groupList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('evaluatedResources') then
    ComposeReference{TFhirBundle}(xml, 'evaluatedResources', elem.evaluatedResources);{x.2a}
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
function TFHIRXmlParser.ParseMedia(element : TMXmlElement; path : string) : TFhirMedia;
var
  child : TMXmlElement;
begin
  result := TFhirMedia.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMediaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMediaChild(element : TFhirMedia; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirProcedureRequest}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'subtype') then
        element.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.localName = 'view') then
        element.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'operator') then
        element.operator := ParseReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{Resource}(child, path+'/device') {b}
      else if (child.localName = 'height') then
        element.heightElement := ParsePositiveInt(child, path+'/height') {b}
      else if (child.localName = 'width') then
        element.widthElement := ParsePositiveInt(child, path+'/width') {b}
      else if (child.localName = 'frames') then
        element.framesElement := ParsePositiveInt(child, path+'/frames') {b}
      else if (child.localName = 'duration') then
        element.durationElement := ParseUnsignedInt(child, path+'/duration') {b}
      else if (child.localName = 'content') then
        element.content := ParseAttachment(child, path+'/content') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : String; elem : TFhirMedia);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMediaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMediaChildren(xml : TXmlBuilder; elem : TFhirMedia);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirProcedureRequest}(xml, 'basedOn', elem.basedOnList[i]);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    ComposeCodeableConcept(xml, 'subtype', elem.subtype);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(xml, 'view', elem.view);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(xml, 'operator', elem.operator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{Resource}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveInt(xml, 'height', elem.heightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveInt(xml, 'width', elem.widthElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveInt(xml, 'frames', elem.framesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedInt(xml, 'duration', elem.durationElement);{x.2b}
  ComposeAttachment(xml, 'content', elem.content);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
function TFHIRXmlParser.ParseMedicationIngredient(element : TMXmlElement; path : string) : TFhirMedicationIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationIngredientChild(element : TFhirMedicationIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemCodeableConcept') then
        element.item := ParseCodeableConcept(child, path+'/itemCodeableConcept'){x.3}
      else if (child.localName = 'itemReference') then
        element.item := ParseReference(child, path+'/itemReference') {a}
      else if (child.localName = 'isActive') then
        element.isActiveElement := ParseBoolean(child, path+'/isActive') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationIngredient(xml : TXmlBuilder; name : String; elem : TFhirMedicationIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationIngredientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationIngredientChildren(xml : TXmlBuilder; elem : TFhirMedicationIngredient);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(elem.item))
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(elem.item));
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isActive', elem.isActiveElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationPackage(element : TMXmlElement; path : string) : TFhirMedicationPackage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationPackageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationPackageChild(element : TFhirMedicationPackage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'container') then
        element.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseMedicationPackageContent(child, path+'/content')){y.2}
      else if (child.localName = 'batch') then
        element.batchList.Add(ParseMedicationPackageBatch(child, path+'/batch')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : String; elem : TFhirMedicationPackage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationPackageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageChildren(xml : TXmlBuilder; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'container', elem.container);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationPackageBatch(xml, 'batch', elem.batchList[i]);
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : TMXmlElement; path : string) : TFhirMedicationPackageContent;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationPackageContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationPackageContentChild(element : TFhirMedicationPackageContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemCodeableConcept') then
        element.item := ParseCodeableConcept(child, path+'/itemCodeableConcept'){x.3}
      else if (child.localName = 'itemReference') then
        element.item := ParseReference(child, path+'/itemReference') {a}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : String; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationPackageContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContentChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageContent);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(elem.item))
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(elem.item));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationPackageBatch(element : TMXmlElement; path : string) : TFhirMedicationPackageBatch;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationPackageBatch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationPackageBatchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationPackageBatchChild(element : TFhirMedicationPackageBatch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'expirationDate') then
        element.expirationDateElement := ParseDateTime(child, path+'/expirationDate') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageBatch(xml : TXmlBuilder; name : String; elem : TFhirMedicationPackageBatch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationPackageBatchChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageBatchChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageBatch);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', elem.expirationDateElement);{x.2b}
end;

function TFHIRXmlParser.ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
var
  child : TMXmlElement;
begin
  result := TFhirMedication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationChild(element : TFhirMedication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'isBrand') then
        element.isBrandElement := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.localName = 'isOverTheCounter') then
        element.isOverTheCounterElement := ParseBoolean(child, path+'/isOverTheCounter') {b}
      else if (child.localName = 'manufacturer') then
        element.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'ingredient') then
        element.ingredientList.Add(ParseMedicationIngredient(child, path+'/ingredient')){y.2}
      else if (child.localName = 'package') then
        element.package := ParseMedicationPackage(child, path+'/package') {b}
      else if (child.localName = 'image') then
        element.imageList.Add(ParseAttachment(child, path+'/image')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : String; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationChildren(xml : TXmlBuilder; elem : TFhirMedication);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBoolean(xml, 'isBrand', elem.isBrandElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isOverTheCounter') then
    ComposeBoolean(xml, 'isOverTheCounter', elem.isOverTheCounterElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationIngredient(xml, 'ingredient', elem.ingredientList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('package') then
    ComposeMedicationPackage(xml, 'package', elem.package);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(xml, 'image', elem.imageList[i]);
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRXmlParser.ParseMedicationAdministrationPerformer(element : TMXmlElement; path : string) : TFhirMedicationAdministrationPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationPerformerChild(element : TFhirMedicationAdministrationPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationPerformer(xml : TXmlBuilder; name : String; elem : TFhirMedicationAdministrationPerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationPerformerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationPerformerChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationPerformer);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosageChild(element : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'site') then
        element.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'dose') then
        element.dose := ParseQuantity(child, path+'/dose') {b}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateQuantity') then
        element.rate := ParseQuantity(child, path+'/rateQuantity'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : String; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationDosageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationDosage);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'site', elem.site);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dose', elem.dose);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(elem.rate));
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationChild(element : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{Resource}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseMedicationAdministrationPerformer(child, path+'/performer')){y.2}
      else if (child.localName = 'notGiven') then
        element.notGivenElement := ParseBoolean(child, path+'/notGiven') {b}
      else if (child.localName = 'reasonNotGiven') then
        element.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'prescription') then
        element.prescription := ParseReference{TFhirMedicationRequest}(child, path+'/prescription') {b}
      else if (child.localName = 'device') then
        element.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'dosage') then
        element.dosage := ParseMedicationAdministrationDosage(child, path+'/dosage') {b}
      else if (child.localName = 'eventHistory') then
        element.eventHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/eventHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : String; elem : TFhirMedicationAdministration);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notGiven') then
    ComposeBoolean(xml, 'notGiven', elem.notGivenElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotGiven') then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationRequest}(xml, 'prescription', elem.prescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosage);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'eventHistory', elem.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRXmlParser.ParseMedicationDispensePerformer(element : TMXmlElement; path : string) : TFhirMedicationDispensePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispensePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispensePerformerChild(element : TFhirMedicationDispensePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispensePerformer(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispensePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispensePerformerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispensePerformerChildren(xml : TXmlBuilder; elem : TFhirMedicationDispensePerformer);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitutionChild(element : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'wasSubstituted') then
        element.wasSubstitutedElement := ParseBoolean(child, path+'/wasSubstituted') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'responsibleParty') then
        element.responsiblePartyList.Add(ParseReference{TFhirPractitioner}(child, path+'/responsibleParty')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispenseSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseSubstitutionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'wasSubstituted', elem.wasSubstitutedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
end;

function TFHIRXmlParser.ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseChild(element : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirProcedure}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseMedicationDispensePerformer(child, path+'/performer')){y.2}
      else if (child.localName = 'authorizingPrescription') then
        element.authorizingPrescriptionList.Add(ParseReference{TFhirMedicationRequest}(child, path+'/authorizingPrescription')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'daysSupply') then
        element.daysSupply := ParseQuantity(child, path+'/daysSupply') {b}
      else if (child.localName = 'whenPrepared') then
        element.whenPreparedElement := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.localName = 'whenHandedOver') then
        element.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'receiver') then
        element.receiverList.Add(ParseReference{Resource}(child, path+'/receiver')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'dosageInstruction') then
        element.dosageInstructionList.Add(ParseDosage(child, path+'/dosageInstruction')){y.2}
      else if (child.localName = 'substitution') then
        element.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if (child.localName = 'detectedIssue') then
        element.detectedIssueList.Add(ParseReference{TFhirDetectedIssue}(child, path+'/detectedIssue')){y.2}
      else if (child.localName = 'notDone') then
        element.notDoneElement := ParseBoolean(child, path+'/notDone') {b}
      else if (child.localName = 'notDoneReasonCodeableConcept') then
        element.notDoneReason := ParseCodeableConcept(child, path+'/notDoneReasonCodeableConcept'){x.3}
      else if (child.localName = 'notDoneReasonReference') then
        element.notDoneReason := ParseReference(child, path+'/notDoneReasonReference') {a}
      else if (child.localName = 'eventHistory') then
        element.eventHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/eventHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispense);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseChildren(xml : TXmlBuilder; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(xml, 'partOf', elem.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('authorizingPrescription') then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('daysSupply') then
    ComposeQuantity(xml, 'daysSupply', elem.daysSupply);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTime(xml, 'whenPrepared', elem.whenPreparedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('whenHandedOver') then
    ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(xml, 'detectedIssue', elem.detectedIssueList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('notDone') then
    ComposeBoolean(xml, 'notDone', elem.notDoneElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.notDoneReason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'notDoneReasonCodeableConcept', TFhirCodeableConcept(elem.notDoneReason))
  else if (SummaryOption in [soFull, soData]) and (elem.notDoneReason is TFhirReference) {2} then
    ComposeReference(xml, 'notDoneReasonReference', TFhirReference(elem.notDoneReason));
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'eventHistory', elem.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
function TFHIRXmlParser.ParseMedicationRequestRequester(element : TMXmlElement; path : string) : TFhirMedicationRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestRequesterChild(element : TFhirMedicationRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirMedicationRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequest;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestDispenseRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequestChild(element : TFhirMedicationRequestDispenseRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'validityPeriod') then
        element.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.localName = 'numberOfRepeatsAllowed') then
        element.numberOfRepeatsAllowedElement := ParsePositiveInt(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'expectedSupplyDuration') then
        element.expectedSupplyDuration := ParseDuration(child, path+'/expectedSupplyDuration') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{TFhirOrganization}(child, path+'/performer') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequest(xml : TXmlBuilder; name : String; elem : TFhirMedicationRequestDispenseRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestDispenseRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestDispenseRequest);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'performer', elem.performer);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationRequestSubstitution(element : TMXmlElement; path : string) : TFhirMedicationRequestSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestSubstitutionChild(element : TFhirMedicationRequestSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'allowed') then
        element.allowedElement := ParseBoolean(child, path+'/allowed') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestSubstitution(xml : TXmlBuilder; name : String; elem : TFhirMedicationRequestSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestSubstitutionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationRequestSubstitution);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'allowed', elem.allowedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationRequest(element : TMXmlElement; path : string) : TFhirMedicationRequest;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestChild(element : TFhirMedicationRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationRequestStatusEnum, SYSTEMS_TFhirMedicationRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirMedicationRequestPriorityEnum, SYSTEMS_TFhirMedicationRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseMedicationRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'recorder') then
        element.recorder := ParseReference{TFhirPractitioner}(child, path+'/recorder') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'dosageInstruction') then
        element.dosageInstructionList.Add(ParseDosage(child, path+'/dosageInstruction')){y.2}
      else if (child.localName = 'dispenseRequest') then
        element.dispenseRequest := ParseMedicationRequestDispenseRequest(child, path+'/dispenseRequest') {b}
      else if (child.localName = 'substitution') then
        element.substitution := ParseMedicationRequestSubstitution(child, path+'/substitution') {b}
      else if (child.localName = 'priorPrescription') then
        element.priorPrescription := ParseReference{TFhirMedicationRequest}(child, path+'/priorPrescription') {b}
      else if (child.localName = 'detectedIssue') then
        element.detectedIssueList.Add(ParseReference{TFhirDetectedIssue}(child, path+'/detectedIssue')){y.2}
      else if (child.localName = 'eventHistory') then
        element.eventHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/eventHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequest(xml : TXmlBuilder; name : String; elem : TFhirMedicationRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationRequestStatusEnum);
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirMedicationRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirMedicationRequestPriorityEnum);
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeMedicationRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(xml, 'recorder', elem.recorder);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationRequestDispenseRequest(xml, 'dispenseRequest', elem.dispenseRequest);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationRequestSubstitution(xml, 'substitution', elem.substitution);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationRequest}(xml, 'priorPrescription', elem.priorPrescription);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(xml, 'detectedIssue', elem.detectedIssueList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'eventHistory', elem.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
function TFHIRXmlParser.ParseMedicationStatement(element : TMXmlElement; path : string) : TFhirMedicationStatement;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationStatementChild(element : TFhirMedicationStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{Resource}(child, path+'/partOf')){y.2}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'dateAsserted') then
        element.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted') {b}
      else if (child.localName = 'informationSource') then
        element.informationSource := ParseReference{Resource}(child, path+'/informationSource') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'derivedFrom') then
        element.derivedFromList.Add(ParseReference{TFhirReference}(child, path+'/derivedFrom')){y.2}
      else if (child.localName = 'taken') then
        element.takenElement := ParseEnum(CODES_TFhirMedicationStatementTakenEnum, SYSTEMS_TFhirMedicationStatementTakenEnum, path+'/taken', child){1a}
      else if (child.localName = 'reasonNotTaken') then
        element.reasonNotTakenList.Add(ParseCodeableConcept(child, path+'/reasonNotTaken')){y.2}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'dosage') then
        element.dosageList.Add(ParseDosage(child, path+'/dosage')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : String; elem : TFhirMedicationStatement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationStatementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementChildren(xml : TXmlBuilder; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(xml, 'partOf', elem.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTime(xml, 'dateAsserted', elem.dateAssertedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('informationSource') then
    ComposeReference{Resource}(xml, 'informationSource', elem.informationSource);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'derivedFrom', elem.derivedFromList[i]);
  ComposeEnum(xml, 'taken', elem.TakenElement, CODES_TFhirMedicationStatementTakenEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotTaken') then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotTaken', elem.reasonNotTakenList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(xml, 'dosage', elem.dosageList[i]);
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
function TFHIRXmlParser.ParseMessageDefinitionFocus(element : TMXmlElement; path : string) : TFhirMessageDefinitionFocus;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionFocusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionFocusChild(element : TFhirMessageDefinitionFocus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/code', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.localName = 'min') then
        element.minElement := ParseUnsignedInt(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionFocus(xml : TXmlBuilder; name : String; elem : TFhirMessageDefinitionFocus);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionFocusChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionFocusChildren(xml : TXmlBuilder; elem : TFhirMessageDefinitionFocus);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.min <> '0')) then
    ComposeUnsignedInt(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageDefinitionAllowedResponse(element : TMXmlElement; path : string) : TFhirMessageDefinitionAllowedResponse;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionAllowedResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionAllowedResponseChild(element : TFhirMessageDefinitionAllowedResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'message') then
        element.message := ParseReference{TFhirMessageDefinition}(child, path+'/message') {b}
      else if (child.localName = 'situation') then
        element.situationElement := ParseMarkdown(child, path+'/situation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionAllowedResponse(xml : TXmlBuilder; name : String; elem : TFhirMessageDefinitionAllowedResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionAllowedResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionAllowedResponseChildren(xml : TXmlBuilder; elem : TFhirMessageDefinitionAllowedResponse);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMessageDefinition}(xml, 'message', elem.message);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'situation', elem.situationElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageDefinition(element : TMXmlElement; path : string) : TFhirMessageDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionChild(element : TFhirMessageDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'base') then
        element.base := ParseReference{TFhirMessageDefinition}(child, path+'/base') {b}
      else if (child.localName = 'parent') then
        element.parentList.Add(ParseReference{Resource}(child, path+'/parent')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirMessageDefinition}(child, path+'/replaces')){y.2}
      else if (child.localName = 'event') then
        element.event := ParseCoding(child, path+'/event') {b}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'focus') then
        element.focusList.Add(ParseMessageDefinitionFocus(child, path+'/focus')){y.2}
      else if (child.localName = 'responseRequired') then
        element.responseRequiredElement := ParseBoolean(child, path+'/responseRequired') {b}
      else if (child.localName = 'allowedResponse') then
        element.allowedResponseList.Add(ParseMessageDefinitionAllowedResponse(child, path+'/allowedResponse')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinition(xml : TXmlBuilder; name : String; elem : TFhirMessageDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionChildren(xml : TXmlBuilder; elem : TFhirMessageDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeReference{TFhirMessageDefinition}(xml, 'base', elem.base);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{Resource}(xml, 'parent', elem.parentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirMessageDefinition}(xml, 'replaces', elem.replacesList[i]);
  ComposeCoding(xml, 'event', elem.event);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(xml, 'focus', elem.focusList[i]);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.responseRequired <> false)) and doCompose('responseRequired') then
    ComposeBoolean(xml, 'responseRequired', elem.responseRequiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('allowedResponse') then
    for i := 0 to elem.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(xml, 'allowedResponse', elem.allowedResponseList[i]);
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRXmlParser.ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderDestinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderDestinationChild(element : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderDestinationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderDestination);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'target', elem.target);{x.2a}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderSourceChild(element : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'software') then
        element.softwareElement := ParseString(child, path+'/software') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'contact') then
        element.contact := ParseContactPoint(child, path+'/contact') {b}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderSourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderSource);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'software', elem.softwareElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(xml, 'contact', elem.contact);{x.2a}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponseChild(element : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierElement := ParseId(child, path+'/identifier') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, path+'/code', child){1a}
      else if (child.localName = 'details') then
        element.details := ParseReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderResponse);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierElement);{x.2b}
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(xml, 'details', elem.details);{x.2a}
end;

function TFHIRXmlParser.ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderChild(element : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'event') then
        element.event := ParseCoding(child, path+'/event') {b}
      else if (child.localName = 'destination') then
        element.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination')){y.2}
      else if (child.localName = 'receiver') then
        element.receiver := ParseReference{Resource}(child, path+'/receiver') {b}
      else if (child.localName = 'sender') then
        element.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.localName = 'timestamp') then
        element.timestampElement := ParseInstant(child, path+'/timestamp') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.localName = 'source') then
        element.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.localName = 'responsible') then
        element.responsible := ParseReference{Resource}(child, path+'/responsible') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'response') then
        element.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.localName = 'focus') then
        element.focusList.Add(ParseReference{TFhirReference}(child, path+'/focus')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : String; elem : TFhirMessageHeader);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderChildren(xml : TXmlBuilder; elem : TFhirMessageHeader);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeCoding(xml, 'event', elem.event);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    ComposeReference{Resource}(xml, 'receiver', elem.receiver);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2a}
  ComposeInstant(xml, 'timestamp', elem.timestampElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2a}
  ComposeMessageHeaderSource(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{Resource}(xml, 'responsible', elem.responsible);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'focus', elem.focusList[i]);
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRXmlParser.ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemUniqueIdChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemUniqueIdChild(element : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'preferred') then
        element.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : String; elem : TFhirNamingSystemUniqueId);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemUniqueIdChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; elem : TFhirNamingSystemUniqueId);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum);
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemChild(element : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, path+'/kind', child){1a}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'responsible') then
        element.responsibleElement := ParseString(child, path+'/responsible') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'uniqueId') then
        element.uniqueIdList.Add(ParseNamingSystemUniqueId(child, path+'/uniqueId')){y.2}
      else if (child.localName = 'replacedBy') then
        element.replacedBy := ParseReference{TFhirNamingSystem}(child, path+'/replacedBy') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystem(xml : TXmlBuilder; name : String; elem : TFhirNamingSystem);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemChildren(xml : TXmlBuilder; elem : TFhirNamingSystem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeString(xml, 'responsible', elem.responsibleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(xml, 'uniqueId', elem.uniqueIdList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('replacedBy') then
    ComposeReference{TFhirNamingSystem}(xml, 'replacedBy', elem.replacedBy);{x.2a}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRXmlParser.ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietChild(element : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'schedule') then
        element.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.localName = 'nutrient') then
        element.nutrientList.Add(ParseNutritionOrderOralDietNutrient(child, path+'/nutrient')){y.2}
      else if (child.localName = 'texture') then
        element.textureList.Add(ParseNutritionOrderOralDietTexture(child, path+'/texture')){y.2}
      else if (child.localName = 'fluidConsistencyType') then
        element.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType')){y.2}
      else if (child.localName = 'instruction') then
        element.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDiet);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDiet);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(xml, 'nutrient', elem.nutrientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(xml, 'texture', elem.textureList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'fluidConsistencyType', elem.fluidConsistencyTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietNutrientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrientChild(element : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        element.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDietNutrient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietNutrientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietNutrient);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietTextureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTextureChild(element : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        element.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.localName = 'foodType') then
        element.foodType := ParseCodeableConcept(child, path+'/foodType') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDietTexture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietTextureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietTexture);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'foodType', elem.foodType);{x.2a}
end;

function TFHIRXmlParser.ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderSupplementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderSupplementChild(element : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'productName') then
        element.productNameElement := ParseString(child, path+'/productName') {b}
      else if (child.localName = 'schedule') then
        element.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'instruction') then
        element.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderSupplement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderSupplementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderSupplement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'productName', elem.productNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaChild(element : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'baseFormulaType') then
        element.baseFormulaType := ParseCodeableConcept(child, path+'/baseFormulaType') {b}
      else if (child.localName = 'baseFormulaProductName') then
        element.baseFormulaProductNameElement := ParseString(child, path+'/baseFormulaProductName') {b}
      else if (child.localName = 'additiveType') then
        element.additiveType := ParseCodeableConcept(child, path+'/additiveType') {b}
      else if (child.localName = 'additiveProductName') then
        element.additiveProductNameElement := ParseString(child, path+'/additiveProductName') {b}
      else if (child.localName = 'caloricDensity') then
        element.caloricDensity := ParseQuantity(child, path+'/caloricDensity') {b}
      else if (child.localName = 'routeofAdministration') then
        element.routeofAdministration := ParseCodeableConcept(child, path+'/routeofAdministration') {b}
      else if (child.localName = 'administration') then
        element.administrationList.Add(ParseNutritionOrderEnteralFormulaAdministration(child, path+'/administration')){y.2}
      else if (child.localName = 'maxVolumeToDeliver') then
        element.maxVolumeToDeliver := ParseQuantity(child, path+'/maxVolumeToDeliver') {b}
      else if (child.localName = 'administrationInstruction') then
        element.administrationInstructionElement := ParseString(child, path+'/administrationInstruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderEnteralFormula);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormula);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'baseFormulaType', elem.baseFormulaType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'baseFormulaProductName', elem.baseFormulaProductNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'additiveType', elem.additiveType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'additiveProductName', elem.additiveProductNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'caloricDensity', elem.caloricDensity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'routeofAdministration', elem.routeofAdministration);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(xml, 'administration', elem.administrationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'maxVolumeToDeliver', elem.maxVolumeToDeliver);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'administrationInstruction', elem.administrationInstructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministrationChild(element : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'schedule') then
        element.schedule := ParseTiming(child, path+'/schedule') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'rateQuantity') then
        element.rate := ParseQuantity(child, path+'/rateQuantity'){x.3}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaAdministrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(elem.rate))
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate));
end;

function TFHIRXmlParser.ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderChild(element : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirNutritionRequestStatusEnum, SYSTEMS_TFhirNutritionRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'dateTime') then
        element.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.localName = 'orderer') then
        element.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.localName = 'allergyIntolerance') then
        element.allergyIntoleranceList.Add(ParseReference{TFhirAllergyIntolerance}(child, path+'/allergyIntolerance')){y.2}
      else if (child.localName = 'foodPreferenceModifier') then
        element.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier')){y.2}
      else if (child.localName = 'excludeFoodModifier') then
        element.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier')){y.2}
      else if (child.localName = 'oralDiet') then
        element.oralDiet := ParseNutritionOrderOralDiet(child, path+'/oralDiet') {b}
      else if (child.localName = 'supplement') then
        element.supplementList.Add(ParseNutritionOrderSupplement(child, path+'/supplement')){y.2}
      else if (child.localName = 'enteralFormula') then
        element.enteralFormula := ParseNutritionOrderEnteralFormula(child, path+'/enteralFormula') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrder);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderChildren(xml : TXmlBuilder; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNutritionRequestStatusEnum);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(xml, 'allergyIntolerance', elem.allergyIntoleranceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'foodPreferenceModifier', elem.foodPreferenceModifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'excludeFoodModifier', elem.excludeFoodModifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(xml, 'oralDiet', elem.oralDiet);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(xml, 'supplement', elem.supplementList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(xml, 'enteralFormula', elem.enteralFormula);{x.2a}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
function TFHIRXmlParser.ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
var
  child : TMXmlElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationReferenceRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationReferenceRangeChild(element : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        element.low := ParseQuantity(child, path+'/low') {b}
      else if (child.localName = 'high') then
        element.high := ParseQuantity(child, path+'/high') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'appliesTo') then
        element.appliesToList.Add(ParseCodeableConcept(child, path+'/appliesTo')){y.2}
      else if (child.localName = 'age') then
        element.age := ParseRange(child, path+'/age') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : String; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationReferenceRangeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; elem : TFhirObservationReferenceRange);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(xml, 'appliesTo', elem.appliesToList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'age', elem.age);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseObservationRelated(element : TMXmlElement; path : string) : TFhirObservationRelated;
var
  child : TMXmlElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationRelatedChild(element : TFhirObservationRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, path+'/type', child){1a}
      else if (child.localName = 'target') then
        element.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : String; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationRelatedChildren(xml : TXmlBuilder; elem : TFhirObservationRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2a}
end;

function TFHIRXmlParser.ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
var
  child : TMXmlElement;
begin
  result := TFhirObservationComponent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationComponentChild(element : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'dataAbsentReason') then
        element.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.localName = 'interpretation') then
        element.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.localName = 'referenceRange') then
        element.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationComponent(xml : TXmlBuilder; name : String; elem : TFhirObservationComponent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationComponentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationComponentChildren(xml : TXmlBuilder; elem : TFhirObservationComponent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
end;

function TFHIRXmlParser.ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
var
  child : TMXmlElement;
begin
  result := TFhirObservation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationChild(element : TFhirObservation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'dataAbsentReason') then
        element.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.localName = 'interpretation') then
        element.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'specimen') then
        element.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{Resource}(child, path+'/device') {b}
      else if (child.localName = 'referenceRange') then
        element.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseObservationRelated(child, path+'/related')){y.2}
      else if (child.localName = 'component') then
        element.componentList.Add(ParseObservationComponent(child, path+'/component')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : String; elem : TFhirObservation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationChildren(xml : TXmlBuilder; elem : TFhirObservation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{Resource}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(xml, 'component', elem.componentList[i]);
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRXmlParser.ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterChild(element : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, path+'/use', child){1a}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'searchType') then
        element.searchTypeElement := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/searchType', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.localName = 'binding') then
        element.binding := ParseOperationDefinitionParameterBinding(child, path+'/binding') {b}
      else if (child.localName = 'part') then
        element.partList.Add(ParseOperationDefinitionParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum);
  ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'searchType', elem.SearchTypeElement, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(xml, 'binding', elem.binding);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'part', elem.partList[i]);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBindingChild(element : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        element.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.localName = 'valueSetReference') then
        element.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if (child.localName = 'valueSetUri') then
        element.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionParameterBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterBindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameterBinding);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet));
end;

function TFHIRXmlParser.ParseOperationDefinitionOverload(element : TMXmlElement; path : string) : TFhirOperationDefinitionOverload;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionOverloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionOverloadChild(element : TFhirOperationDefinitionOverload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'parameterName') then
        element.parameterNameList.Add(ParseString(child, path+'/parameterName')){y.2}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionOverload(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionOverload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionOverloadChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionOverloadChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionOverload);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterNameList.Count - 1 do
      ComposeString(xml, 'parameterName', elem.parameterNameList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

function TFHIRXmlParser.ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionChild(element : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'idempotent') then
        element.idempotentElement := ParseBoolean(child, path+'/idempotent') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'base') then
        element.base := ParseReference{TFhirOperationDefinition}(child, path+'/base') {b}
      else if (child.localName = 'resource') then
        element.resource.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/resource', child)){y.1}
      else if (child.localName = 'system') then
        element.systemElement := ParseBoolean(child, path+'/system') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseBoolean(child, path+'/type') {b}
      else if (child.localName = 'instance') then
        element.instanceElement := ParseBoolean(child, path+'/instance') {b}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter')){y.2}
      else if (child.localName = 'overload') then
        element.overloadList.Add(ParseOperationDefinitionOverload(child, path+'/overload')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionChildren(xml : TXmlBuilder; elem : TFhirOperationDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('idempotent') then
    ComposeBoolean(xml, 'idempotent', elem.idempotentElement);{x.2b}
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeReference{TFhirOperationDefinition}(xml, 'base', elem.base);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resource.Count - 1 do
      ComposeEnum(xml, 'resource', elem.resource[i], CODES_TFhirResourceTypesEnum);
  ComposeBoolean(xml, 'system', elem.systemElement);{x.2b}
  ComposeBoolean(xml, 'type', elem.type_Element);{x.2b}
  ComposeBoolean(xml, 'instance', elem.instanceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'parameter', elem.parameterList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('overload') then
    for i := 0 to elem.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(xml, 'overload', elem.overloadList[i]);
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRXmlParser.ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssueChild(element : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'details') then
        element.details := ParseCodeableConcept(child, path+'/details') {b}
      else if (child.localName = 'diagnostics') then
        element.diagnosticsElement := ParseString(child, path+'/diagnostics') {b}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseString(child, path+'/location')){y.2}
      else if (child.localName = 'expression') then
        element.expressionList.Add(ParseString(child, path+'/expression')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : String; elem : TFhirOperationOutcomeIssue);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeIssueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'details', elem.details);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'diagnostics', elem.diagnosticsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.expressionList.Count - 1 do
      ComposeString(xml, 'expression', elem.expressionList[i]);
end;

function TFHIRXmlParser.ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeChild(element : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'issue') then
        element.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : String; elem : TFhirOperationOutcome);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeChildren(xml : TXmlBuilder; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRXmlParser.ParseOrganizationContact(element : TMXmlElement; path : string) : TFhirOrganizationContact;
var
  child : TMXmlElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationContactChild(element : TFhirOrganizationContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'purpose') then
        element.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : String; elem : TFhirOrganizationContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContactChildren(xml : TXmlBuilder; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'purpose', elem.purpose);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
end;

function TFHIRXmlParser.ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
var
  child : TMXmlElement;
begin
  result := TFhirOrganization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationChild(element : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'alias') then
        element.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseOrganizationContact(child, path+'/contact')){y.2}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : String; elem : TFhirOrganization);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationChildren(xml : TXmlBuilder; elem : TFhirOrganization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(xml, 'alias', elem.aliasList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(xml, 'partOf', elem.partOf);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
function TFHIRXmlParser.ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
var
  child : TMXmlElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientContactChild(element : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relationship') then
        element.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship')){y.2}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : String; elem : TFhirPatientContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientContactChildren(xml : TXmlBuilder; elem : TFhirPatientContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParsePatientAnimal(element : TMXmlElement; path : string) : TFhirPatientAnimal;
var
  child : TMXmlElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientAnimalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientAnimalChild(element : TFhirPatientAnimal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'species') then
        element.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.localName = 'breed') then
        element.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.localName = 'genderStatus') then
        element.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : String; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientAnimalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientAnimalChildren(xml : TXmlBuilder; elem : TFhirPatientAnimal);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'species', elem.species);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'breed', elem.breed);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);{x.2a}
end;

function TFHIRXmlParser.ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirPatientCommunication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientCommunicationChild(element : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.language := ParseCodeableConcept(child, path+'/language') {b}
      else if (child.localName = 'preferred') then
        element.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientCommunication(xml : TXmlBuilder; name : String; elem : TFhirPatientCommunication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientCommunicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientCommunicationChildren(xml : TXmlBuilder; elem : TFhirPatientCommunication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'language', elem.language);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2b}
end;

function TFHIRXmlParser.ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
var
  child : TMXmlElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientLinkChild(element : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'other') then
        element.other := ParseReference{Resource}(child, path+'/other') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : String; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientLinkChildren(xml : TXmlBuilder; elem : TFhirPatientLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'other', elem.other);{x.2a}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum);
end;

function TFHIRXmlParser.ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
var
  child : TMXmlElement;
begin
  result := TFhirPatient.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientChild(element : TFhirPatient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'deceasedBoolean') then
        element.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.localName = 'deceasedDateTime') then
        element.deceased := ParseDateTime(child, path+'/deceasedDateTime'){x.3}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'maritalStatus') then
        element.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.localName = 'multipleBirthBoolean') then
        element.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean'){x.3}
      else if (child.localName = 'multipleBirthInteger') then
        element.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger'){x.3}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParsePatientContact(child, path+'/contact')){y.2}
      else if (child.localName = 'animal') then
        element.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.localName = 'communication') then
        element.communicationList.Add(ParsePatientCommunication(child, path+'/communication')){y.2}
      else if (child.localName = 'generalPractitioner') then
        element.generalPractitionerList.Add(ParseReference{Resource}(child, path+'/generalPractitioner')){y.2}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParsePatientLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : String; elem : TFhirPatient);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientChildren(xml : TXmlBuilder; elem : TFhirPatient);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('animal') then
    ComposePatientAnimal(xml, 'animal', elem.animal);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(xml, 'communication', elem.communicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('generalPractitioner') then
    for i := 0 to elem.generalPractitionerList.Count - 1 do
      ComposeReference{Resource}(xml, 'generalPractitioner', elem.generalPractitionerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(xml, 'link', elem.link_List[i]);
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRXmlParser.ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentNotice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentNoticeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentNoticeChild(element : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.localName = 'statusDate') then
        element.statusDateElement := ParseDate(child, path+'/statusDate') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'paymentStatus') then
        element.paymentStatus := ParseCodeableConcept(child, path+'/paymentStatus') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentNotice(xml : TXmlBuilder; name : String; elem : TFhirPaymentNotice);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentNoticeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentNoticeChildren(xml : TXmlBuilder; elem : TFhirPaymentNotice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('statusDate') then
    ComposeDate(xml, 'statusDate', elem.statusDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentStatus') then
    ComposeCodeableConcept(xml, 'paymentStatus', elem.paymentStatus);{x.2a}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRXmlParser.ParsePaymentReconciliationDetail(element : TMXmlElement; path : string) : TFhirPaymentReconciliationDetail;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationDetailChild(element : TFhirPaymentReconciliationDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.localName = 'submitter') then
        element.submitter := ParseReference{TFhirOrganization}(child, path+'/submitter') {b}
      else if (child.localName = 'payee') then
        element.payee := ParseReference{TFhirOrganization}(child, path+'/payee') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseMoney(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliationDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetailChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationDetail);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'submitter', elem.submitter);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'payee', elem.payee);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParsePaymentReconciliationProcessNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationProcessNoteChild(element : TFhirPaymentReconciliationProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationProcessNote(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliationProcessNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationProcessNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationProcessNoteChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationProcessNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationChild(element : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirProcessRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParsePaymentReconciliationDetail(child, path+'/detail')){y.2}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'total') then
        element.total := ParseMoney(child, path+'/total') {b}
      else if (child.localName = 'processNote') then
        element.processNoteList.Add(ParsePaymentReconciliationProcessNote(child, path+'/processNote')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliation(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirProcessRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(xml, 'detail', elem.detailList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(xml, 'total', elem.total);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(xml, 'processNote', elem.processNoteList[i]);
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
function TFHIRXmlParser.ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
var
  child : TMXmlElement;
begin
  result := TFhirPersonLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonLinkChild(element : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        element.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.localName = 'assurance') then
        element.assuranceElement := ParseEnum(CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, path+'/assurance', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePersonLink(xml : TXmlBuilder; name : String; elem : TFhirPersonLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonLinkChildren(xml : TXmlBuilder; elem : TFhirPersonLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum);
end;

function TFHIRXmlParser.ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
var
  child : TMXmlElement;
begin
  result := TFhirPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonChild(element : TFhirPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'photo') then
        element.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParsePersonLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePerson(xml : TXmlBuilder; name : String; elem : TFhirPerson);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonChildren(xml : TXmlBuilder; elem : TFhirPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(xml, 'link', elem.link_List[i]);
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
function TFHIRXmlParser.ParsePlanDefinitionGoal(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoal;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionGoalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalChild(element : TFhirPlanDefinitionGoal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'description') then
        element.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'start') then
        element.start := ParseCodeableConcept(child, path+'/start') {b}
      else if (child.localName = 'addresses') then
        element.addressesList.Add(ParseCodeableConcept(child, path+'/addresses')){y.2}
      else if (child.localName = 'documentation') then
        element.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation')){y.2}
      else if (child.localName = 'target') then
        element.targetList.Add(ParsePlanDefinitionGoalTarget(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoal(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionGoal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionGoalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionGoal);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'description', elem.description);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'start', elem.start);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeCodeableConcept(xml, 'addresses', elem.addressesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', elem.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(xml, 'target', elem.targetList[i]);
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalTarget(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoalTarget;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionGoalTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalTargetChild(element : TFhirPlanDefinitionGoalTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'measure') then
        element.measure := ParseCodeableConcept(child, path+'/measure') {b}
      else if (child.localName = 'detailQuantity') then
        element.detail := ParseQuantity(child, path+'/detailQuantity'){x.3}
      else if (child.localName = 'detailRange') then
        element.detail := ParseRange(child, path+'/detailRange'){x.3}
      else if (child.localName = 'detailCodeableConcept') then
        element.detail := ParseCodeableConcept(child, path+'/detailCodeableConcept'){x.3}
      else if (child.localName = 'due') then
        element.due := ParseDuration(child, path+'/due') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalTarget(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionGoalTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionGoalTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalTargetChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionGoalTarget);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'measure', elem.measure);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'detailQuantity', TFhirQuantity(elem.detail))
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(xml, 'detailRange', TFhirRange(elem.detail))
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'detailCodeableConcept', TFhirCodeableConcept(elem.detail));
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'due', elem.due);{x.2a}
end;

function TFHIRXmlParser.ParsePlanDefinitionAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionAction;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionChild(element : TFhirPlanDefinitionAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'textEquivalent') then
        element.textEquivalentElement := ParseString(child, path+'/textEquivalent') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'documentation') then
        element.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation')){y.2}
      else if (child.localName = 'goalId') then
        element.goalIdList.Add(ParseId(child, path+'/goalId')){y.2}
      else if (child.localName = 'triggerDefinition') then
        element.triggerDefinitionList.Add(ParseTriggerDefinition(child, path+'/triggerDefinition')){y.2}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParsePlanDefinitionActionCondition(child, path+'/condition')){y.2}
      else if (child.localName = 'input') then
        element.inputList.Add(ParseDataRequirement(child, path+'/input')){y.2}
      else if (child.localName = 'output') then
        element.outputList.Add(ParseDataRequirement(child, path+'/output')){y.2}
      else if (child.localName = 'relatedAction') then
        element.relatedActionList.Add(ParsePlanDefinitionActionRelatedAction(child, path+'/relatedAction')){y.2}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDuration') then
        element.timing := ParseDuration(child, path+'/timingDuration'){x.3}
      else if (child.localName = 'timingRange') then
        element.timing := ParseRange(child, path+'/timingRange'){x.3}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParsePlanDefinitionActionParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'groupingBehavior') then
        element.groupingBehaviorElement := ParseEnum(CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, path+'/groupingBehavior', child){1a}
      else if (child.localName = 'selectionBehavior') then
        element.selectionBehaviorElement := ParseEnum(CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, path+'/selectionBehavior', child){1a}
      else if (child.localName = 'requiredBehavior') then
        element.requiredBehaviorElement := ParseEnum(CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, path+'/requiredBehavior', child){1a}
      else if (child.localName = 'precheckBehavior') then
        element.precheckBehaviorElement := ParseEnum(CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, path+'/precheckBehavior', child){1a}
      else if (child.localName = 'cardinalityBehavior') then
        element.cardinalityBehaviorElement := ParseEnum(CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, path+'/cardinalityBehavior', child){1a}
      else if (child.localName = 'definition') then
        element.definition := ParseReference{Resource}(child, path+'/definition') {b}
      else if (child.localName = 'transform') then
        element.transform := ParseReference{TFhirStructureMap}(child, path+'/transform') {b}
      else if (child.localName = 'dynamicValue') then
        element.dynamicValueList.Add(ParsePlanDefinitionActionDynamicValue(child, path+'/dynamicValue')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParsePlanDefinitionAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionAction(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'textEquivalent', elem.textEquivalentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', elem.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalIdList.Count - 1 do
      ComposeId(xml, 'goalId', elem.goalIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.triggerDefinitionList.Count - 1 do
      ComposeTriggerDefinition(xml, 'triggerDefinition', elem.triggerDefinitionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeDataRequirement(xml, 'input', elem.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeDataRequirement(xml, 'output', elem.outputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(xml, 'relatedAction', elem.relatedActionList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'definition', elem.definition);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureMap}(xml, 'transform', elem.transform);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(xml, 'dynamicValue', elem.dynamicValueList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionCondition(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionCondition;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionConditionChild(element : TFhirPlanDefinitionActionCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseString(child, path+'/language') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionCondition(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionActionCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionConditionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionCondition);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
end;

function TFHIRXmlParser.ParsePlanDefinitionActionRelatedAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionRelatedAction;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionRelatedActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionRelatedActionChild(element : TFhirPlanDefinitionActionRelatedAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actionId') then
        element.actionIdElement := ParseId(child, path+'/actionId') {b}
      else if (child.localName = 'relationship') then
        element.relationshipElement := ParseEnum(CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, path+'/relationship', child){1a}
      else if (child.localName = 'offsetDuration') then
        element.offset := ParseDuration(child, path+'/offsetDuration'){x.3}
      else if (child.localName = 'offsetRange') then
        element.offset := ParseRange(child, path+'/offsetRange'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionRelatedAction(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionActionRelatedAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionRelatedActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionRelatedActionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionRelatedAction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'actionId', elem.actionIdElement);{x.2b}
  ComposeEnum(xml, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum);
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(xml, 'offsetDuration', TFhirDuration(elem.offset))
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(xml, 'offsetRange', TFhirRange(elem.offset));
end;

function TFHIRXmlParser.ParsePlanDefinitionActionParticipant(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionParticipantChild(element : TFhirPlanDefinitionActionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionParticipant(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionActionParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionParticipantChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
end;

function TFHIRXmlParser.ParsePlanDefinitionActionDynamicValue(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionDynamicValue;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionDynamicValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionDynamicValueChild(element : TFhirPlanDefinitionActionDynamicValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseString(child, path+'/language') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionDynamicValue(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinitionActionDynamicValue);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionDynamicValueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionDynamicValueChildren(xml : TXmlBuilder; elem : TFhirPlanDefinitionActionDynamicValue);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
end;

function TFHIRXmlParser.ParsePlanDefinition(element : TMXmlElement; path : string) : TFhirPlanDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionChild(element : TFhirPlanDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseCodeableConcept(child, path+'/topic')){y.2}
      else if (child.localName = 'contributor') then
        element.contributorList.Add(ParseContributor(child, path+'/contributor')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'library') then
        element.library_List.Add(ParseReference{TFhirLibrary}(child, path+'/library')){y.2}
      else if (child.localName = 'goal') then
        element.goalList.Add(ParsePlanDefinitionGoal(child, path+'/goal')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParsePlanDefinitionAction(child, path+'/action')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinition(xml : TXmlBuilder; name : String; elem : TFhirPlanDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionChildren(xml : TXmlBuilder; elem : TFhirPlanDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(xml, 'contributor', elem.contributorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(xml, 'library', elem.library_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposePlanDefinitionGoal(xml, 'goal', elem.goalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(xml, 'action', elem.actionList[i]);
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRXmlParser.ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerQualificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerQualificationChild(element : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'issuer') then
        element.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : String; elem : TFhirPractitionerQualification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerQualificationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualificationChildren(xml : TXmlBuilder; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2a}
end;

function TFHIRXmlParser.ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
var
  child : TMXmlElement;
begin
  result := TFhirPractitioner.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerChild(element : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'qualification') then
        element.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification')){y.2}
      else if (child.localName = 'communication') then
        element.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : String; elem : TFhirPractitioner);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerChildren(xml : TXmlBuilder; elem : TFhirPractitioner);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
function TFHIRXmlParser.ParsePractitionerRoleAvailableTime(element : TMXmlElement; path : string) : TFhirPractitionerRoleAvailableTime;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerRoleAvailableTimeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerRoleAvailableTimeChild(element : TFhirPractitionerRoleAvailableTime; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'daysOfWeek') then
        element.daysOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, path+'/daysOfWeek', child)){y.1}
      else if (child.localName = 'allDay') then
        element.allDayElement := ParseBoolean(child, path+'/allDay') {b}
      else if (child.localName = 'availableStartTime') then
        element.availableStartTimeElement := ParseTime(child, path+'/availableStartTime') {b}
      else if (child.localName = 'availableEndTime') then
        element.availableEndTimeElement := ParseTime(child, path+'/availableEndTime') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleAvailableTime(xml : TXmlBuilder; name : String; elem : TFhirPractitionerRoleAvailableTime);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerRoleAvailableTimeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirPractitionerRoleAvailableTime);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(xml, 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'allDay', elem.allDayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableStartTime', elem.availableStartTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableEndTime', elem.availableEndTimeElement);{x.2b}
end;

function TFHIRXmlParser.ParsePractitionerRoleNotAvailable(element : TMXmlElement; path : string) : TFhirPractitionerRoleNotAvailable;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerRoleNotAvailableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerRoleNotAvailableChild(element : TFhirPractitionerRoleNotAvailable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'during') then
        element.during := ParsePeriod(child, path+'/during') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleNotAvailable(xml : TXmlBuilder; name : String; elem : TFhirPractitionerRoleNotAvailable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerRoleNotAvailableChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleNotAvailableChildren(xml : TXmlBuilder; elem : TFhirPractitionerRoleNotAvailable);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'during', elem.during);{x.2a}
end;

function TFHIRXmlParser.ParsePractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerRole;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerRole.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerRoleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerRoleChild(element : TFhirPractitionerRole; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'practitioner') then
        element.practitioner := ParseReference{TFhirPractitioner}(child, path+'/practitioner') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.localName = 'healthcareService') then
        element.healthcareServiceList.Add(ParseReference{TFhirHealthcareService}(child, path+'/healthcareService')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'availableTime') then
        element.availableTimeList.Add(ParsePractitionerRoleAvailableTime(child, path+'/availableTime')){y.2}
      else if (child.localName = 'notAvailable') then
        element.notAvailableList.Add(ParsePractitionerRoleNotAvailable(child, path+'/notAvailable')){y.2}
      else if (child.localName = 'availabilityExceptions') then
        element.availabilityExceptionsElement := ParseString(child, path+'/availabilityExceptions') {b}
      else if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseReference{TFhirEndpoint}(child, path+'/endpoint')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerRole(xml : TXmlBuilder; name : String; elem : TFhirPractitionerRole);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerRoleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleChildren(xml : TXmlBuilder; elem : TFhirPractitionerRole);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{TFhirPractitioner}(xml, 'practitioner', elem.practitioner);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(xml, 'healthcareService', elem.healthcareServiceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposePractitionerRoleAvailableTime(xml, 'availableTime', elem.availableTimeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposePractitionerRoleNotAvailable(xml, 'notAvailable', elem.notAvailableList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(xml, 'availabilityExceptions', elem.availabilityExceptionsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(xml, 'endpoint', elem.endpointList[i]);
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
function TFHIRXmlParser.ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedurePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedurePerformerChild(element : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : String; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedurePerformerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformerChildren(xml : TXmlBuilder; elem : TFhirProcedurePerformer);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureFocalDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureFocalDeviceChild(element : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.localName = 'manipulated') then
        element.manipulated := ParseReference{TFhirDevice}(child, path+'/manipulated') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDevice(xml : TXmlBuilder; name : String; elem : TFhirProcedureFocalDevice);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureFocalDeviceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; elem : TFhirProcedureFocalDevice);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'action', elem.action);{x.2a}
  ComposeReference{TFhirDevice}(xml, 'manipulated', elem.manipulated);{x.2a}
end;

function TFHIRXmlParser.ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirProcedure.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureChild(element : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{Resource}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'notDone') then
        element.notDoneElement := ParseBoolean(child, path+'/notDone') {b}
      else if (child.localName = 'notDoneReason') then
        element.notDoneReason := ParseCodeableConcept(child, path+'/notDoneReason') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'performedPeriod') then
        element.performed := ParsePeriod(child, path+'/performedPeriod'){x.3}
      else if (child.localName = 'performedDateTime') then
        element.performed := ParseDateTime(child, path+'/performedDateTime'){x.3}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseProcedurePerformer(child, path+'/performer')){y.2}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'report') then
        element.reportList.Add(ParseReference{TFhirDiagnosticReport}(child, path+'/report')){y.2}
      else if (child.localName = 'complication') then
        element.complicationList.Add(ParseCodeableConcept(child, path+'/complication')){y.2}
      else if (child.localName = 'complicationDetail') then
        element.complicationDetailList.Add(ParseReference{TFhirCondition}(child, path+'/complicationDetail')){y.2}
      else if (child.localName = 'followUp') then
        element.followUpList.Add(ParseCodeableConcept(child, path+'/followUp')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'focalDevice') then
        element.focalDeviceList.Add(ParseProcedureFocalDevice(child, path+'/focalDevice')){y.2}
      else if (child.localName = 'usedReference') then
        element.usedReferenceList.Add(ParseReference{Resource}(child, path+'/usedReference')){y.2}
      else if (child.localName = 'usedCode') then
        element.usedCodeList.Add(ParseCodeableConcept(child, path+'/usedCode')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : String; elem : TFhirProcedure);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureChildren(xml : TXmlBuilder; elem : TFhirProcedure);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.notDone <> false)) and doCompose('notDone') then
    ComposeBoolean(xml, 'notDone', elem.notDoneElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(xml, 'notDoneReason', elem.notDoneReason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'performedPeriod', TFhirPeriod(elem.performed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'performedDateTime', TFhirDateTime(elem.performed));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('report') then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('complication') then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('complicationDetail') then
    for i := 0 to elem.complicationDetailList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'complicationDetail', elem.complicationDetailList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(xml, 'followUp', elem.followUpList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(xml, 'focalDevice', elem.focalDeviceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('usedReference') then
    for i := 0 to elem.usedReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'usedReference', elem.usedReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('usedCode') then
    for i := 0 to elem.usedCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'usedCode', elem.usedCodeList[i]);
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
function TFHIRXmlParser.ParseProcedureRequestRequester(element : TMXmlElement; path : string) : TFhirProcedureRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureRequestRequesterChild(element : TFhirProcedureRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirProcedureRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirProcedureRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseProcedureRequest(element : TMXmlElement; path : string) : TFhirProcedureRequest;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureRequestChild(element : TFhirProcedureRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirReference}(child, path+'/replaces')){y.2}
      else if (child.localName = 'requisition') then
        element.requisition := ParseIdentifier(child, path+'/requisition') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'doNotPerform') then
        element.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform') {b}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceTiming') then
        element.occurrence := ParseTiming(child, path+'/occurrenceTiming'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseProcedureRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'performerType') then
        element.performerType := ParseCodeableConcept(child, path+'/performerType') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'supportingInfo') then
        element.supportingInfoList.Add(ParseReference{TFhirReference}(child, path+'/supportingInfo')){y.2}
      else if (child.localName = 'specimen') then
        element.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'relevantHistory') then
        element.relevantHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/relevantHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequest(xml : TXmlBuilder; name : String; elem : TFhirProcedureRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequestChildren(xml : TXmlBuilder; elem : TFhirProcedureRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'replaces', elem.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requisition') then
    ComposeIdentifier(xml, 'requisition', elem.requisition);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.doNotPerform <> false)) and doCompose('doNotPerform') then
    ComposeBoolean(xml, 'doNotPerform', elem.doNotPerformElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeProcedureRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(xml, 'performerType', elem.performerType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInfo', elem.supportingInfoList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'relevantHistory', elem.relevantHistoryList[i]);
end;

{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
function TFHIRXmlParser.ParseProcessRequestItem(element : TMXmlElement; path : string) : TFhirProcessRequestItem;
var
  child : TMXmlElement;
begin
  result := TFhirProcessRequestItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessRequestItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessRequestItemChild(element : TFhirProcessRequestItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParseInteger(child, path+'/sequenceLinkId') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItem(xml : TXmlBuilder; name : String; elem : TFhirProcessRequestItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessRequestItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItemChildren(xml : TXmlBuilder; elem : TFhirProcessRequestItem);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
end;

function TFHIRXmlParser.ParseProcessRequest(element : TMXmlElement; path : string) : TFhirProcessRequest;
var
  child : TMXmlElement;
begin
  result := TFhirProcessRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessRequestChild(element : TFhirProcessRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'action') then
        element.actionElement := ParseEnum(CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, path+'/action', child){1a}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.localName = 'nullify') then
        element.nullifyElement := ParseBoolean(child, path+'/nullify') {b}
      else if (child.localName = 'reference') then
        element.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseProcessRequestItem(child, path+'/item')){y.2}
      else if (child.localName = 'include') then
        element.includeList.Add(ParseString(child, path+'/include')){y.2}
      else if (child.localName = 'exclude') then
        element.excludeList.Add(ParseString(child, path+'/exclude')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessRequest(xml : TXmlBuilder; name : String; elem : TFhirProcessRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestChildren(xml : TXmlBuilder; elem : TFhirProcessRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirActionlistEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('nullify') then
    ComposeBoolean(xml, 'nullify', elem.nullifyElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('include') then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(xml, 'include', elem.includeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('exclude') then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(xml, 'exclude', elem.excludeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
function TFHIRXmlParser.ParseProcessResponseProcessNote(element : TMXmlElement; path : string) : TFhirProcessResponseProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirProcessResponseProcessNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessResponseProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessResponseProcessNoteChild(element : TFhirProcessResponseProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseProcessNote(xml : TXmlBuilder; name : String; elem : TFhirProcessResponseProcessNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessResponseProcessNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseProcessNoteChildren(xml : TXmlBuilder; elem : TFhirProcessResponseProcessNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseProcessResponse(element : TMXmlElement; path : string) : TFhirProcessResponse;
var
  child : TMXmlElement;
begin
  result := TFhirProcessResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessResponseChild(element : TFhirProcessResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'processNote') then
        element.processNoteList.Add(ParseProcessResponseProcessNote(child, path+'/processNote')){y.2}
      else if (child.localName = 'error') then
        element.errorList.Add(ParseCodeableConcept(child, path+'/error')){y.2}
      else if (child.localName = 'communicationRequest') then
        element.communicationRequestList.Add(ParseReference{TFhirCommunicationRequest}(child, path+'/communicationRequest')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessResponse(xml : TXmlBuilder; name : String; elem : TFhirProcessResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseChildren(xml : TXmlBuilder; elem : TFhirProcessResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeProcessResponseProcessNote(xml, 'processNote', elem.processNoteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCodeableConcept(xml, 'error', elem.errorList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') then
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(xml, 'communicationRequest', elem.communicationRequestList[i]);
end;

{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRXmlParser.ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgentChild(element : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.localName = 'whoReference') then
        element.who := ParseReference(child, path+'/whoReference') {a}
      else if (child.localName = 'whoUri') then
        element.who := ParseUri(child, path+'/whoUri'){x.3}
      else if (child.localName = 'onBehalfOfReference') then
        element.onBehalfOf := ParseReference(child, path+'/onBehalfOfReference') {a}
      else if (child.localName = 'onBehalfOfUri') then
        element.onBehalfOf := ParseUri(child, path+'/onBehalfOfUri'){x.3}
      else if (child.localName = 'relatedAgentType') then
        element.relatedAgentType := ParseCodeableConcept(child, path+'/relatedAgentType') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : String; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (elem.who is TFhirReference) {2} then
    ComposeReference(xml, 'whoReference', TFhirReference(elem.who))
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(xml, 'whoUri', TFhirUri(elem.who));
  if (SummaryOption in [soFull, soData]) and (elem.onBehalfOf is TFhirReference) {2} then
    ComposeReference(xml, 'onBehalfOfReference', TFhirReference(elem.onBehalfOf))
  else if (SummaryOption in [soFull, soData]) and (elem.onBehalfOf is TFhirUri) {6} then
    ComposeUri(xml, 'onBehalfOfUri', TFhirUri(elem.onBehalfOf));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relatedAgentType', elem.relatedAgentType);{x.2a}
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceEntityChild(element : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleElement := ParseEnum(CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, path+'/role', child){1a}
      else if (child.localName = 'whatReference') then
        element.what := ParseReference(child, path+'/whatReference') {a}
      else if (child.localName = 'whatIdentifier') then
        element.what := ParseIdentifier(child, path+'/whatIdentifier'){x.3}
      else if (child.localName = 'whatUri') then
        element.what := ParseUri(child, path+'/whatUri'){x.3}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : String; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceEntityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntityChildren(xml : TXmlBuilder; elem : TFhirProvenanceEntity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum);
  if (elem.what is TFhirReference) {2} then
    ComposeReference(xml, 'whatReference', TFhirReference(elem.what))
  else if (elem.what is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'whatIdentifier', TFhirIdentifier(elem.what))
  else if (elem.what is TFhirUri) {6} then
    ComposeUri(xml, 'whatUri', TFhirUri(elem.what));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
end;

function TFHIRXmlParser.ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
var
  child : TMXmlElement;
begin
  result := TFhirProvenance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceChild(element : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        element.targetList.Add(ParseReference{TFhirReference}(child, path+'/target')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'recorded') then
        element.recordedElement := ParseInstant(child, path+'/recorded') {b}
      else if (child.localName = 'policy') then
        element.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCoding(child, path+'/reason')){y.2}
      else if (child.localName = 'activity') then
        element.activity := ParseCoding(child, path+'/activity') {b}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if (child.localName = 'entity') then
        element.entityList.Add(ParseProvenanceEntity(child, path+'/entity')){y.2}
      else if (child.localName = 'signature') then
        element.signatureList.Add(ParseSignature(child, path+'/signature')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : String; elem : TFhirProvenance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceChildren(xml : TXmlBuilder; elem : TFhirProvenance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'target', elem.targetList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  ComposeInstant(xml, 'recorded', elem.recordedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCoding(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    ComposeCoding(xml, 'activity', elem.activity);{x.2a}
  for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('signature') then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', elem.signatureList[i]);
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRXmlParser.ParseQuestionnaireItem(element : TMXmlElement; path : string) : TFhirQuestionnaireItem;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemChild(element : TFhirQuestionnaireItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'prefix') then
        element.prefixElement := ParseString(child, path+'/prefix') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'enableWhen') then
        element.enableWhenList.Add(ParseQuestionnaireItemEnableWhen(child, path+'/enableWhen')){y.2}
      else if (child.localName = 'required') then
        element.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.localName = 'repeats') then
        element.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.localName = 'readOnly') then
        element.readOnlyElement := ParseBoolean(child, path+'/readOnly') {b}
      else if (child.localName = 'maxLength') then
        element.maxLengthElement := ParseInteger(child, path+'/maxLength') {b}
      else if (child.localName = 'options') then
        element.options := ParseReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.localName = 'option') then
        element.optionList.Add(ParseQuestionnaireItemOption(child, path+'/option')){y.2}
      else if (child.localName = 'initialAttachment') then
        element.initial := ParseAttachment(child, path+'/initialAttachment'){x.3}
      else if (child.localName = 'initialCoding') then
        element.initial := ParseCoding(child, path+'/initialCoding'){x.3}
      else if (child.localName = 'initialQuantity') then
        element.initial := ParseQuantity(child, path+'/initialQuantity'){x.3}
      else if (child.localName = 'initialReference') then
        element.initial := ParseReference(child, path+'/initialReference') {a}
      else if (child.localName = 'initialBoolean') then
        element.initial := ParseBoolean(child, path+'/initialBoolean'){x.3}
      else if (child.localName = 'initialDecimal') then
        element.initial := ParseDecimal(child, path+'/initialDecimal'){x.3}
      else if (child.localName = 'initialInteger') then
        element.initial := ParseInteger(child, path+'/initialInteger'){x.3}
      else if (child.localName = 'initialDate') then
        element.initial := ParseDate(child, path+'/initialDate'){x.3}
      else if (child.localName = 'initialDateTime') then
        element.initial := ParseDateTime(child, path+'/initialDateTime'){x.3}
      else if (child.localName = 'initialTime') then
        element.initial := ParseTime(child, path+'/initialTime'){x.3}
      else if (child.localName = 'initialString') then
        element.initial := ParseString(child, path+'/initialString'){x.3}
      else if (child.localName = 'initialUri') then
        element.initial := ParseUri(child, path+'/initialUri'){x.3}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseQuestionnaireItem(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItem(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prefix', elem.prefixElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirItemTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(xml, 'enableWhen', elem.enableWhenList[i]);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readOnly', elem.readOnlyElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'maxLength', elem.maxLengthElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(xml, 'options', elem.options);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeQuestionnaireItemOption(xml, 'option', elem.optionList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'initialAttachment', TFhirAttachment(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirCoding) {6} then
    ComposeCoding(xml, 'initialCoding', TFhirCoding(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'initialQuantity', TFhirQuantity(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirReference) {2} then
    ComposeReference(xml, 'initialReference', TFhirReference(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'initialBoolean', TFhirBoolean(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'initialDecimal', TFhirDecimal(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirInteger) {6} then
    ComposeInteger(xml, 'initialInteger', TFhirInteger(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDate) {6} then
    ComposeDate(xml, 'initialDate', TFhirDate(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'initialDateTime', TFhirDateTime(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirTime) {6} then
    ComposeTime(xml, 'initialTime', TFhirTime(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirString) {6} then
    ComposeString(xml, 'initialString', TFhirString(elem.initial))
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirUri) {6} then
    ComposeUri(xml, 'initialUri', TFhirUri(elem.initial));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(xml, 'item', elem.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireItemEnableWhen(element : TMXmlElement; path : string) : TFhirQuestionnaireItemEnableWhen;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemEnableWhenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemEnableWhenChild(element : TFhirQuestionnaireItemEnableWhen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'question') then
        element.questionElement := ParseString(child, path+'/question') {b}
      else if (child.localName = 'hasAnswer') then
        element.hasAnswerElement := ParseBoolean(child, path+'/hasAnswer') {b}
      else if (child.localName = 'answerAttachment') then
        element.answer := ParseAttachment(child, path+'/answerAttachment'){x.3}
      else if (child.localName = 'answerCoding') then
        element.answer := ParseCoding(child, path+'/answerCoding'){x.3}
      else if (child.localName = 'answerQuantity') then
        element.answer := ParseQuantity(child, path+'/answerQuantity'){x.3}
      else if (child.localName = 'answerReference') then
        element.answer := ParseReference(child, path+'/answerReference') {a}
      else if (child.localName = 'answerBoolean') then
        element.answer := ParseBoolean(child, path+'/answerBoolean'){x.3}
      else if (child.localName = 'answerDecimal') then
        element.answer := ParseDecimal(child, path+'/answerDecimal'){x.3}
      else if (child.localName = 'answerInteger') then
        element.answer := ParseInteger(child, path+'/answerInteger'){x.3}
      else if (child.localName = 'answerDate') then
        element.answer := ParseDate(child, path+'/answerDate'){x.3}
      else if (child.localName = 'answerDateTime') then
        element.answer := ParseDateTime(child, path+'/answerDateTime'){x.3}
      else if (child.localName = 'answerTime') then
        element.answer := ParseTime(child, path+'/answerTime'){x.3}
      else if (child.localName = 'answerString') then
        element.answer := ParseString(child, path+'/answerString'){x.3}
      else if (child.localName = 'answerUri') then
        element.answer := ParseUri(child, path+'/answerUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemEnableWhen(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireItemEnableWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemEnableWhenChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemEnableWhenChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItemEnableWhen);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'question', elem.questionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'hasAnswer', elem.hasAnswerElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'answerAttachment', TFhirAttachment(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirCoding) {6} then
    ComposeCoding(xml, 'answerCoding', TFhirCoding(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'answerQuantity', TFhirQuantity(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirReference) {2} then
    ComposeReference(xml, 'answerReference', TFhirReference(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'answerBoolean', TFhirBoolean(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'answerDecimal', TFhirDecimal(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirInteger) {6} then
    ComposeInteger(xml, 'answerInteger', TFhirInteger(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDate) {6} then
    ComposeDate(xml, 'answerDate', TFhirDate(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'answerDateTime', TFhirDateTime(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirTime) {6} then
    ComposeTime(xml, 'answerTime', TFhirTime(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirString) {6} then
    ComposeString(xml, 'answerString', TFhirString(elem.answer))
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirUri) {6} then
    ComposeUri(xml, 'answerUri', TFhirUri(elem.answer));
end;

function TFHIRXmlParser.ParseQuestionnaireItemOption(element : TMXmlElement; path : string) : TFhirQuestionnaireItemOption;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItemOption.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemOptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemOptionChild(element : TFhirQuestionnaireItemOption; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemOption(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireItemOption);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemOptionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemOptionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireItemOption);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value));
end;

function TFHIRXmlParser.ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireChild(element : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'subjectType') then
        element.subjectType.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/subjectType', child)){y.1}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseQuestionnaireItem(child, path+'/item')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaire);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireChildren(xml : TXmlBuilder; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(xml, 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(xml, 'item', elem.itemList[i]);
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRXmlParser.ParseQuestionnaireResponseItem(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItem;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemChild(element : TFhirQuestionnaireResponseItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'answer') then
        element.answerList.Add(ParseQuestionnaireResponseItemAnswer(child, path+'/answer')){y.2}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItem(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponseItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(xml, 'answer', elem.answerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', elem.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItemAnswer;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseItemAnswerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemAnswerChild(element : TFhirQuestionnaireResponseItemAnswer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference') {a}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemAnswer(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponseItemAnswer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseItemAnswerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemAnswerChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseItemAnswer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', elem.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseChild(element : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'parent') then
        element.parentList.Add(ParseReference{Resource}(child, path+'/parent')){y.2}
      else if (child.localName = 'questionnaire') then
        element.questionnaire := ParseReference{TFhirQuestionnaire}(child, path+'/questionnaire') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'authored') then
        element.authoredElement := ParseDateTime(child, path+'/authored') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponse(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{Resource}(xml, 'parent', elem.parentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeReference{TFhirQuestionnaire}(xml, 'questionnaire', elem.questionnaire);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTime(xml, 'authored', elem.authoredElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', elem.itemList[i]);
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
function TFHIRXmlParser.ParseReferralRequestRequester(element : TMXmlElement; path : string) : TFhirReferralRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirReferralRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferralRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferralRequestRequesterChild(element : TFhirReferralRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReferralRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirReferralRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferralRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferralRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirReferralRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseReferralRequest(element : TMXmlElement; path : string) : TFhirReferralRequest;
var
  child : TMXmlElement;
begin
  result := TFhirReferralRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferralRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferralRequestChild(element : TFhirReferralRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{Resource}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{Resource}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirReferralRequest}(child, path+'/replaces')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'serviceRequested') then
        element.serviceRequestedList.Add(ParseCodeableConcept(child, path+'/serviceRequested')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseReferralRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'specialty') then
        element.specialty := ParseCodeableConcept(child, path+'/specialty') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{Resource}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'supportingInfo') then
        element.supportingInfoList.Add(ParseReference{TFhirReference}(child, path+'/supportingInfo')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'relevantHistory') then
        element.relevantHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/relevantHistory')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReferralRequest(xml : TXmlBuilder; name : String; elem : TFhirReferralRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferralRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferralRequestChildren(xml : TXmlBuilder; elem : TFhirReferralRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'replaces', elem.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceRequested') then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceRequested', elem.serviceRequestedList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReferralRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('specialty') then
    ComposeCodeableConcept(xml, 'specialty', elem.specialty);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInfo', elem.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'relevantHistory', elem.relevantHistoryList[i]);
end;

{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRXmlParser.ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedPersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedPersonChild(element : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : String; elem : TFhirRelatedPerson);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedPersonChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedPersonChildren(xml : TXmlBuilder; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
function TFHIRXmlParser.ParseRequestGroupAction(element : TMXmlElement; path : string) : TFhirRequestGroupAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionChild(element : TFhirRequestGroupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'textEquivalent') then
        element.textEquivalentElement := ParseString(child, path+'/textEquivalent') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'documentation') then
        element.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation')){y.2}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseRequestGroupActionCondition(child, path+'/condition')){y.2}
      else if (child.localName = 'relatedAction') then
        element.relatedActionList.Add(ParseRequestGroupActionRelatedAction(child, path+'/relatedAction')){y.2}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDuration') then
        element.timing := ParseDuration(child, path+'/timingDuration'){x.3}
      else if (child.localName = 'timingRange') then
        element.timing := ParseRange(child, path+'/timingRange'){x.3}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseReference{Resource}(child, path+'/participant')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'groupingBehavior') then
        element.groupingBehaviorElement := ParseEnum(CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, path+'/groupingBehavior', child){1a}
      else if (child.localName = 'selectionBehavior') then
        element.selectionBehaviorElement := ParseEnum(CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, path+'/selectionBehavior', child){1a}
      else if (child.localName = 'requiredBehavior') then
        element.requiredBehaviorElement := ParseEnum(CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, path+'/requiredBehavior', child){1a}
      else if (child.localName = 'precheckBehavior') then
        element.precheckBehaviorElement := ParseEnum(CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, path+'/precheckBehavior', child){1a}
      else if (child.localName = 'cardinalityBehavior') then
        element.cardinalityBehaviorElement := ParseEnum(CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, path+'/cardinalityBehavior', child){1a}
      else if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseRequestGroupAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupAction(xml : TXmlBuilder; name : String; elem : TFhirRequestGroupAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'textEquivalent', elem.textEquivalentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', elem.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(xml, 'relatedAction', elem.relatedActionList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeReference{Resource}(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseRequestGroupActionCondition(element : TMXmlElement; path : string) : TFhirRequestGroupActionCondition;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionConditionChild(element : TFhirRequestGroupActionCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseString(child, path+'/language') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionCondition(xml : TXmlBuilder; name : String; elem : TFhirRequestGroupActionCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionConditionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupActionCondition);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
end;

function TFHIRXmlParser.ParseRequestGroupActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestGroupActionRelatedAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionRelatedActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionRelatedActionChild(element : TFhirRequestGroupActionRelatedAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actionId') then
        element.actionIdElement := ParseId(child, path+'/actionId') {b}
      else if (child.localName = 'relationship') then
        element.relationshipElement := ParseEnum(CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, path+'/relationship', child){1a}
      else if (child.localName = 'offsetDuration') then
        element.offset := ParseDuration(child, path+'/offsetDuration'){x.3}
      else if (child.localName = 'offsetRange') then
        element.offset := ParseRange(child, path+'/offsetRange'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionRelatedAction(xml : TXmlBuilder; name : String; elem : TFhirRequestGroupActionRelatedAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionRelatedActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionRelatedActionChildren(xml : TXmlBuilder; elem : TFhirRequestGroupActionRelatedAction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'actionId', elem.actionIdElement);{x.2b}
  ComposeEnum(xml, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum);
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(xml, 'offsetDuration', TFhirDuration(elem.offset))
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(xml, 'offsetRange', TFhirRange(elem.offset));
end;

function TFHIRXmlParser.ParseRequestGroup(element : TMXmlElement; path : string) : TFhirRequestGroup;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroup.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupChild(element : TFhirRequestGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definition') then
        element.definitionList.Add(ParseReference{TFhirReference}(child, path+'/definition')){y.2}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'replaces') then
        element.replacesList.Add(ParseReference{TFhirReference}(child, path+'/replaces')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseRequestGroupAction(child, path+'/action')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroup(xml : TXmlBuilder; name : String; elem : TFhirRequestGroup);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupChildren(xml : TXmlBuilder; elem : TFhirRequestGroup);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'definition', elem.definitionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'replaces', elem.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(xml, 'action', elem.actionList[i]);
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
function TFHIRXmlParser.ParseResearchStudyArm(element : TMXmlElement; path : string) : TFhirResearchStudyArm;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyArm.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyArmChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyArmChild(element : TFhirResearchStudyArm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyArm(xml : TXmlBuilder; name : String; elem : TFhirResearchStudyArm);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyArmChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyArmChildren(xml : TXmlBuilder; elem : TFhirResearchStudyArm);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseResearchStudy(element : TMXmlElement; path : string) : TFhirResearchStudy;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudy.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyChild(element : TFhirResearchStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'protocol') then
        element.protocolList.Add(ParseReference{TFhirPlanDefinition}(child, path+'/protocol')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirResearchStudy}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'focus') then
        element.focusList.Add(ParseCodeableConcept(child, path+'/focus')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'keyword') then
        element.keywordList.Add(ParseCodeableConcept(child, path+'/keyword')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'enrollment') then
        element.enrollmentList.Add(ParseReference{TFhirGroup}(child, path+'/enrollment')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'sponsor') then
        element.sponsor := ParseReference{TFhirOrganization}(child, path+'/sponsor') {b}
      else if (child.localName = 'principalInvestigator') then
        element.principalInvestigator := ParseReference{TFhirPractitioner}(child, path+'/principalInvestigator') {b}
      else if (child.localName = 'site') then
        element.siteList.Add(ParseReference{TFhirLocation}(child, path+'/site')){y.2}
      else if (child.localName = 'reasonStopped') then
        element.reasonStopped := ParseCodeableConcept(child, path+'/reasonStopped') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'arm') then
        element.armList.Add(ParseResearchStudyArm(child, path+'/arm')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudy(xml : TXmlBuilder; name : String; elem : TFhirResearchStudy);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyChildren(xml : TXmlBuilder; elem : TFhirResearchStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeReference{TFhirPlanDefinition}(xml, 'protocol', elem.protocolList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirResearchStudyStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeCodeableConcept(xml, 'focus', elem.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCodeableConcept(xml, 'keyword', elem.keywordList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enrollment') then
    for i := 0 to elem.enrollmentList.Count - 1 do
      ComposeReference{TFhirGroup}(xml, 'enrollment', elem.enrollmentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sponsor') then
    ComposeReference{TFhirOrganization}(xml, 'sponsor', elem.sponsor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('principalInvestigator') then
    ComposeReference{TFhirPractitioner}(xml, 'principalInvestigator', elem.principalInvestigator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('site') then
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'site', elem.siteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonStopped') then
    ComposeCodeableConcept(xml, 'reasonStopped', elem.reasonStopped);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('arm') then
    for i := 0 to elem.armList.Count - 1 do
      ComposeResearchStudyArm(xml, 'arm', elem.armList[i]);
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
function TFHIRXmlParser.ParseResearchSubject(element : TMXmlElement; path : string) : TFhirResearchSubject;
var
  child : TMXmlElement;
begin
  result := TFhirResearchSubject.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchSubjectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchSubjectChild(element : TFhirResearchSubject; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'study') then
        element.study := ParseReference{TFhirResearchStudy}(child, path+'/study') {b}
      else if (child.localName = 'individual') then
        element.individual := ParseReference{TFhirPatient}(child, path+'/individual') {b}
      else if (child.localName = 'assignedArm') then
        element.assignedArmElement := ParseString(child, path+'/assignedArm') {b}
      else if (child.localName = 'actualArm') then
        element.actualArmElement := ParseString(child, path+'/actualArm') {b}
      else if (child.localName = 'consent') then
        element.consent := ParseReference{TFhirConsent}(child, path+'/consent') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchSubject(xml : TXmlBuilder; name : String; elem : TFhirResearchSubject);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchSubjectChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchSubjectChildren(xml : TXmlBuilder; elem : TFhirResearchSubject);
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirResearchSubjectStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  ComposeReference{TFhirResearchStudy}(xml, 'study', elem.study);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'individual', elem.individual);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('assignedArm') then
    ComposeString(xml, 'assignedArm', elem.assignedArmElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('actualArm') then
    ComposeString(xml, 'actualArm', elem.actualArmElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('consent') then
    ComposeReference{TFhirConsent}(xml, 'consent', elem.consent);{x.2a}
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentPredictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentPredictionChild(element : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'probabilityRange') then
        element.probability := ParseRange(child, path+'/probabilityRange'){x.3}
      else if (child.localName = 'probabilityDecimal') then
        element.probability := ParseDecimal(child, path+'/probabilityDecimal'){x.3}
      else if (child.localName = 'qualitativeRisk') then
        element.qualitativeRisk := ParseCodeableConcept(child, path+'/qualitativeRisk') {b}
      else if (child.localName = 'relativeRisk') then
        element.relativeRiskElement := ParseDecimal(child, path+'/relativeRisk') {b}
      else if (child.localName = 'whenPeriod') then
        element.when := ParsePeriod(child, path+'/whenPeriod'){x.3}
      else if (child.localName = 'whenRange') then
        element.when := ParseRange(child, path+'/whenRange'){x.3}
      else if (child.localName = 'rationale') then
        element.rationaleElement := ParseString(child, path+'/rationale') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : String; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentPredictionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; elem : TFhirRiskAssessmentPrediction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(elem.probability))
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(elem.probability));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'qualitativeRisk', elem.qualitativeRisk);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'relativeRisk', elem.relativeRiskElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(elem.when))
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(elem.when));
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'rationale', elem.rationaleElement);{x.2b}
end;

function TFHIRXmlParser.ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentChild(element : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'basedOn') then
        element.basedOn := ParseReference{TFhirReference}(child, path+'/basedOn') {b}
      else if (child.localName = 'parent') then
        element.parent := ParseReference{TFhirReference}(child, path+'/parent') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'condition') then
        element.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'basis') then
        element.basisList.Add(ParseReference{TFhirReference}(child, path+'/basis')){y.2}
      else if (child.localName = 'prediction') then
        element.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction')){y.2}
      else if (child.localName = 'mitigation') then
        element.mitigationElement := ParseString(child, path+'/mitigation') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : String; elem : TFhirRiskAssessment);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentChildren(xml : TXmlBuilder; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOn);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirReference}(xml, 'parent', elem.parent);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soData]) and doCompose('basis') then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basis', elem.basisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(xml, 'prediction', elem.predictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeString(xml, 'mitigation', elem.mitigationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRXmlParser.ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirSchedule.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseScheduleChild(element : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'serviceCategory') then
        element.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.localName = 'serviceType') then
        element.serviceTypeList.Add(ParseCodeableConcept(child, path+'/serviceType')){y.2}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'actor') then
        element.actorList.Add(ParseReference{Resource}(child, path+'/actor')){y.2}
      else if (child.localName = 'planningHorizon') then
        element.planningHorizon := ParsePeriod(child, path+'/planningHorizon') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : String; elem : TFhirSchedule);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeScheduleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeScheduleChildren(xml : TXmlBuilder; elem : TFhirSchedule);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceType', elem.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  for i := 0 to elem.actorList.Count - 1 do
      ComposeReference{Resource}(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(xml, 'planningHorizon', elem.planningHorizon);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRXmlParser.ParseSearchParameterComponent(element : TMXmlElement; path : string) : TFhirSearchParameterComponent;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameterComponent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterComponentChild(element : TFhirSearchParameterComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'definition') then
        element.definition := ParseReference{TFhirSearchParameter}(child, path+'/definition') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterComponent(xml : TXmlBuilder; name : String; elem : TFhirSearchParameterComponent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterComponentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterComponentChildren(xml : TXmlBuilder; elem : TFhirSearchParameterComponent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirSearchParameter}(xml, 'definition', elem.definition);{x.2a}
  ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
end;

function TFHIRXmlParser.ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterChild(element : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'base') then
        element.base.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/base', child)){y.1}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'derivedFrom') then
        element.derivedFromElement := ParseUri(child, path+'/derivedFrom') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if (child.localName = 'xpath') then
        element.xpathElement := ParseString(child, path+'/xpath') {b}
      else if (child.localName = 'xpathUsage') then
        element.xpathUsageElement := ParseEnum(CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, path+'/xpathUsage', child){1a}
      else if (child.localName = 'target') then
        element.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/target', child)){y.1}
      else if (child.localName = 'comparator') then
        element.comparatorList.Add(ParseEnum(CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, path+'/comparator', child)){y.1}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseEnum(CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, path+'/modifier', child)){y.1}
      else if (child.localName = 'chain') then
        element.chainList.Add(ParseString(child, path+'/chain')){y.2}
      else if (child.localName = 'component') then
        element.componentList.Add(ParseSearchParameterComponent(child, path+'/component')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameter(xml : TXmlBuilder; name : String; elem : TFhirSearchParameter);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterChildren(xml : TXmlBuilder; elem : TFhirSearchParameter);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  for i := 0 to elem.base.Count - 1 do
      ComposeEnum(xml, 'base', elem.base[i], CODES_TFhirResourceTypesEnum);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    ComposeUri(xml, 'derivedFrom', elem.derivedFromElement);{x.2b}
  ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('expression') then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeString(xml, 'xpath', elem.xpathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnum(xml, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(xml, 'target', elem.target[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') then
    for i := 0 to elem.comparatorList.Count - 1 do
      ComposeEnum(xml, 'comparator', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(xml, 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('chain') then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(xml, 'chain', elem.chainList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeSearchParameterComponent(xml, 'component', elem.componentList[i]);
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
function TFHIRXmlParser.ParseSequenceReferenceSeq(element : TMXmlElement; path : string) : TFhirSequenceReferenceSeq;
var
  child : TMXmlElement;
begin
  result := TFhirSequenceReferenceSeq.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSequenceReferenceSeqChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSequenceReferenceSeqChild(element : TFhirSequenceReferenceSeq; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'chromosome') then
        element.chromosome := ParseCodeableConcept(child, path+'/chromosome') {b}
      else if (child.localName = 'genomeBuild') then
        element.genomeBuildElement := ParseString(child, path+'/genomeBuild') {b}
      else if (child.localName = 'referenceSeqId') then
        element.referenceSeqId := ParseCodeableConcept(child, path+'/referenceSeqId') {b}
      else if (child.localName = 'referenceSeqPointer') then
        element.referenceSeqPointer := ParseReference{TFhirSequence}(child, path+'/referenceSeqPointer') {b}
      else if (child.localName = 'referenceSeqString') then
        element.referenceSeqStringElement := ParseString(child, path+'/referenceSeqString') {b}
      else if (child.localName = 'strand') then
        element.strandElement := ParseInteger(child, path+'/strand') {b}
      else if (child.localName = 'windowStart') then
        element.windowStartElement := ParseInteger(child, path+'/windowStart') {b}
      else if (child.localName = 'windowEnd') then
        element.windowEndElement := ParseInteger(child, path+'/windowEnd') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSequenceReferenceSeq(xml : TXmlBuilder; name : String; elem : TFhirSequenceReferenceSeq);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSequenceReferenceSeqChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSequenceReferenceSeqChildren(xml : TXmlBuilder; elem : TFhirSequenceReferenceSeq);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'chromosome', elem.chromosome);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'genomeBuild', elem.genomeBuildElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'referenceSeqId', elem.referenceSeqId);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSequence}(xml, 'referenceSeqPointer', elem.referenceSeqPointer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'referenceSeqString', elem.referenceSeqStringElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'strand', elem.strandElement);{x.2b}
  ComposeInteger(xml, 'windowStart', elem.windowStartElement);{x.2b}
  ComposeInteger(xml, 'windowEnd', elem.windowEndElement);{x.2b}
end;

function TFHIRXmlParser.ParseSequenceVariant(element : TMXmlElement; path : string) : TFhirSequenceVariant;
var
  child : TMXmlElement;
begin
  result := TFhirSequenceVariant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSequenceVariantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSequenceVariantChild(element : TFhirSequenceVariant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'start') then
        element.startElement := ParseInteger(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInteger(child, path+'/end') {b}
      else if (child.localName = 'observedAllele') then
        element.observedAlleleElement := ParseString(child, path+'/observedAllele') {b}
      else if (child.localName = 'referenceAllele') then
        element.referenceAlleleElement := ParseString(child, path+'/referenceAllele') {b}
      else if (child.localName = 'cigar') then
        element.cigarElement := ParseString(child, path+'/cigar') {b}
      else if (child.localName = 'variantPointer') then
        element.variantPointer := ParseReference{TFhirObservation}(child, path+'/variantPointer') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSequenceVariant(xml : TXmlBuilder; name : String; elem : TFhirSequenceVariant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSequenceVariantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSequenceVariantChildren(xml : TXmlBuilder; elem : TFhirSequenceVariant);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'observedAllele', elem.observedAlleleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'referenceAllele', elem.referenceAlleleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'cigar', elem.cigarElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirObservation}(xml, 'variantPointer', elem.variantPointer);{x.2a}
end;

function TFHIRXmlParser.ParseSequenceQuality(element : TMXmlElement; path : string) : TFhirSequenceQuality;
var
  child : TMXmlElement;
begin
  result := TFhirSequenceQuality.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSequenceQualityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSequenceQualityChild(element : TFhirSequenceQuality; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'standardSequence') then
        element.standardSequence := ParseCodeableConcept(child, path+'/standardSequence') {b}
      else if (child.localName = 'start') then
        element.startElement := ParseInteger(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInteger(child, path+'/end') {b}
      else if (child.localName = 'score') then
        element.score := ParseQuantity(child, path+'/score') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'truthTP') then
        element.truthTPElement := ParseDecimal(child, path+'/truthTP') {b}
      else if (child.localName = 'queryTP') then
        element.queryTPElement := ParseDecimal(child, path+'/queryTP') {b}
      else if (child.localName = 'truthFN') then
        element.truthFNElement := ParseDecimal(child, path+'/truthFN') {b}
      else if (child.localName = 'queryFP') then
        element.queryFPElement := ParseDecimal(child, path+'/queryFP') {b}
      else if (child.localName = 'gtFP') then
        element.gtFPElement := ParseDecimal(child, path+'/gtFP') {b}
      else if (child.localName = 'precision') then
        element.precisionElement := ParseDecimal(child, path+'/precision') {b}
      else if (child.localName = 'recall') then
        element.recallElement := ParseDecimal(child, path+'/recall') {b}
      else if (child.localName = 'fScore') then
        element.fScore_Element := ParseDecimal(child, path+'/fScore') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSequenceQuality(xml : TXmlBuilder; name : String; elem : TFhirSequenceQuality);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSequenceQualityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSequenceQualityChildren(xml : TXmlBuilder; elem : TFhirSequenceQuality);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirQualityTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'standardSequence', elem.standardSequence);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'score', elem.score);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'truthTP', elem.truthTPElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'queryTP', elem.queryTPElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'truthFN', elem.truthFNElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'queryFP', elem.queryFPElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'gtFP', elem.gtFPElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'precision', elem.precisionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'recall', elem.recallElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'fScore', elem.fScore_Element);{x.2b}
end;

function TFHIRXmlParser.ParseSequenceRepository(element : TMXmlElement; path : string) : TFhirSequenceRepository;
var
  child : TMXmlElement;
begin
  result := TFhirSequenceRepository.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSequenceRepositoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSequenceRepositoryChild(element : TFhirSequenceRepository; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'datasetId') then
        element.datasetIdElement := ParseString(child, path+'/datasetId') {b}
      else if (child.localName = 'variantsetId') then
        element.variantsetIdElement := ParseString(child, path+'/variantsetId') {b}
      else if (child.localName = 'readsetId') then
        element.readsetIdElement := ParseString(child, path+'/readsetId') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSequenceRepository(xml : TXmlBuilder; name : String; elem : TFhirSequenceRepository);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSequenceRepositoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSequenceRepositoryChildren(xml : TXmlBuilder; elem : TFhirSequenceRepository);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirRepositoryTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'datasetId', elem.datasetIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'variantsetId', elem.variantsetIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'readsetId', elem.readsetIdElement);{x.2b}
end;

function TFHIRXmlParser.ParseSequence(element : TMXmlElement; path : string) : TFhirSequence;
var
  child : TMXmlElement;
begin
  result := TFhirSequence.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSequenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSequenceChild(element : TFhirSequence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'type') then
        element.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.localName = 'coordinateSystem') then
        element.coordinateSystemElement := ParseInteger(child, path+'/coordinateSystem') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'specimen') then
        element.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{TFhirOrganization}(child, path+'/performer') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'referenceSeq') then
        element.referenceSeq := ParseSequenceReferenceSeq(child, path+'/referenceSeq') {b}
      else if (child.localName = 'variant') then
        element.variantList.Add(ParseSequenceVariant(child, path+'/variant')){y.2}
      else if (child.localName = 'observedSeq') then
        element.observedSeqElement := ParseString(child, path+'/observedSeq') {b}
      else if (child.localName = 'quality') then
        element.qualityList.Add(ParseSequenceQuality(child, path+'/quality')){y.2}
      else if (child.localName = 'readCoverage') then
        element.readCoverageElement := ParseInteger(child, path+'/readCoverage') {b}
      else if (child.localName = 'repository') then
        element.repositoryList.Add(ParseSequenceRepository(child, path+'/repository')){y.2}
      else if (child.localName = 'pointer') then
        element.pointerList.Add(ParseReference{TFhirSequence}(child, path+'/pointer')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSequence(xml : TXmlBuilder; name : String; elem : TFhirSequence);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSequenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSequenceChildren(xml : TXmlBuilder; elem : TFhirSequence);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCode(xml, 'type', elem.type_Element);{x.2b}
  ComposeInteger(xml, 'coordinateSystem', elem.coordinateSystemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirOrganization}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceSeq') then
    ComposeSequenceReferenceSeq(xml, 'referenceSeq', elem.referenceSeq);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('variant') then
    for i := 0 to elem.variantList.Count - 1 do
      ComposeSequenceVariant(xml, 'variant', elem.variantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('observedSeq') then
    ComposeString(xml, 'observedSeq', elem.observedSeqElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quality') then
    for i := 0 to elem.qualityList.Count - 1 do
      ComposeSequenceQuality(xml, 'quality', elem.qualityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('readCoverage') then
    ComposeInteger(xml, 'readCoverage', elem.readCoverageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repository') then
    for i := 0 to elem.repositoryList.Count - 1 do
      ComposeSequenceRepository(xml, 'repository', elem.repositoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pointer') then
    for i := 0 to elem.pointerList.Count - 1 do
      ComposeReference{TFhirSequence}(xml, 'pointer', elem.pointerList[i]);
end;

{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
function TFHIRXmlParser.ParseServiceDefinition(element : TMXmlElement; path : string) : TFhirServiceDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirServiceDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseServiceDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseServiceDefinitionChild(element : TFhirServiceDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'approvalDate') then
        element.approvalDateElement := ParseDate(child, path+'/approvalDate') {b}
      else if (child.localName = 'lastReviewDate') then
        element.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'topic') then
        element.topicList.Add(ParseCodeableConcept(child, path+'/topic')){y.2}
      else if (child.localName = 'contributor') then
        element.contributorList.Add(ParseContributor(child, path+'/contributor')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'relatedArtifact') then
        element.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact')){y.2}
      else if (child.localName = 'trigger') then
        element.triggerList.Add(ParseTriggerDefinition(child, path+'/trigger')){y.2}
      else if (child.localName = 'dataRequirement') then
        element.dataRequirementList.Add(ParseDataRequirement(child, path+'/dataRequirement')){y.2}
      else if (child.localName = 'operationDefinition') then
        element.operationDefinition := ParseReference{TFhirOperationDefinition}(child, path+'/operationDefinition') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeServiceDefinition(xml : TXmlBuilder; name : String; elem : TFhirServiceDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeServiceDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeServiceDefinitionChildren(xml : TXmlBuilder; elem : TFhirServiceDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(xml, 'approvalDate', elem.approvalDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(xml, 'lastReviewDate', elem.lastReviewDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(xml, 'effectivePeriod', elem.effectivePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', elem.topicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(xml, 'contributor', elem.contributorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', elem.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('trigger') then
    for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(xml, 'trigger', elem.triggerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(xml, 'dataRequirement', elem.dataRequirementList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('operationDefinition') then
    ComposeReference{TFhirOperationDefinition}(xml, 'operationDefinition', elem.operationDefinition);{x.2a}
end;

{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
function TFHIRXmlParser.ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
var
  child : TMXmlElement;
begin
  result := TFhirSlot.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSlotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSlotChild(element : TFhirSlot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'serviceCategory') then
        element.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.localName = 'serviceType') then
        element.serviceTypeList.Add(ParseCodeableConcept(child, path+'/serviceType')){y.2}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'appointmentType') then
        element.appointmentType := ParseCodeableConcept(child, path+'/appointmentType') {b}
      else if (child.localName = 'schedule') then
        element.schedule := ParseReference{TFhirSchedule}(child, path+'/schedule') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, path+'/status', child){1a}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'overbooked') then
        element.overbookedElement := ParseBoolean(child, path+'/overbooked') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : String; elem : TFhirSlot);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSlotChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSlotChildren(xml : TXmlBuilder; elem : TFhirSlot);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceType', elem.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(xml, 'appointmentType', elem.appointmentType);{x.2a}
  ComposeReference{TFhirSchedule}(xml, 'schedule', elem.schedule);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSlotstatusEnum);
  ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBoolean(xml, 'overbooked', elem.overbookedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRXmlParser.ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenCollectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenCollectionChild(element : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'collector') then
        element.collector := ParseReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.localName = 'collectedPeriod') then
        element.collected := ParsePeriod(child, path+'/collectedPeriod'){x.3}
      else if (child.localName = 'collectedDateTime') then
        element.collected := ParseDateTime(child, path+'/collectedDateTime'){x.3}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : String; elem : TFhirSpecimenCollection);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenCollectionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollectionChildren(xml : TXmlBuilder; elem : TFhirSpecimenCollection);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'collector', elem.collector);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
end;

function TFHIRXmlParser.ParseSpecimenProcessing(element : TMXmlElement; path : string) : TFhirSpecimenProcessing;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenProcessing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenProcessingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenProcessingChild(element : TFhirSpecimenProcessing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'procedure') then
        element.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.localName = 'additive') then
        element.additiveList.Add(ParseReference{TFhirSubstance}(child, path+'/additive')){y.2}
      else if (child.localName = 'timePeriod') then
        element.time := ParsePeriod(child, path+'/timePeriod'){x.3}
      else if (child.localName = 'timeDateTime') then
        element.time := ParseDateTime(child, path+'/timeDateTime'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenProcessing(xml : TXmlBuilder; name : String; elem : TFhirSpecimenProcessing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenProcessingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenProcessingChildren(xml : TXmlBuilder; elem : TFhirSpecimenProcessing);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'procedure', elem.procedure_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timePeriod', TFhirPeriod(elem.time))
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timeDateTime', TFhirDateTime(elem.time));
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenContainerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenContainerChild(element : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'capacity') then
        element.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.localName = 'specimenQuantity') then
        element.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.localName = 'additiveCodeableConcept') then
        element.additive := ParseCodeableConcept(child, path+'/additiveCodeableConcept'){x.3}
      else if (child.localName = 'additiveReference') then
        element.additive := ParseReference(child, path+'/additiveReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : String; elem : TFhirSpecimenContainer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenContainerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainerChildren(xml : TXmlBuilder; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'capacity', elem.capacity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive))
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(xml, 'additiveReference', TFhirReference(elem.additive));
end;

function TFHIRXmlParser.ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimen.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenChild(element : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'accessionIdentifier') then
        element.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'receivedTime') then
        element.receivedTimeElement := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.localName = 'parent') then
        element.parentList.Add(ParseReference{TFhirSpecimen}(child, path+'/parent')){y.2}
      else if (child.localName = 'request') then
        element.requestList.Add(ParseReference{TFhirProcedureRequest}(child, path+'/request')){y.2}
      else if (child.localName = 'collection') then
        element.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.localName = 'processing') then
        element.processingList.Add(ParseSpecimenProcessing(child, path+'/processing')){y.2}
      else if (child.localName = 'container') then
        element.containerList.Add(ParseSpecimenContainer(child, path+'/container')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : String; elem : TFhirSpecimen);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenChildren(xml : TXmlBuilder; elem : TFhirSpecimen);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTime(xml, 'receivedTime', elem.receivedTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'parent', elem.parentList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirProcedureRequest}(xml, 'request', elem.requestList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(xml, 'collection', elem.collection);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') then
    for i := 0 to elem.processingList.Count - 1 do
      ComposeSpecimenProcessing(xml, 'processing', elem.processingList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('container') then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRXmlParser.ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionMappingChild(element : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionMapping);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionSnapshotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshotChild(element : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionSnapshot);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionSnapshotChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionSnapshot);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionDifferentialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferentialChild(element : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionDifferential);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionDifferentialChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionDifferential);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionChild(element : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'keyword') then
        element.keywordList.Add(ParseCoding(child, path+'/keyword')){y.2}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseStructureDefinitionMapping(child, path+'/mapping')){y.2}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'abstract') then
        element.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.localName = 'contextType') then
        element.contextTypeElement := ParseEnum(CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, path+'/contextType', child){1a}
      else if (child.localName = 'context') then
        element.contextList.Add(ParseString(child, path+'/context')){y.2}
      else if (child.localName = 'contextInvariant') then
        element.contextInvariantList.Add(ParseString(child, path+'/contextInvariant')){y.2}
      else if (child.localName = 'type') then
        element.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.localName = 'baseDefinition') then
        element.baseDefinitionElement := ParseUri(child, path+'/baseDefinition') {b}
      else if (child.localName = 'derivation') then
        element.derivationElement := ParseEnum(CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum, path+'/derivation', child){1a}
      else if (child.localName = 'snapshot') then
        element.snapshot := ParseStructureDefinitionSnapshot(child, path+'/snapshot') {b}
      else if (child.localName = 'differential') then
        element.differential := ParseStructureDefinitionDifferential(child, path+'/differential') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinition(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionChildren(xml : TXmlBuilder; elem : TFhirStructureDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCoding(xml, 'keyword', elem.keywordList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum);
  ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnum(xml, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(xml, 'context', elem.contextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextInvariant') then
    for i := 0 to elem.contextInvariantList.Count - 1 do
      ComposeString(xml, 'contextInvariant', elem.contextInvariantList[i]);
  ComposeCode(xml, 'type', elem.type_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('baseDefinition') then
    ComposeUri(xml, 'baseDefinition', elem.baseDefinitionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivation') then
    ComposeEnum(xml, 'derivation', elem.DerivationElement, CODES_TFhirTypeDerivationRuleEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(xml, 'snapshot', elem.snapshot);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(xml, 'differential', elem.differential);{x.2a}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
function TFHIRXmlParser.ParseStructureMapStructure(element : TMXmlElement; path : string) : TFhirStructureMapStructure;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapStructure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapStructureChild(element : TFhirStructureMapStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'alias') then
        element.aliasElement := ParseString(child, path+'/alias') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapStructure(xml : TXmlBuilder; name : String; elem : TFhirStructureMapStructure);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapStructureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapStructureChildren(xml : TXmlBuilder; elem : TFhirStructureMapStructure);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirMapModelModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'alias', elem.aliasElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureMapGroup(element : TMXmlElement; path : string) : TFhirStructureMapGroup;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupChild(element : TFhirStructureMapGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseId(child, path+'/name') {b}
      else if (child.localName = 'extends') then
        element.extendsElement := ParseId(child, path+'/extends') {b}
      else if (child.localName = 'typeMode') then
        element.typeModeElement := ParseEnum(CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum, path+'/typeMode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'input') then
        element.inputList.Add(ParseStructureMapGroupInput(child, path+'/input')){y.2}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseStructureMapGroupRule(child, path+'/rule')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroup(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'extends', elem.extendsElement);{x.2b}
  ComposeEnum(xml, 'typeMode', elem.TypeModeElement, CODES_TFhirMapGroupTypeModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  for i := 0 to elem.inputList.Count - 1 do
      ComposeStructureMapGroupInput(xml, 'input', elem.inputList[i]);
  for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(xml, 'rule', elem.ruleList[i]);
end;

function TFHIRXmlParser.ParseStructureMapGroupInput(element : TMXmlElement; path : string) : TFhirStructureMapGroupInput;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupInputChild(element : TFhirStructureMapGroupInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseId(child, path+'/name') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseString(child, path+'/type') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupInput(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupInput);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupInputChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupInputChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupInput);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', elem.type_Element);{x.2b}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirMapInputModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureMapGroupRule(element : TMXmlElement; path : string) : TFhirStructureMapGroupRule;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleChild(element : TFhirStructureMapGroupRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseId(child, path+'/name') {b}
      else if (child.localName = 'source') then
        element.sourceList.Add(ParseStructureMapGroupRuleSource(child, path+'/source')){y.2}
      else if (child.localName = 'target') then
        element.targetList.Add(ParseStructureMapGroupRuleTarget(child, path+'/target')){y.2}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseStructureMapGroupRule(child, path+'/rule')){y.2}
      else if (child.localName = 'dependent') then
        element.dependentList.Add(ParseStructureMapGroupRuleDependent(child, path+'/dependent')){y.2}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRule(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'name', elem.nameElement);{x.2b}
  for i := 0 to elem.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(xml, 'source', elem.sourceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(xml, 'target', elem.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(xml, 'rule', elem.ruleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(xml, 'dependent', elem.dependentList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleSource(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleSource;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleSourceChild(element : TFhirStructureMapGroupRuleSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'context') then
        element.contextElement := ParseId(child, path+'/context') {b}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseString(child, path+'/type') {b}
      else if (child.localName = 'defaultValueCode') then
        element.defaultValue := ParseCode(child, path+'/defaultValueCode'){x.3}
      else if (child.localName = 'defaultValueId') then
        element.defaultValue := ParseId(child, path+'/defaultValueId'){x.3}
      else if (child.localName = 'defaultValueMarkdown') then
        element.defaultValue := ParseMarkdown(child, path+'/defaultValueMarkdown'){x.3}
      else if (child.localName = 'defaultValueOid') then
        element.defaultValue := ParseOid(child, path+'/defaultValueOid'){x.3}
      else if (child.localName = 'defaultValuePositiveInt') then
        element.defaultValue := ParsePositiveInt(child, path+'/defaultValuePositiveInt'){x.3}
      else if (child.localName = 'defaultValueUnsignedInt') then
        element.defaultValue := ParseUnsignedInt(child, path+'/defaultValueUnsignedInt'){x.3}
      else if (child.localName = 'defaultValueAddress') then
        element.defaultValue := ParseAddress(child, path+'/defaultValueAddress'){x.3}
      else if (child.localName = 'defaultValueAge') then
        element.defaultValue := ParseAge(child, path+'/defaultValueAge'){x.3}
      else if (child.localName = 'defaultValueAnnotation') then
        element.defaultValue := ParseAnnotation(child, path+'/defaultValueAnnotation'){x.3}
      else if (child.localName = 'defaultValueAttachment') then
        element.defaultValue := ParseAttachment(child, path+'/defaultValueAttachment'){x.3}
      else if (child.localName = 'defaultValueCodeableConcept') then
        element.defaultValue := ParseCodeableConcept(child, path+'/defaultValueCodeableConcept'){x.3}
      else if (child.localName = 'defaultValueCoding') then
        element.defaultValue := ParseCoding(child, path+'/defaultValueCoding'){x.3}
      else if (child.localName = 'defaultValueContactPoint') then
        element.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint'){x.3}
      else if (child.localName = 'defaultValueCount') then
        element.defaultValue := ParseCount(child, path+'/defaultValueCount'){x.3}
      else if (child.localName = 'defaultValueDistance') then
        element.defaultValue := ParseDistance(child, path+'/defaultValueDistance'){x.3}
      else if (child.localName = 'defaultValueDuration') then
        element.defaultValue := ParseDuration(child, path+'/defaultValueDuration'){x.3}
      else if (child.localName = 'defaultValueHumanName') then
        element.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName'){x.3}
      else if (child.localName = 'defaultValueIdentifier') then
        element.defaultValue := ParseIdentifier(child, path+'/defaultValueIdentifier'){x.3}
      else if (child.localName = 'defaultValueMoney') then
        element.defaultValue := ParseMoney(child, path+'/defaultValueMoney'){x.3}
      else if (child.localName = 'defaultValuePeriod') then
        element.defaultValue := ParsePeriod(child, path+'/defaultValuePeriod'){x.3}
      else if (child.localName = 'defaultValueQuantity') then
        element.defaultValue := ParseQuantity(child, path+'/defaultValueQuantity'){x.3}
      else if (child.localName = 'defaultValueRange') then
        element.defaultValue := ParseRange(child, path+'/defaultValueRange'){x.3}
      else if (child.localName = 'defaultValueRatio') then
        element.defaultValue := ParseRatio(child, path+'/defaultValueRatio'){x.3}
      else if (child.localName = 'defaultValueReference') then
        element.defaultValue := ParseReference(child, path+'/defaultValueReference'){x.3}
      else if (child.localName = 'defaultValueSampledData') then
        element.defaultValue := ParseSampledData(child, path+'/defaultValueSampledData'){x.3}
      else if (child.localName = 'defaultValueSignature') then
        element.defaultValue := ParseSignature(child, path+'/defaultValueSignature'){x.3}
      else if (child.localName = 'defaultValueTiming') then
        element.defaultValue := ParseTiming(child, path+'/defaultValueTiming'){x.3}
      else if (child.localName = 'defaultValueMeta') then
        element.defaultValue := ParseMeta(child, path+'/defaultValueMeta'){x.3}
      else if (child.localName = 'defaultValueBase64Binary') then
        element.defaultValue := ParseBase64Binary(child, path+'/defaultValueBase64Binary'){x.3}
      else if (child.localName = 'defaultValueBoolean') then
        element.defaultValue := ParseBoolean(child, path+'/defaultValueBoolean'){x.3}
      else if (child.localName = 'defaultValueDate') then
        element.defaultValue := ParseDate(child, path+'/defaultValueDate'){x.3}
      else if (child.localName = 'defaultValueDateTime') then
        element.defaultValue := ParseDateTime(child, path+'/defaultValueDateTime'){x.3}
      else if (child.localName = 'defaultValueDecimal') then
        element.defaultValue := ParseDecimal(child, path+'/defaultValueDecimal'){x.3}
      else if (child.localName = 'defaultValueInstant') then
        element.defaultValue := ParseInstant(child, path+'/defaultValueInstant'){x.3}
      else if (child.localName = 'defaultValueInteger') then
        element.defaultValue := ParseInteger(child, path+'/defaultValueInteger'){x.3}
      else if (child.localName = 'defaultValueString') then
        element.defaultValue := ParseString(child, path+'/defaultValueString'){x.3}
      else if (child.localName = 'defaultValueTime') then
        element.defaultValue := ParseTime(child, path+'/defaultValueTime'){x.3}
      else if (child.localName = 'defaultValueUri') then
        element.defaultValue := ParseUri(child, path+'/defaultValueUri'){x.3}
      else if (child.localName = 'element') then
        element.elementElement := ParseString(child, path+'/element') {b}
      else if (child.localName = 'listMode') then
        element.listModeElement := ParseEnum(CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum, path+'/listMode', child){1a}
      else if (child.localName = 'variable') then
        element.variableElement := ParseId(child, path+'/variable') {b}
      else if (child.localName = 'condition') then
        element.conditionElement := ParseString(child, path+'/condition') {b}
      else if (child.localName = 'check') then
        element.checkElement := ParseString(child, path+'/check') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleSource(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupRuleSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleSourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleSourceChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleSource);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'context', elem.contextElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', elem.type_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(xml, 'defaultValueId', TFhirId(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(xml, 'defaultValueAge', TFhirAge(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(xml, 'defaultValueCount', TFhirCount(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(xml, 'defaultValueDistance', TFhirDistance(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(xml, 'defaultValueDuration', TFhirDuration(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(xml, 'defaultValueMoney', TFhirMoney(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMeta) {6} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(xml, 'defaultValueString', TFhirString(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'element', elem.elementElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'listMode', elem.ListModeElement, CODES_TFhirMapSourceListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'variable', elem.variableElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'condition', elem.conditionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'check', elem.checkElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTarget(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTarget;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetChild(element : TFhirStructureMapGroupRuleTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'context') then
        element.contextElement := ParseId(child, path+'/context') {b}
      else if (child.localName = 'contextType') then
        element.contextTypeElement := ParseEnum(CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum, path+'/contextType', child){1a}
      else if (child.localName = 'element') then
        element.elementElement := ParseString(child, path+'/element') {b}
      else if (child.localName = 'variable') then
        element.variableElement := ParseId(child, path+'/variable') {b}
      else if (child.localName = 'listMode') then
        element.listModeList.Add(ParseEnum(CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum, path+'/listMode', child)){y.1}
      else if (child.localName = 'listRuleId') then
        element.listRuleIdElement := ParseId(child, path+'/listRuleId') {b}
      else if (child.localName = 'transform') then
        element.transformElement := ParseEnum(CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum, path+'/transform', child){1a}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseStructureMapGroupRuleTargetParameter(child, path+'/parameter')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTarget(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupRuleTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'context', elem.contextElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'contextType', elem.ContextTypeElement, CODES_TFhirMapContextTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'element', elem.elementElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'variable', elem.variableElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.listModeList.Count - 1 do
      ComposeEnum(xml, 'listMode', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'listRuleId', elem.listRuleIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'transform', elem.TransformElement, CODES_TFhirMapTransformEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(xml, 'parameter', elem.parameterList[i]);
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetParameter(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTargetParameter;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleTargetParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetParameterChild(element : TFhirStructureMapGroupRuleTargetParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetParameter(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupRuleTargetParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleTargetParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetParameterChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleTargetParameter);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value));
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleDependent(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleDependent;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleDependentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleDependentChild(element : TFhirStructureMapGroupRuleDependent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseId(child, path+'/name') {b}
      else if (child.localName = 'variable') then
        element.variableList.Add(ParseString(child, path+'/variable')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleDependent(xml : TXmlBuilder; name : String; elem : TFhirStructureMapGroupRuleDependent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleDependentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleDependentChildren(xml : TXmlBuilder; elem : TFhirStructureMapGroupRuleDependent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'name', elem.nameElement);{x.2b}
  for i := 0 to elem.variableList.Count - 1 do
      ComposeString(xml, 'variable', elem.variableList[i]);
end;

function TFHIRXmlParser.ParseStructureMap(element : TMXmlElement; path : string) : TFhirStructureMap;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMap.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapChild(element : TFhirStructureMap; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'structure') then
        element.structureList.Add(ParseStructureMapStructure(child, path+'/structure')){y.2}
      else if (child.localName = 'import') then
        element.importList.Add(ParseUri(child, path+'/import')){y.2}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseStructureMapGroup(child, path+'/group')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMap(xml : TXmlBuilder; name : String; elem : TFhirStructureMap);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapChildren(xml : TXmlBuilder; elem : TFhirStructureMap);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') then
    for i := 0 to elem.structureList.Count - 1 do
      ComposeStructureMapStructure(xml, 'structure', elem.structureList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('import') then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(xml, 'import', elem.importList[i]);
  for i := 0 to elem.groupList.Count - 1 do
      ComposeStructureMapGroup(xml, 'group', elem.groupList[i]);
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRXmlParser.ParseSubscriptionChannel(element : TMXmlElement; path : string) : TFhirSubscriptionChannel;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionChannelChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChannelChild(element : TFhirSubscriptionChannel; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if (child.localName = 'payload') then
        element.payloadElement := ParseString(child, path+'/payload') {b}
      else if (child.localName = 'header') then
        element.headerList.Add(ParseString(child, path+'/header')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannel(xml : TXmlBuilder; name : String; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionChannelChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannelChildren(xml : TXmlBuilder; elem : TFhirSubscriptionChannel);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'payload', elem.payloadElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(xml, 'header', elem.headerList[i]);
end;

function TFHIRXmlParser.ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
var
  child : TMXmlElement;
begin
  result := TFhirSubscription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChild(element : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'reason') then
        element.reasonElement := ParseString(child, path+'/reason') {b}
      else if (child.localName = 'criteria') then
        element.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.localName = 'error') then
        element.errorElement := ParseString(child, path+'/error') {b}
      else if (child.localName = 'channel') then
        element.channel := ParseSubscriptionChannel(child, path+'/channel') {b}
      else if (child.localName = 'tag') then
        element.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : String; elem : TFhirSubscription);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChildren(xml : TXmlBuilder; elem : TFhirSubscription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  ComposeString(xml, 'reason', elem.reasonElement);{x.2b}
  ComposeString(xml, 'criteria', elem.criteriaElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeString(xml, 'error', elem.errorElement);{x.2b}
  ComposeSubscriptionChannel(xml, 'channel', elem.channel);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tag') then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(xml, 'tag', elem.tagList[i]);
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRXmlParser.ParseSubstanceInstance(element : TMXmlElement; path : string) : TFhirSubstanceInstance;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceInstanceChild(element : TFhirSubstanceInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'expiry') then
        element.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : String; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstanceChildren(xml : TXmlBuilder; elem : TFhirSubstanceInstance);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceIngredientChild(element : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        element.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.localName = 'substanceCodeableConcept') then
        element.substance := ParseCodeableConcept(child, path+'/substanceCodeableConcept'){x.3}
      else if (child.localName = 'substanceReference') then
        element.substance := ParseReference(child, path+'/substanceReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : String; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceIngredientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredientChildren(xml : TXmlBuilder; elem : TFhirSubstanceIngredient);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'quantity', elem.quantity);{x.2a}
  if (elem.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance))
  else if (elem.substance is TFhirReference) {2} then
    ComposeReference(xml, 'substanceReference', TFhirReference(elem.substance));
end;

function TFHIRXmlParser.ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
var
  child : TMXmlElement;
begin
  result := TFhirSubstance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceChild(element : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseSubstanceInstance(child, path+'/instance')){y.2}
      else if (child.localName = 'ingredient') then
        element.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : String; elem : TFhirSubstance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceChildren(xml : TXmlBuilder; elem : TFhirSubstance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSubstanceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(xml, 'instance', elem.instanceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRXmlParser.ParseSupplyDeliverySuppliedItem(element : TMXmlElement; path : string) : TFhirSupplyDeliverySuppliedItem;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyDeliverySuppliedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyDeliverySuppliedItemChild(element : TFhirSupplyDeliverySuppliedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'itemCodeableConcept') then
        element.item := ParseCodeableConcept(child, path+'/itemCodeableConcept'){x.3}
      else if (child.localName = 'itemReference') then
        element.item := ParseReference(child, path+'/itemReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliverySuppliedItem(xml : TXmlBuilder; name : String; elem : TFhirSupplyDeliverySuppliedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyDeliverySuppliedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliverySuppliedItemChildren(xml : TXmlBuilder; elem : TFhirSupplyDeliverySuppliedItem);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(elem.item))
  else if (SummaryOption in [soFull, soData]) and (elem.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(elem.item));
end;

function TFHIRXmlParser.ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyDelivery.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyDeliveryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyDeliveryChild(element : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirSupplyRequest}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{Resource}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'suppliedItem') then
        element.suppliedItem := ParseSupplyDeliverySuppliedItem(child, path+'/suppliedItem') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceTiming') then
        element.occurrence := ParseTiming(child, path+'/occurrenceTiming'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'supplier') then
        element.supplier := ParseReference{Resource}(child, path+'/supplier') {b}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'receiver') then
        element.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyDelivery(xml : TXmlBuilder; name : String; elem : TFhirSupplyDelivery);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyDeliveryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliveryChildren(xml : TXmlBuilder; elem : TFhirSupplyDelivery);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirSupplyRequest}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(xml, 'partOf', elem.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('suppliedItem') then
    ComposeSupplyDeliverySuppliedItem(xml, 'suppliedItem', elem.suppliedItem);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soData]) and doCompose('supplier') then
    ComposeReference{Resource}(xml, 'supplier', elem.supplier);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRXmlParser.ParseSupplyRequestOrderedItem(element : TMXmlElement; path : string) : TFhirSupplyRequestOrderedItem;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequestOrderedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestOrderedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestOrderedItemChild(element : TFhirSupplyRequestOrderedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'itemCodeableConcept') then
        element.item := ParseCodeableConcept(child, path+'/itemCodeableConcept'){x.3}
      else if (child.localName = 'itemReference') then
        element.item := ParseReference(child, path+'/itemReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestOrderedItem(xml : TXmlBuilder; name : String; elem : TFhirSupplyRequestOrderedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestOrderedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestOrderedItemChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestOrderedItem);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(elem.item))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(elem.item));
end;

function TFHIRXmlParser.ParseSupplyRequestRequester(element : TMXmlElement; path : string) : TFhirSupplyRequestRequester;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequestRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestRequesterChild(element : TFhirSupplyRequestRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestRequester(xml : TXmlBuilder; name : String; elem : TFhirSupplyRequestRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestRequesterChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestChild(element : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'orderedItem') then
        element.orderedItem := ParseSupplyRequestOrderedItem(child, path+'/orderedItem') {b}
      else if (child.localName = 'occurrencePeriod') then
        element.occurrence := ParsePeriod(child, path+'/occurrencePeriod'){x.3}
      else if (child.localName = 'occurrenceTiming') then
        element.occurrence := ParseTiming(child, path+'/occurrenceTiming'){x.3}
      else if (child.localName = 'occurrenceDateTime') then
        element.occurrence := ParseDateTime(child, path+'/occurrenceDateTime'){x.3}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseSupplyRequestRequester(child, path+'/requester') {b}
      else if (child.localName = 'supplier') then
        element.supplierList.Add(ParseReference{TFhirOrganization}(child, path+'/supplier')){y.2}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'deliverFrom') then
        element.deliverFrom := ParseReference{Resource}(child, path+'/deliverFrom') {b}
      else if (child.localName = 'deliverTo') then
        element.deliverTo := ParseReference{Resource}(child, path+'/deliverTo') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequest(xml : TXmlBuilder; name : String; elem : TFhirSupplyRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestChildren(xml : TXmlBuilder; elem : TFhirSupplyRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedItem') then
    ComposeSupplyRequestOrderedItem(xml, 'orderedItem', elem.orderedItem);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(elem.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(elem.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeSupplyRequestRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'supplier', elem.supplierList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soData]) and doCompose('deliverFrom') then
    ComposeReference{Resource}(xml, 'deliverFrom', elem.deliverFrom);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverTo') then
    ComposeReference{Resource}(xml, 'deliverTo', elem.deliverTo);{x.2a}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
function TFHIRXmlParser.ParseTaskRequester(element : TMXmlElement; path : string) : TFhirTaskRequester;
var
  child : TMXmlElement;
begin
  result := TFhirTaskRequester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskRequesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskRequesterChild(element : TFhirTaskRequester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'agent') then
        element.agent := ParseReference{Resource}(child, path+'/agent') {b}
      else if (child.localName = 'onBehalfOf') then
        element.onBehalfOf := ParseReference{TFhirOrganization}(child, path+'/onBehalfOf') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskRequester(xml : TXmlBuilder; name : String; elem : TFhirTaskRequester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskRequesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskRequesterChildren(xml : TXmlBuilder; elem : TFhirTaskRequester);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'agent', elem.agent);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'onBehalfOf', elem.onBehalfOf);{x.2a}
end;

function TFHIRXmlParser.ParseTaskRestriction(element : TMXmlElement; path : string) : TFhirTaskRestriction;
var
  child : TMXmlElement;
begin
  result := TFhirTaskRestriction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskRestrictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskRestrictionChild(element : TFhirTaskRestriction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'repetitions') then
        element.repetitionsElement := ParsePositiveInt(child, path+'/repetitions') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskRestriction(xml : TXmlBuilder; name : String; elem : TFhirTaskRestriction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskRestrictionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskRestrictionChildren(xml : TXmlBuilder; elem : TFhirTaskRestriction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'repetitions', elem.repetitionsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
end;

function TFHIRXmlParser.ParseTaskInput(element : TMXmlElement; path : string) : TFhirTaskInput;
var
  child : TMXmlElement;
begin
  result := TFhirTaskInput.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskInputChild(element : TFhirTaskInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'/valueMarkdown'){x.3}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'/valueOid'){x.3}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'/valuePositiveInt'){x.3}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'/valueUnsignedInt'){x.3}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress'){x.3}
      else if (child.localName = 'valueAge') then
        element.value := ParseAge(child, path+'/valueAge'){x.3}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'/valueAnnotation'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint'){x.3}
      else if (child.localName = 'valueCount') then
        element.value := ParseCount(child, path+'/valueCount'){x.3}
      else if (child.localName = 'valueDistance') then
        element.value := ParseDistance(child, path+'/valueDistance'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName'){x.3}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'/valueIdentifier'){x.3}
      else if (child.localName = 'valueMoney') then
        element.value := ParseMoney(child, path+'/valueMoney'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'/valueSignature'){x.3}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming'){x.3}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta'){x.3}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'/valueBase64Binary'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskInput(xml : TXmlBuilder; name : String; elem : TFhirTaskInput);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskInputChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskInputChildren(xml : TXmlBuilder; elem : TFhirTaskInput);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(elem.value))
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(elem.value))
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(elem.value))
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseTaskOutput(element : TMXmlElement; path : string) : TFhirTaskOutput;
var
  child : TMXmlElement;
begin
  result := TFhirTaskOutput.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskOutputChild(element : TFhirTaskOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'/valueId'){x.3}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'/valueMarkdown'){x.3}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'/valueOid'){x.3}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'/valuePositiveInt'){x.3}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'/valueUnsignedInt'){x.3}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress'){x.3}
      else if (child.localName = 'valueAge') then
        element.value := ParseAge(child, path+'/valueAge'){x.3}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'/valueAnnotation'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint'){x.3}
      else if (child.localName = 'valueCount') then
        element.value := ParseCount(child, path+'/valueCount'){x.3}
      else if (child.localName = 'valueDistance') then
        element.value := ParseDistance(child, path+'/valueDistance'){x.3}
      else if (child.localName = 'valueDuration') then
        element.value := ParseDuration(child, path+'/valueDuration'){x.3}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName'){x.3}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'/valueIdentifier'){x.3}
      else if (child.localName = 'valueMoney') then
        element.value := ParseMoney(child, path+'/valueMoney'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'/valueSignature'){x.3}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming'){x.3}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta'){x.3}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'/valueBase64Binary'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskOutput(xml : TXmlBuilder; name : String; elem : TFhirTaskOutput);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskOutputChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskOutputChildren(xml : TXmlBuilder; elem : TFhirTaskOutput);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(elem.value))
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(elem.value))
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(elem.value))
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(elem.value))
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value))
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseTask(element : TMXmlElement; path : string) : TFhirTask;
var
  child : TMXmlElement;
begin
  result := TFhirTask.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskChild(element : TFhirTask; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'definitionReference') then
        element.definition := ParseReference(child, path+'/definitionReference') {a}
      else if (child.localName = 'definitionUri') then
        element.definition := ParseUri(child, path+'/definitionUri'){x.3}
      else if (child.localName = 'basedOn') then
        element.basedOnList.Add(ParseReference{TFhirReference}(child, path+'/basedOn')){y.2}
      else if (child.localName = 'groupIdentifier') then
        element.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier') {b}
      else if (child.localName = 'partOf') then
        element.partOfList.Add(ParseReference{TFhirTask}(child, path+'/partOf')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusReason') then
        element.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.localName = 'businessStatus') then
        element.businessStatus := ParseCodeableConcept(child, path+'/businessStatus') {b}
      else if (child.localName = 'intent') then
        element.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, path+'/intent', child){1a}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'focus') then
        element.focus := ParseReference{TFhirReference}(child, path+'/focus') {b}
      else if (child.localName = 'for') then
        element.for_ := ParseReference{TFhirReference}(child, path+'/for') {b}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'executionPeriod') then
        element.executionPeriod := ParsePeriod(child, path+'/executionPeriod') {b}
      else if (child.localName = 'authoredOn') then
        element.authoredOnElement := ParseDateTime(child, path+'/authoredOn') {b}
      else if (child.localName = 'lastModified') then
        element.lastModifiedElement := ParseDateTime(child, path+'/lastModified') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseTaskRequester(child, path+'/requester') {b}
      else if (child.localName = 'performerType') then
        element.performerTypeList.Add(ParseCodeableConcept(child, path+'/performerType')){y.2}
      else if (child.localName = 'owner') then
        element.owner := ParseReference{Resource}(child, path+'/owner') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'relevantHistory') then
        element.relevantHistoryList.Add(ParseReference{TFhirProvenance}(child, path+'/relevantHistory')){y.2}
      else if (child.localName = 'restriction') then
        element.restriction := ParseTaskRestriction(child, path+'/restriction') {b}
      else if (child.localName = 'input') then
        element.inputList.Add(ParseTaskInput(child, path+'/input')){y.2}
      else if (child.localName = 'output') then
        element.outputList.Add(ParseTaskOutput(child, path+'/output')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTask(xml : TXmlBuilder; name : String; elem : TFhirTask);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskChildren(xml : TXmlBuilder; elem : TFhirTask);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.definition is TFhirReference) {2} then
    ComposeReference(xml, 'definitionReference', TFhirReference(elem.definition))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.definition is TFhirUri) {6} then
    ComposeUri(xml, 'definitionUri', TFhirUri(elem.definition));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basedOn', elem.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(xml, 'groupIdentifier', elem.groupIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirTask}(xml, 'partOf', elem.partOfList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirTaskStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('businessStatus') then
    ComposeCodeableConcept(xml, 'businessStatus', elem.businessStatus);{x.2a}
  ComposeEnum(xml, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    ComposeReference{TFhirReference}(xml, 'focus', elem.focus);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('for_') then
    ComposeReference{TFhirReference}(xml, 'for', elem.for_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('executionPeriod') then
    ComposePeriod(xml, 'executionPeriod', elem.executionPeriod);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(xml, 'authoredOn', elem.authoredOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastModified') then
    ComposeDateTime(xml, 'lastModified', elem.lastModifiedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeTaskRequester(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('performerType') then
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'performerType', elem.performerTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{Resource}(xml, 'owner', elem.owner);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(xml, 'relevantHistory', elem.relevantHistoryList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('restriction') then
    ComposeTaskRestriction(xml, 'restriction', elem.restriction);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('input') then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeTaskInput(xml, 'input', elem.inputList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('output') then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeTaskOutput(xml, 'output', elem.outputList[i]);
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
function TFHIRXmlParser.ParseTestReportParticipant(element : TMXmlElement; path : string) : TFhirTestReportParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportParticipantChild(element : TFhirTestReportParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportParticipant(xml : TXmlBuilder; name : String; elem : TFhirTestReportParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportParticipantChildren(xml : TXmlBuilder; elem : TFhirTestReportParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirReportParticipantTypeEnum);
  ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestReportSetup(element : TMXmlElement; path : string) : TFhirTestReportSetup;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupChild(element : TFhirTestReportSetup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionList.Add(ParseTestReportSetupAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetup(xml : TXmlBuilder; name : String; elem : TFhirTestReportSetup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupChildren(xml : TXmlBuilder; elem : TFhirTestReportSetup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportSetupAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportSetupAction(element : TMXmlElement; path : string) : TFhirTestReportSetupAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionChild(element : TFhirTestReportSetupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestReportSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestReportSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupAction(xml : TXmlBuilder; name : String; elem : TFhirTestReportSetupAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestReportSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestReportSetupActionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionOperationChild(element : TFhirTestReportSetupActionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'result') then
        element.resultElement := ParseEnum(CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, path+'/result', child){1a}
      else if (child.localName = 'message') then
        element.messageElement := ParseMarkdown(child, path+'/message') {b}
      else if (child.localName = 'detail') then
        element.detailElement := ParseUri(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionOperation(xml : TXmlBuilder; name : String; elem : TFhirTestReportSetupActionOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionOperationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupActionOperation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'message', elem.messageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'detail', elem.detailElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestReportSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestReportSetupActionAssert;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionAssertChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionAssertChild(element : TFhirTestReportSetupActionAssert; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'result') then
        element.resultElement := ParseEnum(CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, path+'/result', child){1a}
      else if (child.localName = 'message') then
        element.messageElement := ParseMarkdown(child, path+'/message') {b}
      else if (child.localName = 'detail') then
        element.detailElement := ParseString(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionAssert(xml : TXmlBuilder; name : String; elem : TFhirTestReportSetupActionAssert);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionAssertChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestReportSetupActionAssert);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'message', elem.messageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'detail', elem.detailElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestReportTest(element : TMXmlElement; path : string) : TFhirTestReportTest;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTestChild(element : TFhirTestReportTest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseTestReportTestAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTest(xml : TXmlBuilder; name : String; elem : TFhirTestReportTest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestChildren(xml : TXmlBuilder; elem : TFhirTestReportTest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTestAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportTestAction(element : TMXmlElement; path : string) : TFhirTestReportTestAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTestAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTestActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTestActionChild(element : TFhirTestReportTestAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestReportSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestReportSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestAction(xml : TXmlBuilder; name : String; elem : TFhirTestReportTestAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTestActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestActionChildren(xml : TXmlBuilder; elem : TFhirTestReportTestAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestReportTeardown(element : TMXmlElement; path : string) : TFhirTestReportTeardown;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTeardown.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTeardownChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTeardownChild(element : TFhirTestReportTeardown; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionList.Add(ParseTestReportTeardownAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardown(xml : TXmlBuilder; name : String; elem : TFhirTestReportTeardown);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTeardownChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownChildren(xml : TXmlBuilder; elem : TFhirTestReportTeardown);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTeardownAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportTeardownAction(element : TMXmlElement; path : string) : TFhirTestReportTeardownAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTeardownActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTeardownActionChild(element : TFhirTestReportTeardownAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestReportSetupActionOperation(child, path+'/operation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownAction(xml : TXmlBuilder; name : String; elem : TFhirTestReportTeardownAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTeardownActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestReportTeardownAction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeTestReportSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
end;

function TFHIRXmlParser.ParseTestReport(element : TMXmlElement; path : string) : TFhirTestReport;
var
  child : TMXmlElement;
begin
  result := TFhirTestReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportChild(element : TFhirTestReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum, path+'/status', child){1a}
      else if (child.localName = 'testScript') then
        element.testScript := ParseReference{TFhirTestScript}(child, path+'/testScript') {b}
      else if (child.localName = 'result') then
        element.resultElement := ParseEnum(CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum, path+'/result', child){1a}
      else if (child.localName = 'score') then
        element.scoreElement := ParseDecimal(child, path+'/score') {b}
      else if (child.localName = 'tester') then
        element.testerElement := ParseString(child, path+'/tester') {b}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseTestReportParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'setup') then
        element.setup := ParseTestReportSetup(child, path+'/setup') {b}
      else if (child.localName = 'test') then
        element.testList.Add(ParseTestReportTest(child, path+'/test')){y.2}
      else if (child.localName = 'teardown') then
        element.teardown := ParseTestReportTeardown(child, path+'/teardown') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReport(xml : TXmlBuilder; name : String; elem : TFhirTestReport);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportChildren(xml : TXmlBuilder; elem : TFhirTestReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirReportStatusCodesEnum);
  ComposeReference{TFhirTestScript}(xml, 'testScript', elem.testScript);{x.2a}
  ComposeEnum(xml, 'result', elem.ResultElement, CODES_TFhirReportResultCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('score') then
    ComposeDecimal(xml, 'score', elem.scoreElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tester') then
    ComposeString(xml, 'tester', elem.testerElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeTestReportParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestReportSetup(xml, 'setup', elem.setup);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestReportTest(xml, 'test', elem.testList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestReportTeardown(xml, 'teardown', elem.teardown);{x.2a}
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRXmlParser.ParseTestScriptOrigin(element : TMXmlElement; path : string) : TFhirTestScriptOrigin;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptOrigin.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptOriginChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptOriginChild(element : TFhirTestScriptOrigin; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'index') then
        element.indexElement := ParseInteger(child, path+'/index') {b}
      else if (child.localName = 'profile') then
        element.profile := ParseCoding(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptOrigin(xml : TXmlBuilder; name : String; elem : TFhirTestScriptOrigin);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptOriginChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptOriginChildren(xml : TXmlBuilder; elem : TFhirTestScriptOrigin);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'index', elem.indexElement);{x.2b}
  ComposeCoding(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptDestination(element : TMXmlElement; path : string) : TFhirTestScriptDestination;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptDestinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptDestinationChild(element : TFhirTestScriptDestination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'index') then
        element.indexElement := ParseInteger(child, path+'/index') {b}
      else if (child.localName = 'profile') then
        element.profile := ParseCoding(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptDestination(xml : TXmlBuilder; name : String; elem : TFhirTestScriptDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptDestinationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptDestinationChildren(xml : TXmlBuilder; elem : TFhirTestScriptDestination);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'index', elem.indexElement);{x.2b}
  ComposeCoding(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadata.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataChild(element : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        element.link_List.Add(ParseTestScriptMetadataLink(child, path+'/link')){y.2}
      else if (child.localName = 'capability') then
        element.capabilityList.Add(ParseTestScriptMetadataCapability(child, path+'/capability')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadata(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadata);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadata);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(xml, 'link', elem.link_List[i]);
  for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(xml, 'capability', elem.capabilityList[i]);
end;

function TFHIRXmlParser.ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataLinkChild(element : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadataLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataCapabilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapabilityChild(element : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'required') then
        element.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.localName = 'validated') then
        element.validatedElement := ParseBoolean(child, path+'/validated') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'origin') then
        element.originList.Add(ParseInteger(child, path+'/origin')){y.2}
      else if (child.localName = 'destination') then
        element.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseUri(child, path+'/link')){y.2}
      else if (child.localName = 'capabilities') then
        element.capabilities := ParseReference{TFhirCapabilityStatement}(child, path+'/capabilities') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadataCapability);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataCapabilityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataCapability);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBoolean(xml, 'validated', elem.validatedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.originList.Count - 1 do
      ComposeInteger(xml, 'origin', elem.originList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(xml, 'link', elem.link_List[i]);
  ComposeReference{TFhirCapabilityStatement}(xml, 'capabilities', elem.capabilities);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptFixture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptFixtureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptFixtureChild(element : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'autocreate') then
        element.autocreateElement := ParseBoolean(child, path+'/autocreate') {b}
      else if (child.localName = 'autodelete') then
        element.autodeleteElement := ParseBoolean(child, path+'/autodelete') {b}
      else if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixture(xml : TXmlBuilder; name : String; elem : TFhirTestScriptFixture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptFixtureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixtureChildren(xml : TXmlBuilder; elem : TFhirTestScriptFixture);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.autocreate <> false)) then
    ComposeBoolean(xml, 'autocreate', elem.autocreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.autodelete <> false)) then
    ComposeBoolean(xml, 'autodelete', elem.autodeleteElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptVariable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptVariableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptVariableChild(element : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'defaultValue') then
        element.defaultValueElement := ParseString(child, path+'/defaultValue') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if (child.localName = 'headerField') then
        element.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.localName = 'hint') then
        element.hintElement := ParseString(child, path+'/hint') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariable(xml : TXmlBuilder; name : String; elem : TFhirTestScriptVariable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptVariableChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariableChildren(xml : TXmlBuilder; elem : TFhirTestScriptVariable);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'defaultValue', elem.defaultValueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'hint', elem.hintElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptRule(element : TMXmlElement; path : string) : TFhirTestScriptRule;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptRuleChild(element : TFhirTestScriptRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if (child.localName = 'param') then
        element.paramList.Add(ParseTestScriptRuleParam(child, path+'/param')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRule(xml : TXmlBuilder; name : String; elem : TFhirTestScriptRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptRuleParam(xml, 'param', elem.paramList[i]);
end;

function TFHIRXmlParser.ParseTestScriptRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptRuleParam;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptRuleParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptRuleParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptRuleParamChild(element : TFhirTestScriptRuleParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRuleParam(xml : TXmlBuilder; name : String; elem : TFhirTestScriptRuleParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptRuleParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptRuleParam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptRuleset(element : TMXmlElement; path : string) : TFhirTestScriptRuleset;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptRuleset.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptRulesetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptRulesetChild(element : TFhirTestScriptRuleset; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseTestScriptRulesetRule(child, path+'/rule')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRuleset(xml : TXmlBuilder; name : String; elem : TFhirTestScriptRuleset);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptRulesetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRulesetChildren(xml : TXmlBuilder; elem : TFhirTestScriptRuleset);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
  for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptRulesetRule(xml, 'rule', elem.ruleList[i]);
end;

function TFHIRXmlParser.ParseTestScriptRulesetRule(element : TMXmlElement; path : string) : TFhirTestScriptRulesetRule;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptRulesetRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptRulesetRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptRulesetRuleChild(element : TFhirTestScriptRulesetRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'ruleId') then
        element.ruleIdElement := ParseId(child, path+'/ruleId') {b}
      else if (child.localName = 'param') then
        element.paramList.Add(ParseTestScriptRulesetRuleParam(child, path+'/param')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRulesetRule(xml : TXmlBuilder; name : String; elem : TFhirTestScriptRulesetRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptRulesetRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRulesetRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptRulesetRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'ruleId', elem.ruleIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptRulesetRuleParam(xml, 'param', elem.paramList[i]);
end;

function TFHIRXmlParser.ParseTestScriptRulesetRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptRulesetRuleParam;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptRulesetRuleParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptRulesetRuleParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptRulesetRuleParamChild(element : TFhirTestScriptRulesetRuleParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRulesetRuleParam(xml : TXmlBuilder; name : String; elem : TFhirTestScriptRulesetRuleParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptRulesetRuleParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptRulesetRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptRulesetRuleParam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupChild(element : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptSetupAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetup(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionChild(element : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationChild(element : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'resource') then
        element.resourceElement := ParseCode(child, path+'/resource') {b}
      else if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'accept') then
        element.acceptElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/accept', child){1a}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.localName = 'destination') then
        element.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.localName = 'encodeRequestUrl') then
        element.encodeRequestUrlElement := ParseBoolean(child, path+'/encodeRequestUrl') {b}
      else if (child.localName = 'origin') then
        element.originElement := ParseInteger(child, path+'/origin') {b}
      else if (child.localName = 'params') then
        element.paramsElement := ParseString(child, path+'/params') {b}
      else if (child.localName = 'requestHeader') then
        element.requestHeaderList.Add(ParseTestScriptSetupActionOperationRequestHeader(child, path+'/requestHeader')){y.2}
      else if (child.localName = 'requestId') then
        element.requestIdElement := ParseId(child, path+'/requestId') {b}
      else if (child.localName = 'responseId') then
        element.responseIdElement := ParseId(child, path+'/responseId') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.localName = 'targetId') then
        element.targetIdElement := ParseId(child, path+'/targetId') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseString(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'resource', elem.resourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBoolean(xml, 'encodeRequestUrl', elem.encodeRequestUrlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'origin', elem.originElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'params', elem.paramsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(xml, 'requestHeader', elem.requestHeaderList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'requestId', elem.requestIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'responseId', elem.responseIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'targetId', elem.targetIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationRequestHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeaderChild(element : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'field') then
        element.fieldElement := ParseString(child, path+'/field') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationRequestHeaderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'field', elem.fieldElement);{x.2b}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertChild(element : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'direction') then
        element.directionElement := ParseEnum(CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, path+'/direction', child){1a}
      else if (child.localName = 'compareToSourceId') then
        element.compareToSourceIdElement := ParseString(child, path+'/compareToSourceId') {b}
      else if (child.localName = 'compareToSourceExpression') then
        element.compareToSourceExpressionElement := ParseString(child, path+'/compareToSourceExpression') {b}
      else if (child.localName = 'compareToSourcePath') then
        element.compareToSourcePathElement := ParseString(child, path+'/compareToSourcePath') {b}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.localName = 'expression') then
        element.expressionElement := ParseString(child, path+'/expression') {b}
      else if (child.localName = 'headerField') then
        element.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.localName = 'minimumId') then
        element.minimumIdElement := ParseString(child, path+'/minimumId') {b}
      else if (child.localName = 'navigationLinks') then
        element.navigationLinksElement := ParseBoolean(child, path+'/navigationLinks') {b}
      else if (child.localName = 'operator') then
        element.operatorElement := ParseEnum(CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, path+'/operator', child){1a}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'requestMethod') then
        element.requestMethodElement := ParseEnum(CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum, path+'/requestMethod', child){1a}
      else if (child.localName = 'requestURL') then
        element.requestURLElement := ParseString(child, path+'/requestURL') {b}
      else if (child.localName = 'resource') then
        element.resourceElement := ParseCode(child, path+'/resource') {b}
      else if (child.localName = 'response') then
        element.responseElement := ParseEnum(CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, path+'/response', child){1a}
      else if (child.localName = 'responseCode') then
        element.responseCodeElement := ParseString(child, path+'/responseCode') {b}
      else if (child.localName = 'rule') then
        element.rule := ParseTestScriptSetupActionAssertRule(child, path+'/rule') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseTestScriptSetupActionAssertRuleset(child, path+'/ruleset') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.localName = 'validateProfileId') then
        element.validateProfileIdElement := ParseId(child, path+'/validateProfileId') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'warningOnly') then
        element.warningOnlyElement := ParseBoolean(child, path+'/warningOnly') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssert);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssert);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceId', elem.compareToSourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceExpression', elem.compareToSourceExpressionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourcePath', elem.compareToSourcePathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', elem.expressionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'minimumId', elem.minimumIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'navigationLinks', elem.navigationLinksElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requestMethod', elem.RequestMethodElement, CODES_TFhirHttpOperationsEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requestURL', elem.requestURLElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'resource', elem.resourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responseCode', elem.responseCodeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssertRule(xml, 'rule', elem.rule);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssertRuleset(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'validateProfileId', elem.validateProfileIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBoolean(xml, 'warningOnly', elem.warningOnlyElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRule(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRule;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssertRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRuleChild(element : TFhirTestScriptSetupActionAssertRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'ruleId') then
        element.ruleIdElement := ParseId(child, path+'/ruleId') {b}
      else if (child.localName = 'param') then
        element.paramList.Add(ParseTestScriptSetupActionAssertRuleParam(child, path+'/param')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRule(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssertRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'ruleId', elem.ruleIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptSetupActionAssertRuleParam(xml, 'param', elem.paramList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRuleParam;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertRuleParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRuleParamChild(element : TFhirTestScriptSetupActionAssertRuleParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRuleParam(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssertRuleParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertRuleParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRuleParam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRuleset(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRuleset;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssertRuleset.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertRulesetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRulesetChild(element : TFhirTestScriptSetupActionAssertRuleset; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'rulesetId') then
        element.rulesetIdElement := ParseId(child, path+'/rulesetId') {b}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseTestScriptSetupActionAssertRulesetRule(child, path+'/rule')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRuleset(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssertRuleset);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertRulesetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRulesetChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRuleset);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'rulesetId', elem.rulesetIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptSetupActionAssertRulesetRule(xml, 'rule', elem.ruleList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRulesetRule(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRulesetRule;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertRulesetRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRulesetRuleChild(element : TFhirTestScriptSetupActionAssertRulesetRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'ruleId') then
        element.ruleIdElement := ParseId(child, path+'/ruleId') {b}
      else if (child.localName = 'param') then
        element.paramList.Add(ParseTestScriptSetupActionAssertRulesetRuleParam(child, path+'/param')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRulesetRule(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssertRulesetRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertRulesetRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRulesetRuleChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRulesetRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'ruleId', elem.ruleIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptSetupActionAssertRulesetRuleParam(xml, 'param', elem.paramList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRulesetRuleParam(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssertRulesetRuleParam;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertRulesetRuleParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertRulesetRuleParamChild(element : TFhirTestScriptSetupActionAssertRulesetRuleParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRulesetRuleParam(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertRulesetRuleParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertRulesetRuleParamChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestChild(element : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptTestAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTest(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestChildren(xml : TXmlBuilder; elem : TFhirTestScriptTest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTestAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestActionChild(element : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTestAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTestAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardown.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownChild(element : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptTeardownAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardown(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTeardown);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardown);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownActionChild(element : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTeardownAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardownAction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
end;

function TFHIRXmlParser.ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
var
  child : TMXmlElement;
begin
  result := TFhirTestScript.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptChild(element : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'origin') then
        element.originList.Add(ParseTestScriptOrigin(child, path+'/origin')){y.2}
      else if (child.localName = 'destination') then
        element.destinationList.Add(ParseTestScriptDestination(child, path+'/destination')){y.2}
      else if (child.localName = 'metadata') then
        element.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.localName = 'fixture') then
        element.fixtureList.Add(ParseTestScriptFixture(child, path+'/fixture')){y.2}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseReference{TFhirReference}(child, path+'/profile')){y.2}
      else if (child.localName = 'variable') then
        element.variableList.Add(ParseTestScriptVariable(child, path+'/variable')){y.2}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseTestScriptRule(child, path+'/rule')){y.2}
      else if (child.localName = 'ruleset') then
        element.rulesetList.Add(ParseTestScriptRuleset(child, path+'/ruleset')){y.2}
      else if (child.localName = 'setup') then
        element.setup := ParseTestScriptSetup(child, path+'/setup') {b}
      else if (child.localName = 'test') then
        element.testList.Add(ParseTestScriptTest(child, path+'/test')){y.2}
      else if (child.localName = 'teardown') then
        element.teardown := ParseTestScriptTeardown(child, path+'/teardown') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScript(xml : TXmlBuilder; name : String; elem : TFhirTestScript);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptChildren(xml : TXmlBuilder; elem : TFhirTestScript);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('origin') then
    for i := 0 to elem.originList.Count - 1 do
      ComposeTestScriptOrigin(xml, 'origin', elem.originList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeTestScriptDestination(xml, 'destination', elem.destinationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(xml, 'fixture', elem.fixtureList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('variable') then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(xml, 'variable', elem.variableList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptRule(xml, 'rule', elem.ruleList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('ruleset') then
    for i := 0 to elem.rulesetList.Count - 1 do
      ComposeTestScriptRuleset(xml, 'ruleset', elem.rulesetList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(xml, 'setup', elem.setup);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(xml, 'test', elem.testList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(xml, 'teardown', elem.teardown);{x.2a}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
function TFHIRXmlParser.ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeChild(element : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lockedDate') then
        element.lockedDateElement := ParseDate(child, path+'/lockedDate') {b}
      else if (child.localName = 'inactive') then
        element.inactiveElement := ParseBoolean(child, path+'/inactive') {b}
      else if (child.localName = 'include') then
        element.includeList.Add(ParseValueSetComposeInclude(child, path+'/include')){y.2}
      else if (child.localName = 'exclude') then
        element.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : String; elem : TFhirValueSetCompose);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeChildren(xml : TXmlBuilder; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'lockedDate', elem.lockedDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'inactive', elem.inactiveElement);{x.2b}
  for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeChild(element : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept')){y.2}
      else if (child.localName = 'filter') then
        element.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter')){y.2}
      else if (child.localName = 'valueSet') then
        element.valueSetList.Add(ParseUri(child, path+'/valueSet')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeInclude);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueSetList.Count - 1 do
      ComposeUri(xml, 'valueSet', elem.valueSetList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptChild(element : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'designation') then
        element.designationList.Add(ParseValueSetComposeIncludeConceptDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeIncludeConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(xml, 'designation', elem.designationList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConceptDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeConceptDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptDesignationChild(element : TFhirValueSetComposeIncludeConceptDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'use') then
        element.use := ParseCoding(child, path+'/use') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptDesignation(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeIncludeConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeConceptDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConceptDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2a}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilterChild(element : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'property') then
        element.property_Element := ParseCode(child, path+'/property') {b}
      else if (child.localName = 'op') then
        element.opElement := ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, path+'/op', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeFilterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeFilter);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'property', elem.property_Element);{x.2b}
  ComposeEnum(xml, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum);
  ComposeCode(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionChild(element : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierElement := ParseUri(child, path+'/identifier') {b}
      else if (child.localName = 'timestamp') then
        element.timestampElement := ParseDateTime(child, path+'/timestamp') {b}
      else if (child.localName = 'total') then
        element.totalElement := ParseInteger(child, path+'/total') {b}
      else if (child.localName = 'offset') then
        element.offsetElement := ParseInteger(child, path+'/offset') {b}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseValueSetExpansionParameter(child, path+'/parameter')){y.2}
      else if (child.localName = 'contains') then
        element.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierElement);{x.2b}
  ComposeDateTime(xml, 'timestamp', elem.timestampElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'total', elem.totalElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'offset', elem.offsetElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(xml, 'parameter', elem.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionParameterChild(element : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionParameter);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionContainsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsChild(element : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'abstract') then
        element.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.localName = 'inactive') then
        element.inactiveElement := ParseBoolean(child, path+'/inactive') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'designation') then
        element.designationList.Add(ParseValueSetComposeIncludeConceptDesignation(child, path+'/designation')){y.2}
      else if (child.localName = 'contains') then
        element.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansionContains);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionContainsChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(xml, 'inactive', elem.inactiveElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(xml, 'designation', elem.designationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
var
  child : TMXmlElement;
begin
  result := TFhirValueSet.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetChild(element : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactDetail(child, path+'/contact')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseMarkdown(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseUsageContext(child, path+'/useContext')){y.2}
      else if (child.localName = 'jurisdiction') then
        element.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction')){y.2}
      else if (child.localName = 'immutable') then
        element.immutableElement := ParseBoolean(child, path+'/immutable') {b}
      else if (child.localName = 'purpose') then
        element.purposeElement := ParseMarkdown(child, path+'/purpose') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseMarkdown(child, path+'/copyright') {b}
      else if (child.localName = 'extensible') then
        element.extensibleElement := ParseBoolean(child, path+'/extensible') {b}
      else if (child.localName = 'compose') then
        element.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.localName = 'expansion') then
        element.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : String; elem : TFhirValueSet);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetChildren(xml : TXmlBuilder; elem : TFhirValueSet);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', elem.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBoolean(xml, 'immutable', elem.immutableElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(xml, 'purpose', elem.purposeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBoolean(xml, 'extensible', elem.extensibleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(xml, 'compose', elem.compose);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(xml, 'expansion', elem.expansion);{x.2a}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRXmlParser.ParseVisionPrescriptionDispense(element : TMXmlElement; path : string) : TFhirVisionPrescriptionDispense;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionDispenseChild(element : TFhirVisionPrescriptionDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'product') then
        element.product := ParseCodeableConcept(child, path+'/product') {b}
      else if (child.localName = 'eye') then
        element.eyeElement := ParseEnum(CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, path+'/eye', child){1a}
      else if (child.localName = 'sphere') then
        element.sphereElement := ParseDecimal(child, path+'/sphere') {b}
      else if (child.localName = 'cylinder') then
        element.cylinderElement := ParseDecimal(child, path+'/cylinder') {b}
      else if (child.localName = 'axis') then
        element.axisElement := ParseInteger(child, path+'/axis') {b}
      else if (child.localName = 'prism') then
        element.prismElement := ParseDecimal(child, path+'/prism') {b}
      else if (child.localName = 'base') then
        element.baseElement := ParseEnum(CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, path+'/base', child){1a}
      else if (child.localName = 'add') then
        element.addElement := ParseDecimal(child, path+'/add') {b}
      else if (child.localName = 'power') then
        element.powerElement := ParseDecimal(child, path+'/power') {b}
      else if (child.localName = 'backCurve') then
        element.backCurveElement := ParseDecimal(child, path+'/backCurve') {b}
      else if (child.localName = 'diameter') then
        element.diameterElement := ParseDecimal(child, path+'/diameter') {b}
      else if (child.localName = 'duration') then
        element.duration := ParseQuantity(child, path+'/duration') {b}
      else if (child.localName = 'color') then
        element.colorElement := ParseString(child, path+'/color') {b}
      else if (child.localName = 'brand') then
        element.brandElement := ParseString(child, path+'/brand') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : String; elem : TFhirVisionPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionDispenseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispenseChildren(xml : TXmlBuilder; elem : TFhirVisionPrescriptionDispense);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'product', elem.product);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'sphere', elem.sphereElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'cylinder', elem.cylinderElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'axis', elem.axisElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'prism', elem.prismElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'add', elem.addElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'power', elem.powerElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'backCurve', elem.backCurveElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'diameter', elem.diameterElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'duration', elem.duration);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'color', elem.colorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'brand', elem.brandElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

function TFHIRXmlParser.ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionChild(element : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'dateWritten') then
        element.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.localName = 'prescriber') then
        element.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'dispense') then
        element.dispenseList.Add(ParseVisionPrescriptionDispense(child, path+'/dispense')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescription(xml : TXmlBuilder; name : String; elem : TFhirVisionPrescription);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionChildren(xml : TXmlBuilder; elem : TFhirVisionPrescription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('dateWritten') then
    ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soData]) and doCompose('dispense') then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(xml, 'dispense', elem.dispenseList[i]);
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRXmlParser.ParseResource(element : TMXmlElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise EXmlException.Create('error - element is nil')
{$IFDEF FHIR_PARAMETERS}
  else if element.localName = 'Parameters' Then
    result := ParseParameters(element, path+'/Parameters')
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if element.localName = 'Account' Then
    result := ParseAccount(element, path+'/Account') 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
   else if element.localName = 'ActivityDefinition' Then
    result := ParseActivityDefinition(element, path+'/ActivityDefinition') 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
   else if element.localName = 'AdverseEvent' Then
    result := ParseAdverseEvent(element, path+'/AdverseEvent') 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if element.localName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance') 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if element.localName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment') 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if element.localName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse') 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if element.localName = 'AuditEvent' Then
    result := ParseAuditEvent(element, path+'/AuditEvent') 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if element.localName = 'Basic' Then
    result := ParseBasic(element, path+'/Basic') 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if element.localName = 'Binary' Then
    result := ParseBinary(element, path+'/Binary') 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
   else if element.localName = 'BodySite' Then
    result := ParseBodySite(element, path+'/BodySite') 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if element.localName = 'Bundle' Then
    result := ParseBundle(element, path+'/Bundle') 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
   else if element.localName = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(element, path+'/CapabilityStatement') 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if element.localName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan') 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
   else if element.localName = 'CareTeam' Then
    result := ParseCareTeam(element, path+'/CareTeam') 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
   else if element.localName = 'ChargeItem' Then
    result := ParseChargeItem(element, path+'/ChargeItem') 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if element.localName = 'Claim' Then
    result := ParseClaim(element, path+'/Claim') 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if element.localName = 'ClaimResponse' Then
    result := ParseClaimResponse(element, path+'/ClaimResponse') 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if element.localName = 'ClinicalImpression' Then
    result := ParseClinicalImpression(element, path+'/ClinicalImpression') 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
   else if element.localName = 'CodeSystem' Then
    result := ParseCodeSystem(element, path+'/CodeSystem') 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if element.localName = 'Communication' Then
    result := ParseCommunication(element, path+'/Communication') 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if element.localName = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(element, path+'/CommunicationRequest') 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
   else if element.localName = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(element, path+'/CompartmentDefinition') 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if element.localName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition') 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if element.localName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap') 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if element.localName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition') 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
   else if element.localName = 'Consent' Then
    result := ParseConsent(element, path+'/Consent') 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if element.localName = 'Contract' Then
    result := ParseContract(element, path+'/Contract') 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if element.localName = 'Coverage' Then
    result := ParseCoverage(element, path+'/Coverage') 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
   else if element.localName = 'DataElement' Then
    result := ParseDataElement(element, path+'/DataElement') 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if element.localName = 'DetectedIssue' Then
    result := ParseDetectedIssue(element, path+'/DetectedIssue') 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if element.localName = 'Device' Then
    result := ParseDevice(element, path+'/Device') 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
   else if element.localName = 'DeviceComponent' Then
    result := ParseDeviceComponent(element, path+'/DeviceComponent') 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if element.localName = 'DeviceMetric' Then
    result := ParseDeviceMetric(element, path+'/DeviceMetric') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
   else if element.localName = 'DeviceRequest' Then
    result := ParseDeviceRequest(element, path+'/DeviceRequest') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if element.localName = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(element, path+'/DeviceUseStatement') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if element.localName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport') 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if element.localName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest') 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if element.localName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference') 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
   else if element.localName = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(element, path+'/EligibilityRequest') 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
   else if element.localName = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(element, path+'/EligibilityResponse') 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if element.localName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter') 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
   else if element.localName = 'Endpoint' Then
    result := ParseEndpoint(element, path+'/Endpoint') 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if element.localName = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(element, path+'/EnrollmentRequest') 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if element.localName = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(element, path+'/EnrollmentResponse') 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if element.localName = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(element, path+'/EpisodeOfCare') 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  {$IFDEF FHIR_EXPANSIONPROFILE}
   else if element.localName = 'ExpansionProfile' Then
    result := ParseExpansionProfile(element, path+'/ExpansionProfile') 
  {$ENDIF}
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if element.localName = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(element, path+'/ExplanationOfBenefit') 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if element.localName = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(element, path+'/FamilyMemberHistory') 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if element.localName = 'Flag' Then
    result := ParseFlag(element, path+'/Flag') 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if element.localName = 'Goal' Then
    result := ParseGoal(element, path+'/Goal') 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
   else if element.localName = 'GraphDefinition' Then
    result := ParseGraphDefinition(element, path+'/GraphDefinition') 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if element.localName = 'Group' Then
    result := ParseGroup(element, path+'/Group') 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
   else if element.localName = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(element, path+'/GuidanceResponse') 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if element.localName = 'HealthcareService' Then
    result := ParseHealthcareService(element, path+'/HealthcareService') 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  {$IFDEF FHIR_IMAGINGMANIFEST}
   else if element.localName = 'ImagingManifest' Then
    result := ParseImagingManifest(element, path+'/ImagingManifest') 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if element.localName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy') 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if element.localName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization') 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if element.localName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation') 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if element.localName = 'ImplementationGuide' Then
    result := ParseImplementationGuide(element, path+'/ImplementationGuide') 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
   else if element.localName = 'Library' Then
    result := ParseLibrary(element, path+'/Library') 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
   else if element.localName = 'Linkage' Then
    result := ParseLinkage(element, path+'/Linkage') 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if element.localName = 'List' Then
    result := ParseList(element, path+'/List') 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if element.localName = 'Location' Then
    result := ParseLocation(element, path+'/Location') 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
   else if element.localName = 'Measure' Then
    result := ParseMeasure(element, path+'/Measure') 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
   else if element.localName = 'MeasureReport' Then
    result := ParseMeasureReport(element, path+'/MeasureReport') 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if element.localName = 'Media' Then
    result := ParseMedia(element, path+'/Media') 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if element.localName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if element.localName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if element.localName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
   else if element.localName = 'MedicationRequest' Then
    result := ParseMedicationRequest(element, path+'/MedicationRequest') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if element.localName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
   else if element.localName = 'MessageDefinition' Then
    result := ParseMessageDefinition(element, path+'/MessageDefinition') 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if element.localName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader') 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if element.localName = 'NamingSystem' Then
    result := ParseNamingSystem(element, path+'/NamingSystem') 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if element.localName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder') 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if element.localName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation') 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if element.localName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition') 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if element.localName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome') 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if element.localName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization') 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if element.localName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient') 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if element.localName = 'PaymentNotice' Then
    result := ParsePaymentNotice(element, path+'/PaymentNotice') 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if element.localName = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(element, path+'/PaymentReconciliation') 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if element.localName = 'Person' Then
    result := ParsePerson(element, path+'/Person') 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
   else if element.localName = 'PlanDefinition' Then
    result := ParsePlanDefinition(element, path+'/PlanDefinition') 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if element.localName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner') 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
   else if element.localName = 'PractitionerRole' Then
    result := ParsePractitionerRole(element, path+'/PractitionerRole') 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if element.localName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure') 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
   else if element.localName = 'ProcedureRequest' Then
    result := ParseProcedureRequest(element, path+'/ProcedureRequest') 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
   else if element.localName = 'ProcessRequest' Then
    result := ParseProcessRequest(element, path+'/ProcessRequest') 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
   else if element.localName = 'ProcessResponse' Then
    result := ParseProcessResponse(element, path+'/ProcessResponse') 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if element.localName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance') 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if element.localName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire') 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if element.localName = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(element, path+'/QuestionnaireResponse') 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
   else if element.localName = 'ReferralRequest' Then
    result := ParseReferralRequest(element, path+'/ReferralRequest') 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if element.localName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson') 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
   else if element.localName = 'RequestGroup' Then
    result := ParseRequestGroup(element, path+'/RequestGroup') 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
   else if element.localName = 'ResearchStudy' Then
    result := ParseResearchStudy(element, path+'/ResearchStudy') 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
   else if element.localName = 'ResearchSubject' Then
    result := ParseResearchSubject(element, path+'/ResearchSubject') 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if element.localName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment') 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if element.localName = 'Schedule' Then
    result := ParseSchedule(element, path+'/Schedule') 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if element.localName = 'SearchParameter' Then
    result := ParseSearchParameter(element, path+'/SearchParameter') 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  {$IFDEF FHIR_SEQUENCE}
   else if element.localName = 'Sequence' Then
    result := ParseSequence(element, path+'/Sequence') 
  {$ENDIF}
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  {$IFDEF FHIR_SERVICEDEFINITION}
   else if element.localName = 'ServiceDefinition' Then
    result := ParseServiceDefinition(element, path+'/ServiceDefinition') 
  {$ENDIF}
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if element.localName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot') 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if element.localName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen') 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if element.localName = 'StructureDefinition' Then
    result := ParseStructureDefinition(element, path+'/StructureDefinition') 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
   else if element.localName = 'StructureMap' Then
    result := ParseStructureMap(element, path+'/StructureMap') 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if element.localName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription') 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if element.localName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance') 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if element.localName = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(element, path+'/SupplyDelivery') 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if element.localName = 'SupplyRequest' Then
    result := ParseSupplyRequest(element, path+'/SupplyRequest') 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
   else if element.localName = 'Task' Then
    result := ParseTask(element, path+'/Task') 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
   else if element.localName = 'TestReport' Then
    result := ParseTestReport(element, path+'/TestReport') 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if element.localName = 'TestScript' Then
    result := ParseTestScript(element, path+'/TestScript') 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if element.localName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet') 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if element.localName = 'VisionPrescription' Then
    result := ParseVisionPrescription(element, path+'/VisionPrescription') 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.create('Error: the element '+element.localName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise EXmlException.Create('error - resource is nil');
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(xml, 'Parameters', TFhirParameters(resource));
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(xml, 'Account', TFhirAccount(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
     frtActivityDefinition: ComposeActivityDefinition(xml, 'ActivityDefinition', TFhirActivityDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
     frtAdverseEvent: ComposeAdverseEvent(xml, 'AdverseEvent', TFhirAdverseEvent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource)); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(xml, 'AuditEvent', TFhirAuditEvent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(xml, 'Basic', TFhirBasic(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(xml, 'Binary', TFhirBinary(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
     frtBodySite: ComposeBodySite(xml, 'BodySite', TFhirBodySite(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(xml, 'Bundle', TFhirBundle(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
     frtCapabilityStatement: ComposeCapabilityStatement(xml, 'CapabilityStatement', TFhirCapabilityStatement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
     frtCareTeam: ComposeCareTeam(xml, 'CareTeam', TFhirCareTeam(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
     frtChargeItem: ComposeChargeItem(xml, 'ChargeItem', TFhirChargeItem(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(xml, 'Claim', TFhirClaim(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(xml, 'ClaimResponse', TFhirClaimResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(xml, 'ClinicalImpression', TFhirClinicalImpression(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
     frtCodeSystem: ComposeCodeSystem(xml, 'CodeSystem', TFhirCodeSystem(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(xml, 'Communication', TFhirCommunication(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(xml, 'CommunicationRequest', TFhirCommunicationRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
     frtCompartmentDefinition: ComposeCompartmentDefinition(xml, 'CompartmentDefinition', TFhirCompartmentDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
     frtConsent: ComposeConsent(xml, 'Consent', TFhirConsent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(xml, 'Contract', TFhirContract(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(xml, 'Coverage', TFhirCoverage(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
     frtDataElement: ComposeDataElement(xml, 'DataElement', TFhirDataElement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(xml, 'DetectedIssue', TFhirDetectedIssue(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
     frtDeviceComponent: ComposeDeviceComponent(xml, 'DeviceComponent', TFhirDeviceComponent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(xml, 'DeviceMetric', TFhirDeviceMetric(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
     frtDeviceRequest: ComposeDeviceRequest(xml, 'DeviceRequest', TFhirDeviceRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(xml, 'DeviceUseStatement', TFhirDeviceUseStatement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
     frtEligibilityRequest: ComposeEligibilityRequest(xml, 'EligibilityRequest', TFhirEligibilityRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
     frtEligibilityResponse: ComposeEligibilityResponse(xml, 'EligibilityResponse', TFhirEligibilityResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
     frtEndpoint: ComposeEndpoint(xml, 'Endpoint', TFhirEndpoint(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(xml, 'EnrollmentRequest', TFhirEnrollmentRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(xml, 'EnrollmentResponse', TFhirEnrollmentResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(xml, 'EpisodeOfCare', TFhirEpisodeOfCare(resource)); 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  {$IFDEF FHIR_EXPANSIONPROFILE}
     frtExpansionProfile: ComposeExpansionProfile(xml, 'ExpansionProfile', TFhirExpansionProfile(resource)); 
  {$ENDIF}
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(xml, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource)); 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(xml, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource)); 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(xml, 'Flag', TFhirFlag(resource)); 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(xml, 'Goal', TFhirGoal(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
     frtGraphDefinition: ComposeGraphDefinition(xml, 'GraphDefinition', TFhirGraphDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
     frtGuidanceResponse: ComposeGuidanceResponse(xml, 'GuidanceResponse', TFhirGuidanceResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(xml, 'HealthcareService', TFhirHealthcareService(resource)); 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  {$IFDEF FHIR_IMAGINGMANIFEST}
     frtImagingManifest: ComposeImagingManifest(xml, 'ImagingManifest', TFhirImagingManifest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(xml, 'ImplementationGuide', TFhirImplementationGuide(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
     frtLibrary: ComposeLibrary(xml, 'Library', TFhirLibrary(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
     frtLinkage: ComposeLinkage(xml, 'Linkage', TFhirLinkage(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(xml, 'List', TFhirList(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
     frtMeasure: ComposeMeasure(xml, 'Measure', TFhirMeasure(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
     frtMeasureReport: ComposeMeasureReport(xml, 'MeasureReport', TFhirMeasureReport(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
     frtMedicationRequest: ComposeMedicationRequest(xml, 'MedicationRequest', TFhirMedicationRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
     frtMessageDefinition: ComposeMessageDefinition(xml, 'MessageDefinition', TFhirMessageDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(xml, 'NamingSystem', TFhirNamingSystem(resource)); 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource)); 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(xml, 'PaymentNotice', TFhirPaymentNotice(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(xml, 'PaymentReconciliation', TFhirPaymentReconciliation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(xml, 'Person', TFhirPerson(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
     frtPlanDefinition: ComposePlanDefinition(xml, 'PlanDefinition', TFhirPlanDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
     frtPractitionerRole: ComposePractitionerRole(xml, 'PractitionerRole', TFhirPractitionerRole(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
     frtProcedureRequest: ComposeProcedureRequest(xml, 'ProcedureRequest', TFhirProcedureRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
     frtProcessRequest: ComposeProcessRequest(xml, 'ProcessRequest', TFhirProcessRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
     frtProcessResponse: ComposeProcessResponse(xml, 'ProcessResponse', TFhirProcessResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource)); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(xml, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
     frtReferralRequest: ComposeReferralRequest(xml, 'ReferralRequest', TFhirReferralRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
     frtRequestGroup: ComposeRequestGroup(xml, 'RequestGroup', TFhirRequestGroup(resource)); 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
     frtResearchStudy: ComposeResearchStudy(xml, 'ResearchStudy', TFhirResearchStudy(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
     frtResearchSubject: ComposeResearchSubject(xml, 'ResearchSubject', TFhirResearchSubject(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(xml, 'Schedule', TFhirSchedule(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(xml, 'SearchParameter', TFhirSearchParameter(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  {$IFDEF FHIR_SEQUENCE}
     frtSequence: ComposeSequence(xml, 'Sequence', TFhirSequence(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  {$IFDEF FHIR_SERVICEDEFINITION}
     frtServiceDefinition: ComposeServiceDefinition(xml, 'ServiceDefinition', TFhirServiceDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(xml, 'StructureDefinition', TFhirStructureDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
     frtStructureMap: ComposeStructureMap(xml, 'StructureMap', TFhirStructureMap(resource)); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(xml, 'SupplyDelivery', TFhirSupplyDelivery(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(xml, 'SupplyRequest', TFhirSupplyRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
     frtTask: ComposeTask(xml, 'Task', TFhirTask(resource)); 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
     frtTestReport: ComposeTestReport(xml, 'TestReport', TFhirTestReport(resource)); 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(xml, 'TestScript', TFhirTestScript(resource)); 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource)); 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(xml, 'VisionPrescription', TFhirVisionPrescription(resource)); 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRXmlParser.ParseFragment(element : TMXmlElement) : TFHIRObject;
begin
   if SameText(element.Name, 'TFhirElement') then
    result := parseElement(element, element.Name)
  else if SameText(element.Name, 'TFhirBackboneElement') then
    result := parseBackboneElement(element, element.Name)
{$IFDEF FHIR_PARAMETERS}
  else if SameText(element.Name, 'TFhirParameters') then
    result := parseParameters(element, element.Name)
{$ENDIF FHIR_PARAMETERS}
  else if SameText(element.Name, 'TFhirExtension') then
    result := parseExtension(element, element.Name)
  else if SameText(element.Name, 'TFhirNarrative') then
    result := parseNarrative(element, element.Name)
  else if SameText(element.Name, 'TFhirContributor') then
    result := parseContributor(element, element.Name)
  else if SameText(element.Name, 'TFhirAttachment') then
    result := parseAttachment(element, element.Name)
  else if SameText(element.Name, 'TFhirDataRequirement') then
    result := parseDataRequirement(element, element.Name)
  else if SameText(element.Name, 'TFhirDosage') then
    result := parseDosage(element, element.Name)
  else if SameText(element.Name, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.Name)
  else if SameText(element.Name, 'TFhirCoding') then
    result := parseCoding(element, element.Name)
  else if SameText(element.Name, 'TFhirSampledData') then
    result := parseSampledData(element, element.Name)
  else if SameText(element.Name, 'TFhirRatio') then
    result := parseRatio(element, element.Name)
  else if SameText(element.Name, 'TFhirReference') then
    result := parseReference(element, element.Name)
  else if SameText(element.Name, 'TFhirTriggerDefinition') then
    result := parseTriggerDefinition(element, element.Name)
  else if SameText(element.Name, 'TFhirPeriod') then
    result := parsePeriod(element, element.Name)
  else if SameText(element.Name, 'TFhirQuantity') then
    result := parseQuantity(element, element.Name)
  else if SameText(element.Name, 'TFhirRange') then
    result := parseRange(element, element.Name)
  else if SameText(element.Name, 'TFhirRelatedArtifact') then
    result := parseRelatedArtifact(element, element.Name)
  else if SameText(element.Name, 'TFhirAnnotation') then
    result := parseAnnotation(element, element.Name)
  else if SameText(element.Name, 'TFhirContactDetail') then
    result := parseContactDetail(element, element.Name)
  else if SameText(element.Name, 'TFhirUsageContext') then
    result := parseUsageContext(element, element.Name)
  else if SameText(element.Name, 'TFhirSignature') then
    result := parseSignature(element, element.Name)
  else if SameText(element.Name, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.Name)
  else if SameText(element.Name, 'TFhirParameterDefinition') then
    result := parseParameterDefinition(element, element.Name)
  else if SameText(element.Name, 'TFhirContactPoint') then
    result := parseContactPoint(element, element.Name)
  else if SameText(element.Name, 'TFhirHumanName') then
    result := parseHumanName(element, element.Name)
  else if SameText(element.Name, 'TFhirMeta') then
    result := parseMeta(element, element.Name)
  else if SameText(element.Name, 'TFhirAddress') then
    result := parseAddress(element, element.Name)
  else if SameText(element.Name, 'TFhirElementDefinition') then
    result := parseElementDefinition(element, element.Name)
  else if SameText(element.Name, 'TFhirTiming') then
    result := parseTiming(element, element.Name)
  else if SameText(element.Name, 'TFhirCount') then
    result := parseCount(element, element.Name)
  else if SameText(element.Name, 'TFhirMoney') then
    result := parseMoney(element, element.Name)
  else if SameText(element.Name, 'TFhirAge') then
    result := parseAge(element, element.Name)
  else if SameText(element.Name, 'TFhirDistance') then
    result := parseDistance(element, element.Name)
  else if SameText(element.Name, 'TFhirDuration') then
    result := parseDuration(element, element.Name)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(element.Name, 'TFhirAccount') then
    result := parseAccount(element, element.Name)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if SameText(element.Name, 'TFhirActivityDefinition') then
    result := parseActivityDefinition(element, element.Name)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if SameText(element.Name, 'TFhirAdverseEvent') then
    result := parseAdverseEvent(element, element.Name)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(element.Name, 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(element, element.Name)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(element.Name, 'TFhirAppointment') then
    result := parseAppointment(element, element.Name)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(element.Name, 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(element, element.Name)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(element.Name, 'TFhirAuditEvent') then
    result := parseAuditEvent(element, element.Name)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(element.Name, 'TFhirBasic') then
    result := parseBasic(element, element.Name)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(element.Name, 'TFhirBinary') then
    result := parseBinary(element, element.Name)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if SameText(element.Name, 'TFhirBodySite') then
    result := parseBodySite(element, element.Name)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(element.Name, 'TFhirBundle') then
    result := parseBundle(element, element.Name)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if SameText(element.Name, 'TFhirCapabilityStatement') then
    result := parseCapabilityStatement(element, element.Name)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(element.Name, 'TFhirCarePlan') then
    result := parseCarePlan(element, element.Name)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if SameText(element.Name, 'TFhirCareTeam') then
    result := parseCareTeam(element, element.Name)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if SameText(element.Name, 'TFhirChargeItem') then
    result := parseChargeItem(element, element.Name)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  else if SameText(element.Name, 'TFhirClaim') then
    result := parseClaim(element, element.Name)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(element.Name, 'TFhirClaimResponse') then
    result := parseClaimResponse(element, element.Name)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(element.Name, 'TFhirClinicalImpression') then
    result := parseClinicalImpression(element, element.Name)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if SameText(element.Name, 'TFhirCodeSystem') then
    result := parseCodeSystem(element, element.Name)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(element.Name, 'TFhirCommunication') then
    result := parseCommunication(element, element.Name)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(element.Name, 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(element, element.Name)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if SameText(element.Name, 'TFhirCompartmentDefinition') then
    result := parseCompartmentDefinition(element, element.Name)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(element.Name, 'TFhirComposition') then
    result := parseComposition(element, element.Name)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(element.Name, 'TFhirConceptMap') then
    result := parseConceptMap(element, element.Name)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(element.Name, 'TFhirCondition') then
    result := parseCondition(element, element.Name)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if SameText(element.Name, 'TFhirConsent') then
    result := parseConsent(element, element.Name)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if SameText(element.Name, 'TFhirContract') then
    result := parseContract(element, element.Name)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(element.Name, 'TFhirCoverage') then
    result := parseCoverage(element, element.Name)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if SameText(element.Name, 'TFhirDataElement') then
    result := parseDataElement(element, element.Name)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(element.Name, 'TFhirDetectedIssue') then
    result := parseDetectedIssue(element, element.Name)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(element.Name, 'TFhirDevice') then
    result := parseDevice(element, element.Name)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if SameText(element.Name, 'TFhirDeviceComponent') then
    result := parseDeviceComponent(element, element.Name)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(element.Name, 'TFhirDeviceMetric') then
    result := parseDeviceMetric(element, element.Name)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if SameText(element.Name, 'TFhirDeviceRequest') then
    result := parseDeviceRequest(element, element.Name)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if SameText(element.Name, 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(element, element.Name)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(element.Name, 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(element, element.Name)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(element.Name, 'TFhirDocumentManifest') then
    result := parseDocumentManifest(element, element.Name)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(element.Name, 'TFhirDocumentReference') then
    result := parseDocumentReference(element, element.Name)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if SameText(element.Name, 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(element, element.Name)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if SameText(element.Name, 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(element, element.Name)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(element.Name, 'TFhirEncounter') then
    result := parseEncounter(element, element.Name)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if SameText(element.Name, 'TFhirEndpoint') then
    result := parseEndpoint(element, element.Name)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(element.Name, 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(element, element.Name)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(element.Name, 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(element, element.Name)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(element.Name, 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(element, element.Name)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  else if SameText(element.Name, 'TFhirExpansionProfile') then
    result := parseExpansionProfile(element, element.Name)
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(element.Name, 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(element, element.Name)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(element.Name, 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(element, element.Name)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(element.Name, 'TFhirFlag') then
    result := parseFlag(element, element.Name)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if SameText(element.Name, 'TFhirGoal') then
    result := parseGoal(element, element.Name)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if SameText(element.Name, 'TFhirGraphDefinition') then
    result := parseGraphDefinition(element, element.Name)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if SameText(element.Name, 'TFhirGroup') then
    result := parseGroup(element, element.Name)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if SameText(element.Name, 'TFhirGuidanceResponse') then
    result := parseGuidanceResponse(element, element.Name)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(element.Name, 'TFhirHealthcareService') then
    result := parseHealthcareService(element, element.Name)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  else if SameText(element.Name, 'TFhirImagingManifest') then
    result := parseImagingManifest(element, element.Name)
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(element.Name, 'TFhirImagingStudy') then
    result := parseImagingStudy(element, element.Name)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(element.Name, 'TFhirImmunization') then
    result := parseImmunization(element, element.Name)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(element.Name, 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(element, element.Name)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(element.Name, 'TFhirImplementationGuide') then
    result := parseImplementationGuide(element, element.Name)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  else if SameText(element.Name, 'TFhirLibrary') then
    result := parseLibrary(element, element.Name)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if SameText(element.Name, 'TFhirLinkage') then
    result := parseLinkage(element, element.Name)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if SameText(element.Name, 'TFhirList') then
    result := parseList(element, element.Name)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(element.Name, 'TFhirLocation') then
    result := parseLocation(element, element.Name)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if SameText(element.Name, 'TFhirMeasure') then
    result := parseMeasure(element, element.Name)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if SameText(element.Name, 'TFhirMeasureReport') then
    result := parseMeasureReport(element, element.Name)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if SameText(element.Name, 'TFhirMedia') then
    result := parseMedia(element, element.Name)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if SameText(element.Name, 'TFhirMedication') then
    result := parseMedication(element, element.Name)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(element.Name, 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(element, element.Name)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(element.Name, 'TFhirMedicationDispense') then
    result := parseMedicationDispense(element, element.Name)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if SameText(element.Name, 'TFhirMedicationRequest') then
    result := parseMedicationRequest(element, element.Name)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if SameText(element.Name, 'TFhirMedicationStatement') then
    result := parseMedicationStatement(element, element.Name)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if SameText(element.Name, 'TFhirMessageDefinition') then
    result := parseMessageDefinition(element, element.Name)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(element.Name, 'TFhirMessageHeader') then
    result := parseMessageHeader(element, element.Name)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(element.Name, 'TFhirNamingSystem') then
    result := parseNamingSystem(element, element.Name)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(element.Name, 'TFhirNutritionOrder') then
    result := parseNutritionOrder(element, element.Name)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(element.Name, 'TFhirObservation') then
    result := parseObservation(element, element.Name)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(element.Name, 'TFhirOperationDefinition') then
    result := parseOperationDefinition(element, element.Name)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(element.Name, 'TFhirOperationOutcome') then
    result := parseOperationOutcome(element, element.Name)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(element.Name, 'TFhirOrganization') then
    result := parseOrganization(element, element.Name)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if SameText(element.Name, 'TFhirPatient') then
    result := parsePatient(element, element.Name)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(element.Name, 'TFhirPaymentNotice') then
    result := parsePaymentNotice(element, element.Name)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(element.Name, 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(element, element.Name)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if SameText(element.Name, 'TFhirPerson') then
    result := parsePerson(element, element.Name)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if SameText(element.Name, 'TFhirPlanDefinition') then
    result := parsePlanDefinition(element, element.Name)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(element.Name, 'TFhirPractitioner') then
    result := parsePractitioner(element, element.Name)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if SameText(element.Name, 'TFhirPractitionerRole') then
    result := parsePractitionerRole(element, element.Name)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(element.Name, 'TFhirProcedure') then
    result := parseProcedure(element, element.Name)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if SameText(element.Name, 'TFhirProcedureRequest') then
    result := parseProcedureRequest(element, element.Name)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if SameText(element.Name, 'TFhirProcessRequest') then
    result := parseProcessRequest(element, element.Name)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if SameText(element.Name, 'TFhirProcessResponse') then
    result := parseProcessResponse(element, element.Name)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(element.Name, 'TFhirProvenance') then
    result := parseProvenance(element, element.Name)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(element.Name, 'TFhirQuestionnaire') then
    result := parseQuestionnaire(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(element.Name, 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if SameText(element.Name, 'TFhirReferralRequest') then
    result := parseReferralRequest(element, element.Name)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(element.Name, 'TFhirRelatedPerson') then
    result := parseRelatedPerson(element, element.Name)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if SameText(element.Name, 'TFhirRequestGroup') then
    result := parseRequestGroup(element, element.Name)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if SameText(element.Name, 'TFhirResearchStudy') then
    result := parseResearchStudy(element, element.Name)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if SameText(element.Name, 'TFhirResearchSubject') then
    result := parseResearchSubject(element, element.Name)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(element.Name, 'TFhirRiskAssessment') then
    result := parseRiskAssessment(element, element.Name)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(element.Name, 'TFhirSchedule') then
    result := parseSchedule(element, element.Name)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(element.Name, 'TFhirSearchParameter') then
    result := parseSearchParameter(element, element.Name)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  else if SameText(element.Name, 'TFhirSequence') then
    result := parseSequence(element, element.Name)
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  else if SameText(element.Name, 'TFhirServiceDefinition') then
    result := parseServiceDefinition(element, element.Name)
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  else if SameText(element.Name, 'TFhirSlot') then
    result := parseSlot(element, element.Name)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(element.Name, 'TFhirSpecimen') then
    result := parseSpecimen(element, element.Name)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(element.Name, 'TFhirStructureDefinition') then
    result := parseStructureDefinition(element, element.Name)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if SameText(element.Name, 'TFhirStructureMap') then
    result := parseStructureMap(element, element.Name)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(element.Name, 'TFhirSubscription') then
    result := parseSubscription(element, element.Name)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(element.Name, 'TFhirSubstance') then
    result := parseSubstance(element, element.Name)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(element.Name, 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(element, element.Name)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(element.Name, 'TFhirSupplyRequest') then
    result := parseSupplyRequest(element, element.Name)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if SameText(element.Name, 'TFhirTask') then
    result := parseTask(element, element.Name)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  else if SameText(element.Name, 'TFhirTestReport') then
    result := parseTestReport(element, element.Name)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(element.Name, 'TFhirTestScript') then
    result := parseTestScript(element, element.Name)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if SameText(element.Name, 'TFhirValueSet') then
    result := parseValueSet(element, element.Name)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(element.Name, 'TFhirVisionPrescription') then
    result := parseVisionPrescription(element, element.Name)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.create('error: the element '+element.Name+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRTypeClass) : TFhirType;
begin
    if (name <> '') and (name <> element.localName) then
    raise EXmlException.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.localName+'"');
 if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirContributor) then
    result := parseContributor(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(element, name)
  else if (type_ = TFhirDosage) then
    result := parseDosage(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(element, name)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(element, name)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(element, name)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(element, name)
  else if (type_ = TFhirSignature) then
    result := parseSignature(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirMeta) then
    result := parseMeta(element, name)
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)
  else if (type_ = TFhirCount) then
    result := parseCount(element, name)
  else if (type_ = TFhirMoney) then
    result := parseMoney(element, name)
  else if (type_ = TFhirAge) then
    result := parseAge(element, name)
  else if (type_ = TFhirDistance) then
    result := parseDistance(element, name)
  else if (type_ = TFhirDuration) then
    result := parseDuration(element, name)
  else
    raise EXmlException.create('Unknown Type');
end;

procedure TFHIRXmlComposer.ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject);
begin
   if (base is TFhirDate) then
    composeDate(xml, name,  TFhirDate(base))
  else if (base is TFhirDateTime) then
    composeDateTime(xml, name,  TFhirDateTime(base))
  else if (base is TFhirString) then
    composeString(xml, name,  TFhirString(base))
  else if (base is TFhirInteger) then
    composeInteger(xml, name,  TFhirInteger(base))
  else if (base is TFhirUri) then
    composeUri(xml, name,  TFhirUri(base))
  else if (base is TFhirInstant) then
    composeInstant(xml, name,  TFhirInstant(base))
  else if (base is TFhirXhtml) then
    composeXhtml(xml, name,  TFhirXhtml(base))
  else if (base is TFhirBoolean) then
    composeBoolean(xml, name,  TFhirBoolean(base))
  else if (base is TFhirBase64Binary) then
    composeBase64Binary(xml, name,  TFhirBase64Binary(base))
  else if (base is TFhirTime) then
    composeTime(xml, name,  TFhirTime(base))
  else if (base is TFhirDecimal) then
    composeDecimal(xml, name,  TFhirDecimal(base))
  else if (base is TFhirCode) then
    composeCode(xml, name,  TFhirCode(base))
  else if (base is TFhirOid) then
    composeOid(xml, name,  TFhirOid(base))
  else if (base is TFhirUuid) then
    composeUuid(xml, name,  TFhirUuid(base))
  else if (base is TFhirMarkdown) then
    composeMarkdown(xml, name,  TFhirMarkdown(base))
  else if (base is TFhirUnsignedInt) then
    composeUnsignedInt(xml, name,  TFhirUnsignedInt(base))
  else if (base is TFhirId) then
    composeId(xml, name,  TFhirId(base))
  else if (base is TFhirPositiveInt) then
    composePositiveInt(xml, name,  TFhirPositiveInt(base))
{$IFDEF FHIR_PARAMETERS}
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(xml, name,  TFhirParametersParameter(base))
  else if (base is TFhirParameters) then
    composeParameters(xml, name,  TFhirParameters(base))
{$ENDIF FHIR_PARAMETERS}
  else if (base is TFhirExtension) then
    composeExtension(xml, name,  TFhirExtension(base))
  else if (base is TFhirNarrative) then
    composeNarrative(xml, name,  TFhirNarrative(base))
  else if (base is TFhirContributor) then
    composeContributor(xml, name,  TFhirContributor(base))
  else if (base is TFhirAttachment) then
    composeAttachment(xml, name,  TFhirAttachment(base))
  else if (base is TFhirDataRequirementCodeFilter) then
    composeDataRequirementCodeFilter(xml, name,  TFhirDataRequirementCodeFilter(base))
  else if (base is TFhirDataRequirementDateFilter) then
    composeDataRequirementDateFilter(xml, name,  TFhirDataRequirementDateFilter(base))
  else if (base is TFhirDataRequirement) then
    composeDataRequirement(xml, name,  TFhirDataRequirement(base))
  else if (base is TFhirDosage) then
    composeDosage(xml, name,  TFhirDosage(base))
  else if (base is TFhirIdentifier) then
    composeIdentifier(xml, name,  TFhirIdentifier(base))
  else if (base is TFhirCoding) then
    composeCoding(xml, name,  TFhirCoding(base))
  else if (base is TFhirSampledData) then
    composeSampledData(xml, name,  TFhirSampledData(base))
  else if (base is TFhirRatio) then
    composeRatio(xml, name,  TFhirRatio(base))
  else if (base is TFhirReference) then
    composeReference(xml, name,  TFhirReference(base))
  else if (base is TFhirTriggerDefinition) then
    composeTriggerDefinition(xml, name,  TFhirTriggerDefinition(base))
  else if (base is TFhirPeriod) then
    composePeriod(xml, name,  TFhirPeriod(base))
  else if (base is TFhirQuantity) then
    composeQuantity(xml, name,  TFhirQuantity(base))
  else if (base is TFhirRange) then
    composeRange(xml, name,  TFhirRange(base))
  else if (base is TFhirRelatedArtifact) then
    composeRelatedArtifact(xml, name,  TFhirRelatedArtifact(base))
  else if (base is TFhirAnnotation) then
    composeAnnotation(xml, name,  TFhirAnnotation(base))
  else if (base is TFhirContactDetail) then
    composeContactDetail(xml, name,  TFhirContactDetail(base))
  else if (base is TFhirUsageContext) then
    composeUsageContext(xml, name,  TFhirUsageContext(base))
  else if (base is TFhirSignature) then
    composeSignature(xml, name,  TFhirSignature(base))
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(xml, name,  TFhirCodeableConcept(base))
  else if (base is TFhirParameterDefinition) then
    composeParameterDefinition(xml, name,  TFhirParameterDefinition(base))
  else if (base is TFhirContactPoint) then
    composeContactPoint(xml, name,  TFhirContactPoint(base))
  else if (base is TFhirHumanName) then
    composeHumanName(xml, name,  TFhirHumanName(base))
  else if (base is TFhirMeta) then
    composeMeta(xml, name,  TFhirMeta(base))
  else if (base is TFhirAddress) then
    composeAddress(xml, name,  TFhirAddress(base))
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(xml, name,  TFhirElementDefinitionSlicing(base))
  else if (base is TFhirElementDefinitionSlicingDiscriminator) then
    composeElementDefinitionSlicingDiscriminator(xml, name,  TFhirElementDefinitionSlicingDiscriminator(base))
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(xml, name,  TFhirElementDefinitionBase(base))
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(xml, name,  TFhirElementDefinitionType(base))
  else if (base is TFhirElementDefinitionExample) then
    composeElementDefinitionExample(xml, name,  TFhirElementDefinitionExample(base))
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(xml, name,  TFhirElementDefinitionConstraint(base))
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(xml, name,  TFhirElementDefinitionBinding(base))
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(xml, name,  TFhirElementDefinitionMapping(base))
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(xml, name,  TFhirElementDefinition(base))
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(xml, name,  TFhirTimingRepeat(base))
  else if (base is TFhirTiming) then
    composeTiming(xml, name,  TFhirTiming(base))
  else if (base is TFhirCount) then
    composeCount(xml, name,  TFhirCount(base))
  else if (base is TFhirMoney) then
    composeMoney(xml, name,  TFhirMoney(base))
  else if (base is TFhirAge) then
    composeAge(xml, name,  TFhirAge(base))
  else if (base is TFhirDistance) then
    composeDistance(xml, name,  TFhirDistance(base))
  else if (base is TFhirDuration) then
    composeDuration(xml, name,  TFhirDuration(base))
{$IFDEF FHIR_ACCOUNT}
  else if (base is TFhirAccountCoverage) then
    composeAccountCoverage(xml, name,  TFhirAccountCoverage(base))
  else if (base is TFhirAccountGuarantor) then
    composeAccountGuarantor(xml, name,  TFhirAccountGuarantor(base))
  else if (base is TFhirAccount) then
    composeAccount(xml, name,  TFhirAccount(base))
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if (base is TFhirActivityDefinitionParticipant) then
    composeActivityDefinitionParticipant(xml, name,  TFhirActivityDefinitionParticipant(base))
  else if (base is TFhirActivityDefinitionDynamicValue) then
    composeActivityDefinitionDynamicValue(xml, name,  TFhirActivityDefinitionDynamicValue(base))
  else if (base is TFhirActivityDefinition) then
    composeActivityDefinition(xml, name,  TFhirActivityDefinition(base))
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if (base is TFhirAdverseEventSuspectEntity) then
    composeAdverseEventSuspectEntity(xml, name,  TFhirAdverseEventSuspectEntity(base))
  else if (base is TFhirAdverseEvent) then
    composeAdverseEvent(xml, name,  TFhirAdverseEvent(base))
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(xml, name,  TFhirAllergyIntoleranceReaction(base))
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(xml, name,  TFhirAllergyIntolerance(base))
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(xml, name,  TFhirAppointmentParticipant(base))
  else if (base is TFhirAppointment) then
    composeAppointment(xml, name,  TFhirAppointment(base))
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(xml, name,  TFhirAppointmentResponse(base))
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (base is TFhirAuditEventAgent) then
    composeAuditEventAgent(xml, name,  TFhirAuditEventAgent(base))
  else if (base is TFhirAuditEventAgentNetwork) then
    composeAuditEventAgentNetwork(xml, name,  TFhirAuditEventAgentNetwork(base))
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(xml, name,  TFhirAuditEventSource(base))
  else if (base is TFhirAuditEventEntity) then
    composeAuditEventEntity(xml, name,  TFhirAuditEventEntity(base))
  else if (base is TFhirAuditEventEntityDetail) then
    composeAuditEventEntityDetail(xml, name,  TFhirAuditEventEntityDetail(base))
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(xml, name,  TFhirAuditEvent(base))
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (base is TFhirBasic) then
    composeBasic(xml, name,  TFhirBasic(base))
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (base is TFhirBinary) then
    composeBinary(xml, name,  TFhirBinary(base))
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if (base is TFhirBodySite) then
    composeBodySite(xml, name,  TFhirBodySite(base))
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if (base is TFhirBundleLink) then
    composeBundleLink(xml, name,  TFhirBundleLink(base))
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(xml, name,  TFhirBundleEntry(base))
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(xml, name,  TFhirBundleEntrySearch(base))
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(xml, name,  TFhirBundleEntryRequest(base))
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(xml, name,  TFhirBundleEntryResponse(base))
  else if (base is TFhirBundle) then
    composeBundle(xml, name,  TFhirBundle(base))
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if (base is TFhirCapabilityStatementSoftware) then
    composeCapabilityStatementSoftware(xml, name,  TFhirCapabilityStatementSoftware(base))
  else if (base is TFhirCapabilityStatementImplementation) then
    composeCapabilityStatementImplementation(xml, name,  TFhirCapabilityStatementImplementation(base))
  else if (base is TFhirCapabilityStatementRest) then
    composeCapabilityStatementRest(xml, name,  TFhirCapabilityStatementRest(base))
  else if (base is TFhirCapabilityStatementRestSecurity) then
    composeCapabilityStatementRestSecurity(xml, name,  TFhirCapabilityStatementRestSecurity(base))
  else if (base is TFhirCapabilityStatementRestSecurityCertificate) then
    composeCapabilityStatementRestSecurityCertificate(xml, name,  TFhirCapabilityStatementRestSecurityCertificate(base))
  else if (base is TFhirCapabilityStatementRestResource) then
    composeCapabilityStatementRestResource(xml, name,  TFhirCapabilityStatementRestResource(base))
  else if (base is TFhirCapabilityStatementRestResourceInteraction) then
    composeCapabilityStatementRestResourceInteraction(xml, name,  TFhirCapabilityStatementRestResourceInteraction(base))
  else if (base is TFhirCapabilityStatementRestResourceSearchParam) then
    composeCapabilityStatementRestResourceSearchParam(xml, name,  TFhirCapabilityStatementRestResourceSearchParam(base))
  else if (base is TFhirCapabilityStatementRestInteraction) then
    composeCapabilityStatementRestInteraction(xml, name,  TFhirCapabilityStatementRestInteraction(base))
  else if (base is TFhirCapabilityStatementRestOperation) then
    composeCapabilityStatementRestOperation(xml, name,  TFhirCapabilityStatementRestOperation(base))
  else if (base is TFhirCapabilityStatementMessaging) then
    composeCapabilityStatementMessaging(xml, name,  TFhirCapabilityStatementMessaging(base))
  else if (base is TFhirCapabilityStatementMessagingEndpoint) then
    composeCapabilityStatementMessagingEndpoint(xml, name,  TFhirCapabilityStatementMessagingEndpoint(base))
  else if (base is TFhirCapabilityStatementMessagingSupportedMessage) then
    composeCapabilityStatementMessagingSupportedMessage(xml, name,  TFhirCapabilityStatementMessagingSupportedMessage(base))
  else if (base is TFhirCapabilityStatementMessagingEvent) then
    composeCapabilityStatementMessagingEvent(xml, name,  TFhirCapabilityStatementMessagingEvent(base))
  else if (base is TFhirCapabilityStatementDocument) then
    composeCapabilityStatementDocument(xml, name,  TFhirCapabilityStatementDocument(base))
  else if (base is TFhirCapabilityStatement) then
    composeCapabilityStatement(xml, name,  TFhirCapabilityStatement(base))
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(xml, name,  TFhirCarePlanActivity(base))
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(xml, name,  TFhirCarePlanActivityDetail(base))
  else if (base is TFhirCarePlan) then
    composeCarePlan(xml, name,  TFhirCarePlan(base))
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if (base is TFhirCareTeamParticipant) then
    composeCareTeamParticipant(xml, name,  TFhirCareTeamParticipant(base))
  else if (base is TFhirCareTeam) then
    composeCareTeam(xml, name,  TFhirCareTeam(base))
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if (base is TFhirChargeItemParticipant) then
    composeChargeItemParticipant(xml, name,  TFhirChargeItemParticipant(base))
  else if (base is TFhirChargeItem) then
    composeChargeItem(xml, name,  TFhirChargeItem(base))
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  else if (base is TFhirClaimRelated) then
    composeClaimRelated(xml, name,  TFhirClaimRelated(base))
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(xml, name,  TFhirClaimPayee(base))
  else if (base is TFhirClaimCareTeam) then
    composeClaimCareTeam(xml, name,  TFhirClaimCareTeam(base))
  else if (base is TFhirClaimInformation) then
    composeClaimInformation(xml, name,  TFhirClaimInformation(base))
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(xml, name,  TFhirClaimDiagnosis(base))
  else if (base is TFhirClaimProcedure) then
    composeClaimProcedure(xml, name,  TFhirClaimProcedure(base))
  else if (base is TFhirClaimInsurance) then
    composeClaimInsurance(xml, name,  TFhirClaimInsurance(base))
  else if (base is TFhirClaimAccident) then
    composeClaimAccident(xml, name,  TFhirClaimAccident(base))
  else if (base is TFhirClaimItem) then
    composeClaimItem(xml, name,  TFhirClaimItem(base))
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(xml, name,  TFhirClaimItemDetail(base))
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(xml, name,  TFhirClaimItemDetailSubDetail(base))
  else if (base is TFhirClaim) then
    composeClaim(xml, name,  TFhirClaim(base))
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(xml, name,  TFhirClaimResponseItem(base))
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(xml, name,  TFhirClaimResponseItemAdjudication(base))
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(xml, name,  TFhirClaimResponseItemDetail(base))
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(xml, name,  TFhirClaimResponseItemDetailSubDetail(base))
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(xml, name,  TFhirClaimResponseAddItem(base))
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(xml, name,  TFhirClaimResponseAddItemDetail(base))
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(xml, name,  TFhirClaimResponseError(base))
  else if (base is TFhirClaimResponsePayment) then
    composeClaimResponsePayment(xml, name,  TFhirClaimResponsePayment(base))
  else if (base is TFhirClaimResponseProcessNote) then
    composeClaimResponseProcessNote(xml, name,  TFhirClaimResponseProcessNote(base))
  else if (base is TFhirClaimResponseInsurance) then
    composeClaimResponseInsurance(xml, name,  TFhirClaimResponseInsurance(base))
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(xml, name,  TFhirClaimResponse(base))
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (base is TFhirClinicalImpressionInvestigation) then
    composeClinicalImpressionInvestigation(xml, name,  TFhirClinicalImpressionInvestigation(base))
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(xml, name,  TFhirClinicalImpressionFinding(base))
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(xml, name,  TFhirClinicalImpression(base))
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if (base is TFhirCodeSystemFilter) then
    composeCodeSystemFilter(xml, name,  TFhirCodeSystemFilter(base))
  else if (base is TFhirCodeSystemProperty) then
    composeCodeSystemProperty(xml, name,  TFhirCodeSystemProperty(base))
  else if (base is TFhirCodeSystemConcept) then
    composeCodeSystemConcept(xml, name,  TFhirCodeSystemConcept(base))
  else if (base is TFhirCodeSystemConceptDesignation) then
    composeCodeSystemConceptDesignation(xml, name,  TFhirCodeSystemConceptDesignation(base))
  else if (base is TFhirCodeSystemConceptProperty) then
    composeCodeSystemConceptProperty(xml, name,  TFhirCodeSystemConceptProperty(base))
  else if (base is TFhirCodeSystem) then
    composeCodeSystem(xml, name,  TFhirCodeSystem(base))
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(xml, name,  TFhirCommunicationPayload(base))
  else if (base is TFhirCommunication) then
    composeCommunication(xml, name,  TFhirCommunication(base))
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(xml, name,  TFhirCommunicationRequestPayload(base))
  else if (base is TFhirCommunicationRequestRequester) then
    composeCommunicationRequestRequester(xml, name,  TFhirCommunicationRequestRequester(base))
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(xml, name,  TFhirCommunicationRequest(base))
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if (base is TFhirCompartmentDefinitionResource) then
    composeCompartmentDefinitionResource(xml, name,  TFhirCompartmentDefinitionResource(base))
  else if (base is TFhirCompartmentDefinition) then
    composeCompartmentDefinition(xml, name,  TFhirCompartmentDefinition(base))
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(xml, name,  TFhirCompositionAttester(base))
  else if (base is TFhirCompositionRelatesTo) then
    composeCompositionRelatesTo(xml, name,  TFhirCompositionRelatesTo(base))
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(xml, name,  TFhirCompositionEvent(base))
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(xml, name,  TFhirCompositionSection(base))
  else if (base is TFhirComposition) then
    composeComposition(xml, name,  TFhirComposition(base))
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (base is TFhirConceptMapGroup) then
    composeConceptMapGroup(xml, name,  TFhirConceptMapGroup(base))
  else if (base is TFhirConceptMapGroupElement) then
    composeConceptMapGroupElement(xml, name,  TFhirConceptMapGroupElement(base))
  else if (base is TFhirConceptMapGroupElementTarget) then
    composeConceptMapGroupElementTarget(xml, name,  TFhirConceptMapGroupElementTarget(base))
  else if (base is TFhirConceptMapGroupElementTargetDependsOn) then
    composeConceptMapGroupElementTargetDependsOn(xml, name,  TFhirConceptMapGroupElementTargetDependsOn(base))
  else if (base is TFhirConceptMapGroupUnmapped) then
    composeConceptMapGroupUnmapped(xml, name,  TFhirConceptMapGroupUnmapped(base))
  else if (base is TFhirConceptMap) then
    composeConceptMap(xml, name,  TFhirConceptMap(base))
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (base is TFhirConditionStage) then
    composeConditionStage(xml, name,  TFhirConditionStage(base))
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(xml, name,  TFhirConditionEvidence(base))
  else if (base is TFhirCondition) then
    composeCondition(xml, name,  TFhirCondition(base))
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if (base is TFhirConsentActor) then
    composeConsentActor(xml, name,  TFhirConsentActor(base))
  else if (base is TFhirConsentPolicy) then
    composeConsentPolicy(xml, name,  TFhirConsentPolicy(base))
  else if (base is TFhirConsentData) then
    composeConsentData(xml, name,  TFhirConsentData(base))
  else if (base is TFhirConsentExcept) then
    composeConsentExcept(xml, name,  TFhirConsentExcept(base))
  else if (base is TFhirConsentExceptActor) then
    composeConsentExceptActor(xml, name,  TFhirConsentExceptActor(base))
  else if (base is TFhirConsentExceptData) then
    composeConsentExceptData(xml, name,  TFhirConsentExceptData(base))
  else if (base is TFhirConsent) then
    composeConsent(xml, name,  TFhirConsent(base))
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if (base is TFhirContractAgent) then
    composeContractAgent(xml, name,  TFhirContractAgent(base))
  else if (base is TFhirContractSigner) then
    composeContractSigner(xml, name,  TFhirContractSigner(base))
  else if (base is TFhirContractValuedItem) then
    composeContractValuedItem(xml, name,  TFhirContractValuedItem(base))
  else if (base is TFhirContractTerm) then
    composeContractTerm(xml, name,  TFhirContractTerm(base))
  else if (base is TFhirContractTermAgent) then
    composeContractTermAgent(xml, name,  TFhirContractTermAgent(base))
  else if (base is TFhirContractTermValuedItem) then
    composeContractTermValuedItem(xml, name,  TFhirContractTermValuedItem(base))
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(xml, name,  TFhirContractFriendly(base))
  else if (base is TFhirContractLegal) then
    composeContractLegal(xml, name,  TFhirContractLegal(base))
  else if (base is TFhirContractRule) then
    composeContractRule(xml, name,  TFhirContractRule(base))
  else if (base is TFhirContract) then
    composeContract(xml, name,  TFhirContract(base))
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (base is TFhirCoverageGrouping) then
    composeCoverageGrouping(xml, name,  TFhirCoverageGrouping(base))
  else if (base is TFhirCoverage) then
    composeCoverage(xml, name,  TFhirCoverage(base))
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if (base is TFhirDataElementMapping) then
    composeDataElementMapping(xml, name,  TFhirDataElementMapping(base))
  else if (base is TFhirDataElement) then
    composeDataElement(xml, name,  TFhirDataElement(base))
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(xml, name,  TFhirDetectedIssueMitigation(base))
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(xml, name,  TFhirDetectedIssue(base))
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (base is TFhirDeviceUdi) then
    composeDeviceUdi(xml, name,  TFhirDeviceUdi(base))
  else if (base is TFhirDevice) then
    composeDevice(xml, name,  TFhirDevice(base))
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if (base is TFhirDeviceComponentProductionSpecification) then
    composeDeviceComponentProductionSpecification(xml, name,  TFhirDeviceComponentProductionSpecification(base))
  else if (base is TFhirDeviceComponent) then
    composeDeviceComponent(xml, name,  TFhirDeviceComponent(base))
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(xml, name,  TFhirDeviceMetricCalibration(base))
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(xml, name,  TFhirDeviceMetric(base))
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if (base is TFhirDeviceRequestRequester) then
    composeDeviceRequestRequester(xml, name,  TFhirDeviceRequestRequester(base))
  else if (base is TFhirDeviceRequest) then
    composeDeviceRequest(xml, name,  TFhirDeviceRequest(base))
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(xml, name,  TFhirDeviceUseStatement(base))
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (base is TFhirDiagnosticReportPerformer) then
    composeDiagnosticReportPerformer(xml, name,  TFhirDiagnosticReportPerformer(base))
  else if (base is TFhirDiagnosticReportImage) then
    composeDiagnosticReportImage(xml, name,  TFhirDiagnosticReportImage(base))
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(xml, name,  TFhirDiagnosticReport(base))
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (base is TFhirDocumentManifestContent) then
    composeDocumentManifestContent(xml, name,  TFhirDocumentManifestContent(base))
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(xml, name,  TFhirDocumentManifestRelated(base))
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(xml, name,  TFhirDocumentManifest(base))
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(xml, name,  TFhirDocumentReferenceRelatesTo(base))
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(xml, name,  TFhirDocumentReferenceContent(base))
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(xml, name,  TFhirDocumentReferenceContext(base))
  else if (base is TFhirDocumentReferenceContextRelated) then
    composeDocumentReferenceContextRelated(xml, name,  TFhirDocumentReferenceContextRelated(base))
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(xml, name,  TFhirDocumentReference(base))
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if (base is TFhirEligibilityRequest) then
    composeEligibilityRequest(xml, name,  TFhirEligibilityRequest(base))
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if (base is TFhirEligibilityResponseInsurance) then
    composeEligibilityResponseInsurance(xml, name,  TFhirEligibilityResponseInsurance(base))
  else if (base is TFhirEligibilityResponseInsuranceBenefitBalance) then
    composeEligibilityResponseInsuranceBenefitBalance(xml, name,  TFhirEligibilityResponseInsuranceBenefitBalance(base))
  else if (base is TFhirEligibilityResponseInsuranceBenefitBalanceFinancial) then
    composeEligibilityResponseInsuranceBenefitBalanceFinancial(xml, name,  TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(base))
  else if (base is TFhirEligibilityResponseError) then
    composeEligibilityResponseError(xml, name,  TFhirEligibilityResponseError(base))
  else if (base is TFhirEligibilityResponse) then
    composeEligibilityResponse(xml, name,  TFhirEligibilityResponse(base))
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(xml, name,  TFhirEncounterStatusHistory(base))
  else if (base is TFhirEncounterClassHistory) then
    composeEncounterClassHistory(xml, name,  TFhirEncounterClassHistory(base))
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(xml, name,  TFhirEncounterParticipant(base))
  else if (base is TFhirEncounterDiagnosis) then
    composeEncounterDiagnosis(xml, name,  TFhirEncounterDiagnosis(base))
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(xml, name,  TFhirEncounterHospitalization(base))
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(xml, name,  TFhirEncounterLocation(base))
  else if (base is TFhirEncounter) then
    composeEncounter(xml, name,  TFhirEncounter(base))
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if (base is TFhirEndpoint) then
    composeEndpoint(xml, name,  TFhirEndpoint(base))
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(xml, name,  TFhirEnrollmentRequest(base))
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(xml, name,  TFhirEnrollmentResponse(base))
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(xml, name,  TFhirEpisodeOfCareStatusHistory(base))
  else if (base is TFhirEpisodeOfCareDiagnosis) then
    composeEpisodeOfCareDiagnosis(xml, name,  TFhirEpisodeOfCareDiagnosis(base))
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(xml, name,  TFhirEpisodeOfCare(base))
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  else if (base is TFhirExpansionProfileFixedVersion) then
    composeExpansionProfileFixedVersion(xml, name,  TFhirExpansionProfileFixedVersion(base))
  else if (base is TFhirExpansionProfileExcludedSystem) then
    composeExpansionProfileExcludedSystem(xml, name,  TFhirExpansionProfileExcludedSystem(base))
  else if (base is TFhirExpansionProfileDesignation) then
    composeExpansionProfileDesignation(xml, name,  TFhirExpansionProfileDesignation(base))
  else if (base is TFhirExpansionProfileDesignationInclude) then
    composeExpansionProfileDesignationInclude(xml, name,  TFhirExpansionProfileDesignationInclude(base))
  else if (base is TFhirExpansionProfileDesignationIncludeDesignation) then
    composeExpansionProfileDesignationIncludeDesignation(xml, name,  TFhirExpansionProfileDesignationIncludeDesignation(base))
  else if (base is TFhirExpansionProfileDesignationExclude) then
    composeExpansionProfileDesignationExclude(xml, name,  TFhirExpansionProfileDesignationExclude(base))
  else if (base is TFhirExpansionProfileDesignationExcludeDesignation) then
    composeExpansionProfileDesignationExcludeDesignation(xml, name,  TFhirExpansionProfileDesignationExcludeDesignation(base))
  else if (base is TFhirExpansionProfile) then
    composeExpansionProfile(xml, name,  TFhirExpansionProfile(base))
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (base is TFhirExplanationOfBenefitRelated) then
    composeExplanationOfBenefitRelated(xml, name,  TFhirExplanationOfBenefitRelated(base))
  else if (base is TFhirExplanationOfBenefitPayee) then
    composeExplanationOfBenefitPayee(xml, name,  TFhirExplanationOfBenefitPayee(base))
  else if (base is TFhirExplanationOfBenefitInformation) then
    composeExplanationOfBenefitInformation(xml, name,  TFhirExplanationOfBenefitInformation(base))
  else if (base is TFhirExplanationOfBenefitCareTeam) then
    composeExplanationOfBenefitCareTeam(xml, name,  TFhirExplanationOfBenefitCareTeam(base))
  else if (base is TFhirExplanationOfBenefitDiagnosis) then
    composeExplanationOfBenefitDiagnosis(xml, name,  TFhirExplanationOfBenefitDiagnosis(base))
  else if (base is TFhirExplanationOfBenefitProcedure) then
    composeExplanationOfBenefitProcedure(xml, name,  TFhirExplanationOfBenefitProcedure(base))
  else if (base is TFhirExplanationOfBenefitInsurance) then
    composeExplanationOfBenefitInsurance(xml, name,  TFhirExplanationOfBenefitInsurance(base))
  else if (base is TFhirExplanationOfBenefitAccident) then
    composeExplanationOfBenefitAccident(xml, name,  TFhirExplanationOfBenefitAccident(base))
  else if (base is TFhirExplanationOfBenefitItem) then
    composeExplanationOfBenefitItem(xml, name,  TFhirExplanationOfBenefitItem(base))
  else if (base is TFhirExplanationOfBenefitItemAdjudication) then
    composeExplanationOfBenefitItemAdjudication(xml, name,  TFhirExplanationOfBenefitItemAdjudication(base))
  else if (base is TFhirExplanationOfBenefitItemDetail) then
    composeExplanationOfBenefitItemDetail(xml, name,  TFhirExplanationOfBenefitItemDetail(base))
  else if (base is TFhirExplanationOfBenefitItemDetailSubDetail) then
    composeExplanationOfBenefitItemDetailSubDetail(xml, name,  TFhirExplanationOfBenefitItemDetailSubDetail(base))
  else if (base is TFhirExplanationOfBenefitAddItem) then
    composeExplanationOfBenefitAddItem(xml, name,  TFhirExplanationOfBenefitAddItem(base))
  else if (base is TFhirExplanationOfBenefitAddItemDetail) then
    composeExplanationOfBenefitAddItemDetail(xml, name,  TFhirExplanationOfBenefitAddItemDetail(base))
  else if (base is TFhirExplanationOfBenefitPayment) then
    composeExplanationOfBenefitPayment(xml, name,  TFhirExplanationOfBenefitPayment(base))
  else if (base is TFhirExplanationOfBenefitProcessNote) then
    composeExplanationOfBenefitProcessNote(xml, name,  TFhirExplanationOfBenefitProcessNote(base))
  else if (base is TFhirExplanationOfBenefitBenefitBalance) then
    composeExplanationOfBenefitBenefitBalance(xml, name,  TFhirExplanationOfBenefitBenefitBalance(base))
  else if (base is TFhirExplanationOfBenefitBenefitBalanceFinancial) then
    composeExplanationOfBenefitBenefitBalanceFinancial(xml, name,  TFhirExplanationOfBenefitBenefitBalanceFinancial(base))
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(xml, name,  TFhirExplanationOfBenefit(base))
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(xml, name,  TFhirFamilyMemberHistoryCondition(base))
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(xml, name,  TFhirFamilyMemberHistory(base))
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (base is TFhirFlag) then
    composeFlag(xml, name,  TFhirFlag(base))
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (base is TFhirGoalTarget) then
    composeGoalTarget(xml, name,  TFhirGoalTarget(base))
  else if (base is TFhirGoal) then
    composeGoal(xml, name,  TFhirGoal(base))
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if (base is TFhirGraphDefinitionLink) then
    composeGraphDefinitionLink(xml, name,  TFhirGraphDefinitionLink(base))
  else if (base is TFhirGraphDefinitionLinkTarget) then
    composeGraphDefinitionLinkTarget(xml, name,  TFhirGraphDefinitionLinkTarget(base))
  else if (base is TFhirGraphDefinitionLinkTargetCompartment) then
    composeGraphDefinitionLinkTargetCompartment(xml, name,  TFhirGraphDefinitionLinkTargetCompartment(base))
  else if (base is TFhirGraphDefinition) then
    composeGraphDefinition(xml, name,  TFhirGraphDefinition(base))
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(xml, name,  TFhirGroupCharacteristic(base))
  else if (base is TFhirGroupMember) then
    composeGroupMember(xml, name,  TFhirGroupMember(base))
  else if (base is TFhirGroup) then
    composeGroup(xml, name,  TFhirGroup(base))
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if (base is TFhirGuidanceResponse) then
    composeGuidanceResponse(xml, name,  TFhirGuidanceResponse(base))
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(xml, name,  TFhirHealthcareServiceAvailableTime(base))
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(xml, name,  TFhirHealthcareServiceNotAvailable(base))
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(xml, name,  TFhirHealthcareService(base))
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  else if (base is TFhirImagingManifestStudy) then
    composeImagingManifestStudy(xml, name,  TFhirImagingManifestStudy(base))
  else if (base is TFhirImagingManifestStudySeries) then
    composeImagingManifestStudySeries(xml, name,  TFhirImagingManifestStudySeries(base))
  else if (base is TFhirImagingManifestStudySeriesInstance) then
    composeImagingManifestStudySeriesInstance(xml, name,  TFhirImagingManifestStudySeriesInstance(base))
  else if (base is TFhirImagingManifest) then
    composeImagingManifest(xml, name,  TFhirImagingManifest(base))
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(xml, name,  TFhirImagingStudySeries(base))
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(xml, name,  TFhirImagingStudySeriesInstance(base))
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(xml, name,  TFhirImagingStudy(base))
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (base is TFhirImmunizationPractitioner) then
    composeImmunizationPractitioner(xml, name,  TFhirImmunizationPractitioner(base))
  else if (base is TFhirImmunizationExplanation) then
    composeImmunizationExplanation(xml, name,  TFhirImmunizationExplanation(base))
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(xml, name,  TFhirImmunizationReaction(base))
  else if (base is TFhirImmunizationVaccinationProtocol) then
    composeImmunizationVaccinationProtocol(xml, name,  TFhirImmunizationVaccinationProtocol(base))
  else if (base is TFhirImmunization) then
    composeImmunization(xml, name,  TFhirImmunization(base))
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(xml, name,  TFhirImmunizationRecommendationRecommendation(base))
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(xml, name,  TFhirImmunizationRecommendationRecommendationDateCriterion(base))
  else if (base is TFhirImmunizationRecommendationRecommendationProtocol) then
    composeImmunizationRecommendationRecommendationProtocol(xml, name,  TFhirImmunizationRecommendationRecommendationProtocol(base))
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(xml, name,  TFhirImmunizationRecommendation(base))
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (base is TFhirImplementationGuideDependency) then
    composeImplementationGuideDependency(xml, name,  TFhirImplementationGuideDependency(base))
  else if (base is TFhirImplementationGuidePackage) then
    composeImplementationGuidePackage(xml, name,  TFhirImplementationGuidePackage(base))
  else if (base is TFhirImplementationGuidePackageResource) then
    composeImplementationGuidePackageResource(xml, name,  TFhirImplementationGuidePackageResource(base))
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(xml, name,  TFhirImplementationGuideGlobal(base))
  else if (base is TFhirImplementationGuidePage) then
    composeImplementationGuidePage(xml, name,  TFhirImplementationGuidePage(base))
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(xml, name,  TFhirImplementationGuide(base))
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  else if (base is TFhirLibrary) then
    composeLibrary(xml, name,  TFhirLibrary(base))
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if (base is TFhirLinkageItem) then
    composeLinkageItem(xml, name,  TFhirLinkageItem(base))
  else if (base is TFhirLinkage) then
    composeLinkage(xml, name,  TFhirLinkage(base))
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if (base is TFhirListEntry) then
    composeListEntry(xml, name,  TFhirListEntry(base))
  else if (base is TFhirList) then
    composeList(xml, name,  TFhirList(base))
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(xml, name,  TFhirLocationPosition(base))
  else if (base is TFhirLocation) then
    composeLocation(xml, name,  TFhirLocation(base))
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if (base is TFhirMeasureGroup) then
    composeMeasureGroup(xml, name,  TFhirMeasureGroup(base))
  else if (base is TFhirMeasureGroupPopulation) then
    composeMeasureGroupPopulation(xml, name,  TFhirMeasureGroupPopulation(base))
  else if (base is TFhirMeasureGroupStratifier) then
    composeMeasureGroupStratifier(xml, name,  TFhirMeasureGroupStratifier(base))
  else if (base is TFhirMeasureSupplementalData) then
    composeMeasureSupplementalData(xml, name,  TFhirMeasureSupplementalData(base))
  else if (base is TFhirMeasure) then
    composeMeasure(xml, name,  TFhirMeasure(base))
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if (base is TFhirMeasureReportGroup) then
    composeMeasureReportGroup(xml, name,  TFhirMeasureReportGroup(base))
  else if (base is TFhirMeasureReportGroupPopulation) then
    composeMeasureReportGroupPopulation(xml, name,  TFhirMeasureReportGroupPopulation(base))
  else if (base is TFhirMeasureReportGroupStratifier) then
    composeMeasureReportGroupStratifier(xml, name,  TFhirMeasureReportGroupStratifier(base))
  else if (base is TFhirMeasureReportGroupStratifierStratum) then
    composeMeasureReportGroupStratifierStratum(xml, name,  TFhirMeasureReportGroupStratifierStratum(base))
  else if (base is TFhirMeasureReportGroupStratifierStratumPopulation) then
    composeMeasureReportGroupStratifierStratumPopulation(xml, name,  TFhirMeasureReportGroupStratifierStratumPopulation(base))
  else if (base is TFhirMeasureReport) then
    composeMeasureReport(xml, name,  TFhirMeasureReport(base))
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if (base is TFhirMedia) then
    composeMedia(xml, name,  TFhirMedia(base))
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (base is TFhirMedicationIngredient) then
    composeMedicationIngredient(xml, name,  TFhirMedicationIngredient(base))
  else if (base is TFhirMedicationPackage) then
    composeMedicationPackage(xml, name,  TFhirMedicationPackage(base))
  else if (base is TFhirMedicationPackageContent) then
    composeMedicationPackageContent(xml, name,  TFhirMedicationPackageContent(base))
  else if (base is TFhirMedicationPackageBatch) then
    composeMedicationPackageBatch(xml, name,  TFhirMedicationPackageBatch(base))
  else if (base is TFhirMedication) then
    composeMedication(xml, name,  TFhirMedication(base))
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (base is TFhirMedicationAdministrationPerformer) then
    composeMedicationAdministrationPerformer(xml, name,  TFhirMedicationAdministrationPerformer(base))
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(xml, name,  TFhirMedicationAdministrationDosage(base))
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(xml, name,  TFhirMedicationAdministration(base))
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (base is TFhirMedicationDispensePerformer) then
    composeMedicationDispensePerformer(xml, name,  TFhirMedicationDispensePerformer(base))
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(xml, name,  TFhirMedicationDispenseSubstitution(base))
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(xml, name,  TFhirMedicationDispense(base))
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if (base is TFhirMedicationRequestRequester) then
    composeMedicationRequestRequester(xml, name,  TFhirMedicationRequestRequester(base))
  else if (base is TFhirMedicationRequestDispenseRequest) then
    composeMedicationRequestDispenseRequest(xml, name,  TFhirMedicationRequestDispenseRequest(base))
  else if (base is TFhirMedicationRequestSubstitution) then
    composeMedicationRequestSubstitution(xml, name,  TFhirMedicationRequestSubstitution(base))
  else if (base is TFhirMedicationRequest) then
    composeMedicationRequest(xml, name,  TFhirMedicationRequest(base))
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(xml, name,  TFhirMedicationStatement(base))
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if (base is TFhirMessageDefinitionFocus) then
    composeMessageDefinitionFocus(xml, name,  TFhirMessageDefinitionFocus(base))
  else if (base is TFhirMessageDefinitionAllowedResponse) then
    composeMessageDefinitionAllowedResponse(xml, name,  TFhirMessageDefinitionAllowedResponse(base))
  else if (base is TFhirMessageDefinition) then
    composeMessageDefinition(xml, name,  TFhirMessageDefinition(base))
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(xml, name,  TFhirMessageHeaderDestination(base))
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(xml, name,  TFhirMessageHeaderSource(base))
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(xml, name,  TFhirMessageHeaderResponse(base))
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(xml, name,  TFhirMessageHeader(base))
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(xml, name,  TFhirNamingSystemUniqueId(base))
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(xml, name,  TFhirNamingSystem(base))
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(xml, name,  TFhirNutritionOrderOralDiet(base))
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(xml, name,  TFhirNutritionOrderOralDietNutrient(base))
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(xml, name,  TFhirNutritionOrderOralDietTexture(base))
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(xml, name,  TFhirNutritionOrderSupplement(base))
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(xml, name,  TFhirNutritionOrderEnteralFormula(base))
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(xml, name,  TFhirNutritionOrderEnteralFormulaAdministration(base))
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(xml, name,  TFhirNutritionOrder(base))
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(xml, name,  TFhirObservationReferenceRange(base))
  else if (base is TFhirObservationRelated) then
    composeObservationRelated(xml, name,  TFhirObservationRelated(base))
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(xml, name,  TFhirObservationComponent(base))
  else if (base is TFhirObservation) then
    composeObservation(xml, name,  TFhirObservation(base))
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(xml, name,  TFhirOperationDefinitionParameter(base))
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(xml, name,  TFhirOperationDefinitionParameterBinding(base))
  else if (base is TFhirOperationDefinitionOverload) then
    composeOperationDefinitionOverload(xml, name,  TFhirOperationDefinitionOverload(base))
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(xml, name,  TFhirOperationDefinition(base))
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(xml, name,  TFhirOperationOutcomeIssue(base))
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(xml, name,  TFhirOperationOutcome(base))
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(xml, name,  TFhirOrganizationContact(base))
  else if (base is TFhirOrganization) then
    composeOrganization(xml, name,  TFhirOrganization(base))
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if (base is TFhirPatientContact) then
    composePatientContact(xml, name,  TFhirPatientContact(base))
  else if (base is TFhirPatientAnimal) then
    composePatientAnimal(xml, name,  TFhirPatientAnimal(base))
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(xml, name,  TFhirPatientCommunication(base))
  else if (base is TFhirPatientLink) then
    composePatientLink(xml, name,  TFhirPatientLink(base))
  else if (base is TFhirPatient) then
    composePatient(xml, name,  TFhirPatient(base))
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(xml, name,  TFhirPaymentNotice(base))
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(xml, name,  TFhirPaymentReconciliationDetail(base))
  else if (base is TFhirPaymentReconciliationProcessNote) then
    composePaymentReconciliationProcessNote(xml, name,  TFhirPaymentReconciliationProcessNote(base))
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(xml, name,  TFhirPaymentReconciliation(base))
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (base is TFhirPersonLink) then
    composePersonLink(xml, name,  TFhirPersonLink(base))
  else if (base is TFhirPerson) then
    composePerson(xml, name,  TFhirPerson(base))
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if (base is TFhirPlanDefinitionGoal) then
    composePlanDefinitionGoal(xml, name,  TFhirPlanDefinitionGoal(base))
  else if (base is TFhirPlanDefinitionGoalTarget) then
    composePlanDefinitionGoalTarget(xml, name,  TFhirPlanDefinitionGoalTarget(base))
  else if (base is TFhirPlanDefinitionAction) then
    composePlanDefinitionAction(xml, name,  TFhirPlanDefinitionAction(base))
  else if (base is TFhirPlanDefinitionActionCondition) then
    composePlanDefinitionActionCondition(xml, name,  TFhirPlanDefinitionActionCondition(base))
  else if (base is TFhirPlanDefinitionActionRelatedAction) then
    composePlanDefinitionActionRelatedAction(xml, name,  TFhirPlanDefinitionActionRelatedAction(base))
  else if (base is TFhirPlanDefinitionActionParticipant) then
    composePlanDefinitionActionParticipant(xml, name,  TFhirPlanDefinitionActionParticipant(base))
  else if (base is TFhirPlanDefinitionActionDynamicValue) then
    composePlanDefinitionActionDynamicValue(xml, name,  TFhirPlanDefinitionActionDynamicValue(base))
  else if (base is TFhirPlanDefinition) then
    composePlanDefinition(xml, name,  TFhirPlanDefinition(base))
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(xml, name,  TFhirPractitionerQualification(base))
  else if (base is TFhirPractitioner) then
    composePractitioner(xml, name,  TFhirPractitioner(base))
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if (base is TFhirPractitionerRoleAvailableTime) then
    composePractitionerRoleAvailableTime(xml, name,  TFhirPractitionerRoleAvailableTime(base))
  else if (base is TFhirPractitionerRoleNotAvailable) then
    composePractitionerRoleNotAvailable(xml, name,  TFhirPractitionerRoleNotAvailable(base))
  else if (base is TFhirPractitionerRole) then
    composePractitionerRole(xml, name,  TFhirPractitionerRole(base))
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(xml, name,  TFhirProcedurePerformer(base))
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(xml, name,  TFhirProcedureFocalDevice(base))
  else if (base is TFhirProcedure) then
    composeProcedure(xml, name,  TFhirProcedure(base))
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if (base is TFhirProcedureRequestRequester) then
    composeProcedureRequestRequester(xml, name,  TFhirProcedureRequestRequester(base))
  else if (base is TFhirProcedureRequest) then
    composeProcedureRequest(xml, name,  TFhirProcedureRequest(base))
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if (base is TFhirProcessRequestItem) then
    composeProcessRequestItem(xml, name,  TFhirProcessRequestItem(base))
  else if (base is TFhirProcessRequest) then
    composeProcessRequest(xml, name,  TFhirProcessRequest(base))
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if (base is TFhirProcessResponseProcessNote) then
    composeProcessResponseProcessNote(xml, name,  TFhirProcessResponseProcessNote(base))
  else if (base is TFhirProcessResponse) then
    composeProcessResponse(xml, name,  TFhirProcessResponse(base))
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(xml, name,  TFhirProvenanceAgent(base))
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(xml, name,  TFhirProvenanceEntity(base))
  else if (base is TFhirProvenance) then
    composeProvenance(xml, name,  TFhirProvenance(base))
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (base is TFhirQuestionnaireItem) then
    composeQuestionnaireItem(xml, name,  TFhirQuestionnaireItem(base))
  else if (base is TFhirQuestionnaireItemEnableWhen) then
    composeQuestionnaireItemEnableWhen(xml, name,  TFhirQuestionnaireItemEnableWhen(base))
  else if (base is TFhirQuestionnaireItemOption) then
    composeQuestionnaireItemOption(xml, name,  TFhirQuestionnaireItemOption(base))
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(xml, name,  TFhirQuestionnaire(base))
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (base is TFhirQuestionnaireResponseItem) then
    composeQuestionnaireResponseItem(xml, name,  TFhirQuestionnaireResponseItem(base))
  else if (base is TFhirQuestionnaireResponseItemAnswer) then
    composeQuestionnaireResponseItemAnswer(xml, name,  TFhirQuestionnaireResponseItemAnswer(base))
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(xml, name,  TFhirQuestionnaireResponse(base))
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if (base is TFhirReferralRequestRequester) then
    composeReferralRequestRequester(xml, name,  TFhirReferralRequestRequester(base))
  else if (base is TFhirReferralRequest) then
    composeReferralRequest(xml, name,  TFhirReferralRequest(base))
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(xml, name,  TFhirRelatedPerson(base))
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if (base is TFhirRequestGroupAction) then
    composeRequestGroupAction(xml, name,  TFhirRequestGroupAction(base))
  else if (base is TFhirRequestGroupActionCondition) then
    composeRequestGroupActionCondition(xml, name,  TFhirRequestGroupActionCondition(base))
  else if (base is TFhirRequestGroupActionRelatedAction) then
    composeRequestGroupActionRelatedAction(xml, name,  TFhirRequestGroupActionRelatedAction(base))
  else if (base is TFhirRequestGroup) then
    composeRequestGroup(xml, name,  TFhirRequestGroup(base))
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if (base is TFhirResearchStudyArm) then
    composeResearchStudyArm(xml, name,  TFhirResearchStudyArm(base))
  else if (base is TFhirResearchStudy) then
    composeResearchStudy(xml, name,  TFhirResearchStudy(base))
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if (base is TFhirResearchSubject) then
    composeResearchSubject(xml, name,  TFhirResearchSubject(base))
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(xml, name,  TFhirRiskAssessmentPrediction(base))
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(xml, name,  TFhirRiskAssessment(base))
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if (base is TFhirSchedule) then
    composeSchedule(xml, name,  TFhirSchedule(base))
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (base is TFhirSearchParameterComponent) then
    composeSearchParameterComponent(xml, name,  TFhirSearchParameterComponent(base))
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(xml, name,  TFhirSearchParameter(base))
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  else if (base is TFhirSequenceReferenceSeq) then
    composeSequenceReferenceSeq(xml, name,  TFhirSequenceReferenceSeq(base))
  else if (base is TFhirSequenceVariant) then
    composeSequenceVariant(xml, name,  TFhirSequenceVariant(base))
  else if (base is TFhirSequenceQuality) then
    composeSequenceQuality(xml, name,  TFhirSequenceQuality(base))
  else if (base is TFhirSequenceRepository) then
    composeSequenceRepository(xml, name,  TFhirSequenceRepository(base))
  else if (base is TFhirSequence) then
    composeSequence(xml, name,  TFhirSequence(base))
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  else if (base is TFhirServiceDefinition) then
    composeServiceDefinition(xml, name,  TFhirServiceDefinition(base))
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  else if (base is TFhirSlot) then
    composeSlot(xml, name,  TFhirSlot(base))
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(xml, name,  TFhirSpecimenCollection(base))
  else if (base is TFhirSpecimenProcessing) then
    composeSpecimenProcessing(xml, name,  TFhirSpecimenProcessing(base))
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(xml, name,  TFhirSpecimenContainer(base))
  else if (base is TFhirSpecimen) then
    composeSpecimen(xml, name,  TFhirSpecimen(base))
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(xml, name,  TFhirStructureDefinitionMapping(base))
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(xml, name,  TFhirStructureDefinitionSnapshot(base))
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(xml, name,  TFhirStructureDefinitionDifferential(base))
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(xml, name,  TFhirStructureDefinition(base))
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if (base is TFhirStructureMapStructure) then
    composeStructureMapStructure(xml, name,  TFhirStructureMapStructure(base))
  else if (base is TFhirStructureMapGroup) then
    composeStructureMapGroup(xml, name,  TFhirStructureMapGroup(base))
  else if (base is TFhirStructureMapGroupInput) then
    composeStructureMapGroupInput(xml, name,  TFhirStructureMapGroupInput(base))
  else if (base is TFhirStructureMapGroupRule) then
    composeStructureMapGroupRule(xml, name,  TFhirStructureMapGroupRule(base))
  else if (base is TFhirStructureMapGroupRuleSource) then
    composeStructureMapGroupRuleSource(xml, name,  TFhirStructureMapGroupRuleSource(base))
  else if (base is TFhirStructureMapGroupRuleTarget) then
    composeStructureMapGroupRuleTarget(xml, name,  TFhirStructureMapGroupRuleTarget(base))
  else if (base is TFhirStructureMapGroupRuleTargetParameter) then
    composeStructureMapGroupRuleTargetParameter(xml, name,  TFhirStructureMapGroupRuleTargetParameter(base))
  else if (base is TFhirStructureMapGroupRuleDependent) then
    composeStructureMapGroupRuleDependent(xml, name,  TFhirStructureMapGroupRuleDependent(base))
  else if (base is TFhirStructureMap) then
    composeStructureMap(xml, name,  TFhirStructureMap(base))
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(xml, name,  TFhirSubscriptionChannel(base))
  else if (base is TFhirSubscription) then
    composeSubscription(xml, name,  TFhirSubscription(base))
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(xml, name,  TFhirSubstanceInstance(base))
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(xml, name,  TFhirSubstanceIngredient(base))
  else if (base is TFhirSubstance) then
    composeSubstance(xml, name,  TFhirSubstance(base))
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (base is TFhirSupplyDeliverySuppliedItem) then
    composeSupplyDeliverySuppliedItem(xml, name,  TFhirSupplyDeliverySuppliedItem(base))
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(xml, name,  TFhirSupplyDelivery(base))
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (base is TFhirSupplyRequestOrderedItem) then
    composeSupplyRequestOrderedItem(xml, name,  TFhirSupplyRequestOrderedItem(base))
  else if (base is TFhirSupplyRequestRequester) then
    composeSupplyRequestRequester(xml, name,  TFhirSupplyRequestRequester(base))
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(xml, name,  TFhirSupplyRequest(base))
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if (base is TFhirTaskRequester) then
    composeTaskRequester(xml, name,  TFhirTaskRequester(base))
  else if (base is TFhirTaskRestriction) then
    composeTaskRestriction(xml, name,  TFhirTaskRestriction(base))
  else if (base is TFhirTaskInput) then
    composeTaskInput(xml, name,  TFhirTaskInput(base))
  else if (base is TFhirTaskOutput) then
    composeTaskOutput(xml, name,  TFhirTaskOutput(base))
  else if (base is TFhirTask) then
    composeTask(xml, name,  TFhirTask(base))
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  else if (base is TFhirTestReportParticipant) then
    composeTestReportParticipant(xml, name,  TFhirTestReportParticipant(base))
  else if (base is TFhirTestReportSetup) then
    composeTestReportSetup(xml, name,  TFhirTestReportSetup(base))
  else if (base is TFhirTestReportSetupAction) then
    composeTestReportSetupAction(xml, name,  TFhirTestReportSetupAction(base))
  else if (base is TFhirTestReportSetupActionOperation) then
    composeTestReportSetupActionOperation(xml, name,  TFhirTestReportSetupActionOperation(base))
  else if (base is TFhirTestReportSetupActionAssert) then
    composeTestReportSetupActionAssert(xml, name,  TFhirTestReportSetupActionAssert(base))
  else if (base is TFhirTestReportTest) then
    composeTestReportTest(xml, name,  TFhirTestReportTest(base))
  else if (base is TFhirTestReportTestAction) then
    composeTestReportTestAction(xml, name,  TFhirTestReportTestAction(base))
  else if (base is TFhirTestReportTeardown) then
    composeTestReportTeardown(xml, name,  TFhirTestReportTeardown(base))
  else if (base is TFhirTestReportTeardownAction) then
    composeTestReportTeardownAction(xml, name,  TFhirTestReportTeardownAction(base))
  else if (base is TFhirTestReport) then
    composeTestReport(xml, name,  TFhirTestReport(base))
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if (base is TFhirTestScriptOrigin) then
    composeTestScriptOrigin(xml, name,  TFhirTestScriptOrigin(base))
  else if (base is TFhirTestScriptDestination) then
    composeTestScriptDestination(xml, name,  TFhirTestScriptDestination(base))
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(xml, name,  TFhirTestScriptMetadata(base))
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(xml, name,  TFhirTestScriptMetadataLink(base))
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(xml, name,  TFhirTestScriptMetadataCapability(base))
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(xml, name,  TFhirTestScriptFixture(base))
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(xml, name,  TFhirTestScriptVariable(base))
  else if (base is TFhirTestScriptRule) then
    composeTestScriptRule(xml, name,  TFhirTestScriptRule(base))
  else if (base is TFhirTestScriptRuleParam) then
    composeTestScriptRuleParam(xml, name,  TFhirTestScriptRuleParam(base))
  else if (base is TFhirTestScriptRuleset) then
    composeTestScriptRuleset(xml, name,  TFhirTestScriptRuleset(base))
  else if (base is TFhirTestScriptRulesetRule) then
    composeTestScriptRulesetRule(xml, name,  TFhirTestScriptRulesetRule(base))
  else if (base is TFhirTestScriptRulesetRuleParam) then
    composeTestScriptRulesetRuleParam(xml, name,  TFhirTestScriptRulesetRuleParam(base))
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(xml, name,  TFhirTestScriptSetup(base))
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(xml, name,  TFhirTestScriptSetupAction(base))
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(xml, name,  TFhirTestScriptSetupActionOperation(base))
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(xml, name,  TFhirTestScriptSetupActionOperationRequestHeader(base))
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(xml, name,  TFhirTestScriptSetupActionAssert(base))
  else if (base is TFhirTestScriptSetupActionAssertRule) then
    composeTestScriptSetupActionAssertRule(xml, name,  TFhirTestScriptSetupActionAssertRule(base))
  else if (base is TFhirTestScriptSetupActionAssertRuleParam) then
    composeTestScriptSetupActionAssertRuleParam(xml, name,  TFhirTestScriptSetupActionAssertRuleParam(base))
  else if (base is TFhirTestScriptSetupActionAssertRuleset) then
    composeTestScriptSetupActionAssertRuleset(xml, name,  TFhirTestScriptSetupActionAssertRuleset(base))
  else if (base is TFhirTestScriptSetupActionAssertRulesetRule) then
    composeTestScriptSetupActionAssertRulesetRule(xml, name,  TFhirTestScriptSetupActionAssertRulesetRule(base))
  else if (base is TFhirTestScriptSetupActionAssertRulesetRuleParam) then
    composeTestScriptSetupActionAssertRulesetRuleParam(xml, name,  TFhirTestScriptSetupActionAssertRulesetRuleParam(base))
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(xml, name,  TFhirTestScriptTest(base))
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(xml, name,  TFhirTestScriptTestAction(base))
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(xml, name,  TFhirTestScriptTeardown(base))
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(xml, name,  TFhirTestScriptTeardownAction(base))
  else if (base is TFhirTestScript) then
    composeTestScript(xml, name,  TFhirTestScript(base))
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(xml, name,  TFhirValueSetCompose(base))
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(xml, name,  TFhirValueSetComposeInclude(base))
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(xml, name,  TFhirValueSetComposeIncludeConcept(base))
  else if (base is TFhirValueSetComposeIncludeConceptDesignation) then
    composeValueSetComposeIncludeConceptDesignation(xml, name,  TFhirValueSetComposeIncludeConceptDesignation(base))
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(xml, name,  TFhirValueSetComposeIncludeFilter(base))
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(xml, name,  TFhirValueSetExpansion(base))
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(xml, name,  TFhirValueSetExpansionParameter(base))
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(xml, name,  TFhirValueSetExpansionContains(base))
  else if (base is TFhirValueSet) then
    composeValueSet(xml, name,  TFhirValueSet(base))
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (base is TFhirVisionPrescriptionDispense) then
    composeVisionPrescriptionDispense(xml, name,  TFhirVisionPrescriptionDispense(base))
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(xml, name,  TFhirVisionPrescription(base))
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    inherited ComposeBase(xml, name, base);
end;

end.

