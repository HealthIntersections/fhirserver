unit fhir3_turtle;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir3.inc}

interface

// FHIR v3.0.1 generated 2018-06-12T19:15:59+10:00

uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_collections, fsl_turtle, 
  fhir_parser, fhir_objects, 
  fhir3_parserBase, fhir3_resources, fhir3_constants, fhir3_types, fhir3_resources_base;

Type

  TFHIRTurtleParser = class (TFHIRTurtleParserBase3)
  protected
    function ParseElement(obj : TTurtleComplex) : TFhirElement; overload;

    procedure ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
    procedure ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement); overload;
    function ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement; overload;

    function ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    function ParseDate(obj : TTurtleComplex) : TFHIRDate; overload;
    function ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime; overload;
    function ParseString(obj : TTurtleComplex) : TFHIRString; overload;
    function ParseInteger(obj : TTurtleComplex) : TFHIRInteger; overload;
    function ParseUri(obj : TTurtleComplex) : TFHIRUri; overload;
    function ParseInstant(obj : TTurtleComplex) : TFHIRInstant; overload;
    function ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml; overload;
    function ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean; overload;
    function ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary; overload;
    function ParseTime(obj : TTurtleComplex) : TFHIRTime; overload;
    function ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal; overload;
    function ParseCode(obj : TTurtleComplex) : TFHIRCode; overload;
    function ParseOid(obj : TTurtleComplex) : TFHIROid; overload;
    function ParseUuid(obj : TTurtleComplex) : TFHIRUuid; overload;
    function ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown; overload;
    function ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt; overload;
    function ParseId(obj : TTurtleComplex) : TFHIRId; overload;
    function ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt; overload;

    procedure ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
    procedure ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter); overload; {b\}
    function ParseParameters(obj : TTurtleComplex) : TFhirParameters; overload;
    procedure ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters); overload;
{$ENDIF FHIR_PARAMETERS}

    function ParseExtension(obj : TTurtleComplex) : TFhirExtension; overload;
    procedure ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension); overload;
    function ParseNarrative(obj : TTurtleComplex) : TFhirNarrative; overload;
    procedure ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative); overload;
    function ParseContributor(obj : TTurtleComplex) : TFhirContributor; overload;
    procedure ParseContributorProperties(obj : TTurtleComplex; result : TFhirContributor); overload;
    function ParseAttachment(obj : TTurtleComplex) : TFhirAttachment; overload;
    procedure ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment); overload;
    function ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter; overload; {b\}
    procedure ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementCodeFilter); overload; {b\}
    function ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter; overload; {b\}
    procedure ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementDateFilter); overload; {b\}
    function ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement; overload;
    procedure ParseDataRequirementProperties(obj : TTurtleComplex; result : TFhirDataRequirement); overload;
    function ParseDosage(obj : TTurtleComplex) : TFhirDosage; overload;
    procedure ParseDosageProperties(obj : TTurtleComplex; result : TFhirDosage); overload;
    function ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier; overload;
    procedure ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier); overload;
    function ParseCoding(obj : TTurtleComplex) : TFhirCoding; overload;
    procedure ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding); overload;
    function ParseSampledData(obj : TTurtleComplex) : TFhirSampledData; overload;
    procedure ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData); overload;
    function ParseRatio(obj : TTurtleComplex) : TFhirRatio; overload;
    procedure ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio); overload;
    function ParseReference(obj : TTurtleComplex) : TFhirReference; overload;
    procedure ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference); overload;
    function ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition; overload;
    procedure ParseTriggerDefinitionProperties(obj : TTurtleComplex; result : TFhirTriggerDefinition); overload;
    function ParsePeriod(obj : TTurtleComplex) : TFhirPeriod; overload;
    procedure ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod); overload;
    function ParseQuantity(obj : TTurtleComplex) : TFhirQuantity; overload;
    procedure ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity); overload;
    function ParseRange(obj : TTurtleComplex) : TFhirRange; overload;
    procedure ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange); overload;
    function ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact; overload;
    procedure ParseRelatedArtifactProperties(obj : TTurtleComplex; result : TFhirRelatedArtifact); overload;
    function ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation; overload;
    procedure ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation); overload;
    function ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail; overload;
    procedure ParseContactDetailProperties(obj : TTurtleComplex; result : TFhirContactDetail); overload;
    function ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext; overload;
    procedure ParseUsageContextProperties(obj : TTurtleComplex; result : TFhirUsageContext); overload;
    function ParseSignature(obj : TTurtleComplex) : TFhirSignature; overload;
    procedure ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature); overload;
    function ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept); overload;
    function ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition; overload;
    procedure ParseParameterDefinitionProperties(obj : TTurtleComplex; result : TFhirParameterDefinition); overload;
    function ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint; overload;
    procedure ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint); overload;
    function ParseHumanName(obj : TTurtleComplex) : TFhirHumanName; overload;
    procedure ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName); overload;
    function ParseMeta(obj : TTurtleComplex) : TFhirMeta; overload;
    procedure ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta); overload;
    function ParseAddress(obj : TTurtleComplex) : TFhirAddress; overload;
    procedure ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress); overload;
    function ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing); overload; {b\}
    function ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator; overload; {b\}
    procedure ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicingDiscriminator); overload; {b\}
    function ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase); overload; {b\}
    function ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType); overload; {b\}
    function ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample; overload; {b\}
    procedure ParseElementDefinitionExampleProperties(obj : TTurtleComplex; result : TFhirElementDefinitionExample); overload; {b\}
    function ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint); overload; {b\}
    function ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding); overload; {b\}
    function ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping); overload; {b\}
    function ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition; overload;
    procedure ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition); overload;
    function ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat); overload; {b\}
    function ParseTiming(obj : TTurtleComplex) : TFhirTiming; overload;
    procedure ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming); overload;
    function ParseCount(obj : TTurtleComplex) : TFhirCount; overload;
    procedure ParseCountProperties(obj : TTurtleComplex; result : TFhirCount); overload;
    function ParseMoney(obj : TTurtleComplex) : TFhirMoney; overload;
    procedure ParseMoneyProperties(obj : TTurtleComplex; result : TFhirMoney); overload;
    function ParseAge(obj : TTurtleComplex) : TFhirAge; overload;
    procedure ParseAgeProperties(obj : TTurtleComplex; result : TFhirAge); overload;
    function ParseDistance(obj : TTurtleComplex) : TFhirDistance; overload;
    procedure ParseDistanceProperties(obj : TTurtleComplex; result : TFhirDistance); overload;
    function ParseDuration(obj : TTurtleComplex) : TFhirDuration; overload;
    procedure ParseDurationProperties(obj : TTurtleComplex; result : TFhirDuration); overload;

{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage; overload; {b\}
    procedure ParseAccountCoverageProperties(obj : TTurtleComplex; result : TFhirAccountCoverage); overload; {b\}
    function ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor; overload; {b\}
    procedure ParseAccountGuarantorProperties(obj : TTurtleComplex; result : TFhirAccountGuarantor); overload; {b\}
    function ParseAccount(obj : TTurtleComplex) : TFhirAccount; overload;
    procedure ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount); overload;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant; overload; {b\}
    procedure ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionParticipant); overload; {b\}
    function ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue; overload; {b\}
    procedure ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionDynamicValue); overload; {b\}
    function ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition; overload;
    procedure ParseActivityDefinitionProperties(obj : TTurtleComplex; result : TFhirActivityDefinition); overload;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity; overload; {b\}
    procedure ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntity); overload; {b\}
    function ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent; overload;
    procedure ParseAdverseEventProperties(obj : TTurtleComplex; result : TFhirAdverseEvent); overload;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction); overload; {b\}
    function ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance); overload;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant); overload; {b\}
    function ParseAppointment(obj : TTurtleComplex) : TFhirAppointment; overload;
    procedure ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment); overload;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse); overload;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent; overload; {b\}
    procedure ParseAuditEventAgentProperties(obj : TTurtleComplex; result : TFhirAuditEventAgent); overload; {b\}
    function ParseAuditEventAgentNetwork(obj : TTurtleComplex) : TFhirAuditEventAgentNetwork; overload; {b\}
    procedure ParseAuditEventAgentNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventAgentNetwork); overload; {b\}
    function ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource); overload; {b\}
    function ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity; overload; {b\}
    procedure ParseAuditEventEntityProperties(obj : TTurtleComplex; result : TFhirAuditEventEntity); overload; {b\}
    function ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail; overload; {b\}
    procedure ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventEntityDetail); overload; {b\}
    function ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent; overload;
    procedure ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent); overload;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(obj : TTurtleComplex) : TFhirBasic; overload;
    procedure ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic); overload;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(obj : TTurtleComplex) : TFhirBinary; overload;
    procedure ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary); overload;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    function ParseBodySite(obj : TTurtleComplex) : TFhirBodySite; overload;
    procedure ParseBodySiteProperties(obj : TTurtleComplex; result : TFhirBodySite); overload;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink); overload; {b\}
    function ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry); overload; {b\}
    function ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch); overload; {b\}
    function ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest); overload; {b\}
    function ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse); overload; {b\}
    function ParseBundle(obj : TTurtleComplex) : TFhirBundle; overload;
    procedure ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle); overload;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware; overload; {b\}
    procedure ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementSoftware); overload; {b\}
    function ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation; overload; {b\}
    procedure ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementImplementation); overload; {b\}
    function ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest; overload; {b\}
    procedure ParseCapabilityStatementRestProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRest); overload; {b\}
    function ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity; overload; {b\}
    procedure ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurity); overload; {b\}
    function ParseCapabilityStatementRestSecurityCertificate(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurityCertificate; overload; {b\}
    procedure ParseCapabilityStatementRestSecurityCertificateProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurityCertificate); overload; {b\}
    function ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource; overload; {b\}
    procedure ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResource); overload; {b\}
    function ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceInteraction); overload; {b\}
    function ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam; overload; {b\}
    procedure ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceSearchParam); overload; {b\}
    function ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestInteraction); overload; {b\}
    function ParseCapabilityStatementRestOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestOperation; overload; {b\}
    procedure ParseCapabilityStatementRestOperationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestOperation); overload; {b\}
    function ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging; overload; {b\}
    procedure ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessaging); overload; {b\}
    function ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint; overload; {b\}
    procedure ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEndpoint); overload; {b\}
    function ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage; overload; {b\}
    procedure ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingSupportedMessage); overload; {b\}
    function ParseCapabilityStatementMessagingEvent(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEvent; overload; {b\}
    procedure ParseCapabilityStatementMessagingEventProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEvent); overload; {b\}
    function ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument; overload; {b\}
    procedure ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementDocument); overload; {b\}
    function ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement; overload;
    procedure ParseCapabilityStatementProperties(obj : TTurtleComplex; result : TFhirCapabilityStatement); overload;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity); overload; {b\}
    function ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail); overload; {b\}
    function ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan; overload;
    procedure ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan); overload;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant; overload; {b\}
    procedure ParseCareTeamParticipantProperties(obj : TTurtleComplex; result : TFhirCareTeamParticipant); overload; {b\}
    function ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam; overload;
    procedure ParseCareTeamProperties(obj : TTurtleComplex; result : TFhirCareTeam); overload;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemParticipant(obj : TTurtleComplex) : TFhirChargeItemParticipant; overload; {b\}
    procedure ParseChargeItemParticipantProperties(obj : TTurtleComplex; result : TFhirChargeItemParticipant); overload; {b\}
    function ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem; overload;
    procedure ParseChargeItemProperties(obj : TTurtleComplex; result : TFhirChargeItem); overload;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated; overload; {b\}
    procedure ParseClaimRelatedProperties(obj : TTurtleComplex; result : TFhirClaimRelated); overload; {b\}
    function ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee); overload; {b\}
    function ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam; overload; {b\}
    procedure ParseClaimCareTeamProperties(obj : TTurtleComplex; result : TFhirClaimCareTeam); overload; {b\}
    function ParseClaimInformation(obj : TTurtleComplex) : TFhirClaimInformation; overload; {b\}
    procedure ParseClaimInformationProperties(obj : TTurtleComplex; result : TFhirClaimInformation); overload; {b\}
    function ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis); overload; {b\}
    function ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure; overload; {b\}
    procedure ParseClaimProcedureProperties(obj : TTurtleComplex; result : TFhirClaimProcedure); overload; {b\}
    function ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance; overload; {b\}
    procedure ParseClaimInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimInsurance); overload; {b\}
    function ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident; overload; {b\}
    procedure ParseClaimAccidentProperties(obj : TTurtleComplex; result : TFhirClaimAccident); overload; {b\}
    function ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem); overload; {b\}
    function ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail); overload; {b\}
    function ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail); overload; {b\}
    function ParseClaim(obj : TTurtleComplex) : TFhirClaim; overload;
    procedure ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim); overload;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem); overload; {b\}
    function ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication); overload; {b\}
    function ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail); overload; {b\}
    function ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail); overload; {b\}
    function ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem); overload; {b\}
    function ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail); overload; {b\}
    function ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError); overload; {b\}
    function ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment; overload; {b\}
    procedure ParseClaimResponsePaymentProperties(obj : TTurtleComplex; result : TFhirClaimResponsePayment); overload; {b\}
    function ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote; overload; {b\}
    procedure ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseProcessNote); overload; {b\}
    function ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance; overload; {b\}
    procedure ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimResponseInsurance); overload; {b\}
    function ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse; overload;
    procedure ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse); overload;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigation(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigation; overload; {b\}
    procedure ParseClinicalImpressionInvestigationProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigation); overload; {b\}
    function ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding); overload; {b\}
    function ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression); overload;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter; overload; {b\}
    procedure ParseCodeSystemFilterProperties(obj : TTurtleComplex; result : TFhirCodeSystemFilter); overload; {b\}
    function ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty; overload; {b\}
    procedure ParseCodeSystemPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemProperty); overload; {b\}
    function ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept; overload; {b\}
    procedure ParseCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirCodeSystemConcept); overload; {b\}
    function ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation; overload; {b\}
    procedure ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptDesignation); overload; {b\}
    function ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty; overload; {b\}
    procedure ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptProperty); overload; {b\}
    function ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem; overload;
    procedure ParseCodeSystemProperties(obj : TTurtleComplex; result : TFhirCodeSystem); overload;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload); overload; {b\}
    function ParseCommunication(obj : TTurtleComplex) : TFhirCommunication; overload;
    procedure ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication); overload;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload); overload; {b\}
    function ParseCommunicationRequestRequester(obj : TTurtleComplex) : TFhirCommunicationRequestRequester; overload; {b\}
    procedure ParseCommunicationRequestRequesterProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestRequester); overload; {b\}
    function ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest); overload;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource; overload; {b\}
    procedure ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinitionResource); overload; {b\}
    function ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition; overload;
    procedure ParseCompartmentDefinitionProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinition); overload;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester); overload; {b\}
    function ParseCompositionRelatesTo(obj : TTurtleComplex) : TFhirCompositionRelatesTo; overload; {b\}
    procedure ParseCompositionRelatesToProperties(obj : TTurtleComplex; result : TFhirCompositionRelatesTo); overload; {b\}
    function ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent); overload; {b\}
    function ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection); overload; {b\}
    function ParseComposition(obj : TTurtleComplex) : TFhirComposition; overload;
    procedure ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition); overload;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup; overload; {b\}
    procedure ParseConceptMapGroupProperties(obj : TTurtleComplex; result : TFhirConceptMapGroup); overload; {b\}
    function ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement; overload; {b\}
    procedure ParseConceptMapGroupElementProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElement); overload; {b\}
    function ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget; overload; {b\}
    procedure ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTarget); overload; {b\}
    function ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTargetDependsOn); overload; {b\}
    function ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped; overload; {b\}
    procedure ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupUnmapped); overload; {b\}
    function ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap; overload;
    procedure ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap); overload;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage); overload; {b\}
    function ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence); overload; {b\}
    function ParseCondition(obj : TTurtleComplex) : TFhirCondition; overload;
    procedure ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition); overload;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentActor(obj : TTurtleComplex) : TFhirConsentActor; overload; {b\}
    procedure ParseConsentActorProperties(obj : TTurtleComplex; result : TFhirConsentActor); overload; {b\}
    function ParseConsentPolicy(obj : TTurtleComplex) : TFhirConsentPolicy; overload; {b\}
    procedure ParseConsentPolicyProperties(obj : TTurtleComplex; result : TFhirConsentPolicy); overload; {b\}
    function ParseConsentData(obj : TTurtleComplex) : TFhirConsentData; overload; {b\}
    procedure ParseConsentDataProperties(obj : TTurtleComplex; result : TFhirConsentData); overload; {b\}
    function ParseConsentExcept(obj : TTurtleComplex) : TFhirConsentExcept; overload; {b\}
    procedure ParseConsentExceptProperties(obj : TTurtleComplex; result : TFhirConsentExcept); overload; {b\}
    function ParseConsentExceptActor(obj : TTurtleComplex) : TFhirConsentExceptActor; overload; {b\}
    procedure ParseConsentExceptActorProperties(obj : TTurtleComplex; result : TFhirConsentExceptActor); overload; {b\}
    function ParseConsentExceptData(obj : TTurtleComplex) : TFhirConsentExceptData; overload; {b\}
    procedure ParseConsentExceptDataProperties(obj : TTurtleComplex; result : TFhirConsentExceptData); overload; {b\}
    function ParseConsent(obj : TTurtleComplex) : TFhirConsent; overload;
    procedure ParseConsentProperties(obj : TTurtleComplex; result : TFhirConsent); overload;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractAgent(obj : TTurtleComplex) : TFhirContractAgent; overload; {b\}
    procedure ParseContractAgentProperties(obj : TTurtleComplex; result : TFhirContractAgent); overload; {b\}
    function ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner); overload; {b\}
    function ParseContractValuedItem(obj : TTurtleComplex) : TFhirContractValuedItem; overload; {b\}
    procedure ParseContractValuedItemProperties(obj : TTurtleComplex; result : TFhirContractValuedItem); overload; {b\}
    function ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm); overload; {b\}
    function ParseContractTermAgent(obj : TTurtleComplex) : TFhirContractTermAgent; overload; {b\}
    procedure ParseContractTermAgentProperties(obj : TTurtleComplex; result : TFhirContractTermAgent); overload; {b\}
    function ParseContractTermValuedItem(obj : TTurtleComplex) : TFhirContractTermValuedItem; overload; {b\}
    procedure ParseContractTermValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermValuedItem); overload; {b\}
    function ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly); overload; {b\}
    function ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal); overload; {b\}
    function ParseContractRule(obj : TTurtleComplex) : TFhirContractRule; overload; {b\}
    procedure ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule); overload; {b\}
    function ParseContract(obj : TTurtleComplex) : TFhirContract; overload;
    procedure ParseContractProperties(obj : TTurtleComplex; result : TFhirContract); overload;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverageGrouping(obj : TTurtleComplex) : TFhirCoverageGrouping; overload; {b\}
    procedure ParseCoverageGroupingProperties(obj : TTurtleComplex; result : TFhirCoverageGrouping); overload; {b\}
    function ParseCoverage(obj : TTurtleComplex) : TFhirCoverage; overload;
    procedure ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage); overload;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    function ParseDataElementMapping(obj : TTurtleComplex) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMappingProperties(obj : TTurtleComplex; result : TFhirDataElementMapping); overload; {b\}
    function ParseDataElement(obj : TTurtleComplex) : TFhirDataElement; overload;
    procedure ParseDataElementProperties(obj : TTurtleComplex; result : TFhirDataElement); overload;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation); overload; {b\}
    function ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue); overload;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdi(obj : TTurtleComplex) : TFhirDeviceUdi; overload; {b\}
    procedure ParseDeviceUdiProperties(obj : TTurtleComplex; result : TFhirDeviceUdi); overload; {b\}
    function ParseDevice(obj : TTurtleComplex) : TFhirDevice; overload;
    procedure ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice); overload;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    function ParseDeviceComponentProductionSpecification(obj : TTurtleComplex) : TFhirDeviceComponentProductionSpecification; overload; {b\}
    procedure ParseDeviceComponentProductionSpecificationProperties(obj : TTurtleComplex; result : TFhirDeviceComponentProductionSpecification); overload; {b\}
    function ParseDeviceComponent(obj : TTurtleComplex) : TFhirDeviceComponent; overload;
    procedure ParseDeviceComponentProperties(obj : TTurtleComplex; result : TFhirDeviceComponent); overload;
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration); overload; {b\}
    function ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric); overload;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestRequester(obj : TTurtleComplex) : TFhirDeviceRequestRequester; overload; {b\}
    procedure ParseDeviceRequestRequesterProperties(obj : TTurtleComplex; result : TFhirDeviceRequestRequester); overload; {b\}
    function ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest; overload;
    procedure ParseDeviceRequestProperties(obj : TTurtleComplex; result : TFhirDeviceRequest); overload;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement); overload;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportPerformer(obj : TTurtleComplex) : TFhirDiagnosticReportPerformer; overload; {b\}
    procedure ParseDiagnosticReportPerformerProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportPerformer); overload; {b\}
    function ParseDiagnosticReportImage(obj : TTurtleComplex) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImageProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportImage); overload; {b\}
    function ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport); overload;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestContent(obj : TTurtleComplex) : TFhirDocumentManifestContent; overload; {b\}
    procedure ParseDocumentManifestContentProperties(obj : TTurtleComplex; result : TFhirDocumentManifestContent); overload; {b\}
    function ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated); overload; {b\}
    function ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest); overload;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo); overload; {b\}
    function ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent); overload; {b\}
    function ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext); overload; {b\}
    function ParseDocumentReferenceContextRelated(obj : TTurtleComplex) : TFhirDocumentReferenceContextRelated; overload; {b\}
    procedure ParseDocumentReferenceContextRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContextRelated); overload; {b\}
    function ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference; overload;
    procedure ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference); overload;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    function ParseEligibilityRequest(obj : TTurtleComplex) : TFhirEligibilityRequest; overload;
    procedure ParseEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirEligibilityRequest); overload;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    function ParseEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirEligibilityResponseInsurance; overload; {b\}
    procedure ParseEligibilityResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsurance); overload; {b\}
    function ParseEligibilityResponseInsuranceBenefitBalance(obj : TTurtleComplex) : TFhirEligibilityResponseInsuranceBenefitBalance; overload; {b\}
    procedure ParseEligibilityResponseInsuranceBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsuranceBenefitBalance); overload; {b\}
    function ParseEligibilityResponseInsuranceBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; overload; {b\}
    procedure ParseEligibilityResponseInsuranceBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial); overload; {b\}
    function ParseEligibilityResponseError(obj : TTurtleComplex) : TFhirEligibilityResponseError; overload; {b\}
    procedure ParseEligibilityResponseErrorProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseError); overload; {b\}
    function ParseEligibilityResponse(obj : TTurtleComplex) : TFhirEligibilityResponse; overload;
    procedure ParseEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirEligibilityResponse); overload;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory); overload; {b\}
    function ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory; overload; {b\}
    procedure ParseEncounterClassHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterClassHistory); overload; {b\}
    function ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant); overload; {b\}
    function ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis; overload; {b\}
    procedure ParseEncounterDiagnosisProperties(obj : TTurtleComplex; result : TFhirEncounterDiagnosis); overload; {b\}
    function ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization); overload; {b\}
    function ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation); overload; {b\}
    function ParseEncounter(obj : TTurtleComplex) : TFhirEncounter; overload;
    procedure ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter); overload;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint; overload;
    procedure ParseEndpointProperties(obj : TTurtleComplex; result : TFhirEndpoint); overload;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest); overload;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse); overload;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory); overload; {b\}
    function ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis; overload; {b\}
    procedure ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareDiagnosis); overload; {b\}
    function ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare); overload;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
    function ParseExpansionProfileFixedVersion(obj : TTurtleComplex) : TFhirExpansionProfileFixedVersion; overload; {b\}
    procedure ParseExpansionProfileFixedVersionProperties(obj : TTurtleComplex; result : TFhirExpansionProfileFixedVersion); overload; {b\}
    function ParseExpansionProfileExcludedSystem(obj : TTurtleComplex) : TFhirExpansionProfileExcludedSystem; overload; {b\}
    procedure ParseExpansionProfileExcludedSystemProperties(obj : TTurtleComplex; result : TFhirExpansionProfileExcludedSystem); overload; {b\}
    function ParseExpansionProfileDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignation; overload; {b\}
    procedure ParseExpansionProfileDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignation); overload; {b\}
    function ParseExpansionProfileDesignationInclude(obj : TTurtleComplex) : TFhirExpansionProfileDesignationInclude; overload; {b\}
    procedure ParseExpansionProfileDesignationIncludeProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationInclude); overload; {b\}
    function ParseExpansionProfileDesignationIncludeDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignationIncludeDesignation; overload; {b\}
    procedure ParseExpansionProfileDesignationIncludeDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationIncludeDesignation); overload; {b\}
    function ParseExpansionProfileDesignationExclude(obj : TTurtleComplex) : TFhirExpansionProfileDesignationExclude; overload; {b\}
    procedure ParseExpansionProfileDesignationExcludeProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationExclude); overload; {b\}
    function ParseExpansionProfileDesignationExcludeDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignationExcludeDesignation; overload; {b\}
    procedure ParseExpansionProfileDesignationExcludeDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationExcludeDesignation); overload; {b\}
    function ParseExpansionProfile(obj : TTurtleComplex) : TFhirExpansionProfile; overload;
    procedure ParseExpansionProfileProperties(obj : TTurtleComplex; result : TFhirExpansionProfile); overload;
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated; overload; {b\}
    procedure ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitRelated); overload; {b\}
    function ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee; overload; {b\}
    procedure ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayee); overload; {b\}
    function ParseExplanationOfBenefitInformation(obj : TTurtleComplex) : TFhirExplanationOfBenefitInformation; overload; {b\}
    procedure ParseExplanationOfBenefitInformationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInformation); overload; {b\}
    function ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam; overload; {b\}
    procedure ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitCareTeam); overload; {b\}
    function ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis; overload; {b\}
    procedure ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitDiagnosis); overload; {b\}
    function ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure; overload; {b\}
    procedure ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcedure); overload; {b\}
    function ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance; overload; {b\}
    procedure ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInsurance); overload; {b\}
    function ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident; overload; {b\}
    procedure ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAccident); overload; {b\}
    function ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem; overload; {b\}
    procedure ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItem); overload; {b\}
    function ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication; overload; {b\}
    procedure ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemAdjudication); overload; {b\}
    function ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetail); overload; {b\}
    function ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetailSubDetail); overload; {b\}
    function ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItem); overload; {b\}
    function ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetail); overload; {b\}
    function ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment; overload; {b\}
    procedure ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayment); overload; {b\}
    function ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote; overload; {b\}
    procedure ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcessNote); overload; {b\}
    function ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalance); overload; {b\}
    function ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload; {b\}
    function ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit); overload;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition); overload; {b\}
    function ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory); overload;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(obj : TTurtleComplex) : TFhirFlag; overload;
    procedure ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag); overload;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget; overload; {b\}
    procedure ParseGoalTargetProperties(obj : TTurtleComplex; result : TFhirGoalTarget); overload; {b\}
    function ParseGoal(obj : TTurtleComplex) : TFhirGoal; overload;
    procedure ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal); overload;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink; overload; {b\}
    procedure ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLink); overload; {b\}
    function ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTarget); overload; {b\}
    function ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTargetCompartment); overload; {b\}
    function ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition; overload;
    procedure ParseGraphDefinitionProperties(obj : TTurtleComplex; result : TFhirGraphDefinition); overload;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic); overload; {b\}
    function ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember); overload; {b\}
    function ParseGroup(obj : TTurtleComplex) : TFhirGroup; overload;
    procedure ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup); overload;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse; overload;
    procedure ParseGuidanceResponseProperties(obj : TTurtleComplex; result : TFhirGuidanceResponse); overload;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime); overload; {b\}
    function ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable); overload; {b\}
    function ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService; overload;
    procedure ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService); overload;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
    function ParseImagingManifestStudy(obj : TTurtleComplex) : TFhirImagingManifestStudy; overload; {b\}
    procedure ParseImagingManifestStudyProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudy); overload; {b\}
    function ParseImagingManifestStudySeries(obj : TTurtleComplex) : TFhirImagingManifestStudySeries; overload; {b\}
    procedure ParseImagingManifestStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudySeries); overload; {b\}
    function ParseImagingManifestStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingManifestStudySeriesInstance; overload; {b\}
    procedure ParseImagingManifestStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudySeriesInstance); overload; {b\}
    function ParseImagingManifest(obj : TTurtleComplex) : TFhirImagingManifest; overload;
    procedure ParseImagingManifestProperties(obj : TTurtleComplex; result : TFhirImagingManifest); overload;
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries); overload; {b\}
    function ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance); overload; {b\}
    function ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy; overload;
    procedure ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy); overload;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPractitioner(obj : TTurtleComplex) : TFhirImmunizationPractitioner; overload; {b\}
    procedure ParseImmunizationPractitionerProperties(obj : TTurtleComplex; result : TFhirImmunizationPractitioner); overload; {b\}
    function ParseImmunizationExplanation(obj : TTurtleComplex) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanationProperties(obj : TTurtleComplex; result : TFhirImmunizationExplanation); overload; {b\}
    function ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction); overload; {b\}
    function ParseImmunizationVaccinationProtocol(obj : TTurtleComplex) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationVaccinationProtocol); overload; {b\}
    function ParseImmunization(obj : TTurtleComplex) : TFhirImmunization; overload;
    procedure ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization); overload;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation); overload; {b\}
    function ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; {b\}
    function ParseImmunizationRecommendationRecommendationProtocol(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationProtocol); overload; {b\}
    function ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation); overload;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependency(obj : TTurtleComplex) : TFhirImplementationGuideDependency; overload; {b\}
    procedure ParseImplementationGuideDependencyProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependency); overload; {b\}
    function ParseImplementationGuidePackage(obj : TTurtleComplex) : TFhirImplementationGuidePackage; overload; {b\}
    procedure ParseImplementationGuidePackageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackage); overload; {b\}
    function ParseImplementationGuidePackageResource(obj : TTurtleComplex) : TFhirImplementationGuidePackageResource; overload; {b\}
    procedure ParseImplementationGuidePackageResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackageResource); overload; {b\}
    function ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal); overload; {b\}
    function ParseImplementationGuidePage(obj : TTurtleComplex) : TFhirImplementationGuidePage; overload; {b\}
    procedure ParseImplementationGuidePageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePage); overload; {b\}
    function ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide); overload;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(obj : TTurtleComplex) : TFhirLibrary; overload;
    procedure ParseLibraryProperties(obj : TTurtleComplex; result : TFhirLibrary); overload;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem; overload; {b\}
    procedure ParseLinkageItemProperties(obj : TTurtleComplex; result : TFhirLinkageItem); overload; {b\}
    function ParseLinkage(obj : TTurtleComplex) : TFhirLinkage; overload;
    procedure ParseLinkageProperties(obj : TTurtleComplex; result : TFhirLinkage); overload;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(obj : TTurtleComplex) : TFhirListEntry; overload; {b\}
    procedure ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry); overload; {b\}
    function ParseList(obj : TTurtleComplex) : TFhirList; overload;
    procedure ParseListProperties(obj : TTurtleComplex; result : TFhirList); overload;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition); overload; {b\}
    function ParseLocation(obj : TTurtleComplex) : TFhirLocation; overload;
    procedure ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation); overload;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup; overload; {b\}
    procedure ParseMeasureGroupProperties(obj : TTurtleComplex; result : TFhirMeasureGroup); overload; {b\}
    function ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation; overload; {b\}
    procedure ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureGroupPopulation); overload; {b\}
    function ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier; overload; {b\}
    procedure ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifier); overload; {b\}
    function ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData; overload; {b\}
    procedure ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; result : TFhirMeasureSupplementalData); overload; {b\}
    function ParseMeasure(obj : TTurtleComplex) : TFhirMeasure; overload;
    procedure ParseMeasureProperties(obj : TTurtleComplex; result : TFhirMeasure); overload;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup; overload; {b\}
    procedure ParseMeasureReportGroupProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroup); overload; {b\}
    function ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation; overload; {b\}
    procedure ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupPopulation); overload; {b\}
    function ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier; overload; {b\}
    procedure ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifier); overload; {b\}
    function ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratum); overload; {b\}
    function ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumPopulation); overload; {b\}
    function ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport; overload;
    procedure ParseMeasureReportProperties(obj : TTurtleComplex; result : TFhirMeasureReport); overload;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(obj : TTurtleComplex) : TFhirMedia; overload;
    procedure ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia); overload;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient; overload; {b\}
    procedure ParseMedicationIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationIngredient); overload; {b\}
    function ParseMedicationPackage(obj : TTurtleComplex) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackageProperties(obj : TTurtleComplex; result : TFhirMedicationPackage); overload; {b\}
    function ParseMedicationPackageContent(obj : TTurtleComplex) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContentProperties(obj : TTurtleComplex; result : TFhirMedicationPackageContent); overload; {b\}
    function ParseMedicationPackageBatch(obj : TTurtleComplex) : TFhirMedicationPackageBatch; overload; {b\}
    procedure ParseMedicationPackageBatchProperties(obj : TTurtleComplex; result : TFhirMedicationPackageBatch); overload; {b\}
    function ParseMedication(obj : TTurtleComplex) : TFhirMedication; overload;
    procedure ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication); overload;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer; overload; {b\}
    procedure ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationPerformer); overload; {b\}
    function ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage); overload; {b\}
    function ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration); overload;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer; overload; {b\}
    procedure ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; result : TFhirMedicationDispensePerformer); overload; {b\}
    function ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution); overload; {b\}
    function ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense); overload;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestRequester(obj : TTurtleComplex) : TFhirMedicationRequestRequester; overload; {b\}
    procedure ParseMedicationRequestRequesterProperties(obj : TTurtleComplex; result : TFhirMedicationRequestRequester); overload; {b\}
    function ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest; overload; {b\}
    procedure ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequest); overload; {b\}
    function ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution; overload; {b\}
    procedure ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationRequestSubstitution); overload; {b\}
    function ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest; overload;
    procedure ParseMedicationRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequest); overload;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement); overload;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus; overload; {b\}
    procedure ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionFocus); overload; {b\}
    function ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse; overload; {b\}
    procedure ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionAllowedResponse); overload; {b\}
    function ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition; overload;
    procedure ParseMessageDefinitionProperties(obj : TTurtleComplex; result : TFhirMessageDefinition); overload;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination); overload; {b\}
    function ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource); overload; {b\}
    function ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse); overload; {b\}
    function ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader; overload;
    procedure ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader); overload;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId); overload; {b\}
    function ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem; overload;
    procedure ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem); overload;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet); overload; {b\}
    function ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient); overload; {b\}
    function ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture); overload; {b\}
    function ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement); overload; {b\}
    function ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula); overload; {b\}
    function ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration); overload; {b\}
    function ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder); overload;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange); overload; {b\}
    function ParseObservationRelated(obj : TTurtleComplex) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelatedProperties(obj : TTurtleComplex; result : TFhirObservationRelated); overload; {b\}
    function ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent); overload; {b\}
    function ParseObservation(obj : TTurtleComplex) : TFhirObservation; overload;
    procedure ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation); overload;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter); overload; {b\}
    function ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding); overload; {b\}
    function ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload; overload; {b\}
    procedure ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionOverload); overload; {b\}
    function ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition); overload;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue); overload; {b\}
    function ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome); overload;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact); overload; {b\}
    function ParseOrganization(obj : TTurtleComplex) : TFhirOrganization; overload;
    procedure ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization); overload;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact); overload; {b\}
    function ParsePatientAnimal(obj : TTurtleComplex) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimalProperties(obj : TTurtleComplex; result : TFhirPatientAnimal); overload; {b\}
    function ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication); overload; {b\}
    function ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink); overload; {b\}
    function ParsePatient(obj : TTurtleComplex) : TFhirPatient; overload;
    procedure ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient); overload;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice); overload;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail); overload; {b\}
    function ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote; overload; {b\}
    procedure ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationProcessNote); overload; {b\}
    function ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation); overload;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink); overload; {b\}
    function ParsePerson(obj : TTurtleComplex) : TFhirPerson; overload;
    procedure ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson); overload;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal; overload; {b\}
    procedure ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoal); overload; {b\}
    function ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget; overload; {b\}
    procedure ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoalTarget); overload; {b\}
    function ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction; overload; {b\}
    procedure ParsePlanDefinitionActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionAction); overload; {b\}
    function ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition; overload; {b\}
    procedure ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionCondition); overload; {b\}
    function ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction; overload; {b\}
    procedure ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionRelatedAction); overload; {b\}
    function ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant; overload; {b\}
    procedure ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionParticipant); overload; {b\}
    function ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue; overload; {b\}
    procedure ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionDynamicValue); overload; {b\}
    function ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition; overload;
    procedure ParsePlanDefinitionProperties(obj : TTurtleComplex; result : TFhirPlanDefinition); overload;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification); overload; {b\}
    function ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner; overload;
    procedure ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner); overload;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRoleAvailableTime(obj : TTurtleComplex) : TFhirPractitionerRoleAvailableTime; overload; {b\}
    procedure ParsePractitionerRoleAvailableTimeProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleAvailableTime); overload; {b\}
    function ParsePractitionerRoleNotAvailable(obj : TTurtleComplex) : TFhirPractitionerRoleNotAvailable; overload; {b\}
    procedure ParsePractitionerRoleNotAvailableProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleNotAvailable); overload; {b\}
    function ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole; overload;
    procedure ParsePractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerRole); overload;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer); overload; {b\}
    function ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice); overload; {b\}
    function ParseProcedure(obj : TTurtleComplex) : TFhirProcedure; overload;
    procedure ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure); overload;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    function ParseProcedureRequestRequester(obj : TTurtleComplex) : TFhirProcedureRequestRequester; overload; {b\}
    procedure ParseProcedureRequestRequesterProperties(obj : TTurtleComplex; result : TFhirProcedureRequestRequester); overload; {b\}
    function ParseProcedureRequest(obj : TTurtleComplex) : TFhirProcedureRequest; overload;
    procedure ParseProcedureRequestProperties(obj : TTurtleComplex; result : TFhirProcedureRequest); overload;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    function ParseProcessRequestItem(obj : TTurtleComplex) : TFhirProcessRequestItem; overload; {b\}
    procedure ParseProcessRequestItemProperties(obj : TTurtleComplex; result : TFhirProcessRequestItem); overload; {b\}
    function ParseProcessRequest(obj : TTurtleComplex) : TFhirProcessRequest; overload;
    procedure ParseProcessRequestProperties(obj : TTurtleComplex; result : TFhirProcessRequest); overload;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    function ParseProcessResponseProcessNote(obj : TTurtleComplex) : TFhirProcessResponseProcessNote; overload; {b\}
    procedure ParseProcessResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirProcessResponseProcessNote); overload; {b\}
    function ParseProcessResponse(obj : TTurtleComplex) : TFhirProcessResponse; overload;
    procedure ParseProcessResponseProperties(obj : TTurtleComplex; result : TFhirProcessResponse); overload;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent); overload; {b\}
    function ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity); overload; {b\}
    function ParseProvenance(obj : TTurtleComplex) : TFhirProvenance; overload;
    procedure ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance); overload;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem; overload; {b\}
    procedure ParseQuestionnaireItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItem); overload; {b\}
    function ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen; overload; {b\}
    procedure ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemEnableWhen); overload; {b\}
    function ParseQuestionnaireItemOption(obj : TTurtleComplex) : TFhirQuestionnaireItemOption; overload; {b\}
    procedure ParseQuestionnaireItemOptionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemOption); overload; {b\}
    function ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire); overload;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem; overload; {b\}
    procedure ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItem); overload; {b\}
    function ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItemAnswer); overload; {b\}
    function ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse); overload;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    function ParseReferralRequestRequester(obj : TTurtleComplex) : TFhirReferralRequestRequester; overload; {b\}
    procedure ParseReferralRequestRequesterProperties(obj : TTurtleComplex; result : TFhirReferralRequestRequester); overload; {b\}
    function ParseReferralRequest(obj : TTurtleComplex) : TFhirReferralRequest; overload;
    procedure ParseReferralRequestProperties(obj : TTurtleComplex; result : TFhirReferralRequest); overload;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson); overload;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction; overload; {b\}
    procedure ParseRequestGroupActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupAction); overload; {b\}
    function ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition; overload; {b\}
    procedure ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionCondition); overload; {b\}
    function ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction; overload; {b\}
    procedure ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionRelatedAction); overload; {b\}
    function ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup; overload;
    procedure ParseRequestGroupProperties(obj : TTurtleComplex; result : TFhirRequestGroup); overload;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyArm(obj : TTurtleComplex) : TFhirResearchStudyArm; overload; {b\}
    procedure ParseResearchStudyArmProperties(obj : TTurtleComplex; result : TFhirResearchStudyArm); overload; {b\}
    function ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy; overload;
    procedure ParseResearchStudyProperties(obj : TTurtleComplex; result : TFhirResearchStudy); overload;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject; overload;
    procedure ParseResearchSubjectProperties(obj : TTurtleComplex; result : TFhirResearchSubject); overload;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction); overload; {b\}
    function ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment); overload;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(obj : TTurtleComplex) : TFhirSchedule; overload;
    procedure ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule); overload;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent; overload; {b\}
    procedure ParseSearchParameterComponentProperties(obj : TTurtleComplex; result : TFhirSearchParameterComponent); overload; {b\}
    function ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter; overload;
    procedure ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter); overload;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
    function ParseSequenceReferenceSeq(obj : TTurtleComplex) : TFhirSequenceReferenceSeq; overload; {b\}
    procedure ParseSequenceReferenceSeqProperties(obj : TTurtleComplex; result : TFhirSequenceReferenceSeq); overload; {b\}
    function ParseSequenceVariant(obj : TTurtleComplex) : TFhirSequenceVariant; overload; {b\}
    procedure ParseSequenceVariantProperties(obj : TTurtleComplex; result : TFhirSequenceVariant); overload; {b\}
    function ParseSequenceQuality(obj : TTurtleComplex) : TFhirSequenceQuality; overload; {b\}
    procedure ParseSequenceQualityProperties(obj : TTurtleComplex; result : TFhirSequenceQuality); overload; {b\}
    function ParseSequenceRepository(obj : TTurtleComplex) : TFhirSequenceRepository; overload; {b\}
    procedure ParseSequenceRepositoryProperties(obj : TTurtleComplex; result : TFhirSequenceRepository); overload; {b\}
    function ParseSequence(obj : TTurtleComplex) : TFhirSequence; overload;
    procedure ParseSequenceProperties(obj : TTurtleComplex; result : TFhirSequence); overload;
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
    function ParseServiceDefinition(obj : TTurtleComplex) : TFhirServiceDefinition; overload;
    procedure ParseServiceDefinitionProperties(obj : TTurtleComplex; result : TFhirServiceDefinition); overload;
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
    function ParseSlot(obj : TTurtleComplex) : TFhirSlot; overload;
    procedure ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot); overload;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection); overload; {b\}
    function ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing; overload; {b\}
    procedure ParseSpecimenProcessingProperties(obj : TTurtleComplex; result : TFhirSpecimenProcessing); overload; {b\}
    function ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer); overload; {b\}
    function ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen; overload;
    procedure ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen); overload;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping); overload; {b\}
    function ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot); overload; {b\}
    function ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential); overload; {b\}
    function ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition); overload;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure; overload; {b\}
    procedure ParseStructureMapStructureProperties(obj : TTurtleComplex; result : TFhirStructureMapStructure); overload; {b\}
    function ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup; overload; {b\}
    procedure ParseStructureMapGroupProperties(obj : TTurtleComplex; result : TFhirStructureMapGroup); overload; {b\}
    function ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput; overload; {b\}
    procedure ParseStructureMapGroupInputProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupInput); overload; {b\}
    function ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule; overload; {b\}
    procedure ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRule); overload; {b\}
    function ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource; overload; {b\}
    procedure ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleSource); overload; {b\}
    function ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTarget); overload; {b\}
    function ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTargetParameter); overload; {b\}
    function ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent; overload; {b\}
    procedure ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleDependent); overload; {b\}
    function ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap; overload;
    procedure ParseStructureMapProperties(obj : TTurtleComplex; result : TFhirStructureMap); overload;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel); overload; {b\}
    function ParseSubscription(obj : TTurtleComplex) : TFhirSubscription; overload;
    procedure ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription); overload;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance); overload; {b\}
    function ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient); overload; {b\}
    function ParseSubstance(obj : TTurtleComplex) : TFhirSubstance; overload;
    procedure ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance); overload;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem; overload; {b\}
    procedure ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; result : TFhirSupplyDeliverySuppliedItem); overload; {b\}
    function ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery); overload;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestOrderedItem(obj : TTurtleComplex) : TFhirSupplyRequestOrderedItem; overload; {b\}
    procedure ParseSupplyRequestOrderedItemProperties(obj : TTurtleComplex; result : TFhirSupplyRequestOrderedItem); overload; {b\}
    function ParseSupplyRequestRequester(obj : TTurtleComplex) : TFhirSupplyRequestRequester; overload; {b\}
    procedure ParseSupplyRequestRequesterProperties(obj : TTurtleComplex; result : TFhirSupplyRequestRequester); overload; {b\}
    function ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest); overload;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRequester(obj : TTurtleComplex) : TFhirTaskRequester; overload; {b\}
    procedure ParseTaskRequesterProperties(obj : TTurtleComplex; result : TFhirTaskRequester); overload; {b\}
    function ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction; overload; {b\}
    procedure ParseTaskRestrictionProperties(obj : TTurtleComplex; result : TFhirTaskRestriction); overload; {b\}
    function ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput; overload; {b\}
    procedure ParseTaskInputProperties(obj : TTurtleComplex; result : TFhirTaskInput); overload; {b\}
    function ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput; overload; {b\}
    procedure ParseTaskOutputProperties(obj : TTurtleComplex; result : TFhirTaskOutput); overload; {b\}
    function ParseTask(obj : TTurtleComplex) : TFhirTask; overload;
    procedure ParseTaskProperties(obj : TTurtleComplex; result : TFhirTask); overload;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant; overload; {b\}
    procedure ParseTestReportParticipantProperties(obj : TTurtleComplex; result : TFhirTestReportParticipant); overload; {b\}
    function ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup; overload; {b\}
    procedure ParseTestReportSetupProperties(obj : TTurtleComplex; result : TFhirTestReportSetup); overload; {b\}
    function ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction; overload; {b\}
    procedure ParseTestReportSetupActionProperties(obj : TTurtleComplex; result : TFhirTestReportSetupAction); overload; {b\}
    function ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation; overload; {b\}
    procedure ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionOperation); overload; {b\}
    function ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert; overload; {b\}
    procedure ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionAssert); overload; {b\}
    function ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest; overload; {b\}
    procedure ParseTestReportTestProperties(obj : TTurtleComplex; result : TFhirTestReportTest); overload; {b\}
    function ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction; overload; {b\}
    procedure ParseTestReportTestActionProperties(obj : TTurtleComplex; result : TFhirTestReportTestAction); overload; {b\}
    function ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown; overload; {b\}
    procedure ParseTestReportTeardownProperties(obj : TTurtleComplex; result : TFhirTestReportTeardown); overload; {b\}
    function ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction; overload; {b\}
    procedure ParseTestReportTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestReportTeardownAction); overload; {b\}
    function ParseTestReport(obj : TTurtleComplex) : TFhirTestReport; overload;
    procedure ParseTestReportProperties(obj : TTurtleComplex; result : TFhirTestReport); overload;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin; overload; {b\}
    procedure ParseTestScriptOriginProperties(obj : TTurtleComplex; result : TFhirTestScriptOrigin); overload; {b\}
    function ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination; overload; {b\}
    procedure ParseTestScriptDestinationProperties(obj : TTurtleComplex; result : TFhirTestScriptDestination); overload; {b\}
    function ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata); overload; {b\}
    function ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink); overload; {b\}
    function ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability); overload; {b\}
    function ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture); overload; {b\}
    function ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable); overload; {b\}
    function ParseTestScriptRule(obj : TTurtleComplex) : TFhirTestScriptRule; overload; {b\}
    procedure ParseTestScriptRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptRule); overload; {b\}
    function ParseTestScriptRuleParam(obj : TTurtleComplex) : TFhirTestScriptRuleParam; overload; {b\}
    procedure ParseTestScriptRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptRuleParam); overload; {b\}
    function ParseTestScriptRuleset(obj : TTurtleComplex) : TFhirTestScriptRuleset; overload; {b\}
    procedure ParseTestScriptRulesetProperties(obj : TTurtleComplex; result : TFhirTestScriptRuleset); overload; {b\}
    function ParseTestScriptRulesetRule(obj : TTurtleComplex) : TFhirTestScriptRulesetRule; overload; {b\}
    procedure ParseTestScriptRulesetRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptRulesetRule); overload; {b\}
    function ParseTestScriptRulesetRuleParam(obj : TTurtleComplex) : TFhirTestScriptRulesetRuleParam; overload; {b\}
    procedure ParseTestScriptRulesetRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptRulesetRuleParam); overload; {b\}
    function ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup); overload; {b\}
    function ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction); overload; {b\}
    function ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation); overload; {b\}
    function ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader); overload; {b\}
    function ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert); overload; {b\}
    function ParseTestScriptSetupActionAssertRule(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRule; overload; {b\}
    procedure ParseTestScriptSetupActionAssertRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRule); overload; {b\}
    function ParseTestScriptSetupActionAssertRuleParam(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRuleParam; overload; {b\}
    procedure ParseTestScriptSetupActionAssertRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRuleParam); overload; {b\}
    function ParseTestScriptSetupActionAssertRuleset(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRuleset; overload; {b\}
    procedure ParseTestScriptSetupActionAssertRulesetProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRuleset); overload; {b\}
    function ParseTestScriptSetupActionAssertRulesetRule(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRulesetRule; overload; {b\}
    procedure ParseTestScriptSetupActionAssertRulesetRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRulesetRule); overload; {b\}
    function ParseTestScriptSetupActionAssertRulesetRuleParam(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRulesetRuleParam; overload; {b\}
    procedure ParseTestScriptSetupActionAssertRulesetRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRulesetRuleParam); overload; {b\}
    function ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest); overload; {b\}
    function ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction); overload; {b\}
    function ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown); overload; {b\}
    function ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction); overload; {b\}
    function ParseTestScript(obj : TTurtleComplex) : TFhirTestScript; overload;
    procedure ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript); overload;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose); overload; {b\}
    function ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude); overload; {b\}
    function ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept); overload; {b\}
    function ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConceptDesignation); overload; {b\}
    function ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter); overload; {b\}
    function ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion); overload; {b\}
    function ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter); overload; {b\}
    function ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains); overload; {b\}
    function ParseValueSet(obj : TTurtleComplex) : TFhirValueSet; overload;
    procedure ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet); overload;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionDispense(obj : TTurtleComplex) : TFhirVisionPrescriptionDispense; overload; {b\}
    procedure ParseVisionPrescriptionDispenseProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionDispense); overload; {b\}
    function ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription); overload;
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(obj : TTurtleComplex) : TFhirResource; override;
    function ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;  overload;
  end;

  TFHIRTurtleComposer = class (TFHIRTurtleComposerBase3)
  protected
    procedure ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);

    procedure ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);

    Procedure ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
    Procedure ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
    Procedure ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
    Procedure ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
    Procedure ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
    Procedure ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
    Procedure ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
    Procedure ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
    Procedure ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
    Procedure ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
    Procedure ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
    Procedure ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
    Procedure ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
    Procedure ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
    Procedure ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
    Procedure ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
    Procedure ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
    Procedure ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
    Procedure ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);

    Procedure ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer); overload;
    Procedure ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer); overload;
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
    procedure ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
{$ENDIF FHIR_PARAMETERS}

    procedure ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
    procedure ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
    procedure ComposeContributor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContributor; useType : boolean; index : integer);
    procedure ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
    procedure ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirement; useType : boolean; index : integer);
    procedure ComposeDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosage; useType : boolean; index : integer);
    procedure ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
    procedure ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
    procedure ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
    procedure ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
    procedure ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
    procedure ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTriggerDefinition; useType : boolean; index : integer);
    procedure ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
    procedure ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
    procedure ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
    procedure ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedArtifact; useType : boolean; index : integer);
    procedure ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
    procedure ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactDetail; useType : boolean; index : integer);
    procedure ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirUsageContext; useType : boolean; index : integer);
    procedure ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
    procedure ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
    procedure ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameterDefinition; useType : boolean; index : integer);
    procedure ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
    procedure ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
    procedure ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
    procedure ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
    procedure ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
    procedure ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionExample; useType : boolean; index : integer);
    procedure ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
    procedure ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
    procedure ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
    procedure ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);
    procedure ComposeCount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCount; useType : boolean; index : integer);
    procedure ComposeMoney(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMoney; useType : boolean; index : integer);
    procedure ComposeAge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAge; useType : boolean; index : integer);
    procedure ComposeDistance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDistance; useType : boolean; index : integer);
    procedure ComposeDuration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDuration; useType : boolean; index : integer);

{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountCoverage; useType : boolean; index : integer);
    procedure ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountGuarantor; useType : boolean; index : integer);
    procedure ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
    procedure ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
    procedure ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
    procedure ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEvent; useType : boolean; index : integer);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
    procedure ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
    procedure ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgent; useType : boolean; index : integer);
    procedure ComposeAuditEventAgentNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgentNetwork; useType : boolean; index : integer);
    procedure ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
    procedure ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntity; useType : boolean; index : integer);
    procedure ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
    procedure ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    procedure ComposeBodySite(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodySite; useType : boolean; index : integer);
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
    procedure ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
    procedure ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
    procedure ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
    procedure ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
    procedure ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRest; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestSecurityCertificate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurityCertificate; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestOperation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEvent; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
    procedure ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatement; useType : boolean; index : integer);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
    procedure ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
    procedure ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeamParticipant; useType : boolean; index : integer);
    procedure ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeam; useType : boolean; index : integer);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemParticipant; useType : boolean; index : integer);
    procedure ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItem; useType : boolean; index : integer);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimRelated; useType : boolean; index : integer);
    procedure ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
    procedure ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCareTeam; useType : boolean; index : integer);
    procedure ComposeClaimInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInformation; useType : boolean; index : integer);
    procedure ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
    procedure ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimProcedure; useType : boolean; index : integer);
    procedure ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInsurance; useType : boolean; index : integer);
    procedure ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimAccident; useType : boolean; index : integer);
    procedure ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
    procedure ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
    procedure ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponsePayment; useType : boolean; index : integer);
    procedure ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
    procedure ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseInsurance; useType : boolean; index : integer);
    procedure ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigation; useType : boolean; index : integer);
    procedure ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
    procedure ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemFilter; useType : boolean; index : integer);
    procedure ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConcept; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystem; useType : boolean; index : integer);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
    procedure ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
    procedure ComposeCommunicationRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestRequester; useType : boolean; index : integer);
    procedure ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
    procedure ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
    procedure ComposeCompositionRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionRelatesTo; useType : boolean; index : integer);
    procedure ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
    procedure ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
    procedure ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroup; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElement; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
    procedure ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
    procedure ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
    procedure ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentActor; useType : boolean; index : integer);
    procedure ComposeConsentPolicy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentPolicy; useType : boolean; index : integer);
    procedure ComposeConsentData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentData; useType : boolean; index : integer);
    procedure ComposeConsentExcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExcept; useType : boolean; index : integer);
    procedure ComposeConsentExceptActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExceptActor; useType : boolean; index : integer);
    procedure ComposeConsentExceptData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExceptData; useType : boolean; index : integer);
    procedure ComposeConsent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsent; useType : boolean; index : integer);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractAgent; useType : boolean; index : integer);
    procedure ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
    procedure ComposeContractValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractValuedItem; useType : boolean; index : integer);
    procedure ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
    procedure ComposeContractTermAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAgent; useType : boolean; index : integer);
    procedure ComposeContractTermValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermValuedItem; useType : boolean; index : integer);
    procedure ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
    procedure ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
    procedure ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
    procedure ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverageGrouping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageGrouping; useType : boolean; index : integer);
    procedure ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    procedure ComposeDataElementMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementMapping; useType : boolean; index : integer);
    procedure ComposeDataElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElement; useType : boolean; index : integer);
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
    procedure ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdi(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUdi; useType : boolean; index : integer);
    procedure ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    procedure ComposeDeviceComponentProductionSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; useType : boolean; index : integer);
    procedure ComposeDeviceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponent; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
    procedure ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequestRequester; useType : boolean; index : integer);
    procedure ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequest; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportPerformer; useType : boolean; index : integer);
    procedure ComposeDiagnosticReportImage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; useType : boolean; index : integer);
    procedure ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestContent; useType : boolean; index : integer);
    procedure ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
    procedure ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContextRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; useType : boolean; index : integer);
    procedure ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    procedure ComposeEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    procedure ComposeEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsurance; useType : boolean; index : integer);
    procedure ComposeEligibilityResponseInsuranceBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalance; useType : boolean; index : integer);
    procedure ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; useType : boolean; index : integer);
    procedure ComposeEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseError; useType : boolean; index : integer);
    procedure ComposeEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
    procedure ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterClassHistory; useType : boolean; index : integer);
    procedure ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
    procedure ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterDiagnosis; useType : boolean; index : integer);
    procedure ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
    procedure ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
    procedure ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEndpoint; useType : boolean; index : integer);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
    procedure ComposeExpansionProfileFixedVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileFixedVersion; useType : boolean; index : integer);
    procedure ComposeExpansionProfileExcludedSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileExcludedSystem; useType : boolean; index : integer);
    procedure ComposeExpansionProfileDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignation; useType : boolean; index : integer);
    procedure ComposeExpansionProfileDesignationInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationInclude; useType : boolean; index : integer);
    procedure ComposeExpansionProfileDesignationIncludeDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationIncludeDesignation; useType : boolean; index : integer);
    procedure ComposeExpansionProfileDesignationExclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationExclude; useType : boolean; index : integer);
    procedure ComposeExpansionProfileDesignationExcludeDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationExcludeDesignation; useType : boolean; index : integer);
    procedure ComposeExpansionProfile(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfile; useType : boolean; index : integer);
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInformation; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
    procedure ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalTarget; useType : boolean; index : integer);
    procedure ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLink; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
    procedure ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
    procedure ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
    procedure ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGuidanceResponse; useType : boolean; index : integer);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
    procedure ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
    procedure ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
    procedure ComposeImagingManifestStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudy; useType : boolean; index : integer);
    procedure ComposeImagingManifestStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingManifestStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifest; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationPractitioner; useType : boolean; index : integer);
    procedure ComposeImmunizationExplanation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationExplanation; useType : boolean; index : integer);
    procedure ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
    procedure ComposeImmunizationVaccinationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; useType : boolean; index : integer);
    procedure ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependency(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePackageResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
    procedure ComposeImplementationGuidePage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePage; useType : boolean; index : integer);
    procedure ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLibrary; useType : boolean; index : integer);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkageItem; useType : boolean; index : integer);
    procedure ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkage; useType : boolean; index : integer);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
    procedure ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
    procedure ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroup; useType : boolean; index : integer);
    procedure ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureSupplementalData; useType : boolean; index : integer);
    procedure ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasure; useType : boolean; index : integer);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroup; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReport; useType : boolean; index : integer);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationPackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackage; useType : boolean; index : integer);
    procedure ComposeMedicationPackageContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageContent; useType : boolean; index : integer);
    procedure ComposeMedicationPackageBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageBatch; useType : boolean; index : integer);
    procedure ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
    procedure ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
    procedure ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
    procedure ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestRequester; useType : boolean; index : integer);
    procedure ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
    procedure ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
    procedure ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
    procedure ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
    procedure ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
    procedure ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
    procedure ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
    procedure ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
    procedure ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
    procedure ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
    procedure ComposeObservationRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationRelated; useType : boolean; index : integer);
    procedure ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
    procedure ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
    procedure ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
    procedure ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
    procedure ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
    procedure ComposePatientAnimal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientAnimal; useType : boolean; index : integer);
    procedure ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
    procedure ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
    procedure ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
    procedure ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
    procedure ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
    procedure ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
    procedure ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
    procedure ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
    procedure ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
    procedure ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRoleAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleAvailableTime; useType : boolean; index : integer);
    procedure ComposePractitionerRoleNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleNotAvailable; useType : boolean; index : integer);
    procedure ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRole; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
    procedure ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
    procedure ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    procedure ComposeProcedureRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequestRequester; useType : boolean; index : integer);
    procedure ComposeProcedureRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequest; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    procedure ComposeProcessRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequestItem; useType : boolean; index : integer);
    procedure ComposeProcessRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequest; useType : boolean; index : integer);
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    procedure ComposeProcessResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponseProcessNote; useType : boolean; index : integer);
    procedure ComposeProcessResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponse; useType : boolean; index : integer);
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
    procedure ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
    procedure ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemOption(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemOption; useType : boolean; index : integer);
    procedure ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    procedure ComposeReferralRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequestRequester; useType : boolean; index : integer);
    procedure ComposeReferralRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequest; useType : boolean; index : integer);
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupAction; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
    procedure ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroup; useType : boolean; index : integer);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyArm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyArm; useType : boolean; index : integer);
    procedure ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudy; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchSubject; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
    procedure ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterComponent; useType : boolean; index : integer);
    procedure ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
    procedure ComposeSequenceReferenceSeq(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceReferenceSeq; useType : boolean; index : integer);
    procedure ComposeSequenceVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceVariant; useType : boolean; index : integer);
    procedure ComposeSequenceQuality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceQuality; useType : boolean; index : integer);
    procedure ComposeSequenceRepository(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceRepository; useType : boolean; index : integer);
    procedure ComposeSequence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequence; useType : boolean; index : integer);
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
    procedure ComposeServiceDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirServiceDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
    procedure ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenProcessing; useType : boolean; index : integer);
    procedure ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
    procedure ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
    procedure ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapStructure; useType : boolean; index : integer);
    procedure ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroup; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupInput; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRule; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
    procedure ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMap; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
    procedure ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
    procedure ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
    procedure ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
    procedure ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestOrderedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestOrderedItem; useType : boolean; index : integer);
    procedure ComposeSupplyRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestRequester; useType : boolean; index : integer);
    procedure ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRequester; useType : boolean; index : integer);
    procedure ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRestriction; useType : boolean; index : integer);
    procedure ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskInput; useType : boolean; index : integer);
    procedure ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskOutput; useType : boolean; index : integer);
    procedure ComposeTask(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTask; useType : boolean; index : integer);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportParticipant; useType : boolean; index : integer);
    procedure ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetup; useType : boolean; index : integer);
    procedure ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupAction; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTest; useType : boolean; index : integer);
    procedure ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTestAction; useType : boolean; index : integer);
    procedure ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardown; useType : boolean; index : integer);
    procedure ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReport; useType : boolean; index : integer);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptOrigin; useType : boolean; index : integer);
    procedure ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptDestination; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
    procedure ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
    procedure ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
    procedure ComposeTestScriptRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRule; useType : boolean; index : integer);
    procedure ComposeTestScriptRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRuleParam; useType : boolean; index : integer);
    procedure ComposeTestScriptRuleset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRuleset; useType : boolean; index : integer);
    procedure ComposeTestScriptRulesetRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRulesetRule; useType : boolean; index : integer);
    procedure ComposeTestScriptRulesetRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRulesetRuleParam; useType : boolean; index : integer);
    procedure ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssertRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRule; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssertRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRuleParam; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssertRuleset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRuleset; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssertRulesetRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRulesetRule; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssertRulesetRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam; useType : boolean; index : integer);
    procedure ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
    procedure ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
    procedure ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
    procedure ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; useType : boolean; index : integer);
    procedure ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
{$ENDIF FHIR_VISIONPRESCRIPTION}
  
    procedure ComposeResource(parent :  TTurtleComplex; resource : TFhirResource); overload; override;
  end;

implementation

{ TFHIRTurtleParser }

function TFHIRTurtleParser.ParseElement(obj : TTurtleComplex) : TFhirElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElement.create;
  try
    ParseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
    this := parent;
  if (index > -1)  then
    this.addPredicate('fhir:index', inttostr(index), 'int');
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Element', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'Element', 'extension', elem.extensionList[i], false, i);{x.d3}
end;

procedure TFHIRTurtleParser.ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
var
  item : TTurtleComplex;
begin
  if KeepParseLocations then
  begin
    element.LocationData.ParseStart := obj.Start;
    element.LocationData.ParseFinish := obj.Stop;
  end;
  element.idElement := ParseId(obj.complex('http://hl7.org/fhir/Element.id'));{q1}
  for item in obj.complexes('http://hl7.org/fhir/Element.extension') do
    element.extensionList.Add(parseExtension(item));
end;

procedure TFHIRTurtleParser.ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement);
var
  item : TTurtleComplex;
begin
  parseElementProperties(obj, element);
  for item in obj.complexes('http://hl7.org/fhir/Element.modifierExtension') do
    element.modifierExtensionList.Add(parseExtension(item));
end;

function TFHIRTurtleParser.ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBackboneElement.create;
  try
    ParseBackboneElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BackboneElement'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'BackboneElement', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
  value : String;
begin
  if obj = nil then
    exit(nil);

  if (obj.has('http://hl7.org/fhir/value')) then
    value := obj.stringLiteral('http://hl7.org/fhir/value');
  i := StringArrayIndexOfSensitive(aNames, value);
  if (value <> '') and (i < 0) then
    raise ERdfException.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames));
  result := TFHIREnum.create;
  try
    result.value := value;
    result.system := aSystems[i];
    parseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDate(obj : TTurtleComplex) : TFHIRDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDate.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:date');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDateTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:dateTime');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseString(obj : TTurtleComplex) : TFHIRString;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirString.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:string');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInteger(obj : TTurtleComplex) : TFHIRInteger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInteger.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:integer');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:int');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUri(obj : TTurtleComplex) : TFHIRUri;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUri.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uri');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInstant(obj : TTurtleComplex) : TFHIRInstant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInstant.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:instant');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:dateTime');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirXhtml.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:xhtml');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBoolean.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
     result.value := StringToBoolean(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:boolean');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:boolean');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBase64Binary.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTBytes(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:base64Binary');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:base64Binary');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseTime(obj : TTurtleComplex) : TFHIRTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:time');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:time');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDecimal.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:decimal');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:decimal');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCode(obj : TTurtleComplex) : TFHIRCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCode.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:token');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseOid(obj : TTurtleComplex) : TFHIROid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:oid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUuid(obj : TTurtleComplex) : TFHIRUuid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUuid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uuid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarkdown.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:markdown');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUnsignedInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:unsignedInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:nonNegativeInteger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseId(obj : TTurtleComplex) : TFHIRId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirId.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:id');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPositiveInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:positiveInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:positiveInteger');
  composeElement(this, parentType, name, value, false, index);
end;

procedure TFHIRTurtleParser.ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
begin
  if KeepParseLocations then
  begin
    resource.LocationData.ParseStart := obj.Start;
    resource.LocationData.ParseFinish := obj.Stop;
  end;
  resource.idElement := ParseId(obj.complex('http://hl7.org/fhir/Resource.id'));{q1}
  resource.meta := ParseMeta(obj.complex('http://hl7.org/fhir/Resource.meta'));{q3b}
  resource.implicitRulesElement := ParseUri(obj.complex('http://hl7.org/fhir/Resource.implicitRules'));{q1}
  resource.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Resource.language'));{q1}
end;

Procedure TFHIRTurtleComposer.ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Resource', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('meta') then
    ComposeMeta(this, 'Resource', 'meta', elem.metaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUri(this, 'Resource', 'implicitRules', elem.implicitRulesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCode(this, 'Resource', 'language', elem.languageElement, false, -1);{x.2ea}
end;

procedure TFHIRTurtleParser.ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);
var
  item : TTurtleComplex;
begin
  ParseResourceProperties(obj, resource);
  resource.text := ParseNarrative(obj.complex('http://hl7.org/fhir/DomainResource.text'));{q3b}
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.contained') do
    resource.containedList.Add(parseInnerResource(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.extension') do
    resource.extensionList.Add(parseExtension(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.modifierExtension') do
    resource.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer);
var
  i : integer{z.c};
begin
  ComposeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(this, 'DomainResource', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(this, 'DomainResource', 'contained', elem.containedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('extension') then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'extension', elem.extensionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

{$IFDEF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Parameters.parameter.name'));{q1}
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueMeta', item) then
      result.value := parseMeta(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUri', item) then
      result.value := parseUri(item);
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Parameters.parameter.resource'));{q3a}
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter.part') do
      result.partList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParametersParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Parameters.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Parameters.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(this, 'Parameters.parameter', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Parameters.parameter', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Parameters.parameter', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Parameters.parameter', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Parameters.parameter', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Parameters.parameter', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Parameters.parameter', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Parameters.parameter', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Parameters.parameter', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Parameters.parameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Parameters.parameter', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Parameters.parameter', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Parameters.parameter', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Parameters.parameter', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Parameters.parameter', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Parameters.parameter', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Parameters.parameter', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Parameters.parameter', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Parameters.parameter', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Parameters.parameter', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Parameters.parameter', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Parameters.parameter', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Parameters.parameter', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Parameters.parameter', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Parameters.parameter', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Parameters.parameter', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Parameters.parameter', 'valueMeta', TFhirMeta(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Parameters.parameter', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Parameters.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Parameters.parameter', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Parameters.parameter', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Parameters.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Parameters.parameter', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Parameters.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Parameters.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Parameters.parameter', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Parameters.parameter', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Parameters.parameter', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseParameters(obj : TTurtleComplex) : TFhirParameters;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameters.create;
  try
    ParseParametersProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter') do
      result.parameterList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Parameters'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseExtension(obj : TTurtleComplex) : TFhirExtension;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Extension.url'));{q1}
    if obj.has('http://hl7.org/fhir/Extension.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Extension.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Extension.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Extension.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Extension.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Extension.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Extension.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Extension.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Extension.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Extension.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Extension.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Extension.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Extension.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Extension.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Extension.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Extension.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Extension.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Extension.valueMeta', item) then
      result.value := parseMeta(item);
    if obj.has('http://hl7.org/fhir/Extension.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Extension.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Extension.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Extension.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Extension.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Extension.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Extension'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeUri(this, 'Extension', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Extension', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(this, 'Extension', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Extension', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Extension', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Extension', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Extension', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Extension', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Extension', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Extension', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Extension', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Extension', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Extension', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Extension', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Extension', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Extension', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Extension', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Extension', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Extension', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Extension', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Extension', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Extension', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Extension', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Extension', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Extension', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Extension', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Extension', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Extension', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Extension', 'valueMeta', TFhirMeta(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Extension', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Extension', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Extension', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Extension', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Extension', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Extension', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Extension', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Extension', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Extension', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Extension', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseNarrative(obj : TTurtleComplex) : TFhirNarrative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative);
begin
    ParseElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Narrative.status'), CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    result.div_ := ParseXHtmlNode(obj.stringLiteral('http://hl7.org/fhir/Narrative.div'));{q2}
end;

procedure TFHIRTurtleComposer.ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Narrative'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Narrative', 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, false, -1);{x.d4}
  ComposeXHtmlNode(this, 'Narrative', 'div', elem.div_Element, false, -1);{x.2eb}
end;

function TFHIRTurtleParser.ParseContributor(obj : TTurtleComplex) : TFhirContributor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContributor.create;
  try
    ParseContributorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContributorProperties(obj : TTurtleComplex; result : TFhirContributor);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Contributor.type'), CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Contributor.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contributor.contact') do
      result.contactList.Add(parseContactDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeContributor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContributor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contributor'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Contributor', 'type', elem.Type_Element, CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'Contributor', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Contributor', 'contact', elem.contactList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAttachment(obj : TTurtleComplex) : TFhirAttachment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment);
begin
    ParseElementProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.contentType'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.language'));{q1}
    result.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.data'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Attachment.url'));{q1}
    result.sizeElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Attachment.size'));{q1}
    result.hashElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.hash'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Attachment.title'));{q1}
    result.creationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Attachment.creation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Attachment'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'data', elem.dataElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Attachment', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'Attachment', 'size', elem.sizeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'hash', elem.hashElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Attachment', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Attachment', 'creation', elem.creationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementCodeFilter.create;
  try
    ParseDataRequirementCodeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementCodeFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.path'));{q1}
    if obj.has('http://hl7.org/fhir/DataRequirement.codeFilter.valueSetReference', item) {a3} then
      result.valueSet := ParseReference(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.codeFilter.valueSetString', item) then
      result.valueSet := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter.valueCode') do
      result.valueCodeList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter.valueCoding') do
      result.valueCodingList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter.valueCodeableConcept') do
      result.valueCodeableConceptList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementCodeFilter'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'DataRequirement.codeFilter', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'DataRequirement.codeFilter', 'valueSetReference', TFhirReference(elem.valueSet), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirString) {6} then
    ComposeString(this, 'DataRequirement.codeFilter', 'valueSetString', TFhirString(elem.valueSet), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCode(this, 'DataRequirement.codeFilter', 'valueCode', elem.valueCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodingList.Count - 1 do
      ComposeCoding(this, 'DataRequirement.codeFilter', 'valueCoding', elem.valueCodingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'DataRequirement.codeFilter', 'valueCodeableConcept', elem.valueCodeableConceptList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementDateFilter.create;
  try
    ParseDataRequirementDateFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementDateFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.dateFilter.path'));{q1}
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valueDateTime', item) then
      result.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementDateFilter'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'DataRequirement.dateFilter', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'DataRequirement.dateFilter', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'DataRequirement.dateFilter', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DataRequirement.dateFilter', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirement.create;
  try
    ParseDataRequirementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementProperties(obj : TTurtleComplex; result : TFhirDataRequirement);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.profile') do
      result.profileList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.mustSupport') do
      result.mustSupportList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter') do
      result.codeFilterList.Add(parseDataRequirementCodeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.dateFilter') do
      result.dateFilterList.Add(parseDataRequirementDateFilter(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirement'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DataRequirement', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'DataRequirement', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mustSupportList.Count - 1 do
      ComposeString(this, 'DataRequirement', 'mustSupport', elem.mustSupportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(this, 'DataRequirement', 'codeFilter', elem.codeFilterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(this, 'DataRequirement', 'dateFilter', elem.dateFilterList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDosage(obj : TTurtleComplex) : TFhirDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDosage.create;
  try
    ParseDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDosageProperties(obj : TTurtleComplex; result : TFhirDosage);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.sequenceElement := ParseInteger(obj.complex('http://hl7.org/fhir/Dosage.sequence'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Dosage.additionalInstruction') do
      result.additionalInstructionList.Add(parseCodeableConcept(item));
    result.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.patientInstruction'));{q1}
    result.timing := ParseTiming(obj.complex('http://hl7.org/fhir/Dosage.timing'));{q3b}
    if obj.has('http://hl7.org/fhir/Dosage.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Dosage.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.method'));{q3b}
    if obj.has('http://hl7.org/fhir/Dosage.doseRange', item) then
      result.dose := parseRange(item);
    if obj.has('http://hl7.org/fhir/Dosage.doseQuantity', item) then
      result.dose := parseQuantity(item);
    result.maxDosePerPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerPeriod'));{q3b}
    result.maxDosePerAdministration := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerAdministration'));{q3b}
    result.maxDosePerLifetime := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerLifetime'));{q3b}
    if obj.has('http://hl7.org/fhir/Dosage.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Dosage.rateRange', item) then
      result.rate := parseRange(item);
    if obj.has('http://hl7.org/fhir/Dosage.rateQuantity', item) then
      result.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Dosage'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'Dosage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(this, 'Dosage', 'additionalInstruction', elem.additionalInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Dosage', 'patientInstruction', elem.patientInstructionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTiming(this, 'Dosage', 'timing', elem.timingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Dosage', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Dosage', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'Dosage', 'doseRange', TFhirRange(elem.dose), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage', 'doseQuantity', TFhirQuantity(elem.dose), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeRatio(this, 'Dosage', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerAdministration', elem.maxDosePerAdministrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerLifetime', elem.maxDosePerLifetimeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'Dosage', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'Dosage', 'rateRange', TFhirRange(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage', 'rateQuantity', TFhirQuantity(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier);
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Identifier.use'), CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Identifier.type'));{q3b}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Identifier.system'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Identifier.value'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Identifier.period'));{q3b}
    result.assigner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Identifier.assigner'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Identifier'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Identifier', 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Identifier', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Identifier', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Identifier', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Identifier', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Identifier', 'assigner', elem.assignerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCoding(obj : TTurtleComplex) : TFhirCoding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoding.create;
  try
    ParseCodingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding);
begin
    ParseElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Coding.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Coding.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.display'));{q1}
    result.userSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coding.userSelected'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Coding', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Coding', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'Coding', 'userSelected', elem.userSelectedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSampledData(obj : TTurtleComplex) : TFhirSampledData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData);
begin
    ParseElementProperties(obj, result);
    result.origin := ParseQuantity(obj.complex('http://hl7.org/fhir/SampledData.origin'));{q3b}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.period'));{q1}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.factor'));{q1}
    result.lowerLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.lowerLimit'));{q1}
    result.upperLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.upperLimit'));{q1}
    result.dimensionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/SampledData.dimensions'));{q1}
    result.dataElement := ParseString(obj.complex('http://hl7.org/fhir/SampledData.data'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SampledData'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeQuantity(this, 'SampledData', 'origin', elem.originElement, false, -1);{x.2f}
  ComposeDecimal(this, 'SampledData', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimal(this, 'SampledData', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'lowerLimit', elem.lowerLimitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'upperLimit', elem.upperLimitElement, false, -1);{x.2ea}
  ComposePositiveInt(this, 'SampledData', 'dimensions', elem.dimensionsElement, false, -1);{x.2ea}
  ComposeString(this, 'SampledData', 'data', elem.dataElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRatio(obj : TTurtleComplex) : TFhirRatio;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRatio.create;
  try
    ParseRatioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio);
begin
    ParseElementProperties(obj, result);
    result.numerator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.numerator'));{q3b}
    result.denominator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.denominator'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Ratio'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'numerator', elem.numeratorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'denominator', elem.denominatorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseReference(obj : TTurtleComplex) : TFhirReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReference.create;
  try
    ParseReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference);
begin
    ParseElementProperties(obj, result);
    result.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.reference'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Reference.identifier'));{q3b}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Reference'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'Reference', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTriggerDefinition.create;
  try
    ParseTriggerDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTriggerDefinitionProperties(obj : TTurtleComplex; result : TFhirTriggerDefinition);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TriggerDefinition.type'), CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum);
    result.eventNameElement := ParseString(obj.complex('http://hl7.org/fhir/TriggerDefinition.eventName'));{q1}
    if obj.has('http://hl7.org/fhir/TriggerDefinition.eventTimingTiming', item) then
      result.eventTiming := parseTiming(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.eventTimingReference', item) {a3} then
      result.eventTiming := ParseReference(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.eventTimingDate', item) then
      result.eventTiming := parseDate(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.eventTimingDateTime', item) then
      result.eventTiming := parseDateTime(item);
    result.eventData := ParseDataRequirement(obj.complex('http://hl7.org/fhir/TriggerDefinition.eventData'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTriggerDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TriggerDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TriggerDefinition', 'type', elem.Type_Element, CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'TriggerDefinition', 'eventName', elem.eventNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirTiming) {6} then
    ComposeTiming(this, 'TriggerDefinition', 'eventTimingTiming', TFhirTiming(elem.eventTiming), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirReference) {2} then
    ComposeReference(this, 'TriggerDefinition', 'eventTimingReference', TFhirReference(elem.eventTiming), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirDate) {6} then
    ComposeDate(this, 'TriggerDefinition', 'eventTimingDate', TFhirDate(elem.eventTiming), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventTiming is TFhirDateTime) {6} then
    ComposeDateTime(this, 'TriggerDefinition', 'eventTimingDateTime', TFhirDateTime(elem.eventTiming), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDataRequirement(this, 'TriggerDefinition', 'eventData', elem.eventDataElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePeriod(obj : TTurtleComplex) : TFhirPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod);
begin
    ParseElementProperties(obj, result);
    result.startElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.start'));{q1}
    result.end_Element := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.end'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Period'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'end', elem.end_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseQuantity(obj : TTurtleComplex) : TFhirQuantity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity);
begin
    ParseElementProperties(obj, result);
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Quantity.value'));{q1}
    result.comparatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Quantity.comparator'), CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    result.unit_Element := ParseString(obj.complex('http://hl7.org/fhir/Quantity.unit'));{q1}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Quantity.system'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Quantity.code'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Quantity'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Quantity', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Quantity', 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Quantity', 'unit', elem.unit_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Quantity', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Quantity', 'code', elem.codeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRange(obj : TTurtleComplex) : TFhirRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRange.create;
  try
    ParseRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange);
begin
    ParseElementProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.high'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Range'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'high', elem.highElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedArtifact.create;
  try
    ParseRelatedArtifactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedArtifactProperties(obj : TTurtleComplex; result : TFhirRelatedArtifact);
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedArtifact.type'), CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum);
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.display'));{q1}
    result.citationElement := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.citation'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/RelatedArtifact.url'));{q1}
    result.document := ParseAttachment(obj.complex('http://hl7.org/fhir/RelatedArtifact.document'));{q3b}
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RelatedArtifact.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedArtifact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedArtifact'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'RelatedArtifact', 'type', elem.Type_Element, CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'RelatedArtifact', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'RelatedArtifact', 'citation', elem.citationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'RelatedArtifact', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeAttachment(this, 'RelatedArtifact', 'document', elem.documentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirReference}(this, 'RelatedArtifact', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Annotation.authorReference', item) {a3} then
      result.author := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Annotation.authorString', item) then
      result.author := parseString(item);
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Annotation.time'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Annotation.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Annotation'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(this, 'Annotation', 'authorReference', TFhirReference(elem.author), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(this, 'Annotation', 'authorString', TFhirString(elem.author), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Annotation', 'time', elem.timeElement, false, -1);{x.2ea}
  ComposeString(this, 'Annotation', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactDetail.create;
  try
    ParseContactDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactDetailProperties(obj : TTurtleComplex; result : TFhirContactDetail);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ContactDetail.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ContactDetail.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactDetail'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactDetail', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ContactDetail', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUsageContext.create;
  try
    ParseUsageContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseUsageContextProperties(obj : TTurtleComplex; result : TFhirUsageContext);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/UsageContext.code'));{q3b}
    if obj.has('http://hl7.org/fhir/UsageContext.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/UsageContext.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/UsageContext.valueRange', item) then
      result.value := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirUsageContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:UsageContext'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'UsageContext', 'code', elem.codeElement, false, -1);{x.2f}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'UsageContext', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'UsageContext', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'UsageContext', 'valueRange', TFhirRange(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSignature(obj : TTurtleComplex) : TFhirSignature;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Signature.type') do
      result.type_List.Add(parseCoding(item));
    result.whenElement := ParseInstant(obj.complex('http://hl7.org/fhir/Signature.when'));{q1}
    if obj.has('http://hl7.org/fhir/Signature.whoReference', item) {a3} then
      result.who := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Signature.whoUri', item) then
      result.who := parseUri(item);
    if obj.has('http://hl7.org/fhir/Signature.onBehalfOfReference', item) {a3} then
      result.onBehalfOf := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Signature.onBehalfOfUri', item) then
      result.onBehalfOf := parseUri(item);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.contentType'));{q1}
    result.blobElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Signature.blob'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Signature'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'Signature', 'type', elem.type_List[i], false, i);{x.d3}
  ComposeInstant(this, 'Signature', 'when', elem.whenElement, false, -1);{x.2ea}
  if (elem.who is TFhirReference) {2} then
    ComposeReference(this, 'Signature', 'whoReference', TFhirReference(elem.who), false,-1){x.d8}
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(this, 'Signature', 'whoUri', TFhirUri(elem.who), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.onBehalfOf is TFhirReference) {2} then
    ComposeReference(this, 'Signature', 'onBehalfOfReference', TFhirReference(elem.onBehalfOf), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.onBehalfOf is TFhirUri) {6} then
    ComposeUri(this, 'Signature', 'onBehalfOfUri', TFhirUri(elem.onBehalfOf), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Signature', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Signature', 'blob', elem.blobElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CodeableConcept.coding') do
      result.codingList.Add(parseCoding(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/CodeableConcept.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeableConcept'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(this, 'CodeableConcept', 'coding', elem.codingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'CodeableConcept', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameterDefinition.create;
  try
    ParseParameterDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParameterDefinitionProperties(obj : TTurtleComplex; result : TFhirParameterDefinition);
begin
    ParseElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/ParameterDefinition.name'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/ParameterDefinition.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.max'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.documentation'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/ParameterDefinition.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameterDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParameterDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'ParameterDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ParameterDefinition', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ParameterDefinition', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ParameterDefinition', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ParameterDefinition', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ParameterDefinition', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ParameterDefinition', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint);
begin
    ParseElementProperties(obj, result);
    result.systemElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.system'), CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ContactPoint.value'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.use'), CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ContactPoint.rank'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ContactPoint.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactPoint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactPoint', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'ContactPoint', 'rank', elem.rankElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'ContactPoint', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseHumanName(obj : TTurtleComplex) : TFhirHumanName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/HumanName.use'), CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.text'));{q1}
    result.familyElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.family'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HumanName.given') do
      result.givenList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.prefix') do
      result.prefixList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.suffix') do
      result.suffixList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/HumanName.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HumanName'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'HumanName', 'use', elem.UseElement, CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'family', elem.familyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(this, 'HumanName', 'given', elem.givenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(this, 'HumanName', 'prefix', elem.prefixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(this, 'HumanName', 'suffix', elem.suffixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'HumanName', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeta(obj : TTurtleComplex) : TFhirMeta;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeta.create;
  try
    ParseMetaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.versionIdElement := ParseId(obj.complex('http://hl7.org/fhir/Meta.versionId'));{q1}
    result.lastUpdatedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Meta.lastUpdated'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Meta.profile') do
      result.profileList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.security') do
      result.securityList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.tag') do
      result.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Meta'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Meta', 'versionId', elem.versionIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Meta', 'lastUpdated', elem.lastUpdatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(this, 'Meta', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(this, 'Meta', 'security', elem.securityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(this, 'Meta', 'tag', elem.tagList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAddress(obj : TTurtleComplex) : TFhirAddress;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAddress.create;
  try
    ParseAddressProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Address.use'), CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Address.type'), CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Address.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Address.line') do
      result.lineList.Add(parseString(item));
    result.cityElement := ParseString(obj.complex('http://hl7.org/fhir/Address.city'));{q1}
    result.districtElement := ParseString(obj.complex('http://hl7.org/fhir/Address.district'));{q1}
    result.stateElement := ParseString(obj.complex('http://hl7.org/fhir/Address.state'));{q1}
    result.postalCodeElement := ParseString(obj.complex('http://hl7.org/fhir/Address.postalCode'));{q1}
    result.countryElement := ParseString(obj.complex('http://hl7.org/fhir/Address.country'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Address.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Address'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'use', elem.UseElement, CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(this, 'Address', 'line', elem.lineList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'city', elem.cityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'district', elem.districtElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'state', elem.stateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'postalCode', elem.postalCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'country', elem.countryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Address', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.slicing.discriminator') do
      result.discriminatorList.Add(parseElementDefinitionSlicingDiscriminator(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.description'));{q1}
    result.orderedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.ordered'));{q1}
    result.rulesElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.rules'), CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(this, 'ElementDefinition.slicing', 'discriminator', elem.discriminatorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.slicing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBoolean(this, 'ElementDefinition.slicing', 'ordered', elem.orderedElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.slicing', 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    ParseElementDefinitionSlicingDiscriminatorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicingDiscriminator);
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.type'), CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.path'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicingDiscriminator'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ElementDefinition.slicing.discriminator', 'type', elem.Type_Element, CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'ElementDefinition.slicing.discriminator', 'path', elem.pathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase);
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.path'));{q1}
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.base.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.max'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBase'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition.base', 'path', elem.pathElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'ElementDefinition.base', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.base', 'max', elem.maxElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.codeElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.type.code'));{q1}
    result.profileElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.type.profile'));{q1}
    result.targetProfileElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.type.targetProfile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.aggregation') do
      result.aggregationList.Add(parseEnum(item, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum));
    result.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.type.versioning'), CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionType'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ElementDefinition.type', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ElementDefinition.type', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ElementDefinition.type', 'targetProfile', elem.targetProfileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.versioningElement <> nil) and (elem.versioningElement.primitiveValue <> 'either')) then
    ComposeEnum(this, 'ElementDefinition.type', 'versioning', elem.VersioningElement, CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionExample.create;
  try
    ParseElementDefinitionExampleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionExampleProperties(obj : TTurtleComplex; result : TFhirElementDefinitionExample);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.example.label'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueMeta', item) then
      result.value := parseMeta(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionExample; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionExample'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition.example', 'label', elem.label_Element, false, -1);{x.2ea}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition.example', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition.example', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition.example', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition.example', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition.example', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition.example', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition.example', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition.example', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition.example', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition.example', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition.example', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition.example', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition.example', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition.example', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition.example', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition.example', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition.example', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition.example', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition.example', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition.example', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition.example', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition.example', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition.example', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition.example', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition.example', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition.example', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition.example', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition.example', 'valueMeta', TFhirMeta(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition.example', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition.example', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition.example', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition.example', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition.example', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition.example', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition.example', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition.example', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition.example', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition.example', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(obj, result);
    result.keyElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.key'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.requirements'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.severity'), CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    result.humanElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.human'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.expression'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.xpath'));{q1}
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.source'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionConstraint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.constraint', 'key', elem.keyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.constraint', 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, false, -1);{x.d4}
  ComposeString(this, 'ElementDefinition.constraint', 'human', elem.humanElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.constraint', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'xpath', elem.xpathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ElementDefinition.constraint', 'source', elem.sourceElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.description'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.binding.valueSetReference', item) {a3} then
      result.valueSet := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.binding.valueSetUri', item) then
      result.valueSet := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBinding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ElementDefinition.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.binding', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'ElementDefinition.binding', 'valueSetReference', TFhirReference(elem.valueSet), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition.binding', 'valueSetUri', TFhirUri(elem.valueSet), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.identity'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.language'));{q1}
    result.mapElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.map'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionMapping'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ElementDefinition.mapping', 'language', elem.languageElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.mapping', 'map', elem.mapElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.mapping', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.path'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.representation') do
      result.representationList.Add(parseEnum(item, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum));
    result.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.sliceName'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.label'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.code') do
      result.codeList.Add(parseCoding(item));
    result.slicing := ParseElementDefinitionSlicing(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing'));{q3b}
    result.shortElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.short'));{q1}
    result.definitionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.definition'));{q1}
    result.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.comment'));{q1}
    result.requirementsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.requirements'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.alias') do
      result.aliasList.Add(parseString(item));
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.max'));{q1}
    result.base := ParseElementDefinitionBase(obj.complex('http://hl7.org/fhir/ElementDefinition.base'));{q3b}
    result.contentReferenceElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.contentReference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type') do
      result.type_List.Add(parseElementDefinitionType(item));
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCode', item) then
      result.defaultValue := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueId', item) then
      result.defaultValue := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueMarkdown', item) then
      result.defaultValue := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueOid', item) then
      result.defaultValue := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValuePositiveInt', item) then
      result.defaultValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUnsignedInt', item) then
      result.defaultValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAddress', item) then
      result.defaultValue := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAge', item) then
      result.defaultValue := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAnnotation', item) then
      result.defaultValue := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAttachment', item) then
      result.defaultValue := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCodeableConcept', item) then
      result.defaultValue := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCoding', item) then
      result.defaultValue := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueContactPoint', item) then
      result.defaultValue := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCount', item) then
      result.defaultValue := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDistance', item) then
      result.defaultValue := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDuration', item) then
      result.defaultValue := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueHumanName', item) then
      result.defaultValue := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueIdentifier', item) then
      result.defaultValue := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueMoney', item) then
      result.defaultValue := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValuePeriod', item) then
      result.defaultValue := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueQuantity', item) then
      result.defaultValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueRange', item) then
      result.defaultValue := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueRatio', item) then
      result.defaultValue := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueReference', item) then
      result.defaultValue := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueSampledData', item) then
      result.defaultValue := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueSignature', item) then
      result.defaultValue := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueTiming', item) then
      result.defaultValue := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueMeta', item) then
      result.defaultValue := parseMeta(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueBase64Binary', item) then
      result.defaultValue := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueBoolean', item) then
      result.defaultValue := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDate', item) then
      result.defaultValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDateTime', item) then
      result.defaultValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDecimal', item) then
      result.defaultValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueInstant', item) then
      result.defaultValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueInteger', item) then
      result.defaultValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueString', item) then
      result.defaultValue := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueTime', item) then
      result.defaultValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUri', item) then
      result.defaultValue := parseUri(item);
    result.meaningWhenMissingElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.meaningWhenMissing'));{q1}
    result.orderMeaningElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.orderMeaning'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCode', item) then
      result.fixed := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedId', item) then
      result.fixed := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedMarkdown', item) then
      result.fixed := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedOid', item) then
      result.fixed := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedPositiveInt', item) then
      result.fixed := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUnsignedInt', item) then
      result.fixed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAddress', item) then
      result.fixed := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAge', item) then
      result.fixed := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAnnotation', item) then
      result.fixed := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAttachment', item) then
      result.fixed := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCodeableConcept', item) then
      result.fixed := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCoding', item) then
      result.fixed := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedContactPoint', item) then
      result.fixed := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCount', item) then
      result.fixed := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDistance', item) then
      result.fixed := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDuration', item) then
      result.fixed := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedHumanName', item) then
      result.fixed := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedIdentifier', item) then
      result.fixed := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedMoney', item) then
      result.fixed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedPeriod', item) then
      result.fixed := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedQuantity', item) then
      result.fixed := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedRange', item) then
      result.fixed := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedRatio', item) then
      result.fixed := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedReference', item) then
      result.fixed := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedSampledData', item) then
      result.fixed := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedSignature', item) then
      result.fixed := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedTiming', item) then
      result.fixed := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedMeta', item) then
      result.fixed := parseMeta(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedBase64Binary', item) then
      result.fixed := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedBoolean', item) then
      result.fixed := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDate', item) then
      result.fixed := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDateTime', item) then
      result.fixed := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDecimal', item) then
      result.fixed := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedInstant', item) then
      result.fixed := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedInteger', item) then
      result.fixed := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedString', item) then
      result.fixed := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedTime', item) then
      result.fixed := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUri', item) then
      result.fixed := parseUri(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCode', item) then
      result.pattern := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternId', item) then
      result.pattern := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternMarkdown', item) then
      result.pattern := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternOid', item) then
      result.pattern := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternPositiveInt', item) then
      result.pattern := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUnsignedInt', item) then
      result.pattern := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAddress', item) then
      result.pattern := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAge', item) then
      result.pattern := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAnnotation', item) then
      result.pattern := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAttachment', item) then
      result.pattern := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCodeableConcept', item) then
      result.pattern := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCoding', item) then
      result.pattern := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternContactPoint', item) then
      result.pattern := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCount', item) then
      result.pattern := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDistance', item) then
      result.pattern := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDuration', item) then
      result.pattern := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternHumanName', item) then
      result.pattern := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternIdentifier', item) then
      result.pattern := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternMoney', item) then
      result.pattern := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternPeriod', item) then
      result.pattern := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternQuantity', item) then
      result.pattern := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternRange', item) then
      result.pattern := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternRatio', item) then
      result.pattern := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternReference', item) then
      result.pattern := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternSampledData', item) then
      result.pattern := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternSignature', item) then
      result.pattern := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternTiming', item) then
      result.pattern := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternMeta', item) then
      result.pattern := parseMeta(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternBase64Binary', item) then
      result.pattern := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternBoolean', item) then
      result.pattern := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDate', item) then
      result.pattern := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDateTime', item) then
      result.pattern := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDecimal', item) then
      result.pattern := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternInstant', item) then
      result.pattern := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternInteger', item) then
      result.pattern := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternString', item) then
      result.pattern := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternTime', item) then
      result.pattern := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUri', item) then
      result.pattern := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.example') do
      result.exampleList.Add(parseElementDefinitionExample(item));
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValuePositiveInt', item) then
      result.minValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueUnsignedInt', item) then
      result.minValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueQuantity', item) then
      result.minValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDate', item) then
      result.minValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDateTime', item) then
      result.minValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueInstant', item) then
      result.minValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueTime', item) then
      result.minValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDecimal', item) then
      result.minValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueInteger', item) then
      result.minValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValuePositiveInt', item) then
      result.maxValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueUnsignedInt', item) then
      result.maxValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueQuantity', item) then
      result.maxValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDate', item) then
      result.maxValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDateTime', item) then
      result.maxValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueInstant', item) then
      result.maxValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueTime', item) then
      result.maxValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDecimal', item) then
      result.maxValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueInteger', item) then
      result.maxValue := parseInteger(item);
    result.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.maxLength'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.condition') do
      result.conditionList.Add(parseId(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.constraint') do
      result.constraintList.Add(parseElementDefinitionConstraint(item));
    result.mustSupportElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.mustSupport'));{q1}
    result.isModifierElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifier'));{q1}
    result.isSummaryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isSummary'));{q1}
    result.binding := ParseElementDefinitionBinding(obj.complex('http://hl7.org/fhir/ElementDefinition.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.mapping') do
      result.mappingList.Add(parseElementDefinitionMapping(item));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'sliceName', elem.sliceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'ElementDefinition', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(this, 'ElementDefinition', 'slicing', elem.slicingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'short', elem.shortElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'ElementDefinition', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'ElementDefinition', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(this, 'ElementDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'ElementDefinition', 'contentReference', elem.contentReferenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(this, 'ElementDefinition', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'defaultValueCode', TFhirCode(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'defaultValueId', TFhirId(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'defaultValueOid', TFhirOid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'defaultValueAddress', TFhirAddress(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'defaultValueAge', TFhirAge(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'defaultValueCoding', TFhirCoding(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'defaultValueCount', TFhirCount(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'defaultValueDistance', TFhirDistance(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'defaultValueDuration', TFhirDuration(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'defaultValueMoney', TFhirMoney(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'defaultValueRange', TFhirRange(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'defaultValueRatio', TFhirRatio(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'defaultValueReference', TFhirReference(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'defaultValueSignature', TFhirSignature(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'defaultValueTiming', TFhirTiming(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'defaultValueMeta', TFhirMeta(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'defaultValueDate', TFhirDate(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'defaultValueInstant', TFhirInstant(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'defaultValueInteger', TFhirInteger(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'defaultValueString', TFhirString(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'defaultValueTime', TFhirTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'defaultValueUri', TFhirUri(elem.defaultValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'meaningWhenMissing', elem.meaningWhenMissingElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'orderMeaning', elem.orderMeaningElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'fixedCode', TFhirCode(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'fixedId', TFhirId(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'fixedMarkdown', TFhirMarkdown(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'fixedOid', TFhirOid(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'fixedAddress', TFhirAddress(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'fixedAge', TFhirAge(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'fixedAnnotation', TFhirAnnotation(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'fixedAttachment', TFhirAttachment(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'fixedCoding', TFhirCoding(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'fixedContactPoint', TFhirContactPoint(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'fixedCount', TFhirCount(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'fixedDistance', TFhirDistance(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'fixedDuration', TFhirDuration(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'fixedHumanName', TFhirHumanName(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'fixedIdentifier', TFhirIdentifier(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'fixedMoney', TFhirMoney(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'fixedPeriod', TFhirPeriod(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'fixedQuantity', TFhirQuantity(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'fixedRange', TFhirRange(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'fixedRatio', TFhirRatio(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'fixedReference', TFhirReference(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'fixedSampledData', TFhirSampledData(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'fixedSignature', TFhirSignature(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'fixedTiming', TFhirTiming(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'fixedMeta', TFhirMeta(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'fixedBoolean', TFhirBoolean(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'fixedDate', TFhirDate(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'fixedDateTime', TFhirDateTime(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'fixedDecimal', TFhirDecimal(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'fixedInstant', TFhirInstant(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'fixedInteger', TFhirInteger(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'fixedString', TFhirString(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'fixedTime', TFhirTime(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'fixedUri', TFhirUri(elem.fixed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'patternCode', TFhirCode(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'patternId', TFhirId(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'patternMarkdown', TFhirMarkdown(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'patternOid', TFhirOid(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'patternAddress', TFhirAddress(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'patternAge', TFhirAge(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'patternAnnotation', TFhirAnnotation(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'patternAttachment', TFhirAttachment(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'patternCoding', TFhirCoding(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'patternContactPoint', TFhirContactPoint(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'patternCount', TFhirCount(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'patternDistance', TFhirDistance(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'patternDuration', TFhirDuration(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'patternHumanName', TFhirHumanName(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'patternIdentifier', TFhirIdentifier(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'patternMoney', TFhirMoney(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'patternPeriod', TFhirPeriod(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'patternQuantity', TFhirQuantity(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'patternRange', TFhirRange(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'patternRatio', TFhirRatio(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'patternReference', TFhirReference(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'patternSampledData', TFhirSampledData(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'patternSignature', TFhirSignature(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'patternTiming', TFhirTiming(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'patternMeta', TFhirMeta(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'patternBoolean', TFhirBoolean(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'patternDate', TFhirDate(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'patternDateTime', TFhirDateTime(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'patternDecimal', TFhirDecimal(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'patternInstant', TFhirInstant(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'patternInteger', TFhirInteger(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'patternString', TFhirString(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'patternTime', TFhirTime(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'patternUri', TFhirUri(elem.pattern), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.exampleList.Count - 1 do
      ComposeElementDefinitionExample(this, 'ElementDefinition', 'example', elem.exampleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'minValueQuantity', TFhirQuantity(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'minValueDate', TFhirDate(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'minValueDateTime', TFhirDateTime(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'minValueInstant', TFhirInstant(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'minValueTime', TFhirTime(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'minValueDecimal', TFhirDecimal(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'minValueInteger', TFhirInteger(elem.minValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'maxValueQuantity', TFhirQuantity(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'maxValueDate', TFhirDate(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'maxValueDateTime', TFhirDateTime(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'maxValueInstant', TFhirInstant(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'maxValueTime', TFhirTime(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'maxValueDecimal', TFhirDecimal(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'maxValueInteger', TFhirInteger(elem.maxValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'maxLength', elem.maxLengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(this, 'ElementDefinition', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(this, 'ElementDefinition', 'constraint', elem.constraintList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'mustSupport', elem.mustSupportElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'isModifier', elem.isModifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBoolean(this, 'ElementDefinition', 'isSummary', elem.isSummaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(this, 'ElementDefinition', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(this, 'ElementDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsDuration', item) then
      result.bounds := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsRange', item) then
      result.bounds := parseRange(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsPeriod', item) then
      result.bounds := parsePeriod(item);
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.count'));{q1}
    result.countMaxElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.countMax'));{q1}
    result.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.duration'));{q1}
    result.durationMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.durationMax'));{q1}
    result.durationUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.durationUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    result.frequencyElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.frequency'));{q1}
    result.frequencyMaxElement := ParseInteger(obj.complex('http://hl7.org/fhir/Timing.repeat.frequencyMax'));{q1}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.period'));{q1}
    result.periodMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.periodMax'));{q1}
    result.periodUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.periodUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.dayOfWeek') do
      result.dayOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.timeOfDay') do
      result.timeOfDayList.Add(parseTime(item));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.when') do
      result.whenList.Add(parseEnum(item, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum));
    result.offsetElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Timing.repeat.offset'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TimingRepeat'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirDuration) {6} then
    ComposeDuration(this, 'Timing.repeat', 'boundsDuration', TFhirDuration(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(this, 'Timing.repeat', 'boundsRange', TFhirRange(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(this, 'Timing.repeat', 'boundsPeriod', TFhirPeriod(elem.bounds), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Timing.repeat', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Timing.repeat', 'countMax', elem.countMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'duration', elem.durationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'durationMax', elem.durationMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'durationUnit', elem.DurationUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeInteger(this, 'Timing.repeat', 'frequency', elem.frequencyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Timing.repeat', 'frequencyMax', elem.frequencyMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'periodMax', elem.periodMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'periodUnit', elem.PeriodUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.timeOfDayList.Count - 1 do
      ComposeTime(this, 'Timing.repeat', 'timeOfDay', elem.timeOfDayList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', elem.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', elem.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Timing.repeat', 'offset', elem.offsetElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTiming(obj : TTurtleComplex) : TFhirTiming;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTiming.create;
  try
    ParseTimingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Timing.event') do
      result.eventList.Add(parseDateTime(item));
    result.repeat_ := ParseTimingRepeat(obj.complex('http://hl7.org/fhir/Timing.repeat'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Timing.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Timing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(this, 'Timing', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(this, 'Timing', 'repeat', elem.repeat_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Timing', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCount(obj : TTurtleComplex) : TFhirCount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCount.create;
  try
    ParseCountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCountProperties(obj : TTurtleComplex; result : TFhirCount);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeCount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Count'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseMoney(obj : TTurtleComplex) : TFhirMoney;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMoney.create;
  try
    ParseMoneyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMoneyProperties(obj : TTurtleComplex; result : TFhirMoney);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeMoney(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMoney; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Money'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseAge(obj : TTurtleComplex) : TFhirAge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAge.create;
  try
    ParseAgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAgeProperties(obj : TTurtleComplex; result : TFhirAge);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeAge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Age'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseDistance(obj : TTurtleComplex) : TFhirDistance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDistance.create;
  try
    ParseDistanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDistanceProperties(obj : TTurtleComplex; result : TFhirDistance);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeDistance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDistance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Distance'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseDuration(obj : TTurtleComplex) : TFhirDuration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDuration.create;
  try
    ParseDurationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDurationProperties(obj : TTurtleComplex; result : TFhirDuration);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeDuration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDuration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Duration'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

{$IFDEF FHIR_ACCOUNT}
function TFHIRTurtleParser.ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountCoverage.create;
  try
    ParseAccountCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountCoverageProperties(obj : TTurtleComplex; result : TFhirAccountCoverage);
begin
    ParseBackboneElementProperties(obj, result);
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/Account.coverage.coverage'));{q3b}
    result.priorityElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Account.coverage.priority'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountCoverage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCoverage}(this, 'Account.coverage', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Account.coverage', 'priority', elem.priorityElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountGuarantor.create;
  try
    ParseAccountGuarantorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountGuarantorProperties(obj : TTurtleComplex; result : TFhirAccountGuarantor);
begin
    ParseBackboneElementProperties(obj, result);
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Account.guarantor.party'));{q3b}
    result.onHoldElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Account.guarantor.onHold'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.guarantor.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountGuarantor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountGuarantor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Account.guarantor', 'party', elem.partyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Account.guarantor', 'onHold', elem.onHoldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Account.guarantor', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAccount(obj : TTurtleComplex) : TFhirAccount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccount.create;
  try
    ParseAccountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Account.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Account.status'), CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.type'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Account.name'));{q1}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Account.subject'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.period'));{q3b}
    result.active := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.active'));{q3b}
    result.balance := ParseMoney(obj.complex('http://hl7.org/fhir/Account.balance'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Account.coverage') do
      result.coverageList.Add(parseAccountCoverage(item));
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Account.owner'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Account.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Account.guarantor') do
      result.guarantorList.Add(parseAccountGuarantor(item));
end;

procedure TFHIRTurtleComposer.ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Account'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Account', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Account', 'status', elem.StatusElement, CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Account', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Account', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Account', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Account', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposePeriod(this, 'Account', 'active', elem.activeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('balance') then
    ComposeMoney(this, 'Account', 'balance', elem.balanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeAccountCoverage(this, 'Account', 'coverage', elem.coverageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Account', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Account', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('guarantor') then
    for i := 0 to elem.guarantorList.Count - 1 do
      ComposeAccountGuarantor(this, 'Account', 'guarantor', elem.guarantorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
function TFHIRTurtleParser.ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionParticipant.create;
  try
    ParseActivityDefinitionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ActivityDefinition.participant', 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ActivityDefinition.participant', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    ParseActivityDefinitionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionDynamicValue);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.description'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.path'));{q1}
    result.languageElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionDynamicValue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition.dynamicValue', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition.dynamicValue', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition.dynamicValue', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition.dynamicValue', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinition.create;
  try
    ParseActivityDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionProperties(obj : TTurtleComplex; result : TFhirActivityDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ActivityDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActivityDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ActivityDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.usage'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ActivityDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.contributor') do
      result.contributorList.Add(parseContributor(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.library') do
      result.library_List.Add(parseReference{TFhirLibrary}(item));
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.kind'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.code'));{q3b}
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingDateTime', item) then
      result.timing := parseDateTime(item);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/ActivityDefinition.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.participant') do
      result.participantList.Add(parseActivityDefinitionParticipant(item));
    if obj.has('http://hl7.org/fhir/ActivityDefinition.productReference', item) {a3} then
      result.product := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ActivityDefinition.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dosage') do
      result.dosageList.Add(parseDosage(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.transform := ParseReference{TFhirStructureMap}(obj.complex('http://hl7.org/fhir/ActivityDefinition.transform'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dynamicValue') do
      result.dynamicValueList.Add(parseActivityDefinitionDynamicValue(item));
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ActivityDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ActivityDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ActivityDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ActivityDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ActivityDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ActivityDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ActivityDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ActivityDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ActivityDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ActivityDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ActivityDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'ActivityDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ActivityDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ActivityDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ActivityDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ActivityDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(this, 'ActivityDefinition', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ActivityDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ActivityDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(this, 'ActivityDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('kind') then
    ComposeEnum(this, 'ActivityDefinition', 'kind', elem.KindElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'ActivityDefinition', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'ActivityDefinition', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'ActivityDefinition', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ActivityDefinition', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'ActivityDefinition', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(this, 'ActivityDefinition', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'ActivityDefinition', 'productReference', TFhirReference(elem.product), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'ActivityDefinition', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(this, 'ActivityDefinition', 'dosage', elem.dosageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('transform') then
    ComposeReference{TFhirStructureMap}(this, 'ActivityDefinition', 'transform', elem.transformElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dynamicValue') then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(this, 'ActivityDefinition', 'dynamicValue', elem.dynamicValueList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
function TFHIRTurtleParser.ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSuspectEntity.create;
  try
    ParseAdverseEventSuspectEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntity);
begin
    ParseBackboneElementProperties(obj, result);
    result.instance := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.instance'));{q3b}
    result.causalityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality'), CODES_TFhirAdverseEventCausalityEnum, SYSTEMS_TFhirAdverseEventCausalityEnum);
    result.causalityAssessment := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causalityAssessment'));{q3b}
    result.causalityProductRelatednessElement := ParseString(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causalityProductRelatedness'));{q1}
    result.causalityMethod := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causalityMethod'));{q3b}
    result.causalityAuthor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causalityAuthor'));{q3b}
    result.causalityResult := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causalityResult'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSuspectEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'AdverseEvent.suspectEntity', 'instance', elem.instanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AdverseEvent.suspectEntity', 'causality', elem.CausalityElement, CODES_TFhirAdverseEventCausalityEnum, SYSTEMS_TFhirAdverseEventCausalityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity', 'causalityAssessment', elem.causalityAssessmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AdverseEvent.suspectEntity', 'causalityProductRelatedness', elem.causalityProductRelatednessElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity', 'causalityMethod', elem.causalityMethodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AdverseEvent.suspectEntity', 'causalityAuthor', elem.causalityAuthorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity', 'causalityResult', elem.causalityResultElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEvent.create;
  try
    ParseAdverseEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventProperties(obj : TTurtleComplex; result : TFhirAdverseEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AdverseEvent.identifier'));{q3b}
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdverseEvent.category'), CODES_TFhirAdverseEventCategoryEnum, SYSTEMS_TFhirAdverseEventCategoryEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.type'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AdverseEvent.subject'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.reaction') do
      result.reactionList.Add(parseReference{TFhirCondition}(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/AdverseEvent.location'));{q3b}
    result.seriousness := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.seriousness'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.outcome'));{q3b}
    result.recorder := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AdverseEvent.recorder'));{q3b}
    result.eventParticipant := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AdverseEvent.eventParticipant'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AdverseEvent.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.suspectEntity') do
      result.suspectEntityList.Add(parseAdverseEventSuspectEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.subjectMedicalHistory') do
      result.subjectMedicalHistoryList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.referenceDocument') do
      result.referenceDocumentList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.study') do
      result.studyList.Add(parseReference{TFhirResearchStudy}(item));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEvent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'AdverseEvent', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(this, 'AdverseEvent', 'category', elem.CategoryElement, CODES_TFhirAdverseEventCategoryEnum, SYSTEMS_TFhirAdverseEventCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'AdverseEvent', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'AdverseEvent', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'AdverseEvent', 'reaction', elem.reactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'AdverseEvent', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('seriousness') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'seriousness', elem.seriousnessElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(this, 'AdverseEvent', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('eventParticipant') then
    ComposeReference{Resource}(this, 'AdverseEvent', 'eventParticipant', elem.eventParticipantElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'AdverseEvent', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suspectEntity') then
    for i := 0 to elem.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(this, 'AdverseEvent', 'suspectEntity', elem.suspectEntityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectMedicalHistory') then
    for i := 0 to elem.subjectMedicalHistoryList.Count - 1 do
      ComposeReference{Resource}(this, 'AdverseEvent', 'subjectMedicalHistory', elem.subjectMedicalHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceDocument') then
    for i := 0 to elem.referenceDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'AdverseEvent', 'referenceDocument', elem.referenceDocumentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('study') then
    for i := 0 to elem.studyList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(this, 'AdverseEvent', 'study', elem.studyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRTurtleParser.ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.substance'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.manifestation') do
      result.manifestationList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.description'));{q1}
    result.onsetElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.onset'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.severity'), CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    result.exposureRoute := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.exposureRoute'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntoleranceReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'substance', elem.substanceElement, false, -1);{x.2f}
  for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'manifestation', elem.manifestationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AllergyIntolerance.reaction', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance.reaction', 'onset', elem.onsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AllergyIntolerance.reaction', 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'exposureRoute', elem.exposureRouteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance.reaction', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.clinicalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.clinicalStatus'), CODES_TFhirAllergyClinicalStatusEnum, SYSTEMS_TFhirAllergyClinicalStatusEnum);
    result.verificationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.verificationStatus'), CODES_TFhirAllergyVerificationStatusEnum, SYSTEMS_TFhirAllergyVerificationStatusEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.type'), CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.category') do
      result.categoryList.Add(parseEnum(item, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum));
    result.criticalityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.criticality'), CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.code'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.patient'));{q3b}
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetDateTime', item) then
      result.onset := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetString', item) then
      result.onset := parseString(item);
    result.assertedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.assertedDate'));{q1}
    result.recorder := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recorder'));{q3b}
    result.asserter := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.asserter'));{q3b}
    result.lastOccurrenceElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.lastOccurrence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction') do
      result.reactionList.Add(parseAllergyIntoleranceReaction(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntolerance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AllergyIntolerance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeEnum(this, 'AllergyIntolerance', 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirAllergyClinicalStatusEnum, SYSTEMS_TFhirAllergyClinicalStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'AllergyIntolerance', 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirAllergyVerificationStatusEnum, SYSTEMS_TFhirAllergyVerificationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(this, 'AllergyIntolerance', 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnum(this, 'AllergyIntolerance', 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'AllergyIntolerance', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'AllergyIntolerance', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'AllergyIntolerance', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'AllergyIntolerance', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AllergyIntolerance', 'onsetDateTime', TFhirDateTime(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'AllergyIntolerance', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('assertedDate') then
    ComposeDateTime(this, 'AllergyIntolerance', 'assertedDate', elem.assertedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(this, 'AllergyIntolerance', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lastOccurrence') then
    ComposeDateTime(this, 'AllergyIntolerance', 'lastOccurrence', elem.lastOccurrenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(this, 'AllergyIntolerance', 'reaction', elem.reactionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRTurtleParser.ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Appointment.participant.actor'));{q3b}
    result.requiredElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.required'), CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.status'), CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
end;

procedure TFHIRTurtleComposer.ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Appointment.participant', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Appointment.participant', 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, false, -1);{x.d4}
  ComposeEnum(this, 'Appointment.participant', 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseAppointment(obj : TTurtleComplex) : TFhirAppointment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.status'), CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    result.serviceCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.serviceCategory'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    result.appointmentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.appointmentType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.indication') do
      result.indicationList.Add(parseReference{Resource}(item));
    result.priorityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Appointment.priority'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.end'));{q1}
    result.minutesDurationElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.minutesDuration'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.slot') do
      result.slotList.Add(parseReference{TFhirSlot}(item));
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Appointment.created'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.incomingReferral') do
      result.incomingReferralList.Add(parseReference{TFhirReferralRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant') do
      result.participantList.Add(parseAppointmentParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.requestedPeriod') do
      result.requestedPeriodList.Add(parsePeriod(item));
end;

procedure TFHIRTurtleComposer.ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Appointment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Appointment', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Appointment', 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(this, 'Appointment', 'serviceCategory', elem.serviceCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(this, 'Appointment', 'appointmentType', elem.appointmentTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(this, 'Appointment', 'indication', elem.indicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedInt(this, 'Appointment', 'priority', elem.priorityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'Appointment', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Appointment', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstant(this, 'Appointment', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Appointment', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveInt(this, 'Appointment', 'minutesDuration', elem.minutesDurationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('slot') then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(this, 'Appointment', 'slot', elem.slotList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'Appointment', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Appointment', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'Appointment', 'incomingReferral', elem.incomingReferralList[i], false, i);{x.d3}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(this, 'Appointment', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('requestedPeriod') then
    for i := 0 to elem.requestedPeriodList.Count - 1 do
      ComposePeriod(this, 'Appointment', 'requestedPeriod', elem.requestedPeriodList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRTurtleParser.ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.appointment := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/AppointmentResponse.appointment'));{q3b}
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.end'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.participantType') do
      result.participantTypeList.Add(parseCodeableConcept(item));
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AppointmentResponse.actor'));{q3b}
    result.participantStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AppointmentResponse.participantStatus'), CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/AppointmentResponse.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AppointmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirAppointment}(this, 'AppointmentResponse', 'appointment', elem.appointmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstant(this, 'AppointmentResponse', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstant(this, 'AppointmentResponse', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentResponse', 'participantType', elem.participantTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{Resource}(this, 'AppointmentResponse', 'actor', elem.actorElement, false, -1);{x.2f}
  ComposeEnum(this, 'AppointmentResponse', 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'AppointmentResponse', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRTurtleParser.ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventAgent.create;
  try
    ParseAuditEventAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventAgentProperties(obj : TTurtleComplex; result : TFhirAuditEventAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/AuditEvent.agent.reference'));{q3b}
    result.userId := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.agent.userId'));{q3b}
    result.altIdElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.altId'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.name'));{q1}
    result.requestorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AuditEvent.agent.requestor'));{q1}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/AuditEvent.agent.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.policy') do
      result.policyList.Add(parseUri(item));
    result.media := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.agent.media'));{q3b}
    result.network := ParseAuditEventAgentNetwork(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.purposeOfUse') do
      result.purposeOfUseList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'role', elem.roleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'AuditEvent.agent', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEvent.agent', 'userId', elem.userIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent', 'altId', elem.altIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'AuditEvent.agent', 'requestor', elem.requestorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'AuditEvent.agent', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'AuditEvent.agent', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.agent', 'media', elem.mediaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventAgentNetwork(this, 'AuditEvent.agent', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'purposeOfUse', elem.purposeOfUseList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventAgentNetwork(obj : TTurtleComplex) : TFhirAuditEventAgentNetwork;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventAgentNetwork.create;
  try
    ParseAuditEventAgentNetworkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventAgentNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventAgentNetwork);
begin
    ParseBackboneElementProperties(obj, result);
    result.addressElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network.address'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network.type'), CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeAuditEventAgentNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgentNetwork; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventAgentNetwork'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent.network', 'address', elem.addressElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AuditEvent.agent.network', 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.siteElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.source.site'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.source.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.source.type') do
      result.type_List.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.source', 'site', elem.siteElement, false, -1);{x.2ea}
  ComposeIdentifier(this, 'AuditEvent.source', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'AuditEvent.source', 'type', elem.type_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntity.create;
  try
    ParseAuditEventEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityProperties(obj : TTurtleComplex; result : TFhirAuditEventEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AuditEvent.entity.identifier'));{q3b}
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/AuditEvent.entity.reference'));{q3b}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.type'));{q3b}
    result.role := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.role'));{q3b}
    result.lifecycle := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.lifecycle'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.description'));{q1}
    result.queryElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.entity.query'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.detail') do
      result.detailList.Add(parseAuditEventEntityDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'AuditEvent.entity', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'AuditEvent.entity', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'lifecycle', elem.lifecycleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.entity', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEvent.entity', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.entity', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'AuditEvent.entity', 'query', elem.queryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(this, 'AuditEvent.entity', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntityDetail.create;
  try
    ParseAuditEventEntityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventEntityDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.detail.type'));{q1}
    result.valueElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.entity.detail.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntityDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'AuditEvent.entity.detail', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeBase64Binary(this, 'AuditEvent.entity.detail', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.subtype') do
      result.subtypeList.Add(parseCoding(item));
    result.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.action'), CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    result.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/AuditEvent.recorded'));{q1}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.outcome'), CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    result.outcomeDescElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.outcomeDesc'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.purposeOfEvent') do
      result.purposeOfEventList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent') do
      result.agentList.Add(parseAuditEventAgent(item));
    result.source := ParseAuditEventSource(obj.complex('http://hl7.org/fhir/AuditEvent.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity') do
      result.entityList.Add(parseAuditEventEntity(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEvent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCoding(this, 'AuditEvent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(this, 'AuditEvent', 'subtype', elem.subtypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    ComposeEnum(this, 'AuditEvent', 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, false, -1);{x.d4}
  ComposeInstant(this, 'AuditEvent', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'AuditEvent', 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcomeDesc') then
    ComposeString(this, 'AuditEvent', 'outcomeDesc', elem.outcomeDescElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purposeOfEvent') then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent', 'purposeOfEvent', elem.purposeOfEventList[i], false, i);{x.d3}
  for i := 0 to elem.agentList.Count - 1 do
      ComposeAuditEventAgent(this, 'AuditEvent', 'agent', elem.agentList[i], false, i);{x.d3}
  ComposeAuditEventSource(this, 'AuditEvent', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeAuditEventEntity(this, 'AuditEvent', 'entity', elem.entityList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRTurtleParser.ParseBasic(obj : TTurtleComplex) : TFhirBasic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBasic.create;
  try
    ParseBasicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Basic.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Basic.code'));{q3b}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Basic.subject'));{q3b}
    result.createdElement := ParseDate(obj.complex('http://hl7.org/fhir/Basic.created'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Basic.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Basic'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Basic', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Basic', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'Basic', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDate(this, 'Basic', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Basic', 'author', elem.authorElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRTurtleParser.ParseBinary(obj : TTurtleComplex) : TFhirBinary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary);
begin
    ParseResourceProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Binary.contentType'));{q1}
    result.securityContext := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Binary.securityContext'));{q3b}
    result.contentElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Binary.content'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Binary'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  ComposeCode(this, 'Binary', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityContext') then
    ComposeReference{TFhirReference}(this, 'Binary', 'securityContext', elem.securityContextElement, false, -1);{x.2f}
  ComposeBase64Binary(this, 'Binary', 'content', elem.contentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
function TFHIRTurtleParser.ParseBodySite(obj : TTurtleComplex) : TFhirBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodySite.create;
  try
    ParseBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodySiteProperties(obj : TTurtleComplex; result : TFhirBodySite);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/BodySite.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/BodySite.active'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodySite.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BodySite.qualifier') do
      result.qualifierList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BodySite.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/BodySite.image') do
      result.imageList.Add(parseAttachment(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/BodySite.patient'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBodySite(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodySite'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BodySite', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'BodySite', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'BodySite', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('qualifier') then
    for i := 0 to elem.qualifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodySite', 'qualifier', elem.qualifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'BodySite', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'BodySite', 'image', elem.imageList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'BodySite', 'patient', elem.patientElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
function TFHIRTurtleParser.ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.relationElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.link.relation'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.link.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.link', 'relation', elem.relationElement, false, -1);{x.2ea}
  ComposeUri(this, 'Bundle.link', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry.link') do
      result.link_List.Add(parseBundleLink(item));
    result.fullUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.fullUrl'));{q1}
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.resource'));{q3a}
    result.search := ParseBundleEntrySearch(obj.complex('http://hl7.org/fhir/Bundle.entry.search'));{q3b}
    result.request := ParseBundleEntryRequest(obj.complex('http://hl7.org/fhir/Bundle.entry.request'));{q3b}
    result.response := ParseBundleEntryResponse(obj.complex('http://hl7.org/fhir/Bundle.entry.response'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle.entry', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry', 'fullUrl', elem.fullUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(this, 'Bundle.entry', 'search', elem.searchElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(this, 'Bundle.entry', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(this, 'Bundle.entry', 'response', elem.responseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.search.mode'), CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    result.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Bundle.entry.search.score'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntrySearch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Bundle.entry.search', 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Bundle.entry.search', 'score', elem.scoreElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(obj, result);
    result.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.request.method'), CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.request.url'));{q1}
    result.ifNoneMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneMatch'));{q1}
    result.ifModifiedSinceElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifModifiedSince'));{q1}
    result.ifMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifMatch'));{q1}
    result.ifNoneExistElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneExist'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Bundle.entry.request', 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, false, -1);{x.d4}
  ComposeUri(this, 'Bundle.entry.request', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneMatch', elem.ifNoneMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.request', 'ifModifiedSince', elem.ifModifiedSinceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifMatch', elem.ifMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneExist', elem.ifNoneExistElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.status'));{q1}
    result.locationElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.response.location'));{q1}
    result.etagElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.etag'));{q1}
    result.lastModifiedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.response.lastModified'));{q1}
    result.outcome := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.response.outcome'));{q3a}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.entry.response', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry.response', 'location', elem.locationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.response', 'etag', elem.etagElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.response', 'lastModified', elem.lastModifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry.response', 'outcome', elem.outcomeElement, false, -1);{x.2ec}
end;

function TFHIRTurtleParser.ParseBundle(obj : TTurtleComplex) : TFhirBundle;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundle.create;
  try
    ParseBundleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Bundle.identifier'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.type'), CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    result.totalElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Bundle.total'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Bundle.link') do
      result.link_List.Add(parseBundleLink(item));
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry') do
      result.entryList.Add(parseBundleEntry(item));
    result.signature := ParseSignature(obj.complex('http://hl7.org/fhir/Bundle.signature'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Bundle'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'Bundle', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'Bundle', 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(this, 'Bundle', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(this, 'Bundle', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(this, 'Bundle', 'signature', elem.signatureElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
function TFHIRTurtleParser.ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementSoftware.create;
  try
    ParseCapabilityStatementSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementSoftware);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.name'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.version'));{q1}
    result.releaseDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.releaseDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementSoftware'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.software', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement.software', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CapabilityStatement.software', 'releaseDate', elem.releaseDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementImplementation.create;
  try
    ParseCapabilityStatementImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementImplementation);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.description'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementImplementation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.implementation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CapabilityStatement.implementation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRest.create;
  try
    ParseCapabilityStatementRestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.mode'), CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.documentation'));{q1}
    result.security := ParseCapabilityStatementRestSecurity(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource') do
      result.resourceList.Add(parseCapabilityStatementRestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.interaction') do
      result.interactionList.Add(parseCapabilityStatementRestInteraction(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.searchParam') do
      result.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.operation') do
      result.operationList.Add(parseCapabilityStatementRestOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.compartment') do
      result.compartmentList.Add(parseUri(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest', 'mode', elem.ModeElement, CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.rest', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(this, 'CapabilityStatement.rest', 'security', elem.securityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(this, 'CapabilityStatement.rest', 'resource', elem.resourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(this, 'CapabilityStatement.rest', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestOperation(this, 'CapabilityStatement.rest', 'operation', elem.operationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(this, 'CapabilityStatement.rest', 'compartment', elem.compartmentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    ParseCapabilityStatementRestSecurityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.corsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.cors'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.security.service') do
      result.serviceList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.security.certificate') do
      result.certificateList.Add(parseCapabilityStatementRestSecurityCertificate(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestSecurity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.security', 'cors', elem.corsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement.rest.security', 'service', elem.serviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.rest.security', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeCapabilityStatementRestSecurityCertificate(this, 'CapabilityStatement.rest.security', 'certificate', elem.certificateList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestSecurityCertificate(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurityCertificate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestSecurityCertificate.create;
  try
    ParseCapabilityStatementRestSecurityCertificateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestSecurityCertificateProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurityCertificate);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseCode(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.certificate.type'));{q1}
    result.blobElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.certificate.blob'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestSecurityCertificate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurityCertificate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestSecurityCertificate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'CapabilityStatement.rest.security.certificate', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'CapabilityStatement.rest.security.certificate', 'blob', elem.blobElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResource.create;
  try
    ParseCapabilityStatementRestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.profile'));{q3b}
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction') do
      result.interactionList.Add(parseCapabilityStatementRestResourceInteraction(item));
    result.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.versioning'), CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    result.readHistoryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.readHistory'));{q1}
    result.updateCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.updateCreate'));{q1}
    result.conditionalCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalCreate'));{q1}
    result.conditionalReadElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalRead'), CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum);
    result.conditionalUpdateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalUpdate'));{q1}
    result.conditionalDeleteElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalDelete'), CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.referencePolicy') do
      result.referencePolicyList.Add(parseEnum(item, CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchInclude') do
      result.searchIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchRevInclude') do
      result.searchRevIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam') do
      result.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'CapabilityStatement.rest.resource', 'profile', elem.profileElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(this, 'CapabilityStatement.rest.resource', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'readHistory', elem.readHistoryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'updateCreate', elem.updateCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalCreate', elem.conditionalCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalRead', elem.ConditionalReadElement, CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalUpdate', elem.conditionalUpdateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchInclude', elem.searchIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchRevInclude', elem.searchRevIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest.resource', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    ParseCapabilityStatementRestResourceInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.code'), CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource.interaction', 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.rest.resource.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    ParseCapabilityStatementRestResourceSearchParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceSearchParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.name'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.definition'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceSearchParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.rest.resource.searchParam', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'CapabilityStatement.rest.resource.searchParam', 'definition', elem.definitionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement.rest.resource.searchParam', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.rest.resource.searchParam', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    ParseCapabilityStatementRestInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.code'), CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.interaction', 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.rest.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestOperation.create;
  try
    ParseCapabilityStatementRestOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestOperationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.operation.name'));{q1}
    result.definition := ParseReference{TFhirOperationDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.operation.definition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.rest.operation', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeReference{TFhirOperationDefinition}(this, 'CapabilityStatement.rest.operation', 'definition', elem.definitionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessaging.create;
  try
    ParseCapabilityStatementMessagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint') do
      result.endpointList.Add(parseCapabilityStatementMessagingEndpoint(item));
    result.reliableCacheElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.reliableCache'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage') do
      result.supportedMessageList.Add(parseCapabilityStatementMessagingSupportedMessage(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.event') do
      result.eventList.Add(parseCapabilityStatementMessagingEvent(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessaging'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(this, 'CapabilityStatement.messaging', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'CapabilityStatement.messaging', 'reliableCache', elem.reliableCacheElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.messaging', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(this, 'CapabilityStatement.messaging', 'supportedMessage', elem.supportedMessageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCapabilityStatementMessagingEvent(this, 'CapabilityStatement.messaging', 'event', elem.eventList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    ParseCapabilityStatementMessagingEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEndpoint);
begin
    ParseBackboneElementProperties(obj, result);
    result.protocol := ParseCoding(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.protocol'));{q3b}
    result.addressElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.address'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingEndpoint'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'CapabilityStatement.messaging.endpoint', 'protocol', elem.protocolElement, false, -1);{x.2f}
  ComposeUri(this, 'CapabilityStatement.messaging.endpoint', 'address', elem.addressElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    ParseCapabilityStatementMessagingSupportedMessageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingSupportedMessage);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.mode'), CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum);
    result.definition := ParseReference{TFhirMessageDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.definition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingSupportedMessage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.messaging.supportedMessage', 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, false, -1);{x.d4}
  ComposeReference{TFhirMessageDefinition}(this, 'CapabilityStatement.messaging.supportedMessage', 'definition', elem.definitionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingEvent(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingEvent.create;
  try
    ParseCapabilityStatementMessagingEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingEventProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEvent);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.code'));{q3b}
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.category'), CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.mode'), CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum);
    result.focusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.focus'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.request := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.request'));{q3b}
    result.response := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.response'));{q3b}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.event.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'CapabilityStatement.messaging.event', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.messaging.event', 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, false, -1);{x.d4}
  ComposeEnum(this, 'CapabilityStatement.messaging.event', 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, false, -1);{x.d4}
  ComposeEnum(this, 'CapabilityStatement.messaging.event', 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeReference{TFhirStructureDefinition}(this, 'CapabilityStatement.messaging.event', 'request', elem.requestElement, false, -1);{x.2f}
  ComposeReference{TFhirStructureDefinition}(this, 'CapabilityStatement.messaging.event', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.messaging.event', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementDocument.create;
  try
    ParseCapabilityStatementDocumentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementDocument);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.mode'), CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.documentation'));{q1}
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementDocument'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.document', 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement.document', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  ComposeReference{TFhirStructureDefinition}(this, 'CapabilityStatement.document', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatement.create;
  try
    ParseCapabilityStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementProperties(obj : TTurtleComplex; result : TFhirCapabilityStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.copyright'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.kind'), CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.instantiates') do
      result.instantiatesList.Add(parseUri(item));
    result.software := ParseCapabilityStatementSoftware(obj.complex('http://hl7.org/fhir/CapabilityStatement.software'));{q3b}
    result.implementation_ := ParseCapabilityStatementImplementation(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation'));{q3b}
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/CapabilityStatement.fhirVersion'));{q1}
    result.acceptUnknownElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.acceptUnknown'), CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.format') do
      result.formatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.patchFormat') do
      result.patchFormatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.implementationGuide') do
      result.implementationGuideList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.profile') do
      result.profileList.Add(parseReference{TFhirStructureDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest') do
      result.restList.Add(parseCapabilityStatementRest(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging') do
      result.messagingList.Add(parseCapabilityStatementMessaging(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.document') do
      result.documentList.Add(parseCapabilityStatementDocument(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'CapabilityStatement', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'CapabilityStatement', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CapabilityStatement', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CapabilityStatement', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CapabilityStatement', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'CapabilityStatement', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CapabilityStatement', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CapabilityStatement', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CapabilityStatement', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CapabilityStatement', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CapabilityStatement', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'CapabilityStatement', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement', 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') then
    for i := 0 to elem.instantiatesList.Count - 1 do
      ComposeUri(this, 'CapabilityStatement', 'instantiates', elem.instantiatesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeCapabilityStatementSoftware(this, 'CapabilityStatement', 'software', elem.softwareElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeCapabilityStatementImplementation(this, 'CapabilityStatement', 'implementation', elem.implementation_Element, false, -1);{x.2f}
  ComposeId(this, 'CapabilityStatement', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement', 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, false, -1);{x.d4}
  for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'format', elem.formatList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patchFormat') then
    for i := 0 to elem.patchFormatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'patchFormat', elem.patchFormatList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementationGuide') then
    for i := 0 to elem.implementationGuideList.Count - 1 do
      ComposeUri(this, 'CapabilityStatement', 'implementationGuide', elem.implementationGuideList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(this, 'CapabilityStatement', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') then
    for i := 0 to elem.restList.Count - 1 do
      ComposeCapabilityStatementRest(this, 'CapabilityStatement', 'rest', elem.restList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('messaging') then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(this, 'CapabilityStatement', 'messaging', elem.messagingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('document') then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(this, 'CapabilityStatement', 'document', elem.documentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
function TFHIRTurtleParser.ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.outcomeCodeableConcept') do
      result.outcomeCodeableConceptList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.outcomeReference') do
      result.outcomeReferenceList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.progress') do
      result.progressList.Add(parseAnnotation(item));
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.activity.reference'));{q3b}
    result.detail := ParseCarePlanActivityDetail(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan.activity', 'outcomeCodeableConcept', elem.outcomeCodeableConceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan.activity', 'outcomeReference', elem.outcomeReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan.activity', 'progress', elem.progressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlan.activity', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(this, 'CarePlan.activity', 'detail', elem.detailElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseCarePlanActivityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.category'));{q3b}
    result.definition := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.definition'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.status'), CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    result.statusReasonElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.statusReason'));{q1}
    result.prohibitedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.prohibited'));{q1}
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledTiming', item) then
      result.scheduled := parseTiming(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledPeriod', item) then
      result.scheduled := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledString', item) then
      result.scheduled := parseString(item);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.performer') do
      result.performerList.Add(parseReference{Resource}(item));
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productReference', item) {a3} then
      result.product := ParseReference(item);
    result.dailyAmount := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.dailyAmount'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.quantity'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivityDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'CarePlan.activity.detail', 'definition', elem.definitionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan.activity.detail', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan.activity.detail', 'goal', elem.goalList[i], false, i);{x.d3}
  ComposeEnum(this, 'CarePlan.activity.detail', 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlan.activity.detail', 'statusReason', elem.statusReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.prohibited <> false)) then
    ComposeBoolean(this, 'CarePlan.activity.detail', 'prohibited', elem.prohibitedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'CarePlan.activity.detail', 'scheduledTiming', TFhirTiming(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CarePlan.activity.detail', 'scheduledPeriod', TFhirPeriod(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(this, 'CarePlan.activity.detail', 'scheduledString', TFhirString(elem.scheduled), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'CarePlan.activity.detail', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan.activity.detail', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'CarePlan.activity.detail', 'productReference', TFhirReference(elem.product), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'dailyAmount', elem.dailyAmountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlan.activity.detail', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.replaces') do
      result.replacesList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.partOf') do
      result.partOfList.Add(parseReference{TFhirCarePlan}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.status'), CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.intent'), CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.description'));{q1}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CarePlan.context'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CarePlan.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.author') do
      result.authorList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.careTeam') do
      result.careTeamList.Add(parseReference{TFhirCareTeam}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.addresses') do
      result.addressesList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity') do
      result.activityList.Add(parseCarePlanActivity(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlan'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CarePlan', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'CarePlan', 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'CarePlan', 'intent', elem.IntentElement, CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CarePlan', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'CarePlan', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeReference{Resource}(this, 'CarePlan', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'CarePlan', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'CarePlan', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'CarePlan', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(this, 'CarePlan', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(this, 'CarePlan', 'activity', elem.activityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
function TFHIRTurtleParser.ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeamParticipant.create;
  try
    ParseCareTeamParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamParticipantProperties(obj : TTurtleComplex; result : TFhirCareTeamParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CareTeam.participant.role'));{q3b}
    result.member := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CareTeam.participant.member'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CareTeam.participant.onBehalfOf'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CareTeam.participant.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeamParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeamParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'CareTeam.participant', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'CareTeam.participant', 'member', elem.memberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'CareTeam.participant', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'CareTeam.participant', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeam.create;
  try
    ParseCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamProperties(obj : TTurtleComplex; result : TFhirCareTeam);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CareTeam.status'), CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CareTeam.name'));{q1}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CareTeam.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CareTeam.context'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CareTeam.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.participant') do
      result.participantList.Add(parseCareTeamParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.managingOrganization') do
      result.managingOrganizationList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeam'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CareTeam', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'CareTeam', 'status', elem.StatusElement, CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CareTeam', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'CareTeam', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'CareTeam', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'CareTeam', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCareTeamParticipant(this, 'CareTeam', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CareTeam', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    for i := 0 to elem.managingOrganizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'CareTeam', 'managingOrganization', elem.managingOrganizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CareTeam', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
function TFHIRTurtleParser.ParseChargeItemParticipant(obj : TTurtleComplex) : TFhirChargeItemParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemParticipant.create;
  try
    ParseChargeItemParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemParticipantProperties(obj : TTurtleComplex; result : TFhirChargeItemParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.participant.role'));{q3b}
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ChargeItem.participant.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeChargeItemParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ChargeItem.participant', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'ChargeItem.participant', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItem.create;
  try
    ParseChargeItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemProperties(obj : TTurtleComplex; result : TFhirChargeItem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ChargeItem.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.definition') do
      result.definitionList.Add(parseUri(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItem.status'), CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.partOf') do
      result.partOfList.Add(parseReference{TFhirChargeItem}(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ChargeItem.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ChargeItem.context'));{q3b}
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.participant') do
      result.participantList.Add(parseChargeItemParticipant(item));
    result.performingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ChargeItem.performingOrganization'));{q3b}
    result.requestingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ChargeItem.requestingOrganization'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ChargeItem.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.bodysite') do
      result.bodysiteList.Add(parseCodeableConcept(item));
    result.factorOverrideElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ChargeItem.factorOverride'));{q1}
    result.priceOverride := ParseMoney(obj.complex('http://hl7.org/fhir/ChargeItem.priceOverride'));{q3b}
    result.overrideReasonElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItem.overrideReason'));{q1}
    result.enterer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ChargeItem.enterer'));{q3b}
    result.enteredDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ChargeItem.enteredDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.service') do
      result.serviceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ChargeItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeUri(this, 'ChargeItem', 'definition', elem.definitionList[i], false, i);{x.d3}
  ComposeEnum(this, 'ChargeItem', 'status', elem.StatusElement, CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirChargeItem}(this, 'ChargeItem', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ChargeItem', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'ChargeItem', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'ChargeItem', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ChargeItem', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ChargeItem', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ChargeItem', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeChargeItemParticipant(this, 'ChargeItem', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('performingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ChargeItem', 'performingOrganization', elem.performingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ChargeItem', 'requestingOrganization', elem.requestingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'ChargeItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodysite') then
    for i := 0 to elem.bodysiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'bodysite', elem.bodysiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('factorOverride') then
    ComposeDecimal(this, 'ChargeItem', 'factorOverride', elem.factorOverrideElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('priceOverride') then
    ComposeMoney(this, 'ChargeItem', 'priceOverride', elem.priceOverrideElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('overrideReason') then
    ComposeString(this, 'ChargeItem', 'overrideReason', elem.overrideReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{Resource}(this, 'ChargeItem', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enteredDate') then
    ComposeDateTime(this, 'ChargeItem', 'enteredDate', elem.enteredDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('service') then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeReference{Resource}(this, 'ChargeItem', 'service', elem.serviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'ChargeItem', 'account', elem.accountList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ChargeItem', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ChargeItem', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
function TFHIRTurtleParser.ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimRelated.create;
  try
    ParseClaimRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimRelatedProperties(obj : TTurtleComplex; result : TFhirClaimRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/Claim.related.claim'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.related.relationship'));{q3b}
    result.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/Claim.related.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(this, 'Claim.related', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.related', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Claim.related', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.payee.type'));{q3b}
    result.resourceType := ParseCoding(obj.complex('http://hl7.org/fhir/Claim.payee.resourceType'));{q3b}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Claim.payee.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimPayee'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Claim.payee', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Claim.payee', 'resourceType', elem.resourceTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'Claim.payee', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimCareTeam.create;
  try
    ParseClaimCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimCareTeamProperties(obj : TTurtleComplex; result : TFhirClaimCareTeam);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.careTeam.sequence'));{q1}
    result.provider := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Claim.careTeam.provider'));{q3b}
    result.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.careTeam.responsible'));{q1}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.role'));{q3b}
    result.qualification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.qualification'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimCareTeam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.careTeam', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeReference{Resource}(this, 'Claim.careTeam', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Claim.careTeam', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'qualification', elem.qualificationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimInformation(obj : TTurtleComplex) : TFhirClaimInformation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimInformation.create;
  try
    ParseClaimInformationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimInformationProperties(obj : TTurtleComplex; result : TFhirClaimInformation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.information.sequence'));{q1}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.information.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.information.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Claim.information.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Claim.information.timingDate', item) then
      result.timing := parseDate(item);
    if obj.has('http://hl7.org/fhir/Claim.information.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Claim.information.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Claim.information.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Claim.information.valueString', item) then
      result.value := parseString(item);
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.information.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInformation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimInformation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.information', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Claim.information', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.information', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.information', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(this, 'Claim.information', 'timingDate', TFhirDate(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Claim.information', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Claim.information', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'Claim.information', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Claim.information', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.information', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.diagnosis.sequence'));{q1}
    if obj.has('http://hl7.org/fhir/Claim.diagnosis.diagnosisCodeableConcept', item) then
      result.diagnosis := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.diagnosis.diagnosisReference', item) {a3} then
      result.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.packageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.diagnosis.packageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.diagnosis', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis), false, -1){x.d9}
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'Claim.diagnosis', 'diagnosisReference', TFhirReference(elem.diagnosis), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.diagnosis', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'packageCode', elem.packageCodeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimProcedure.create;
  try
    ParseClaimProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProcedureProperties(obj : TTurtleComplex; result : TFhirClaimProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.procedure.sequence'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.procedure.date'));{q1}
    if obj.has('http://hl7.org/fhir/Claim.procedure.procedureCodeableConcept', item) then
      result.procedure_ := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.procedure.procedureReference', item) {a3} then
      result.procedure_ := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimProcedure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.procedure', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Claim.procedure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_), false, -1){x.d9}
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'Claim.procedure', 'procedureReference', TFhirReference(elem.procedure_), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimInsurance.create;
  try
    ParseClaimInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.insurance.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.insurance.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/Claim.insurance.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/Claim.insurance.businessArrangement'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/Claim.insurance.claimResponse'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.insurance', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'Claim.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'Claim.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Claim.insurance', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'Claim.insurance', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'Claim.insurance', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimAccident.create;
  try
    ParseClaimAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimAccidentProperties(obj : TTurtleComplex; result : TFhirClaimAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.accident.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.accident.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Claim.accident.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Claim.accident.locationReference', item) {a3} then
      result.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimAccident'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDate(this, 'Claim.accident', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.accident', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.accident', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.accident', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.careTeamLinkId') do
      result.careTeamLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.diagnosisLinkId') do
      result.diagnosisLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.procedureLinkId') do
      result.procedureLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.informationLinkId') do
      result.informationLinkIdList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/Claim.item.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Claim.item.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.encounter') do
      result.encounterList.Add(parseReference{TFhirEncounter}(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail') do
      result.detailList.Add(parseClaimItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'careTeamLinkId', elem.careTeamLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'diagnosisLinkId', elem.diagnosisLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'procedureLinkId', elem.procedureLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'informationLinkId', elem.informationLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.item', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'Claim.item', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.item', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.item', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.item', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(this, 'Claim.item', 'encounter', elem.encounterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(this, 'Claim.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item.detail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(this, 'Claim.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail.subDetail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item.detail.subDetail', 'udi', elem.udiList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaim(obj : TTurtleComplex) : TFhirClaim;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaim.create;
  try
    ParseClaimProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Claim.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.subType') do
      result.subTypeList.Add(parseCodeableConcept(item));
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.use'), CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Claim.patient'));{q3b}
    result.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Claim.billablePeriod'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.enterer'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.organization'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.priority'));{q3b}
    result.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.fundsReserve'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.related') do
      result.relatedList.Add(parseClaimRelated(item));
    result.prescription := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Claim.prescription'));{q3b}
    result.originalPrescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/Claim.originalPrescription'));{q3b}
    result.payee := ParseClaimPayee(obj.complex('http://hl7.org/fhir/Claim.payee'));{q3b}
    result.referral := ParseReference{TFhirReferralRequest}(obj.complex('http://hl7.org/fhir/Claim.referral'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Claim.facility'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.careTeam') do
      result.careTeamList.Add(parseClaimCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.information') do
      result.informationList.Add(parseClaimInformation(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis') do
      result.diagnosisList.Add(parseClaimDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure') do
      result.procedure_List.Add(parseClaimProcedure(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance') do
      result.insuranceList.Add(parseClaimInsurance(item));
    result.accident := ParseClaimAccident(obj.complex('http://hl7.org/fhir/Claim.accident'));{q3b}
    result.employmentImpacted := ParsePeriod(obj.complex('http://hl7.org/fhir/Claim.employmentImpacted'));{q3b}
    result.hospitalization := ParsePeriod(obj.complex('http://hl7.org/fhir/Claim.hospitalization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item') do
      result.itemList.Add(parseClaimItem(item));
    result.total := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.total'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Claim'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Claim', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Claim', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Claim', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim', 'subType', elem.subTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('use') then
    ComposeEnum(this, 'Claim', 'use', elem.UseElement, CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Claim', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('billablePeriod') then
    ComposePeriod(this, 'Claim', 'billablePeriod', elem.billablePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'Claim', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Claim', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(this, 'Claim', 'fundsReserve', elem.fundsReserveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeClaimRelated(this, 'Claim', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(this, 'Claim', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'Claim', 'originalPrescription', elem.originalPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeClaimPayee(this, 'Claim', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(this, 'Claim', 'referral', elem.referralElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'Claim', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeClaimCareTeam(this, 'Claim', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('information') then
    for i := 0 to elem.informationList.Count - 1 do
      ComposeClaimInformation(this, 'Claim', 'information', elem.informationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(this, 'Claim', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeClaimProcedure(this, 'Claim', 'procedure', elem.procedure_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimInsurance(this, 'Claim', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeClaimAccident(this, 'Claim', 'accident', elem.accidentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('employmentImpacted') then
    ComposePeriod(this, 'Claim', 'employmentImpacted', elem.employmentImpactedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposePeriod(this, 'Claim', 'hospitalization', elem.hospitalizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(this, 'Claim', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(this, 'Claim', 'total', elem.totalElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRTurtleParser.ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail') do
      result.detailList.Add(parseClaimResponseItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(this, 'ClaimResponse.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.category'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.reason'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.item.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimResponseItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(this, 'ClaimResponse.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.sequenceLinkId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.sequenceLinkId') do
      result.sequenceLinkIdList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.fee := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail') do
      result.detailList.Add(parseClaimResponseAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'sequenceLinkId', elem.sequenceLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(this, 'ClaimResponse.addItem', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.fee := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.sequenceLinkId'));{q1}
    result.detailSequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.detailSequenceLinkId'));{q1}
    result.subdetailSequenceLinkIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.subdetailSequenceLinkId'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.error.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseError'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ClaimResponse.error', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponsePayment.create;
  try
    ParseClaimResponsePaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponsePaymentProperties(obj : TTurtleComplex; result : TFhirClaimResponsePayment);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.type'));{q3b}
    result.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustment'));{q3b}
    result.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustmentReason'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.date'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.amount'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.identifier'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponsePayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponsePayment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.payment', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.payment', 'adjustment', elem.adjustmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.payment', 'adjustmentReason', elem.adjustmentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ClaimResponse.payment', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.payment', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ClaimResponse.payment', 'identifier', elem.identifierElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseProcessNote.create;
  try
    ParseClaimResponseProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.number'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.text'));{q1}
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.language'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.processNote', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.processNote', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse.processNote', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.processNote', 'language', elem.languageElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseInsurance.create;
  try
    ParseClaimResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimResponseInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.businessArrangement'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.insurance.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.claimResponse'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.insurance', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'ClaimResponse.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'ClaimResponse.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse.insurance', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ClaimResponse.insurance', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'ClaimResponse.insurance', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ClaimResponse.patient'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClaimResponse.created'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurer'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClaimResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ClaimResponse.requestOrganization'));{q3b}
    result.request := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ClaimResponse.request'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.disposition'));{q1}
    result.payeeType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payeeType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item') do
      result.itemList.Add(parseClaimResponseItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem') do
      result.addItemList.Add(parseClaimResponseAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.error') do
      result.errorList.Add(parseClaimResponseError(item));
    result.totalCost := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.totalCost'));{q3b}
    result.unallocDeductable := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.unallocDeductable'));{q3b}
    result.totalBenefit := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.totalBenefit'));{q3b}
    result.payment := ParseClaimResponsePayment(obj.complex('http://hl7.org/fhir/ClaimResponse.payment'));{q3b}
    result.reserved := ParseCoding(obj.complex('http://hl7.org/fhir/ClaimResponse.reserved'));{q3b}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.processNote') do
      result.processNoteList.Add(parseClaimResponseProcessNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.communicationRequest') do
      result.communicationRequestList.Add(parseReference{TFhirCommunicationRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.insurance') do
      result.insuranceList.Add(parseClaimResponseInsurance(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClaimResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'ClaimResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'ClaimResponse', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ClaimResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'ClaimResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(this, 'ClaimResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'ClaimResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('payeeType') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'payeeType', elem.payeeTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(this, 'ClaimResponse', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(this, 'ClaimResponse', 'addItem', elem.addItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(this, 'ClaimResponse', 'error', elem.errorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('totalCost') then
    ComposeMoney(this, 'ClaimResponse', 'totalCost', elem.totalCostElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('unallocDeductable') then
    ComposeMoney(this, 'ClaimResponse', 'unallocDeductable', elem.unallocDeductableElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('totalBenefit') then
    ComposeMoney(this, 'ClaimResponse', 'totalBenefit', elem.totalBenefitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeClaimResponsePayment(this, 'ClaimResponse', 'payment', elem.paymentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reserved') then
    ComposeCoding(this, 'ClaimResponse', 'reserved', elem.reservedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(this, 'ClaimResponse', 'processNote', elem.processNoteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') then
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(this, 'ClaimResponse', 'communicationRequest', elem.communicationRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(this, 'ClaimResponse', 'insurance', elem.insuranceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRTurtleParser.ParseClinicalImpressionInvestigation(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionInvestigation.create;
  try
    ParseClinicalImpressionInvestigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionInvestigationProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.investigation.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigation.item') do
      result.itemList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionInvestigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionInvestigation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClinicalImpression.investigation', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression.investigation', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/ClinicalImpression.finding.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ClinicalImpression.finding.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.basisElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.basis'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionFinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClinicalImpression.finding', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'ClinicalImpression.finding', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression.finding', 'basis', elem.basisElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClinicalImpression.status'), CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.description'));{q1}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ClinicalImpression.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ClinicalImpression.context'));{q3b}
    if obj.has('http://hl7.org/fhir/ClinicalImpression.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ClinicalImpression.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClinicalImpression.date'));{q1}
    result.assessor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClinicalImpression.assessor'));{q3b}
    result.previous := ParseReference{TFhirClinicalImpression}(obj.complex('http://hl7.org/fhir/ClinicalImpression.previous'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.problem') do
      result.problemList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigation') do
      result.investigationList.Add(parseClinicalImpressionInvestigation(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.protocol') do
      result.protocolList.Add(parseUri(item));
    result.summaryElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.summary'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.finding') do
      result.findingList.Add(parseClinicalImpressionFinding(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisCodeableConcept') do
      result.prognosisCodeableConceptList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisReference') do
      result.prognosisReferenceList.Add(parseReference{TFhirRiskAssessment}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.action') do
      result.actionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpression'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClinicalImpression', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ClinicalImpression', 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ClinicalImpression', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeReference{Resource}(this, 'ClinicalImpression', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'ClinicalImpression', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'ClinicalImpression', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ClinicalImpression', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ClinicalImpression', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(this, 'ClinicalImpression', 'assessor', elem.assessorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(this, 'ClinicalImpression', 'previous', elem.previousElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'problem', elem.problemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('investigation') then
    for i := 0 to elem.investigationList.Count - 1 do
      ComposeClinicalImpressionInvestigation(this, 'ClinicalImpression', 'investigation', elem.investigationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeUri(this, 'ClinicalImpression', 'protocol', elem.protocolList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeString(this, 'ClinicalImpression', 'summary', elem.summaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('finding') then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(this, 'ClinicalImpression', 'finding', elem.findingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisCodeableConcept') then
    for i := 0 to elem.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalImpression', 'prognosisCodeableConcept', elem.prognosisCodeableConceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisReference') then
    for i := 0 to elem.prognosisReferenceList.Count - 1 do
      ComposeReference{TFhirRiskAssessment}(this, 'ClinicalImpression', 'prognosisReference', elem.prognosisReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(this, 'ClinicalImpression', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ClinicalImpression', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
function TFHIRTurtleParser.ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemFilter.create;
  try
    ParseCodeSystemFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemFilterProperties(obj : TTurtleComplex; result : TFhirCodeSystemFilter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.filter.code'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter.operator') do
      result.operatorList.Add(parseEnum(item, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum));
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.filter', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.filter', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i); {x.d1}
  for i := 0 to elem.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i);{x.d2}
  ComposeString(this, 'CodeSystem.filter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemProperty.create;
  try
    ParseCodeSystemPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemProperty);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.property.code'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.property.uri'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.property.description'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.property.type'), CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.property', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CodeSystem.property', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.property', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem.property', 'type', elem.Type_Element, CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConcept.create;
  try
    ParseCodeSystemConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirCodeSystemConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.display'));{q1}
    result.definitionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.definition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.designation') do
      result.designationList.Add(parseCodeSystemConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.property') do
      result.property_List.Add(parseCodeSystemConceptProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.concept') do
      result.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(this, 'CodeSystem.concept', 'designation', elem.designationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(this, 'CodeSystem.concept', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem.concept', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptDesignation.create;
  try
    ParseCodeSystemConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.use'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'CodeSystem.concept.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'CodeSystem.concept.designation', 'use', elem.useElement, false, -1);{x.2f}
  ComposeString(this, 'CodeSystem.concept.designation', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptProperty.create;
  try
    ParseCodeSystemConceptPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.property.code'));{q1}
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueDateTime', item) then
      result.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.concept.property', 'code', elem.codeElement, false, -1);{x.2ea}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'CodeSystem.concept.property', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'CodeSystem.concept.property', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'CodeSystem.concept.property', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'CodeSystem.concept.property', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'CodeSystem.concept.property', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CodeSystem.concept.property', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystem.create;
  try
    ParseCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemProperties(obj : TTurtleComplex; result : TFhirCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/CodeSystem.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CodeSystem.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.copyright'));{q1}
    result.caseSensitiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.caseSensitive'));{q1}
    result.valueSetElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.valueSet'));{q1}
    result.hierarchyMeaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.hierarchyMeaning'), CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum);
    result.compositionalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.compositional'));{q1}
    result.versionNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.versionNeeded'));{q1}
    result.contentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.content'), CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum);
    result.countElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CodeSystem.count'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter') do
      result.filterList.Add(parseCodeSystemFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.property') do
      result.property_List.Add(parseCodeSystemProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept') do
      result.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'CodeSystem', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'CodeSystem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'CodeSystem', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CodeSystem', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CodeSystem', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CodeSystem', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'CodeSystem', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CodeSystem', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CodeSystem', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CodeSystem', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CodeSystem', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CodeSystem', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'CodeSystem', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('caseSensitive') then
    ComposeBoolean(this, 'CodeSystem', 'caseSensitive', elem.caseSensitiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('valueSet') then
    ComposeUri(this, 'CodeSystem', 'valueSet', elem.valueSetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hierarchyMeaning') then
    ComposeEnum(this, 'CodeSystem', 'hierarchyMeaning', elem.HierarchyMeaningElement, CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositional') then
    ComposeBoolean(this, 'CodeSystem', 'compositional', elem.compositionalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('versionNeeded') then
    ComposeBoolean(this, 'CodeSystem', 'versionNeeded', elem.versionNeededElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem', 'content', elem.ContentElement, CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('count') then
    ComposeUnsignedInt(this, 'CodeSystem', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('filter') then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeCodeSystemFilter(this, 'CodeSystem', 'filter', elem.filterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemProperty(this, 'CodeSystem', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('concept') then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRTurtleParser.ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Communication.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Communication.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'Communication.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunication(obj : TTurtleComplex) : TFhirCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Communication.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.partOf') do
      result.partOfList.Add(parseReference{TFhirReference}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    result.notDoneElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Communication.notDone'));{q1}
    result.notDoneReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.notDoneReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Communication.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.topic') do
      result.topicList.Add(parseReference{TFhirReference}(item));
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Communication.context'));{q3b}
    result.sentElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.sent'));{q1}
    result.receivedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.received'));{q1}
    result.sender := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Communication.sender'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.payload') do
      result.payloadList.Add(parseCommunicationPayload(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Communication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Communication', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'Communication', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Communication', 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDone') then
    ComposeBoolean(this, 'Communication', 'notDone', elem.notDoneElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(this, 'Communication', 'notDoneReason', elem.notDoneReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Communication', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'Communication', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Communication', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('sent') then
    ComposeDateTime(this, 'Communication', 'sent', elem.sentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('received') then
    ComposeDateTime(this, 'Communication', 'received', elem.receivedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{Resource}(this, 'Communication', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'Communication', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(this, 'Communication', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Communication', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRTurtleParser.ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequestPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationRequest.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationRequest.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'CommunicationRequest.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunicationRequestRequester(obj : TTurtleComplex) : TFhirCommunicationRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequestRequester.create;
  try
    ParseCommunicationRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestRequesterProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'CommunicationRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'CommunicationRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.replaces') do
      result.replacesList.Add(parseReference{TFhirCommunicationRequest}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/CommunicationRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.topic') do
      result.topicList.Add(parseReference{TFhirReference}(item));
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.payload') do
      result.payloadList.Add(parseCommunicationRequestPayload(item));
    if obj.has('http://hl7.org/fhir/CommunicationRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CommunicationRequest.authoredOn'));{q1}
    result.sender := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/CommunicationRequest.sender'));{q3b}
    result.requester := ParseCommunicationRequestRequester(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CommunicationRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CommunicationRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(this, 'CommunicationRequest', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'CommunicationRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'CommunicationRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'CommunicationRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'CommunicationRequest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CommunicationRequest', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(this, 'CommunicationRequest', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'CommunicationRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CommunicationRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'CommunicationRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{Resource}(this, 'CommunicationRequest', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeCommunicationRequestRequester(this, 'CommunicationRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'CommunicationRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CommunicationRequest', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
function TFHIRTurtleParser.ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinitionResource.create;
  try
    ParseCompartmentDefinitionResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinitionResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource.param') do
      result.paramList.Add(parseString(item));
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinitionResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CompartmentDefinition.resource', 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeString(this, 'CompartmentDefinition.resource', 'param', elem.paramList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CompartmentDefinition.resource', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinition.create;
  try
    ParseCompartmentDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CompartmentDefinition.url'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CompartmentDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.purpose'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    result.searchElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.search'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource') do
      result.resourceList.Add(parseCompartmentDefinitionResource(item));
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'CompartmentDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  ComposeString(this, 'CompartmentDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CompartmentDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CompartmentDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CompartmentDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'CompartmentDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CompartmentDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CompartmentDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CompartmentDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CompartmentDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CompartmentDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CompartmentDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  ComposeEnum(this, 'CompartmentDefinition', 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'CompartmentDefinition', 'search', elem.searchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(this, 'CompartmentDefinition', 'resource', elem.resourceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
function TFHIRTurtleParser.ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester.mode') do
      result.modeList.Add(parseEnum(item, CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum));
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.attester.time'));{q1}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Composition.attester.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionAttester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'Composition.attester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, false, i); {x.d1}
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(this, 'Composition.attester', 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Composition.attester', 'time', elem.timeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Composition.attester', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCompositionRelatesTo(obj : TTurtleComplex) : TFhirCompositionRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionRelatesTo.create;
  try
    ParseCompositionRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionRelatesToProperties(obj : TTurtleComplex; result : TFhirCompositionRelatesTo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.relatesTo.code'), CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/Composition.relatesTo.targetIdentifier', item) then
      result.target := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Composition.relatesTo.targetReference', item) {a3} then
      result.target := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeCompositionRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionRelatesTo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Composition.relatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, false, -1);{x.d4}
  if (elem.target is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Composition.relatesTo', 'targetIdentifier', TFhirIdentifier(elem.target), false, -1){x.d9}
  else if (elem.target is TFhirReference) {2} then
    ComposeReference(this, 'Composition.relatesTo', 'targetReference', TFhirReference(elem.target), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.code') do
      result.codeList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Composition.event.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition.event', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Composition.event', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.event', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.section.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.code'));{q3b}
    result.text := ParseNarrative(obj.complex('http://hl7.org/fhir/Composition.section.text'));{q3b}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.section.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.orderedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.entry') do
      result.entryList.Add(parseReference{TFhirReference}(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.emptyReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionSection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Composition.section', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'Composition.section', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Composition.section', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.section', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition.section', 'section', elem.sectionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseComposition(obj : TTurtleComplex) : TFhirComposition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Composition.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.status'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.type'));{q3b}
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.class'));{q3b}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Composition.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Composition.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Composition.author') do
      result.authorList.Add(parseReference{Resource}(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.title'));{q1}
    result.confidentialityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.confidentiality'), CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum);
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester') do
      result.attesterList.Add(parseCompositionAttester(item));
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Composition.custodian'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.relatesTo') do
      result.relatesToList.Add(parseCompositionRelatesTo(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.event') do
      result.eventList.Add(parseCompositionEvent(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Composition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Composition', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'Composition', 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'Composition', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(this, 'Composition', 'class', elem.class_Element, false, -1);{x.2f}
  ComposeReference{TFhirReference}(this, 'Composition', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Composition', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'Composition', 'date', elem.dateElement, false, -1);{x.2ea}
  for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'Composition', 'author', elem.authorList[i], false, i);{x.d3}
  ComposeString(this, 'Composition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnum(this, 'Composition', 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attester') then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(this, 'Composition', 'attester', elem.attesterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'Composition', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeCompositionRelatesTo(this, 'Composition', 'relatesTo', elem.relatesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(this, 'Composition', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('section') then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition', 'section', elem.sectionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRTurtleParser.ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroup.create;
  try
    ParseConceptMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupProperties(obj : TTurtleComplex; result : TFhirConceptMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.source'));{q1}
    result.sourceVersionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.sourceVersion'));{q1}
    result.targetElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.target'));{q1}
    result.targetVersionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.targetVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element') do
      result.elementList.Add(parseConceptMapGroupElement(item));
    result.unmapped := ParseConceptMapGroupUnmapped(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group', 'sourceVersion', elem.sourceVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group', 'target', elem.targetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group', 'targetVersion', elem.targetVersionElement, false, -1);{x.2ea}
  for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapGroupElement(this, 'ConceptMap.group', 'element', elem.elementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(this, 'ConceptMap.group', 'unmapped', elem.unmappedElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElement.create;
  try
    ParseConceptMapGroupElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target') do
      result.targetList.Add(parseConceptMapGroupElementTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(this, 'ConceptMap.group.element', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTarget.create;
  try
    ParseConceptMapGroupElementTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.display'));{q1}
    result.equivalenceElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.equivalence'), CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn') do
      result.dependsOnList.Add(parseConceptMapGroupElementTargetDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.product') do
      result.productList.Add(parseConceptMapGroupElementTargetDependsOn(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element.target', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.equivalenceElement <> nil) and (elem.equivalenceElement.primitiveValue <> 'equivalent')) then
    ComposeEnum(this, 'ConceptMap.group.element.target', 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'dependsOn', elem.dependsOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'product', elem.productList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    ParseConceptMapGroupElementTargetDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTargetDependsOn);
begin
    ParseBackboneElementProperties(obj, result);
    result.property_Element := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.property'));{q1}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.system'));{q1}
    result.codeElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTargetDependsOn'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ConceptMap.group.element.target.dependsOn', 'property', elem.property_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group.element.target.dependsOn', 'system', elem.systemElement, false, -1);{x.2ea}
  ComposeString(this, 'ConceptMap.group.element.target.dependsOn', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target.dependsOn', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupUnmapped.create;
  try
    ParseConceptMapGroupUnmappedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupUnmapped);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.mode'), CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.display'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupUnmapped'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ConceptMap.group.unmapped', 'mode', elem.ModeElement, CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.unmapped', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.unmapped', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group.unmapped', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ConceptMap.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConceptMap.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ConceptMap.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.copyright'));{q1}
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceUri', item) then
      result.source := parseUri(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetReference', item) {a3} then
      result.target := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetUri', item) then
      result.target := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group') do
      result.groupList.Add(parseConceptMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMap'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ConceptMap', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ConceptMap', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ConceptMap', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ConceptMap', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ConceptMap', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ConceptMap', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ConceptMap', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ConceptMap', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ConceptMap', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ConceptMap', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ConceptMap', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ConceptMap', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ConceptMap', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'sourceReference', TFhirReference(elem.source), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'sourceUri', TFhirUri(elem.source), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirReference) {2} then
    ComposeReference(this, 'ConceptMap', 'targetReference', TFhirReference(elem.target), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'targetUri', TFhirUri(elem.target), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeConceptMapGroup(this, 'ConceptMap', 'group', elem.groupList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRTurtleParser.ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.summary := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.summary'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage.assessment') do
      result.assessmentList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionStage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'summary', elem.summaryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(this, 'Condition.stage', 'assessment', elem.assessmentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionEvidence.create;
  try
    ParseConditionEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionEvidence'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition.evidence', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Condition.evidence', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCondition(obj : TTurtleComplex) : TFhirCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCondition.create;
  try
    ParseConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Condition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.clinicalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Condition.clinicalStatus'), CODES_TFhirConditionClinicalEnum, SYSTEMS_TFhirConditionClinicalEnum);
    result.verificationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Condition.verificationStatus'), CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Condition.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.severity'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Condition.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Condition.context'));{q3b}
    if obj.has('http://hl7.org/fhir/Condition.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetDateTime', item) then
      result.onset := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetString', item) then
      result.onset := parseString(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementAge', item) then
      result.abatement := parseAge(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementPeriod', item) then
      result.abatement := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementRange', item) then
      result.abatement := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementDateTime', item) then
      result.abatement := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementBoolean', item) then
      result.abatement := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementString', item) then
      result.abatement := parseString(item);
    result.assertedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Condition.assertedDate'));{q1}
    result.asserter := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Condition.asserter'));{q3b}
    result.stage := ParseConditionStage(obj.complex('http://hl7.org/fhir/Condition.stage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence') do
      result.evidenceList.Add(parseConditionEvidence(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Condition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Condition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeEnum(this, 'Condition', 'clinicalStatus', elem.ClinicalStatusElement, CODES_TFhirConditionClinicalEnum, SYSTEMS_TFhirConditionClinicalEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.verificationStatusElement <> nil) and (elem.verificationStatusElement.primitiveValue <> 'unknown')) and doCompose('verificationStatus') then
    ComposeEnum(this, 'Condition', 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('severity') then
    ComposeCodeableConcept(this, 'Condition', 'severity', elem.severityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'Condition', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Condition', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'onsetDateTime', TFhirDateTime(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'Condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'abatementAge', TFhirAge(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'abatementPeriod', TFhirPeriod(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'abatementRange', TFhirRange(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'abatementDateTime', TFhirDateTime(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Condition', 'abatementBoolean', TFhirBoolean(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(this, 'Condition', 'abatementString', TFhirString(elem.abatement), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assertedDate') then
    ComposeDateTime(this, 'Condition', 'assertedDate', elem.assertedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(this, 'Condition', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('stage') then
    ComposeConditionStage(this, 'Condition', 'stage', elem.stageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(this, 'Condition', 'evidence', elem.evidenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Condition', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
function TFHIRTurtleParser.ParseConsentActor(obj : TTurtleComplex) : TFhirConsentActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentActor.create;
  try
    ParseConsentActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentActorProperties(obj : TTurtleComplex; result : TFhirConsentActor);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.actor.role'));{q3b}
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Consent.actor.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Consent.actor', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Consent.actor', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsentPolicy(obj : TTurtleComplex) : TFhirConsentPolicy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentPolicy.create;
  try
    ParseConsentPolicyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentPolicyProperties(obj : TTurtleComplex; result : TFhirConsentPolicy);
begin
    ParseBackboneElementProperties(obj, result);
    result.authorityElement := ParseUri(obj.complex('http://hl7.org/fhir/Consent.policy.authority'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/Consent.policy.uri'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConsentPolicy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentPolicy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentPolicy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Consent.policy', 'authority', elem.authorityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Consent.policy', 'uri', elem.uriElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConsentData(obj : TTurtleComplex) : TFhirConsentData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentData.create;
  try
    ParseConsentDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentDataProperties(obj : TTurtleComplex; result : TFhirConsentData);
begin
    ParseBackboneElementProperties(obj, result);
    result.meaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.data.meaning'), CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Consent.data.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentData'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Consent.data', 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Consent.data', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsentExcept(obj : TTurtleComplex) : TFhirConsentExcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentExcept.create;
  try
    ParseConsentExceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentExceptProperties(obj : TTurtleComplex; result : TFhirConsentExcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.except.type'), CODES_TFhirConsentExceptTypeEnum, SYSTEMS_TFhirConsentExceptTypeEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.except.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.actor') do
      result.actorList.Add(parseConsentExceptActor(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.purpose') do
      result.purposeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.class') do
      result.class_List.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.code') do
      result.codeList.Add(parseCoding(item));
    result.dataPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.except.dataPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.except.data') do
      result.dataList.Add(parseConsentExceptData(item));
end;

procedure TFHIRTurtleComposer.ComposeConsentExcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentExcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Consent.except', 'type', elem.Type_Element, CODES_TFhirConsentExceptTypeEnum, SYSTEMS_TFhirConsentExceptTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.except', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentExceptActor(this, 'Consent.except', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent.except', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Consent.except', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(this, 'Consent.except', 'purpose', elem.purposeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoding(this, 'Consent.except', 'class', elem.class_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'Consent.except', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.except', 'dataPeriod', elem.dataPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentExceptData(this, 'Consent.except', 'data', elem.dataList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConsentExceptActor(obj : TTurtleComplex) : TFhirConsentExceptActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentExceptActor.create;
  try
    ParseConsentExceptActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentExceptActorProperties(obj : TTurtleComplex; result : TFhirConsentExceptActor);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.except.actor.role'));{q3b}
    result.reference := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Consent.except.actor.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentExceptActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExceptActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentExceptActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Consent.except.actor', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Consent.except.actor', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsentExceptData(obj : TTurtleComplex) : TFhirConsentExceptData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentExceptData.create;
  try
    ParseConsentExceptDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentExceptDataProperties(obj : TTurtleComplex; result : TFhirConsentExceptData);
begin
    ParseBackboneElementProperties(obj, result);
    result.meaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.except.data.meaning'), CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Consent.except.data.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentExceptData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentExceptData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentExceptData'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Consent.except.data', 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Consent.except.data', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsent(obj : TTurtleComplex) : TFhirConsent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsent.create;
  try
    ParseConsentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProperties(obj : TTurtleComplex; result : TFhirConsent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Consent.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.status'), CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum);
    for item in obj.complexes('http://hl7.org/fhir/Consent.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Consent.patient'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.period'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Consent.dateTime'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Consent.consentingParty') do
      result.consentingPartyList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.actor') do
      result.actorList.Add(parseConsentActor(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.organization') do
      result.organizationList.Add(parseReference{TFhirOrganization}(item));
    if obj.has('http://hl7.org/fhir/Consent.sourceAttachment', item) then
      result.source := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Consent.sourceIdentifier', item) then
      result.source := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Consent.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Consent.policy') do
      result.policyList.Add(parseConsentPolicy(item));
    result.policyRuleElement := ParseUri(obj.complex('http://hl7.org/fhir/Consent.policyRule'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Consent.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.purpose') do
      result.purposeList.Add(parseCoding(item));
    result.dataPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.dataPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.data') do
      result.dataList.Add(parseConsentData(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.except') do
      result.except_List.Add(parseConsentExcept(item));
end;

procedure TFHIRTurtleComposer.ComposeConsent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Consent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Consent', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'Consent', 'status', elem.StatusElement, CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'Consent', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Consent', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateTime') then
    ComposeDateTime(this, 'Consent', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('consentingParty') then
    for i := 0 to elem.consentingPartyList.Count - 1 do
      ComposeReference{Resource}(this, 'Consent', 'consentingParty', elem.consentingPartyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentActor(this, 'Consent', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    for i := 0 to elem.organizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Consent', 'organization', elem.organizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Consent', 'sourceAttachment', TFhirAttachment(elem.source), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Consent', 'sourceIdentifier', TFhirIdentifier(elem.source), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'Consent', 'sourceReference', TFhirReference(elem.source), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeConsentPolicy(this, 'Consent', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyRule') then
    ComposeUri(this, 'Consent', 'policyRule', elem.policyRuleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Consent', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(this, 'Consent', 'purpose', elem.purposeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataPeriod') then
    ComposePeriod(this, 'Consent', 'dataPeriod', elem.dataPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('data') then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentData(this, 'Consent', 'data', elem.dataList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('except_') then
    for i := 0 to elem.except_List.Count - 1 do
      ComposeConsentExcept(this, 'Consent', 'except', elem.except_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
function TFHIRTurtleParser.ParseContractAgent(obj : TTurtleComplex) : TFhirContractAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractAgent.create;
  try
    ParseContractAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractAgentProperties(obj : TTurtleComplex; result : TFhirContractAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.agent.actor'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeContractAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Contract.agent', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.agent', 'role', elem.roleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.signer.type'));{q3b}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.signer.party'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer.signature') do
      result.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractSigner'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Contract.signer', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Contract.signer', 'party', elem.partyElement, false, -1);{x.2f}
  for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Contract.signer', 'signature', elem.signatureList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractValuedItem(obj : TTurtleComplex) : TFhirContractValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractValuedItem.create;
  try
    ParseContractValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractValuedItemProperties(obj : TTurtleComplex; result : TFhirContractValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.valuedItem.entityCodeableConcept', item) then
      result.entity := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.valuedItem.entityReference', item) {a3} then
      result.entity := ParseReference(item);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.valuedItem.identifier'));{q3b}
    result.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.valuedItem.effectiveTime'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.valuedItem.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.valuedItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.valuedItem.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.valuedItem.points'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.valuedItem.net'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractValuedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.valuedItem', 'entityReference', TFhirReference(elem.entity), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.valuedItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.valuedItem', 'effectiveTime', elem.effectiveTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.valuedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.valuedItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.valuedItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.valuedItem', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.valuedItem', 'net', elem.netElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.identifier'));{q3b}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.term.applies'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.subType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.topic') do
      result.topicList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.actionReason') do
      result.actionReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.agent') do
      result.agentList.Add(parseContractTermAgent(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.valuedItem') do
      result.valuedItemList.Add(parseContractTermValuedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.group') do
      result.groupList.Add(parseContractTerm(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTerm'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Contract.term', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract.term', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract.term', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'subType', elem.subTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract.term', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term', 'actionReason', elem.actionReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Contract.term', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeContractTermAgent(this, 'Contract.term', 'agent', elem.agentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(this, 'Contract.term', 'valuedItem', elem.valuedItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(this, 'Contract.term', 'group', elem.groupList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermAgent(obj : TTurtleComplex) : TFhirContractTermAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAgent.create;
  try
    ParseContractTermAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAgentProperties(obj : TTurtleComplex; result : TFhirContractTermAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Contract.term.agent.actor'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Contract.term.agent', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.agent', 'role', elem.roleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermValuedItem(obj : TTurtleComplex) : TFhirContractTermValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermValuedItem.create;
  try
    ParseContractTermValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.term.valuedItem.entityCodeableConcept', item) then
      result.entity := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.term.valuedItem.entityReference', item) {a3} then
      result.entity := ParseReference(item);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.identifier'));{q3b}
    result.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.effectiveTime'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.points'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.valuedItem.net'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractTermValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermValuedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.valuedItem', 'entityReference', TFhirReference(elem.entity), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.term.valuedItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.valuedItem', 'effectiveTime', elem.effectiveTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.valuedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.valuedItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.valuedItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.valuedItem', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.valuedItem', 'net', elem.netElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractFriendly'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.friendly', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.friendly', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractLegal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.legal', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.legal', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractRule(obj : TTurtleComplex) : TFhirContractRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.rule', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.rule', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContract(obj : TTurtleComplex) : TFhirContract;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContract.create;
  try
    ParseContractProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractProperties(obj : TTurtleComplex; result : TFhirContract);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Contract.status'), CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum);
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.applies'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subject') do
      result.subjectList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.topic') do
      result.topicList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.authority') do
      result.authorityList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.domain') do
      result.domainList.Add(parseReference{TFhirLocation}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subType') do
      result.subTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.actionReason') do
      result.actionReasonList.Add(parseCodeableConcept(item));
    result.decisionType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.decisionType'));{q3b}
    result.contentDerivative := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDerivative'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.agent') do
      result.agentList.Add(parseContractAgent(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer') do
      result.signerList.Add(parseContractSigner(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.valuedItem') do
      result.valuedItemList.Add(parseContractValuedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term') do
      result.termList.Add(parseContractTerm(item));
    if obj.has('http://hl7.org/fhir/Contract.bindingAttachment', item) then
      result.binding := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.bindingReference', item) {a3} then
      result.binding := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Contract.friendly') do
      result.friendlyList.Add(parseContractFriendly(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.legal') do
      result.legalList.Add(parseContractLegal(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.rule') do
      result.ruleList.Add(parseContractRule(item));
end;

procedure TFHIRTurtleComposer.ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contract'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Contract', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Contract', 'status', elem.StatusElement, CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(this, 'Contract', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(this, 'Contract', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Contract', 'authority', elem.authorityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('domain') then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Contract', 'domain', elem.domainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Contract', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'subType', elem.subTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('actionReason') then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'actionReason', elem.actionReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('decisionType') then
    ComposeCodeableConcept(this, 'Contract', 'decisionType', elem.decisionTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contentDerivative') then
    ComposeCodeableConcept(this, 'Contract', 'contentDerivative', elem.contentDerivativeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Contract', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('agent') then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeContractAgent(this, 'Contract', 'agent', elem.agentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('signer') then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(this, 'Contract', 'signer', elem.signerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('valuedItem') then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(this, 'Contract', 'valuedItem', elem.valuedItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('term') then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(this, 'Contract', 'term', elem.termList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract', 'bindingAttachment', TFhirAttachment(elem.binding), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'bindingReference', TFhirReference(elem.binding), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(this, 'Contract', 'friendly', elem.friendlyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('legal') then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(this, 'Contract', 'legal', elem.legalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(this, 'Contract', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRTurtleParser.ParseCoverageGrouping(obj : TTurtleComplex) : TFhirCoverageGrouping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageGrouping.create;
  try
    ParseCoverageGroupingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageGroupingProperties(obj : TTurtleComplex; result : TFhirCoverageGrouping);
begin
    ParseBackboneElementProperties(obj, result);
    result.groupElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.group'));{q1}
    result.groupDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.groupDisplay'));{q1}
    result.subGroupElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subGroup'));{q1}
    result.subGroupDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subGroupDisplay'));{q1}
    result.planElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.plan'));{q1}
    result.planDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.planDisplay'));{q1}
    result.subPlanElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subPlan'));{q1}
    result.subPlanDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subPlanDisplay'));{q1}
    result.class_Element := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.class'));{q1}
    result.classDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.classDisplay'));{q1}
    result.subClassElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subClass'));{q1}
    result.subClassDisplayElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.grouping.subClassDisplay'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoverageGrouping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageGrouping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageGrouping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'group', elem.groupElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'groupDisplay', elem.groupDisplayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subGroup', elem.subGroupElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subGroupDisplay', elem.subGroupDisplayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'plan', elem.planElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'planDisplay', elem.planDisplayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subPlan', elem.subPlanElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subPlanDisplay', elem.subPlanDisplayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'class', elem.class_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'classDisplay', elem.classDisplayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subClass', elem.subClassElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.grouping', 'subClassDisplay', elem.subClassDisplayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCoverage(obj : TTurtleComplex) : TFhirCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Coverage.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.type'));{q3b}
    result.policyHolder := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Coverage.policyHolder'));{q3b}
    result.subscriber := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Coverage.subscriber'));{q3b}
    result.subscriberIdElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.subscriberId'));{q1}
    result.beneficiary := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Coverage.beneficiary'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.relationship'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.payor') do
      result.payorList.Add(parseReference{Resource}(item));
    result.grouping := ParseCoverageGrouping(obj.complex('http://hl7.org/fhir/Coverage.grouping'));{q3b}
    result.dependentElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.dependent'));{q1}
    result.sequenceElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.sequence'));{q1}
    result.orderElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Coverage.order'));{q1}
    result.networkElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.network'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.contract') do
      result.contractList.Add(parseReference{TFhirContract}(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coverage'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Coverage', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Coverage', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyHolder') then
    ComposeReference{Resource}(this, 'Coverage', 'policyHolder', elem.policyHolderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriber') then
    ComposeReference{Resource}(this, 'Coverage', 'subscriber', elem.subscriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeString(this, 'Coverage', 'subscriberId', elem.subscriberIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('beneficiary') then
    ComposeReference{TFhirPatient}(this, 'Coverage', 'beneficiary', elem.beneficiaryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(this, 'Coverage', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Coverage', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payor') then
    for i := 0 to elem.payorList.Count - 1 do
      ComposeReference{Resource}(this, 'Coverage', 'payor', elem.payorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('grouping') then
    ComposeCoverageGrouping(this, 'Coverage', 'grouping', elem.groupingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposeString(this, 'Coverage', 'dependent', elem.dependentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposeString(this, 'Coverage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    ComposePositiveInt(this, 'Coverage', 'order', elem.orderElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeString(this, 'Coverage', 'network', elem.networkElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(this, 'Coverage', 'contract', elem.contractList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
function TFHIRTurtleParser.ParseDataElementMapping(obj : TTurtleComplex) : TFhirDataElementMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataElementMapping.create;
  try
    ParseDataElementMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataElementMappingProperties(obj : TTurtleComplex; result : TFhirDataElementMapping);
begin
    ParseBackboneElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/DataElement.mapping.identity'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/DataElement.mapping.uri'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.mapping.name'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.mapping.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDataElementMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElementMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataElementMapping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'DataElement.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DataElement.mapping', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElement.mapping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DataElement.mapping', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDataElement(obj : TTurtleComplex) : TFhirDataElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataElement.create;
  try
    ParseDataElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataElementProperties(obj : TTurtleComplex; result : TFhirDataElement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/DataElement.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.version'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataElement.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DataElement.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DataElement.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.publisher'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/DataElement.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataElement.contact') do
      result.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/DataElement.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/DataElement.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/DataElement.copyright'));{q1}
    result.stringencyElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataElement.stringency'), CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum);
    for item in obj.complexes('http://hl7.org/fhir/DataElement.mapping') do
      result.mappingList.Add(parseDataElementMapping(item));
    for item in obj.complexes('http://hl7.org/fhir/DataElement.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeDataElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataElement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'DataElement', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DataElement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'DataElement', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DataElement', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'DataElement', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'DataElement', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'DataElement', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'DataElement', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'DataElement', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'DataElement', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'DataElement', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'DataElement', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'DataElement', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnum(this, 'DataElement', 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(this, 'DataElement', 'mapping', elem.mappingList[i], false, i);{x.d3}
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'DataElement', 'element', elem.elementList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRTurtleParser.ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.action'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.date'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueMitigation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DetectedIssue.mitigation', 'action', elem.actionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DetectedIssue.mitigation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'DetectedIssue.mitigation', 'author', elem.authorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DetectedIssue.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.category'));{q3b}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.severity'), CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DetectedIssue.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.date'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DetectedIssue.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.implicated') do
      result.implicatedList.Add(parseReference{TFhirReference}(item));
    result.detailElement := ParseString(obj.complex('http://hl7.org/fhir/DetectedIssue.detail'));{q1}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/DetectedIssue.reference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.mitigation') do
      result.mitigationList.Add(parseDetectedIssueMitigation(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssue'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'DetectedIssue', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'DetectedIssue', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'DetectedIssue', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnum(this, 'DetectedIssue', 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'DetectedIssue', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'DetectedIssue', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'DetectedIssue', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DetectedIssue', 'implicated', elem.implicatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeString(this, 'DetectedIssue', 'detail', elem.detailElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUri(this, 'DetectedIssue', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(this, 'DetectedIssue', 'mitigation', elem.mitigationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRTurtleParser.ParseDeviceUdi(obj : TTurtleComplex) : TFhirDeviceUdi;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUdi.create;
  try
    ParseDeviceUdiProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUdiProperties(obj : TTurtleComplex; result : TFhirDeviceUdi);
begin
    ParseBackboneElementProperties(obj, result);
    result.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udi.deviceIdentifier'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udi.name'));{q1}
    result.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udi.jurisdiction'));{q1}
    result.carrierHRFElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udi.carrierHRF'));{q1}
    result.carrierAIDCElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Device.udi.carrierAIDC'));{q1}
    result.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udi.issuer'));{q1}
    result.entryTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.udi.entryType'), CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceUdi(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUdi; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUdi'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udi', 'deviceIdentifier', elem.deviceIdentifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udi', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device.udi', 'jurisdiction', elem.jurisdictionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udi', 'carrierHRF', elem.carrierHRFElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'Device.udi', 'carrierAIDC', elem.carrierAIDCElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device.udi', 'issuer', elem.issuerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Device.udi', 'entryType', elem.EntryTypeElement, CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseDevice(obj : TTurtleComplex) : TFhirDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Device.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.udi := ParseDeviceUdi(obj.complex('http://hl7.org/fhir/Device.udi'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.status'), CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.type'));{q3b}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.lotNumber'));{q1}
    result.manufacturerElement := ParseString(obj.complex('http://hl7.org/fhir/Device.manufacturer'));{q1}
    result.manufactureDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.manufactureDate'));{q1}
    result.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.expirationDate'));{q1}
    result.modelElement := ParseString(obj.complex('http://hl7.org/fhir/Device.model'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Device.version'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Device.patient'));{q3b}
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Device.owner'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Device.location'));{q3b}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Device.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.safety') do
      result.safetyList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Device'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Device', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('udi') then
    ComposeDeviceUdi(this, 'Device', 'udi', elem.udiElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Device', 'status', elem.StatusElement, CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Device', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Device', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeString(this, 'Device', 'manufacturer', elem.manufacturerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTime(this, 'Device', 'manufactureDate', elem.manufactureDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateTime(this, 'Device', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeString(this, 'Device', 'model', elem.modelElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(this, 'Device', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Device', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Device', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Device', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Device', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'Device', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Device', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') then
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'safety', elem.safetyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
function TFHIRTurtleParser.ParseDeviceComponentProductionSpecification(obj : TTurtleComplex) : TFhirDeviceComponentProductionSpecification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    ParseDeviceComponentProductionSpecificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceComponentProductionSpecificationProperties(obj : TTurtleComplex; result : TFhirDeviceComponentProductionSpecification);
begin
    ParseBackboneElementProperties(obj, result);
    result.specType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.specType'));{q3b}
    result.componentId := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.componentId'));{q3b}
    result.productionSpecElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceComponent.productionSpecification.productionSpec'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceComponentProductionSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponentProductionSpecification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceComponentProductionSpecification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceComponent.productionSpecification', 'specType', elem.specTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceComponent.productionSpecification', 'componentId', elem.componentIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DeviceComponent.productionSpecification', 'productionSpec', elem.productionSpecElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceComponent(obj : TTurtleComplex) : TFhirDeviceComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceComponent.create;
  try
    ParseDeviceComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceComponentProperties(obj : TTurtleComplex; result : TFhirDeviceComponent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceComponent.identifier'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.type'));{q3b}
    result.lastSystemChangeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceComponent.lastSystemChange'));{q1}
    result.source := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceComponent.source'));{q3b}
    result.parent := ParseReference{TFhirDeviceComponent}(obj.complex('http://hl7.org/fhir/DeviceComponent.parent'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceComponent.operationalStatus') do
      result.operationalStatusList.Add(parseCodeableConcept(item));
    result.parameterGroup := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.parameterGroup'));{q3b}
    result.measurementPrincipleElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceComponent.measurementPrinciple'), CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum);
    for item in obj.complexes('http://hl7.org/fhir/DeviceComponent.productionSpecification') do
      result.productionSpecificationList.Add(parseDeviceComponentProductionSpecification(item));
    result.languageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceComponent.languageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDeviceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceComponent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeIdentifier(this, 'DeviceComponent', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'DeviceComponent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastSystemChange') then
    ComposeInstant(this, 'DeviceComponent', 'lastSystemChange', elem.lastSystemChangeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(this, 'DeviceComponent', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceComponent', 'parent', elem.parentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceComponent', 'operationalStatus', elem.operationalStatusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parameterGroup') then
    ComposeCodeableConcept(this, 'DeviceComponent', 'parameterGroup', elem.parameterGroupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnum(this, 'DeviceComponent', 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productionSpecification') then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(this, 'DeviceComponent', 'productionSpecification', elem.productionSpecificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('languageCode') then
    ComposeCodeableConcept(this, 'DeviceComponent', 'languageCode', elem.languageCodeElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRTurtleParser.ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.type'), CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    result.stateElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.state'), CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    result.timeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.time'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetricCalibration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceMetric.calibration', 'time', elem.timeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceMetric.identifier'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.type'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.unit'));{q3b}
    result.source := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceMetric.source'));{q3b}
    result.parent := ParseReference{TFhirDeviceComponent}(obj.complex('http://hl7.org/fhir/DeviceMetric.parent'));{q3b}
    result.operationalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.operationalStatus'), CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    result.colorElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.color'), CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.category'), CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    result.measurementPeriod := ParseTiming(obj.complex('http://hl7.org/fhir/DeviceMetric.measurementPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.calibration') do
      result.calibrationList.Add(parseDeviceMetricCalibration(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetric'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeIdentifier(this, 'DeviceMetric', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'DeviceMetric', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(this, 'DeviceMetric', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(this, 'DeviceMetric', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(this, 'DeviceMetric', 'parent', elem.parentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnum(this, 'DeviceMetric', 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnum(this, 'DeviceMetric', 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, false, -1);{x.d4}
  ComposeEnum(this, 'DeviceMetric', 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(this, 'DeviceMetric', 'measurementPeriod', elem.measurementPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(this, 'DeviceMetric', 'calibration', elem.calibrationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
function TFHIRTurtleParser.ParseDeviceRequestRequester(obj : TTurtleComplex) : TFhirDeviceRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequestRequester.create;
  try
    ParseDeviceRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestRequesterProperties(obj : TTurtleComplex; result : TFhirDeviceRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/DeviceRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'DeviceRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'DeviceRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequest.create;
  try
    ParseDeviceRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestProperties(obj : TTurtleComplex; result : TFhirDeviceRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.priorRequest') do
      result.priorRequestList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intent := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.intent'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if obj.has('http://hl7.org/fhir/DeviceRequest.codeReference', item) {a3} then
      result.code := ParseReference(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.codeCodeableConcept', item) then
      result.code := parseCodeableConcept(item);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceRequest.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceRequest.context'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceRequest.authoredOn'));{q1}
    result.requester := ParseDeviceRequestRequester(obj.complex('http://hl7.org/fhir/DeviceRequest.requester'));{q3b}
    result.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.performerType'));{q3b}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceRequest.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'DeviceRequest', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorRequest') then
    for i := 0 to elem.priorRequestList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'priorRequest', elem.priorRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'DeviceRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'DeviceRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'DeviceRequest', 'intent', elem.intentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.priorityElement <> nil) and (elem.priorityElement.primitiveValue <> 'If missing, normal priority')) and doCompose('priority') then
    ComposeEnum(this, 'DeviceRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (elem.code is TFhirReference) {2} then
    ComposeReference(this, 'DeviceRequest', 'codeReference', TFhirReference(elem.code), false,-1){x.d8}
  else if (elem.code is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceRequest', 'codeCodeableConcept', TFhirCodeableConcept(elem.code), false, -1);{x.d9}
  ComposeReference{Resource}(this, 'DeviceRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'DeviceRequest', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'DeviceRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeDeviceRequestRequester(this, 'DeviceRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(this, 'DeviceRequest', 'performerType', elem.performerTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(this, 'DeviceRequest', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'DeviceRequest', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
function TFHIRTurtleParser.ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUseStatement.create;
  try
    ParseDeviceUseStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceUseStatement.status'), CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.subject'));{q3b}
    result.whenUsed := ParsePeriod(obj.complex('http://hl7.org/fhir/DeviceUseStatement.whenUsed'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingDateTime', item) then
      result.timing := parseDateTime(item);
    result.recordedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUseStatement.recordedOn'));{q1}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.source'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.indication') do
      result.indicationList.Add(parseCodeableConcept(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceUseStatement.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUseStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DeviceUseStatement', 'status', elem.StatusElement, CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum, false, -1);{x.d4}
  ComposeReference{Resource}(this, 'DeviceUseStatement', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('whenUsed') then
    ComposePeriod(this, 'DeviceUseStatement', 'whenUsed', elem.whenUsedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseStatement', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseStatement', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseStatement', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('recordedOn') then
    ComposeDateTime(this, 'DeviceUseStatement', 'recordedOn', elem.recordedOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'DeviceUseStatement', 'source', elem.sourceElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'DeviceUseStatement', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseStatement', 'indication', elem.indicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'DeviceUseStatement', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceUseStatement', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRTurtleParser.ParseDiagnosticReportPerformer(obj : TTurtleComplex) : TFhirDiagnosticReportPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportPerformer.create;
  try
    ParseDiagnosticReportPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportPerformerProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.performer.role'));{q3b}
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticReport.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DiagnosticReport.performer', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'DiagnosticReport.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDiagnosticReportImage(obj : TTurtleComplex) : TFhirDiagnosticReportImage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportImage.create;
  try
    ParseDiagnosticReportImageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportImageProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportImage);
begin
    ParseBackboneElementProperties(obj, result);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.image.comment'));{q1}
    result.link_ := ParseReference{TFhirMedia}(obj.complex('http://hl7.org/fhir/DiagnosticReport.image.link'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportImage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportImage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportImage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport.image', 'comment', elem.commentElement, false, -1);{x.2ea}
  ComposeReference{TFhirMedia}(this, 'DiagnosticReport.image', 'link', elem.link_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticReport.status'), CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticReport.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DiagnosticReport.context'));{q3b}
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DiagnosticReport.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.performer') do
      result.performerList.Add(parseDiagnosticReportPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.result') do
      result.resultList.Add(parseReference{TFhirObservation}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.imagingStudy') do
      result.imagingStudyList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.image') do
      result.imageList.Add(parseDiagnosticReportImage(item));
    result.conclusionElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.conclusion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.codedDiagnosis') do
      result.codedDiagnosisList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.presentedForm') do
      result.presentedFormList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticReport', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  ComposeEnum(this, 'DiagnosticReport', 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'DiagnosticReport', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'DiagnosticReport', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'DiagnosticReport', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'DiagnosticReport', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'DiagnosticReport', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DiagnosticReport', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'DiagnosticReport', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeDiagnosticReportPerformer(this, 'DiagnosticReport', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticReport', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'DiagnosticReport', 'result', elem.resultList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(this, 'DiagnosticReport', 'imagingStudy', elem.imagingStudyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(this, 'DiagnosticReport', 'image', elem.imageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeString(this, 'DiagnosticReport', 'conclusion', elem.conclusionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('codedDiagnosis') then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'codedDiagnosis', elem.codedDiagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(this, 'DiagnosticReport', 'presentedForm', elem.presentedFormList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRTurtleParser.ParseDocumentManifestContent(obj : TTurtleComplex) : TFhirDocumentManifestContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestContent.create;
  try
    ParseDocumentManifestContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestContentProperties(obj : TTurtleComplex; result : TFhirDocumentManifestContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/DocumentManifest.content.pAttachment', item) then
      result.p := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/DocumentManifest.content.pReference', item) {a3} then
      result.p := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(this, 'DocumentManifest.content', 'pAttachment', TFhirAttachment(elem.p), false, -1){x.d9}
  else if (elem.p is TFhirReference) {2} then
    ComposeReference(this, 'DocumentManifest.content', 'pReference', TFhirReference(elem.p), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.related.identifier'));{q3b}
    result.ref := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/DocumentManifest.related.ref'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentManifest.related', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentManifest.related', 'ref', elem.refElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentManifest.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentManifest.type'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentManifest.subject'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentManifest.created'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.author') do
      result.authorList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/DocumentManifest.source'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentManifest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.content') do
      result.contentList.Add(parseDocumentManifestContent(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.related') do
      result.relatedList.Add(parseDocumentManifestRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentManifest', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentManifest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DocumentManifest', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'DocumentManifest', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'DocumentManifest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'DocumentManifest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentManifest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUri(this, 'DocumentManifest', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentManifest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(this, 'DocumentManifest', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(this, 'DocumentManifest', 'related', elem.relatedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRTurtleParser.ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.code'), CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    result.target := ParseReference{TFhirDocumentReference}(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.target'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceRelatesTo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DocumentReference.relatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirDocumentReference}(this, 'DocumentReference.relatesTo', 'target', elem.targetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent);
begin
    ParseBackboneElementProperties(obj, result);
    result.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/DocumentReference.content.attachment'));{q3b}
    result.format := ParseCoding(obj.complex('http://hl7.org/fhir/DocumentReference.content.format'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeAttachment(this, 'DocumentReference.content', 'attachment', elem.attachmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'DocumentReference.content', 'format', elem.formatElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContext.create;
  try
    ParseDocumentReferenceContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DocumentReference.context.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.event') do
      result.eventList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/DocumentReference.context.period'));{q3b}
    result.facilityType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.facilityType'));{q3b}
    result.practiceSetting := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.practiceSetting'));{q3b}
    result.sourcePatientInfo := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DocumentReference.context.sourcePatientInfo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.related') do
      result.relatedList.Add(parseDocumentReferenceContextRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContext'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(this, 'DocumentReference.context', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference.context', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DocumentReference.context', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'facilityType', elem.facilityTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'practiceSetting', elem.practiceSettingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'DocumentReference.context', 'sourcePatientInfo', elem.sourcePatientInfoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(this, 'DocumentReference.context', 'related', elem.relatedList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContextRelated(obj : TTurtleComplex) : TFhirDocumentReferenceContextRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContextRelated.create;
  try
    ParseDocumentReferenceContextRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContextRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContextRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentReference.context.related.identifier'));{q3b}
    result.ref := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/DocumentReference.context.related.ref'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContextRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContextRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContextRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentReference.context.related', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentReference.context.related', 'ref', elem.refElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentReference.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.docStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.docStatus'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.type'));{q3b}
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.class'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentReference.subject'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentReference.created'));{q1}
    result.indexedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DocumentReference.indexed'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.author') do
      result.authorList.Add(parseReference{Resource}(item));
    result.authenticator := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/DocumentReference.authenticator'));{q3b}
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/DocumentReference.custodian'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.relatesTo') do
      result.relatesToList.Add(parseDocumentReferenceRelatesTo(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentReference.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.securityLabel') do
      result.securityLabelList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content') do
      result.contentList.Add(parseDocumentReferenceContent(item));
    result.context := ParseDocumentReferenceContext(obj.complex('http://hl7.org/fhir/DocumentReference.context'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReference'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentReference', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentReference', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DocumentReference', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeEnum(this, 'DocumentReference', 'docStatus', elem.DocStatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'DocumentReference', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(this, 'DocumentReference', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'DocumentReference', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'DocumentReference', 'created', elem.createdElement, false, -1);{x.2ea}
  ComposeInstant(this, 'DocumentReference', 'indexed', elem.indexedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(this, 'DocumentReference', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authenticator') then
    ComposeReference{Resource}(this, 'DocumentReference', 'authenticator', elem.authenticatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'DocumentReference', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(this, 'DocumentReference', 'relatesTo', elem.relatesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentReference', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(this, 'DocumentReference', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(this, 'DocumentReference', 'context', elem.contextElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
function TFHIRTurtleParser.ParseEligibilityRequest(obj : TTurtleComplex) : TFhirEligibilityRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityRequest.create;
  try
    ParseEligibilityRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirEligibilityRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EligibilityRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EligibilityRequest.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityRequest.priority'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EligibilityRequest.patient'));{q3b}
    if obj.has('http://hl7.org/fhir/EligibilityRequest.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/EligibilityRequest.servicedDate', item) then
      result.serviced := parseDate(item);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EligibilityRequest.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EligibilityRequest.enterer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EligibilityRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityRequest.organization'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityRequest.insurer'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/EligibilityRequest.facility'));{q3b}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/EligibilityRequest.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/EligibilityRequest.businessArrangement'));{q1}
    result.benefitCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityRequest.benefitCategory'));{q3b}
    result.benefitSubCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityRequest.benefitSubCategory'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EligibilityRequest', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'EligibilityRequest', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'EligibilityRequest', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'EligibilityRequest', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'EligibilityRequest', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EligibilityRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityRequest', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityRequest', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'EligibilityRequest', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(this, 'EligibilityRequest', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('businessArrangement') then
    ComposeString(this, 'EligibilityRequest', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitCategory') then
    ComposeCodeableConcept(this, 'EligibilityRequest', 'benefitCategory', elem.benefitCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitSubCategory') then
    ComposeCodeableConcept(this, 'EligibilityRequest', 'benefitSubCategory', elem.benefitSubCategoryElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
function TFHIRTurtleParser.ParseEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirEligibilityResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponseInsurance.create;
  try
    ParseEligibilityResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.coverage'));{q3b}
    result.contract := ParseReference{TFhirContract}(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.contract'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance') do
      result.benefitBalanceList.Add(parseEligibilityResponseInsuranceBenefitBalance(item));
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponseInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCoverage}(this, 'EligibilityResponse.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirContract}(this, 'EligibilityResponse.insurance', 'contract', elem.contractElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeEligibilityResponseInsuranceBenefitBalance(this, 'EligibilityResponse.insurance', 'benefitBalance', elem.benefitBalanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEligibilityResponseInsuranceBenefitBalance(obj : TTurtleComplex) : TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponseInsuranceBenefitBalance.create;
  try
    ParseEligibilityResponseInsuranceBenefitBalanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseInsuranceBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsuranceBenefitBalance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.category'));{q3b}
    result.subCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.subCategory'));{q3b}
    result.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.excluded'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.description'));{q1}
    result.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.network'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.unit'));{q3b}
    result.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.term'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial') do
      result.financialList.Add(parseEligibilityResponseInsuranceBenefitBalanceFinancial(item));
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponseInsuranceBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponseInsuranceBenefitBalance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance', 'subCategory', elem.subCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EligibilityResponse.insurance.benefitBalance', 'excluded', elem.excludedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EligibilityResponse.insurance.benefitBalance', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EligibilityResponse.insurance.benefitBalance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance', 'term', elem.termElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.financialList.Count - 1 do
      ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(this, 'EligibilityResponse.insurance.benefitBalance', 'financial', elem.financialList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEligibilityResponseInsuranceBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.create;
  try
    ParseEligibilityResponseInsuranceBenefitBalanceFinancialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseInsuranceBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.type'));{q3b}
    if obj.has('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.allowedUnsignedInt', item) then
      result.allowed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.allowedMoney', item) then
      result.allowed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.allowedString', item) then
      result.allowed := parseString(item);
    if obj.has('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.usedUnsignedInt', item) then
      result.used := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/EligibilityResponse.insurance.benefitBalance.financial.usedMoney', item) then
      result.used := parseMoney(item);
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponseInsuranceBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponseInsuranceBenefitBalanceFinancial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'allowedMoney', TFhirMoney(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'allowedString', TFhirString(elem.allowed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(this, 'EligibilityResponse.insurance.benefitBalance.financial', 'usedMoney', TFhirMoney(elem.used), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseEligibilityResponseError(obj : TTurtleComplex) : TFhirEligibilityResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponseError.create;
  try
    ParseEligibilityResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseErrorProperties(obj : TTurtleComplex; result : TFhirEligibilityResponseError);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.error.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponseError'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'EligibilityResponse.error', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEligibilityResponse(obj : TTurtleComplex) : TFhirEligibilityResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEligibilityResponse.create;
  try
    ParseEligibilityResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirEligibilityResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EligibilityResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EligibilityResponse.created'));{q1}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EligibilityResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityResponse.requestOrganization'));{q3b}
    result.request := ParseReference{TFhirEligibilityRequest}(obj.complex('http://hl7.org/fhir/EligibilityResponse.request'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EligibilityResponse.disposition'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EligibilityResponse.insurer'));{q3b}
    result.inforceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EligibilityResponse.inforce'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.insurance') do
      result.insuranceList.Add(parseEligibilityResponseInsurance(item));
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EligibilityResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EligibilityResponse.error') do
      result.errorList.Add(parseEligibilityResponseError(item));
end;

procedure TFHIRTurtleComposer.ComposeEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEligibilityResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EligibilityResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EligibilityResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EligibilityResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EligibilityResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'EligibilityResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEligibilityRequest}(this, 'EligibilityResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'EligibilityResponse', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'EligibilityResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'EligibilityResponse', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('inforce') then
    ComposeBoolean(this, 'EligibilityResponse', 'inforce', elem.inforceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeEligibilityResponseInsurance(this, 'EligibilityResponse', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'EligibilityResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeEligibilityResponseError(this, 'EligibilityResponse', 'error', elem.errorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRTurtleParser.ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Encounter.statusHistory', 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);{x.d4}
  ComposePeriod(this, 'Encounter.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterClassHistory.create;
  try
    ParseEncounterClassHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterClassHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterClassHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.class_ := ParseCoding(obj.complex('http://hl7.org/fhir/Encounter.classHistory.class'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.classHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterClassHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterClassHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Encounter.classHistory', 'class', elem.class_Element, false, -1);{x.2f}
  ComposePeriod(this, 'Encounter.classHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.participant.period'));{q3b}
    result.individual := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Encounter.participant.individual'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.participant', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(this, 'Encounter.participant', 'individual', elem.individualElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterDiagnosis.create;
  try
    ParseEncounterDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterDiagnosisProperties(obj : TTurtleComplex; result : TFhirEncounterDiagnosis);
begin
    ParseBackboneElementProperties(obj, result);
    result.condition := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.condition'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.role'));{q3b}
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.rank'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Encounter.diagnosis', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.diagnosis', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Encounter.diagnosis', 'rank', elem.rankElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterHospitalization.create;
  try
    ParseEncounterHospitalizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.preAdmissionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.preAdmissionIdentifier'));{q3b}
    result.origin := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.origin'));{q3b}
    result.admitSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.admitSource'));{q3b}
    result.reAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.reAdmission'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.dietPreference') do
      result.dietPreferenceList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialCourtesy') do
      result.specialCourtesyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialArrangement') do
      result.specialArrangementList.Add(parseCodeableConcept(item));
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.destination'));{q3b}
    result.dischargeDisposition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.dischargeDisposition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterHospitalization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Encounter.hospitalization', 'preAdmissionIdentifier', elem.preAdmissionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'origin', elem.originElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'admitSource', elem.admitSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'reAdmission', elem.reAdmissionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dietPreference', elem.dietPreferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialCourtesy', elem.specialCourtesyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialArrangement', elem.specialArrangementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dischargeDisposition', elem.dischargeDispositionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(obj, result);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.location.location'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.location.status'), CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.location.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterLocation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirLocation}(this, 'Encounter.location', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Encounter.location', 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.location', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounter(obj : TTurtleComplex) : TFhirEncounter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.statusHistory') do
      result.statusHistoryList.Add(parseEncounterStatusHistory(item));
    result.class_ := ParseCoding(obj.complex('http://hl7.org/fhir/Encounter.class'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.classHistory') do
      result.classHistoryList.Add(parseEncounterClassHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.priority'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Encounter.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.episodeOfCare') do
      result.episodeOfCareList.Add(parseReference{TFhirEpisodeOfCare}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.incomingReferral') do
      result.incomingReferralList.Add(parseReference{TFhirReferralRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant') do
      result.participantList.Add(parseEncounterParticipant(item));
    result.appointment := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/Encounter.appointment'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.period'));{q3b}
    result.length := ParseDuration(obj.complex('http://hl7.org/fhir/Encounter.length'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.diagnosis') do
      result.diagnosisList.Add(parseEncounterDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
    result.hospitalization := ParseEncounterHospitalization(obj.complex('http://hl7.org/fhir/Encounter.hospitalization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.location') do
      result.locationList.Add(parseEncounterLocation(item));
    result.serviceProvider := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Encounter.serviceProvider'));{q3b}
    result.partOf := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Encounter.partOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Encounter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Encounter', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Encounter', 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(this, 'Encounter', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCoding(this, 'Encounter', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('classHistory') then
    for i := 0 to elem.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(this, 'Encounter', 'classHistory', elem.classHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Encounter', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Encounter', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(this, 'Encounter', 'episodeOfCare', elem.episodeOfCareList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'Encounter', 'incomingReferral', elem.incomingReferralList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(this, 'Encounter', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    ComposeReference{TFhirAppointment}(this, 'Encounter', 'appointment', elem.appointmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'Encounter', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeDuration(this, 'Encounter', 'length', elem.lengthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(this, 'Encounter', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'Encounter', 'account', elem.accountList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(this, 'Encounter', 'hospitalization', elem.hospitalizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(this, 'Encounter', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(this, 'Encounter', 'serviceProvider', elem.serviceProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(this, 'Encounter', 'partOf', elem.partOfElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
function TFHIRTurtleParser.ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEndpoint.create;
  try
    ParseEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEndpointProperties(obj : TTurtleComplex; result : TFhirEndpoint);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Endpoint.status'), CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum);
    result.connectionType := ParseCoding(obj.complex('http://hl7.org/fhir/Endpoint.connectionType'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Endpoint.name'));{q1}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Endpoint.managingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Endpoint.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadType') do
      result.payloadTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadMimeType') do
      result.payloadMimeTypeList.Add(parseCode(item));
    result.addressElement := ParseUri(obj.complex('http://hl7.org/fhir/Endpoint.address'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.header') do
      result.headerList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Endpoint'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Endpoint', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Endpoint', 'status', elem.StatusElement, CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum, false, -1);{x.d4}
  ComposeCoding(this, 'Endpoint', 'connectionType', elem.connectionTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Endpoint', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Endpoint', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Endpoint', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Endpoint', 'period', elem.periodElement, false, -1);{x.2f}
  for i := 0 to elem.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Endpoint', 'payloadType', elem.payloadTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payloadMimeType') then
    for i := 0 to elem.payloadMimeTypeList.Count - 1 do
      ComposeCode(this, 'Endpoint', 'payloadMimeType', elem.payloadMimeTypeList[i], false, i);{x.d3}
  ComposeUri(this, 'Endpoint', 'address', elem.addressElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('header') then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(this, 'Endpoint', 'header', elem.headerList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRTurtleParser.ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentRequest.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentRequest.created'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.organization'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.subject'));{q3b}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.coverage'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EnrollmentRequest', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'EnrollmentRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(this, 'EnrollmentRequest', 'coverage', elem.coverageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRTurtleParser.ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.request := ParseReference{TFhirEnrollmentRequest}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.request'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EnrollmentResponse.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EnrollmentResponse.disposition'));{q1}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestOrganization'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EnrollmentResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(this, 'EnrollmentResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'EnrollmentResponse', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'EnrollmentResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRTurtleParser.ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'EpisodeOfCare.statusHistory', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  ComposePeriod(this, 'EpisodeOfCare.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    ParseEpisodeOfCareDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareDiagnosis);
begin
    ParseBackboneElementProperties(obj, result);
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.condition'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.role'));{q3b}
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.rank'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCondition}(this, 'EpisodeOfCare.diagnosis', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'EpisodeOfCare.diagnosis', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'EpisodeOfCare.diagnosis', 'rank', elem.rankElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.statusHistory') do
      result.statusHistoryList.Add(parseEpisodeOfCareStatusHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.diagnosis') do
      result.diagnosisList.Add(parseEpisodeOfCareDiagnosis(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.patient'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.managingOrganization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.referralRequest') do
      result.referralRequestList.Add(parseReference{TFhirReferralRequest}(item));
    result.careManager := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careManager'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.team') do
      result.teamList.Add(parseReference{TFhirCareTeam}(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCare'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EpisodeOfCare', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'EpisodeOfCare', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(this, 'EpisodeOfCare', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(this, 'EpisodeOfCare', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'EpisodeOfCare', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EpisodeOfCare', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'EpisodeOfCare', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'EpisodeOfCare', 'referralRequest', elem.referralRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(this, 'EpisodeOfCare', 'careManager', elem.careManagerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('team') then
    for i := 0 to elem.teamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(this, 'EpisodeOfCare', 'team', elem.teamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'EpisodeOfCare', 'account', elem.accountList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
function TFHIRTurtleParser.ParseExpansionProfileFixedVersion(obj : TTurtleComplex) : TFhirExpansionProfileFixedVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileFixedVersion.create;
  try
    ParseExpansionProfileFixedVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileFixedVersionProperties(obj : TTurtleComplex; result : TFhirExpansionProfileFixedVersion);
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ExpansionProfile.fixedVersion.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ExpansionProfile.fixedVersion.version'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExpansionProfile.fixedVersion.mode'), CODES_TFhirSystemVersionProcessingModeEnum, SYSTEMS_TFhirSystemVersionProcessingModeEnum);
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileFixedVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileFixedVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileFixedVersion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ExpansionProfile.fixedVersion', 'system', elem.systemElement, false, -1);{x.2ea}
  ComposeString(this, 'ExpansionProfile.fixedVersion', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ExpansionProfile.fixedVersion', 'mode', elem.ModeElement, CODES_TFhirSystemVersionProcessingModeEnum, SYSTEMS_TFhirSystemVersionProcessingModeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseExpansionProfileExcludedSystem(obj : TTurtleComplex) : TFhirExpansionProfileExcludedSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileExcludedSystem.create;
  try
    ParseExpansionProfileExcludedSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileExcludedSystemProperties(obj : TTurtleComplex; result : TFhirExpansionProfileExcludedSystem);
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludedSystem.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludedSystem.version'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileExcludedSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileExcludedSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileExcludedSystem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ExpansionProfile.excludedSystem', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExpansionProfile.excludedSystem', 'version', elem.versionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExpansionProfileDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileDesignation.create;
  try
    ParseExpansionProfileDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.include := ParseExpansionProfileDesignationInclude(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.include'));{q3b}
    result.exclude := ParseExpansionProfileDesignationExclude(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.exclude'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpansionProfileDesignationInclude(this, 'ExpansionProfile.designation', 'include', elem.includeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpansionProfileDesignationExclude(this, 'ExpansionProfile.designation', 'exclude', elem.excludeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExpansionProfileDesignationInclude(obj : TTurtleComplex) : TFhirExpansionProfileDesignationInclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileDesignationInclude.create;
  try
    ParseExpansionProfileDesignationIncludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileDesignationIncludeProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationInclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.designation.include.designation') do
      result.designationList.Add(parseExpansionProfileDesignationIncludeDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileDesignationInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationInclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileDesignationInclude'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeExpansionProfileDesignationIncludeDesignation(this, 'ExpansionProfile.designation.include', 'designation', elem.designationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExpansionProfileDesignationIncludeDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignationIncludeDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileDesignationIncludeDesignation.create;
  try
    ParseExpansionProfileDesignationIncludeDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileDesignationIncludeDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationIncludeDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.include.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.include.designation.use'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileDesignationIncludeDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationIncludeDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileDesignationIncludeDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ExpansionProfile.designation.include.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ExpansionProfile.designation.include.designation', 'use', elem.useElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExpansionProfileDesignationExclude(obj : TTurtleComplex) : TFhirExpansionProfileDesignationExclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileDesignationExclude.create;
  try
    ParseExpansionProfileDesignationExcludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileDesignationExcludeProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationExclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.designation.exclude.designation') do
      result.designationList.Add(parseExpansionProfileDesignationExcludeDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileDesignationExclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationExclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileDesignationExclude'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeExpansionProfileDesignationExcludeDesignation(this, 'ExpansionProfile.designation.exclude', 'designation', elem.designationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExpansionProfileDesignationExcludeDesignation(obj : TTurtleComplex) : TFhirExpansionProfileDesignationExcludeDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfileDesignationExcludeDesignation.create;
  try
    ParseExpansionProfileDesignationExcludeDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileDesignationExcludeDesignationProperties(obj : TTurtleComplex; result : TFhirExpansionProfileDesignationExcludeDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.exclude.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation.exclude.designation.use'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfileDesignationExcludeDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfileDesignationExcludeDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfileDesignationExcludeDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ExpansionProfile.designation.exclude.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ExpansionProfile.designation.exclude.designation', 'use', elem.useElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExpansionProfile(obj : TTurtleComplex) : TFhirExpansionProfile;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpansionProfile.create;
  try
    ParseExpansionProfileProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpansionProfileProperties(obj : TTurtleComplex; result : TFhirExpansionProfile);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ExpansionProfile.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExpansionProfile.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ExpansionProfile.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExpansionProfile.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExpansionProfile.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExpansionProfile.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ExpansionProfile.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExpansionProfile.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExpansionProfile.fixedVersion') do
      result.fixedVersionList.Add(parseExpansionProfileFixedVersion(item));
    result.excludedSystem := ParseExpansionProfileExcludedSystem(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludedSystem'));{q3b}
    result.includeDesignationsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.includeDesignations'));{q1}
    result.designation := ParseExpansionProfileDesignation(obj.complex('http://hl7.org/fhir/ExpansionProfile.designation'));{q3b}
    result.includeDefinitionElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.includeDefinition'));{q1}
    result.activeOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.activeOnly'));{q1}
    result.excludeNestedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludeNested'));{q1}
    result.excludeNotForUIElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludeNotForUI'));{q1}
    result.excludePostCoordinatedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.excludePostCoordinated'));{q1}
    result.displayLanguageElement := ParseCode(obj.complex('http://hl7.org/fhir/ExpansionProfile.displayLanguage'));{q1}
    result.limitedExpansionElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExpansionProfile.limitedExpansion'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExpansionProfile(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpansionProfile; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExpansionProfile'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ExpansionProfile', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ExpansionProfile', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ExpansionProfile', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ExpansionProfile', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ExpansionProfile', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ExpansionProfile', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ExpansionProfile', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ExpansionProfile', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ExpansionProfile', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ExpansionProfile', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ExpansionProfile', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ExpansionProfile', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fixedVersion') then
    for i := 0 to elem.fixedVersionList.Count - 1 do
      ComposeExpansionProfileFixedVersion(this, 'ExpansionProfile', 'fixedVersion', elem.fixedVersionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludedSystem') then
    ComposeExpansionProfileExcludedSystem(this, 'ExpansionProfile', 'excludedSystem', elem.excludedSystemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('includeDesignations') then
    ComposeBoolean(this, 'ExpansionProfile', 'includeDesignations', elem.includeDesignationsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('designation') then
    ComposeExpansionProfileDesignation(this, 'ExpansionProfile', 'designation', elem.designationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.includeDefinition <> false)) and doCompose('includeDefinition') then
    ComposeBoolean(this, 'ExpansionProfile', 'includeDefinition', elem.includeDefinitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.activeOnly <> false)) and doCompose('activeOnly') then
    ComposeBoolean(this, 'ExpansionProfile', 'activeOnly', elem.activeOnlyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludeNested') then
    ComposeBoolean(this, 'ExpansionProfile', 'excludeNested', elem.excludeNestedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludeNotForUI') then
    ComposeBoolean(this, 'ExpansionProfile', 'excludeNotForUI', elem.excludeNotForUIElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('excludePostCoordinated') then
    ComposeBoolean(this, 'ExpansionProfile', 'excludePostCoordinated', elem.excludePostCoordinatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('displayLanguage') then
    ComposeCode(this, 'ExpansionProfile', 'displayLanguage', elem.displayLanguageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('limitedExpansion') then
    ComposeBoolean(this, 'ExpansionProfile', 'limitedExpansion', elem.limitedExpansionElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRTurtleParser.ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitRelated.create;
  try
    ParseExplanationOfBenefitRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.claim'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.relationship'));{q3b}
    result.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit.related', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.related', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.related', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayee.create;
  try
    ParseExplanationOfBenefitPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayee);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.type'));{q3b}
    result.resourceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.resourceType'));{q3b}
    result.party := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayee'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payee', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payee', 'resourceType', elem.resourceTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'ExplanationOfBenefit.payee', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitInformation(obj : TTurtleComplex) : TFhirExplanationOfBenefitInformation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitInformation.create;
  try
    ParseExplanationOfBenefitInformationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitInformationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInformation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.information.sequence'));{q1}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.information.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.information.code'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.timingDate', item) then
      result.timing := parseDate(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.information.valueString', item) then
      result.value := parseString(item);
    result.reason := ParseCoding(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.information.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInformation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitInformation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.information', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.information', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.information', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.information', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.information', 'timingDate', TFhirDate(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ExplanationOfBenefit.information', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ExplanationOfBenefit.information', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.information', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.information', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ExplanationOfBenefit.information', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    ParseExplanationOfBenefitCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitCareTeam);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.sequence'));{q1}
    result.provider := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.provider'));{q3b}
    result.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.responsible'));{q1}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.role'));{q3b}
    result.qualification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.qualification'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitCareTeam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.careTeam', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeReference{Resource}(this, 'ExplanationOfBenefit.careTeam', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.careTeam', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'qualification', elem.qualificationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    ParseExplanationOfBenefitDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.sequence'));{q1}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.diagnosisCodeableConcept', item) then
      result.diagnosis := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.diagnosisReference', item) {a3} then
      result.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.packageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.packageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.diagnosis', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis), false, -1){x.d9}
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisReference', TFhirReference(elem.diagnosis), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'packageCode', elem.packageCodeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    ParseExplanationOfBenefitProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.sequence'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.date'));{q1}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.procedure.procedureCodeableConcept', item) then
      result.procedure_ := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.procedure.procedureReference', item) {a3} then
      result.procedure_ := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcedure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.procedure', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ExplanationOfBenefit.procedure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_), false, -1){x.d9}
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.procedure', 'procedureReference', TFhirReference(elem.procedure_), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    ParseExplanationOfBenefitInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance.coverage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.insurance.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCoverage}(this, 'ExplanationOfBenefit.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ExplanationOfBenefit.insurance', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAccident.create;
  try
    ParseExplanationOfBenefitAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.type'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.accident.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.accident.locationReference', item) {a3} then
      result.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAccident'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.accident', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.accident', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.accident', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.accident', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItem.create;
  try
    ParseExplanationOfBenefitItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.careTeamLinkId') do
      result.careTeamLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.diagnosisLinkId') do
      result.diagnosisLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.procedureLinkId') do
      result.procedureLinkIdList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.informationLinkId') do
      result.informationLinkIdList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.encounter') do
      result.encounterList.Add(parseReference{TFhirEncounter}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail') do
      result.detailList.Add(parseExplanationOfBenefitItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'careTeamLinkId', elem.careTeamLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'diagnosisLinkId', elem.diagnosisLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'procedureLinkId', elem.procedureLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'informationLinkId', elem.informationLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.item', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.item', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.item', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.item', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(this, 'ExplanationOfBenefit.item', 'encounter', elem.encounterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(this, 'ExplanationOfBenefit.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    ParseExplanationOfBenefitItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.category'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.reason'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    ParseExplanationOfBenefitItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.sequence'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.type'));{q3b}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail') do
      result.subDetailList.Add(parseExplanationOfBenefitItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item.detail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(this, 'ExplanationOfBenefit.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.sequence'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.type'));{q3b}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item.detail.subDetail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    ParseExplanationOfBenefitAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.sequenceLinkId') do
      result.sequenceLinkIdList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.fee := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail') do
      result.detailList.Add(parseExplanationOfBenefitAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'sequenceLinkId', elem.sequenceLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(this, 'ExplanationOfBenefit.addItem', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.category'));{q3b}
    result.service := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.service'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.fee := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.fee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'service', elem.serviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'fee', elem.feeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayment.create;
  try
    ParseExplanationOfBenefitPaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayment);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.type'));{q3b}
    result.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustment'));{q3b}
    result.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustmentReason'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.date'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.amount'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.identifier'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'adjustment', elem.adjustmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'adjustmentReason', elem.adjustmentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.payment', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.payment', 'identifier', elem.identifierElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    ParseExplanationOfBenefitProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.number'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.text'));{q1}
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.language'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ExplanationOfBenefit.processNote', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.processNote', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.processNote', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.processNote', 'language', elem.languageElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    ParseExplanationOfBenefitBenefitBalanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.category'));{q3b}
    result.subCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.subCategory'));{q3b}
    result.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.excluded'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.description'));{q1}
    result.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.network'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.unit'));{q3b}
    result.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.term'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial') do
      result.financialList.Add(parseExplanationOfBenefitBenefitBalanceFinancial(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'subCategory', elem.subCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.benefitBalance', 'excluded', elem.excludedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'term', elem.termElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(this, 'ExplanationOfBenefit.benefitBalance', 'financial', elem.financialList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalanceFinancial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.type'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedUnsignedInt', item) then
      result.allowed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedMoney', item) then
      result.allowed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedString', item) then
      result.allowed := parseString(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.usedUnsignedInt', item) then
      result.used := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.usedMoney', item) then
      result.used := parseMoney(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalanceFinancial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance.financial', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedMoney', TFhirMoney(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedString', TFhirString(elem.allowed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedMoney', TFhirMoney(elem.used), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.status'), CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.subType') do
      result.subTypeList.Add(parseCodeableConcept(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.patient'));{q3b}
    result.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.billablePeriod'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.enterer'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.organization'));{q3b}
    result.referral := ParseReference{TFhirReferralRequest}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.referral'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.facility'));{q3b}
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claim'));{q3b}
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claimResponse'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.disposition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.related') do
      result.relatedList.Add(parseExplanationOfBenefitRelated(item));
    result.prescription := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.prescription'));{q3b}
    result.originalPrescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.originalPrescription'));{q3b}
    result.payee := ParseExplanationOfBenefitPayee(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.information') do
      result.informationList.Add(parseExplanationOfBenefitInformation(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.careTeam') do
      result.careTeamList.Add(parseExplanationOfBenefitCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis') do
      result.diagnosisList.Add(parseExplanationOfBenefitDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure') do
      result.procedure_List.Add(parseExplanationOfBenefitProcedure(item));
    result.precedenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.precedence'));{q1}
    result.insurance := ParseExplanationOfBenefitInsurance(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance'));{q3b}
    result.accident := ParseExplanationOfBenefitAccident(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident'));{q3b}
    result.employmentImpacted := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.employmentImpacted'));{q3b}
    result.hospitalization := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.hospitalization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item') do
      result.itemList.Add(parseExplanationOfBenefitItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem') do
      result.addItemList.Add(parseExplanationOfBenefitAddItem(item));
    result.totalCost := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.totalCost'));{q3b}
    result.unallocDeductable := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.unallocDeductable'));{q3b}
    result.totalBenefit := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.totalBenefit'));{q3b}
    result.payment := ParseExplanationOfBenefitPayment(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment'));{q3b}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.processNote') do
      result.processNoteList.Add(parseExplanationOfBenefitProcessNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance') do
      result.benefitBalanceList.Add(parseExplanationOfBenefitBenefitBalance(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefit'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExplanationOfBenefit', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'ExplanationOfBenefit', 'status', elem.StatusElement, CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'subType', elem.subTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'ExplanationOfBenefit', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('billablePeriod') then
    ComposePeriod(this, 'ExplanationOfBenefit', 'billablePeriod', elem.billablePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ExplanationOfBenefit', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(this, 'ExplanationOfBenefit', 'referral', elem.referralElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'ExplanationOfBenefit', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('claim') then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('claimResponse') then
    ComposeReference{TFhirClaimResponse}(this, 'ExplanationOfBenefit', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'ExplanationOfBenefit', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(this, 'ExplanationOfBenefit', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(this, 'ExplanationOfBenefit', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'ExplanationOfBenefit', 'originalPrescription', elem.originalPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeExplanationOfBenefitPayee(this, 'ExplanationOfBenefit', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('information') then
    for i := 0 to elem.informationList.Count - 1 do
      ComposeExplanationOfBenefitInformation(this, 'ExplanationOfBenefit', 'information', elem.informationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(this, 'ExplanationOfBenefit', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(this, 'ExplanationOfBenefit', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(this, 'ExplanationOfBenefit', 'procedure', elem.procedure_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('precedence') then
    ComposePositiveInt(this, 'ExplanationOfBenefit', 'precedence', elem.precedenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    ComposeExplanationOfBenefitInsurance(this, 'ExplanationOfBenefit', 'insurance', elem.insuranceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeExplanationOfBenefitAccident(this, 'ExplanationOfBenefit', 'accident', elem.accidentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('employmentImpacted') then
    ComposePeriod(this, 'ExplanationOfBenefit', 'employmentImpacted', elem.employmentImpactedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposePeriod(this, 'ExplanationOfBenefit', 'hospitalization', elem.hospitalizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(this, 'ExplanationOfBenefit', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(this, 'ExplanationOfBenefit', 'addItem', elem.addItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('totalCost') then
    ComposeMoney(this, 'ExplanationOfBenefit', 'totalCost', elem.totalCostElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('unallocDeductable') then
    ComposeMoney(this, 'ExplanationOfBenefit', 'unallocDeductable', elem.unallocDeductableElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('totalBenefit') then
    ComposeMoney(this, 'ExplanationOfBenefit', 'totalBenefit', elem.totalBenefitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeExplanationOfBenefitPayment(this, 'ExplanationOfBenefit', 'payment', elem.paymentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(this, 'ExplanationOfBenefit', 'processNote', elem.processNoteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitBalance') then
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(this, 'ExplanationOfBenefit', 'benefitBalance', elem.benefitBalanceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRTurtleParser.ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.code'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.outcome'));{q3b}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetString', item) then
      result.onset := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistoryCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory.condition', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory.condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory.condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory.condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory.condition', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.status'), CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    result.notDoneElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.notDone'));{q1}
    result.notDoneReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.notDoneReason'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.date'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.name'));{q1}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.relationship'));{q3b}
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornPeriod', item) then
      result.born := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornDate', item) then
      result.born := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornString', item) then
      result.born := parseString(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageAge', item) then
      result.age := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageRange', item) then
      result.age := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageString', item) then
      result.age := parseString(item);
    result.estimatedAgeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.estimatedAge'));{q1}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedAge', item) then
      result.deceased := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedRange', item) then
      result.deceased := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedDate', item) then
      result.deceased := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedString', item) then
      result.deceased := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition') do
      result.conditionList.Add(parseFamilyMemberHistoryCondition(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistory'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FamilyMemberHistory', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'FamilyMemberHistory', 'definition', elem.definitionList[i], false, i);{x.d3}
  ComposeEnum(this, 'FamilyMemberHistory', 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.notDone <> false)) and doCompose('notDone') then
    ComposeBoolean(this, 'FamilyMemberHistory', 'notDone', elem.notDoneElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'notDoneReason', elem.notDoneReasonElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'FamilyMemberHistory', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'FamilyMemberHistory', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'FamilyMemberHistory', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'FamilyMemberHistory', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'FamilyMemberHistory', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory', 'bornPeriod', TFhirPeriod(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'bornDate', TFhirDate(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'bornString', TFhirString(elem.born), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'ageAge', TFhirAge(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'ageRange', TFhirRange(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'ageString', TFhirString(elem.age), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('estimatedAge') then
    ComposeBoolean(this, 'FamilyMemberHistory', 'estimatedAge', elem.estimatedAgeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'deceasedAge', TFhirAge(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'deceasedRange', TFhirRange(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'FamilyMemberHistory', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'deceasedDate', TFhirDate(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'deceasedString', TFhirString(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'FamilyMemberHistory', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'FamilyMemberHistory', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(this, 'FamilyMemberHistory', 'condition', elem.conditionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRTurtleParser.ParseFlag(obj : TTurtleComplex) : TFhirFlag;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFlag.create;
  try
    ParseFlagProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Flag.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Flag.status'), CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Flag.subject'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Flag.period'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Flag.encounter'));{q3b}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Flag.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Flag'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Flag', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Flag', 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Flag', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Flag', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Flag', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Flag', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Flag', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Flag', 'author', elem.authorElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
function TFHIRTurtleParser.ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoalTarget.create;
  try
    ParseGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalTargetProperties(obj : TTurtleComplex; result : TFhirGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.target.measure'));{q3b}
    if obj.has('http://hl7.org/fhir/Goal.target.detailQuantity', item) then
      result.detail := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailRange', item) then
      result.detail := parseRange(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailCodeableConcept', item) then
      result.detail := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.target.dueDuration', item) then
      result.due := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Goal.target.dueDate', item) then
      result.due := parseDate(item);
end;

procedure TFHIRTurtleComposer.ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GoalTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal.target', 'measure', elem.measureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Goal.target', 'detailQuantity', TFhirQuantity(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(this, 'Goal.target', 'detailRange', TFhirRange(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal.target', 'detailCodeableConcept', TFhirCodeableConcept(elem.detail), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDuration) {6} then
    ComposeDuration(this, 'Goal.target', 'dueDuration', TFhirDuration(elem.due), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDate) {6} then
    ComposeDate(this, 'Goal.target', 'dueDate', TFhirDate(elem.due), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseGoal(obj : TTurtleComplex) : TFhirGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoal.create;
  try
    ParseGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Goal.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Goal.status'), CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Goal.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.priority'));{q3b}
    result.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.description'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Goal.subject'));{q3b}
    if obj.has('http://hl7.org/fhir/Goal.startCodeableConcept', item) then
      result.start := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.startDate', item) then
      result.start := parseDate(item);
    result.target := ParseGoalTarget(obj.complex('http://hl7.org/fhir/Goal.target'));{q3b}
    result.statusDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Goal.statusDate'));{q1}
    result.statusReasonElement := ParseString(obj.complex('http://hl7.org/fhir/Goal.statusReason'));{q1}
    result.expressedBy := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Goal.expressedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Goal.addresses') do
      result.addressesList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcomeCode') do
      result.outcomeCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcomeReference') do
      result.outcomeReferenceList.Add(parseReference{TFhirObservation}(item));
end;

procedure TFHIRTurtleComposer.ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Goal'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Goal', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Goal', 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Goal', 'priority', elem.priorityElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Goal', 'description', elem.descriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Goal', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal', 'startCodeableConcept', TFhirCodeableConcept(elem.start), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'startDate', TFhirDate(elem.start), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeGoalTarget(this, 'Goal', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDate(this, 'Goal', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeString(this, 'Goal', 'statusReason', elem.statusReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('expressedBy') then
    ComposeReference{Resource}(this, 'Goal', 'expressedBy', elem.expressedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(this, 'Goal', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Goal', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeCode') then
    for i := 0 to elem.outcomeCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'outcomeCode', elem.outcomeCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeReference') then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'Goal', 'outcomeReference', elem.outcomeReferenceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
function TFHIRTurtleParser.ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLink.create;
  try
    ParseGraphDefinitionLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLink);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.path'));{q1}
    result.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.sliceName'));{q1}
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/GraphDefinition.link.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.max'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target') do
      result.targetList.Add(parseGraphDefinitionLinkTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'GraphDefinition.link', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'sliceName', elem.sliceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'GraphDefinition.link', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(this, 'GraphDefinition.link', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    ParseGraphDefinitionLinkTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseUri(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.profile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.compartment') do
      result.compartmentList.Add(parseGraphDefinitionLinkTargetCompartment(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.link') do
      result.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'GraphDefinition.link.target', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(this, 'GraphDefinition.link.target', 'compartment', elem.compartmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition.link.target', 'link', elem.link_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    ParseGraphDefinitionLinkTargetCompartmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTargetCompartment);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    result.ruleElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.rule'), CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum);
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.expression'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTargetCompartment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);{x.d4}
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'rule', elem.RuleElement, CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinition.create;
  try
    ParseGraphDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionProperties(obj : TTurtleComplex; result : TFhirGraphDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/GraphDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/GraphDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GraphDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.purpose'));{q1}
    result.startElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.start'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseUri(obj.complex('http://hl7.org/fhir/GraphDefinition.profile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link') do
      result.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'GraphDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'GraphDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'GraphDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'GraphDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'GraphDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'GraphDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'GraphDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'GraphDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'GraphDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'GraphDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'GraphDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'GraphDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'GraphDefinition', 'start', elem.StartElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeUri(this, 'GraphDefinition', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
function TFHIRTurtleParser.ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.characteristic.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueBoolean', item) then
      result.value := parseBoolean(item);
    result.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.characteristic.exclude'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.characteristic.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Group.characteristic', 'code', elem.codeElement, false, -1);{x.2f}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Group.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Group.characteristic', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Group.characteristic', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Group.characteristic', 'valueBoolean', TFhirBoolean(elem.value), false, -1);{x.d9}
  ComposeBoolean(this, 'Group.characteristic', 'exclude', elem.excludeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.characteristic', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember);
begin
    ParseBackboneElementProperties(obj, result);
    result.entity := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Group.member.entity'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.member.period'));{q3b}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.member.inactive'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupMember'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Group.member', 'entity', elem.entityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.member', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(this, 'Group.member', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseGroup(obj : TTurtleComplex) : TFhirGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroup.create;
  try
    ParseGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Group.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.active'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Group.type'), CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    result.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.actual'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.code'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Group.name'));{q1}
    result.quantityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Group.quantity'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Group.characteristic') do
      result.characteristicList.Add(parseGroupCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/Group.member') do
      result.memberList.Add(parseGroupMember(item));
end;

procedure TFHIRTurtleComposer.ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Group'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Group', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Group', 'active', elem.activeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Group', 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'Group', 'actual', elem.actualElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Group', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedInt(this, 'Group', 'quantity', elem.quantityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(this, 'Group', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('member') then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(this, 'Group', 'member', elem.memberList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
function TFHIRTurtleParser.ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGuidanceResponse.create;
  try
    ParseGuidanceResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGuidanceResponseProperties(obj : TTurtleComplex; result : TFhirGuidanceResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.requestIdElement := ParseId(obj.complex('http://hl7.org/fhir/GuidanceResponse.requestId'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/GuidanceResponse.identifier'));{q3b}
    result.module := ParseReference{TFhirServiceDefinition}(obj.complex('http://hl7.org/fhir/GuidanceResponse.module'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GuidanceResponse.status'), CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/GuidanceResponse.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/GuidanceResponse.context'));{q3b}
    result.occurrenceDateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GuidanceResponse.occurrenceDateTime'));{q1}
    result.performer := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/GuidanceResponse.performer'));{q3b}
    if obj.has('http://hl7.org/fhir/GuidanceResponse.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/GuidanceResponse.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.evaluationMessage') do
      result.evaluationMessageList.Add(parseReference{TFhirOperationOutcome}(item));
    result.outputParameters := ParseReference{TFhirParameters}(obj.complex('http://hl7.org/fhir/GuidanceResponse.outputParameters'));{q3b}
    result.result := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/GuidanceResponse.result'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.dataRequirement') do
      result.dataRequirementList.Add(parseDataRequirement(item));
end;

procedure TFHIRTurtleComposer.ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGuidanceResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GuidanceResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestId') then
    ComposeId(this, 'GuidanceResponse', 'requestId', elem.requestIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'GuidanceResponse', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeReference{TFhirServiceDefinition}(this, 'GuidanceResponse', 'module', elem.moduleElement, false, -1);{x.2f}
  ComposeEnum(this, 'GuidanceResponse', 'status', elem.StatusElement, CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'GuidanceResponse', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'GuidanceResponse', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('occurrenceDateTime') then
    ComposeDateTime(this, 'GuidanceResponse', 'occurrenceDateTime', elem.occurrenceDateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirDevice}(this, 'GuidanceResponse', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'GuidanceResponse', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'GuidanceResponse', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'GuidanceResponse', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evaluationMessage') then
    for i := 0 to elem.evaluationMessageList.Count - 1 do
      ComposeReference{TFhirOperationOutcome}(this, 'GuidanceResponse', 'evaluationMessage', elem.evaluationMessageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outputParameters') then
    ComposeReference{TFhirParameters}(this, 'GuidanceResponse', 'outputParameters', elem.outputParametersElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    ComposeReference{Resource}(this, 'GuidanceResponse', 'result', elem.resultElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'GuidanceResponse', 'dataRequirement', elem.dataRequirementList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRTurtleParser.ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseHealthcareServiceAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.allDay'));{q1}
    result.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableStartTime'));{q1}
    result.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableEndTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceAvailableTime'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareService.availableTime', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableStartTime', elem.availableStartTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableEndTime', elem.availableEndTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseHealthcareServiceNotAvailableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.description'));{q1}
    result.during := ParsePeriod(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.during'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceNotAvailable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'HealthcareService.notAvailable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'HealthcareService.notAvailable', 'during', elem.duringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.active'));{q1}
    result.providedBy := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/HealthcareService.providedBy'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.category'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.name'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.comment'));{q1}
    result.extraDetailsElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.extraDetails'));{q1}
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/HealthcareService.photo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.coverageArea') do
      result.coverageAreaList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceProvisionCode') do
      result.serviceProvisionCodeList.Add(parseCodeableConcept(item));
    result.eligibility := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility'));{q3b}
    result.eligibilityNoteElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.eligibilityNote'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.programName') do
      result.programNameList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.characteristic') do
      result.characteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.referralMethod') do
      result.referralMethodList.Add(parseCodeableConcept(item));
    result.appointmentRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.appointmentRequired'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime') do
      result.availableTimeList.Add(parseHealthcareServiceAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.notAvailable') do
      result.notAvailableList.Add(parseHealthcareServiceNotAvailable(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.availabilityExceptions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareService'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'HealthcareService', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'HealthcareService', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(this, 'HealthcareService', 'providedBy', elem.providedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'HealthcareService', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'HealthcareService', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(this, 'HealthcareService', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeString(this, 'HealthcareService', 'extraDetails', elem.extraDetailsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'HealthcareService', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'HealthcareService', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'coverageArea', elem.coverageAreaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'serviceProvisionCode', elem.serviceProvisionCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    ComposeCodeableConcept(this, 'HealthcareService', 'eligibility', elem.eligibilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeString(this, 'HealthcareService', 'eligibilityNote', elem.eligibilityNoteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('programName') then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(this, 'HealthcareService', 'programName', elem.programNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'referralMethod', elem.referralMethodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBoolean(this, 'HealthcareService', 'appointmentRequired', elem.appointmentRequiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(this, 'HealthcareService', 'availableTime', elem.availableTimeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(this, 'HealthcareService', 'notAvailable', elem.notAvailableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'HealthcareService', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'HealthcareService', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
function TFHIRTurtleParser.ParseImagingManifestStudy(obj : TTurtleComplex) : TFhirImagingManifestStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingManifestStudy.create;
  try
    ParseImagingManifestStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingManifestStudyProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudy);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingManifest.study.uid'));{q1}
    result.imagingStudy := ParseReference{TFhirImagingStudy}(obj.complex('http://hl7.org/fhir/ImagingManifest.study.imagingStudy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingManifest.study.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingManifest.study.series') do
      result.seriesList.Add(parseImagingManifestStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingManifestStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingManifestStudy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingManifest.study', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(this, 'ImagingManifest.study', 'imagingStudy', elem.imagingStudyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingManifest.study', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingManifestStudySeries(this, 'ImagingManifest.study', 'series', elem.seriesList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingManifestStudySeries(obj : TTurtleComplex) : TFhirImagingManifestStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingManifestStudySeries.create;
  try
    ParseImagingManifestStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingManifestStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingManifest.study.series.uid'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingManifest.study.series.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingManifest.study.series.instance') do
      result.instanceList.Add(parseImagingManifestStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingManifestStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingManifestStudySeries'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingManifest.study.series', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingManifest.study.series', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingManifestStudySeriesInstance(this, 'ImagingManifest.study.series', 'instance', elem.instanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingManifestStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingManifestStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingManifestStudySeriesInstance.create;
  try
    ParseImagingManifestStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingManifestStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingManifestStudySeriesInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.sopClassElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingManifest.study.series.instance.sopClass'));{q1}
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingManifest.study.series.instance.uid'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImagingManifestStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifestStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingManifestStudySeriesInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingManifest.study.series.instance', 'sopClass', elem.sopClassElement, false, -1);{x.2ea}
  ComposeOid(this, 'ImagingManifest.study.series.instance', 'uid', elem.uidElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImagingManifest(obj : TTurtleComplex) : TFhirImagingManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingManifest.create;
  try
    ParseImagingManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingManifestProperties(obj : TTurtleComplex; result : TFhirImagingManifest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ImagingManifest.identifier'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImagingManifest.patient'));{q3b}
    result.authoringTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingManifest.authoringTime'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ImagingManifest.author'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingManifest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingManifest.study') do
      result.studyList.Add(parseImagingManifestStudy(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingManifest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ImagingManifest', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'ImagingManifest', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTime(this, 'ImagingManifest', 'authoringTime', elem.authoringTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'ImagingManifest', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImagingManifest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingManifestStudy(this, 'ImagingManifest', 'study', elem.studyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRTurtleParser.ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.uid'));{q1}
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.number'));{q1}
    result.modality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.modality'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.description'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.numberOfInstances'));{q1}
    result.availabilityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.series.availability'), CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    result.bodySite := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.bodySite'));{q3b}
    result.laterality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.laterality'));{q3b}
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.series.started'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.performer') do
      result.performerList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.instance') do
      result.instanceList.Add(parseImagingStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeries'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingStudy.series', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'number', elem.numberElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ImagingStudy.series', 'modality', elem.modalityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ImagingStudy.series', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingStudy.series', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'laterality', elem.lateralityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy.series', 'started', elem.startedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ImagingStudy.series', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(this, 'ImagingStudy.series', 'instance', elem.instanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.uid'));{q1}
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.number'));{q1}
    result.sopClassElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.sopClass'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.title'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingStudy.series.instance', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series.instance', 'number', elem.numberElement, false, -1);{x.2ea}
  ComposeOid(this, 'ImagingStudy.series.instance', 'sopClass', elem.sopClassElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImagingStudy.series.instance', 'title', elem.titleElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.uidElement := ParseOid(obj.complex('http://hl7.org/fhir/ImagingStudy.uid'));{q1}
    result.accession := ParseIdentifier(obj.complex('http://hl7.org/fhir/ImagingStudy.accession'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.availabilityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.availability'), CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.modalityList') do
      result.modalityListList.Add(parseCoding(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImagingStudy.patient'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ImagingStudy.context'));{q3b}
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.started'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    result.referrer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ImagingStudy.referrer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.interpreter') do
      result.interpreterList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    result.numberOfSeriesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfSeries'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfInstances'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.procedureReference') do
      result.procedureReferenceList.Add(parseReference{TFhirProcedure}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.procedureCode') do
      result.procedureCodeList.Add(parseCodeableConcept(item));
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingStudy.reason'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series') do
      result.seriesList.Add(parseImagingStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudy'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeOid(this, 'ImagingStudy', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accession') then
    ComposeIdentifier(this, 'ImagingStudy', 'accession', elem.accessionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingStudy', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnum(this, 'ImagingStudy', 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modalityList') then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(this, 'ImagingStudy', 'modalityList', elem.modalityListList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'ImagingStudy', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'ImagingStudy', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTime(this, 'ImagingStudy', 'started', elem.startedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'ImagingStudy', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'referrer', elem.referrerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    for i := 0 to elem.interpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'interpreter', elem.interpreterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingStudy', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSeries') then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfSeries', elem.numberOfSeriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfInstances') then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureReference') then
    for i := 0 to elem.procedureReferenceList.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'ImagingStudy', 'procedureReference', elem.procedureReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureCode') then
    for i := 0 to elem.procedureCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImagingStudy', 'procedureCode', elem.procedureCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'ImagingStudy', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImagingStudy', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(this, 'ImagingStudy', 'series', elem.seriesList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRTurtleParser.ParseImmunizationPractitioner(obj : TTurtleComplex) : TFhirImmunizationPractitioner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationPractitioner.create;
  try
    ParseImmunizationPractitionerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationPractitionerProperties(obj : TTurtleComplex; result : TFhirImmunizationPractitioner);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.practitioner.role'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Immunization.practitioner.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationPractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationPractitioner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationPractitioner'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Immunization.practitioner', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'Immunization.practitioner', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImmunizationExplanation(obj : TTurtleComplex) : TFhirImmunizationExplanation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationExplanation.create;
  try
    ParseImmunizationExplanationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationExplanationProperties(obj : TTurtleComplex; result : TFhirImmunizationExplanation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.explanation.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.explanation.reasonNotGiven') do
      result.reasonNotGivenList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationExplanation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationExplanation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationExplanation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.explanation', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.explanation', 'reasonNotGiven', elem.reasonNotGivenList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.reaction.date'));{q1}
    result.detail := ParseReference{TFhirObservation}(obj.complex('http://hl7.org/fhir/Immunization.reaction.detail'));{q3b}
    result.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.reaction.reported'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.reaction', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(this, 'Immunization.reaction', 'detail', elem.detailElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization.reaction', 'reported', elem.reportedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationVaccinationProtocol(obj : TTurtleComplex) : TFhirImmunizationVaccinationProtocol;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseImmunizationVaccinationProtocolProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationVaccinationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationVaccinationProtocol);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.doseSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseSequence'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.description'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.authority'));{q3b}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.series'));{q1}
    result.seriesDosesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.seriesDoses'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.vaccinationProtocol.targetDisease') do
      result.targetDiseaseList.Add(parseCodeableConcept(item));
    result.doseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseStatus'));{q3b}
    result.doseStatusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccinationProtocol.doseStatusReason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationVaccinationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationVaccinationProtocol; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationVaccinationProtocol'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Immunization.vaccinationProtocol', 'doseSequence', elem.doseSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.vaccinationProtocol', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Immunization.vaccinationProtocol', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.vaccinationProtocol', 'series', elem.seriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Immunization.vaccinationProtocol', 'seriesDoses', elem.seriesDosesElement, false, -1);{x.2ea}
  for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'targetDisease', elem.targetDiseaseList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'doseStatus', elem.doseStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization.vaccinationProtocol', 'doseStatusReason', elem.doseStatusReasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImmunization(obj : TTurtleComplex) : TFhirImmunization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Immunization.status'), CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum);
    result.notGivenElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.notGiven'));{q1}
    result.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccineCode'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Immunization.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Immunization.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.date'));{q1}
    result.primarySourceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.primarySource'));{q1}
    result.reportOrigin := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.reportOrigin'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Immunization.location'));{q3b}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.manufacturer'));{q3b}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.lotNumber'));{q1}
    result.expirationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Immunization.expirationDate'));{q1}
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.route'));{q3b}
    result.doseQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Immunization.doseQuantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.practitioner') do
      result.practitionerList.Add(parseImmunizationPractitioner(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.note') do
      result.noteList.Add(parseAnnotation(item));
    result.explanation := ParseImmunizationExplanation(obj.complex('http://hl7.org/fhir/Immunization.explanation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reaction') do
      result.reactionList.Add(parseImmunizationReaction(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.vaccinationProtocol') do
      result.vaccinationProtocolList.Add(parseImmunizationVaccinationProtocol(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Immunization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Immunization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Immunization', 'status', elem.StatusElement, CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'Immunization', 'notGiven', elem.notGivenElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Immunization', 'vaccineCode', elem.vaccineCodeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Immunization', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Immunization', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Immunization', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'Immunization', 'primarySource', elem.primarySourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reportOrigin') then
    ComposeCodeableConcept(this, 'Immunization', 'reportOrigin', elem.reportOriginElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Immunization', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Immunization', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Immunization', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDate(this, 'Immunization', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(this, 'Immunization', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(this, 'Immunization', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(this, 'Immunization', 'doseQuantity', elem.doseQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    for i := 0 to elem.practitionerList.Count - 1 do
      ComposeImmunizationPractitioner(this, 'Immunization', 'practitioner', elem.practitionerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Immunization', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('explanation') then
    ComposeImmunizationExplanation(this, 'Immunization', 'explanation', elem.explanationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(this, 'Immunization', 'reaction', elem.reactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('vaccinationProtocol') then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(this, 'Immunization', 'vaccinationProtocol', elem.vaccinationProtocolList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.date'));{q1}
    result.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.vaccineCode'));{q3b}
    result.targetDisease := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.targetDisease'));{q3b}
    result.doseNumberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.doseNumber'));{q1}
    result.forecastStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion') do
      result.dateCriterionList.Add(parseImmunizationRecommendationRecommendationDateCriterion(item));
    result.protocol := ParseImmunizationRecommendationRecommendationProtocol(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingImmunization') do
      result.supportingImmunizationList.Add(parseReference{TFhirImmunization}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingPatientInformation') do
      result.supportingPatientInformationList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'vaccineCode', elem.vaccineCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'targetDisease', elem.targetDiseaseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ImmunizationRecommendation.recommendation', 'doseNumber', elem.doseNumberElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastStatus', elem.forecastStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(this, 'ImmunizationRecommendation.recommendation', 'dateCriterion', elem.dateCriterionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(this, 'ImmunizationRecommendation.recommendation', 'protocol', elem.protocolElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(this, 'ImmunizationRecommendation.recommendation', 'supportingImmunization', elem.supportingImmunizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(this, 'ImmunizationRecommendation.recommendation', 'supportingPatientInformation', elem.supportingPatientInformationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.code'));{q3b}
    result.valueElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationDateCriterion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProtocol(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseImmunizationRecommendationRecommendationProtocolProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProtocolProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationProtocol);
begin
    ParseBackboneElementProperties(obj, result);
    result.doseSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.doseSequence'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.description'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.authority'));{q3b}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.protocol.series'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationProtocol(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationProtocol'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ImmunizationRecommendation.recommendation.protocol', 'doseSequence', elem.doseSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation.protocol', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationRecommendation.recommendation.protocol', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation.protocol', 'series', elem.seriesElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation') do
      result.recommendationList.Add(parseImmunizationRecommendationRecommendation(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationRecommendation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'ImmunizationRecommendation', 'patient', elem.patientElement, false, -1);{x.2f}
  for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(this, 'ImmunizationRecommendation', 'recommendation', elem.recommendationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRTurtleParser.ParseImplementationGuideDependency(obj : TTurtleComplex) : TFhirImplementationGuideDependency;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDependency.create;
  try
    ParseImplementationGuideDependencyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDependencyProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependency);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependency.type'), CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum);
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependency.uri'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDependency(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependency; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDependency'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.dependency', 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, false, -1);{x.d4}
  ComposeUri(this, 'ImplementationGuide.dependency', 'uri', elem.uriElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuidePackage(obj : TTurtleComplex) : TFhirImplementationGuidePackage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePackage.create;
  try
    ParseImplementationGuidePackageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePackageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.package.resource') do
      result.resourceList.Add(parseImplementationGuidePackageResource(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePackage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ImplementationGuide.package', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(this, 'ImplementationGuide.package', 'resource', elem.resourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuidePackageResource(obj : TTurtleComplex) : TFhirImplementationGuidePackageResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePackageResource.create;
  try
    ParseImplementationGuidePackageResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePackageResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePackageResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.exampleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.example'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.description'));{q1}
    result.acronymElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.acronym'));{q1}
    if obj.has('http://hl7.org/fhir/ImplementationGuide.package.resource.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.package.resource.sourceUri', item) then
      result.source := parseUri(item);
    result.exampleFor := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/ImplementationGuide.package.resource.exampleFor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePackageResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePackageResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePackageResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'ImplementationGuide.package.resource', 'example', elem.exampleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.package.resource', 'acronym', elem.acronymElement, false, -1);{x.2ea}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'ImplementationGuide.package.resource', 'sourceReference', TFhirReference(elem.source), false,-1){x.d8}
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ImplementationGuide.package.resource', 'sourceUri', TFhirUri(elem.source), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuide.package.resource', 'exampleFor', elem.exampleForElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideGlobal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.global', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeReference{TFhirStructureDefinition}(this, 'ImplementationGuide.global', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImplementationGuidePage(obj : TTurtleComplex) : TFhirImplementationGuidePage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuidePage.create;
  try
    ParseImplementationGuidePageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuidePageProperties(obj : TTurtleComplex; result : TFhirImplementationGuidePage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.source'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.title'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.kind'), CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.type') do
      result.type_.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.package') do
      result.packageList.Add(parseString(item));
    result.formatElement := ParseCode(obj.complex('http://hl7.org/fhir/ImplementationGuide.page.format'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.page.page') do
      result.pageList.Add(parseImplementationGuidePage(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuidePage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuidePage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuidePage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ImplementationGuide.page', 'source', elem.sourceElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide.page', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide.page', 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.page', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.page', 'type', elem.type_[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.page', 'package', elem.packageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ImplementationGuide.page', 'format', elem.formatElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(this, 'ImplementationGuide.page', 'page', elem.pageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImplementationGuide.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.copyright'));{q1}
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.fhirVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.dependency') do
      result.dependencyList.Add(parseImplementationGuideDependency(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.package') do
      result.packageList.Add(parseImplementationGuidePackage(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.global') do
      result.globalList.Add(parseImplementationGuideGlobal(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.binary') do
      result.binaryList.Add(parseUri(item));
    result.page := ParseImplementationGuidePage(obj.complex('http://hl7.org/fhir/ImplementationGuide.page'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuide'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'ImplementationGuide', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ImplementationGuide', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ImplementationGuide', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ImplementationGuide', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ImplementationGuide', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ImplementationGuide', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ImplementationGuide', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ImplementationGuide', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ImplementationGuide', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ImplementationGuide', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(this, 'ImplementationGuide', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependency') then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(this, 'ImplementationGuide', 'dependency', elem.dependencyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('package') then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(this, 'ImplementationGuide', 'package', elem.packageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(this, 'ImplementationGuide', 'global', elem.globalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('binary') then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(this, 'ImplementationGuide', 'binary', elem.binaryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('page') then
    ComposeImplementationGuidePage(this, 'ImplementationGuide', 'page', elem.pageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
function TFHIRTurtleParser.ParseLibrary(obj : TTurtleComplex) : TFhirLibrary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLibrary.create;
  try
    ParseLibraryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLibraryProperties(obj : TTurtleComplex; result : TFhirLibrary);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Library.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Library.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Library.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Library.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Library.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Library.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Library.experimental'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Library.type'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Library.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Library.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Library.usage'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Library.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Library.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.contributor') do
      result.contributorList.Add(parseContributor(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Library.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.parameter') do
      result.parameterList.Add(parseParameterDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.dataRequirement') do
      result.dataRequirementList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.content') do
      result.contentList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLibrary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Library'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Library', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Library', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Library', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Library', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Library', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Library', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Library', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Library', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Library', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Library', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Library', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Library', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'Library', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Library', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Library', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Library', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Library', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(this, 'Library', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Library', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Library', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParameterDefinition(this, 'Library', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'Library', 'dataRequirement', elem.dataRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('content') then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(this, 'Library', 'content', elem.contentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
function TFHIRTurtleParser.ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkageItem.create;
  try
    ParseLinkageItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageItemProperties(obj : TTurtleComplex; result : TFhirLinkageItem);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Linkage.item.type'), CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum);
    result.resource := ParseReference(obj.complex('http://hl7.org/fhir/Linkage.item.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkageItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LinkageItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Linkage.item', 'type', elem.Type_Element, CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum, false, -1);{x.d4}
  ComposeReference(this, 'Linkage.item', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseLinkage(obj : TTurtleComplex) : TFhirLinkage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkage.create;
  try
    ParseLinkageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageProperties(obj : TTurtleComplex; result : TFhirLinkage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Linkage.active'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Linkage.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Linkage.item') do
      result.itemList.Add(parseLinkageItem(item));
end;

procedure TFHIRTurtleComposer.ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Linkage'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Linkage', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'Linkage', 'author', elem.authorElement, false, -1);{x.2f}
  for i := 0 to elem.itemList.Count - 1 do
      ComposeLinkageItem(this, 'Linkage', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
function TFHIRTurtleParser.ParseListEntry(obj : TTurtleComplex) : TFhirListEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry);
begin
    ParseBackboneElementProperties(obj, result);
    result.flag := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.entry.flag'));{q3b}
    result.deletedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/List.entry.deleted'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.entry.date'));{q1}
    result.item := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/List.entry.item'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ListEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List.entry', 'flag', elem.flagElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBoolean(this, 'List.entry', 'deleted', elem.deletedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'List.entry', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeReference{TFhirReference}(this, 'List.entry', 'item', elem.itemElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseList(obj : TTurtleComplex) : TFhirList;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirList.create;
  try
    ParseListProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListProperties(obj : TTurtleComplex; result : TFhirList);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/List.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.status'), CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/List.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/List.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/List.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.date'));{q1}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/List.source'));{q3b}
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.orderedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/List.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/List.entry') do
      result.entryList.Add(parseListEntry(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.emptyReason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:List'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'List', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'List', 'status', elem.StatusElement, CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'List', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'List', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'List', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'List', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'List', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'List', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'List', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(this, 'List', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'List', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('entry') then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(this, 'List', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(this, 'List', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRTurtleParser.ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(obj, result);
    result.longitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.longitude'));{q1}
    result.latitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.latitude'));{q1}
    result.altitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.altitude'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LocationPosition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDecimal(this, 'Location.position', 'longitude', elem.longitudeElement, false, -1);{x.2ea}
  ComposeDecimal(this, 'Location.position', 'latitude', elem.latitudeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Location.position', 'altitude', elem.altitudeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseLocation(obj : TTurtleComplex) : TFhirLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocation.create;
  try
    ParseLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Location.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.status'), CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    result.operationalStatus := ParseCoding(obj.complex('http://hl7.org/fhir/Location.operationalStatus'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Location.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Location.alias') do
      result.aliasList.Add(parseString(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Location.description'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.mode'), CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Location.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Location.address'));{q3b}
    result.physicalType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.physicalType'));{q3b}
    result.position := ParseLocationPosition(obj.complex('http://hl7.org/fhir/Location.position'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Location.managingOrganization'));{q3b}
    result.partOf := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Location.partOf'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Location.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Location'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Location', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Location', 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeCoding(this, 'Location', 'operationalStatus', elem.operationalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Location', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'Location', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Location', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnum(this, 'Location', 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Location', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Location', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(this, 'Location', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(this, 'Location', 'physicalType', elem.physicalTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(this, 'Location', 'position', elem.positionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Location', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(this, 'Location', 'partOf', elem.partOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'Location', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
function TFHIRTurtleParser.ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroup.create;
  try
    ParseMeasureGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupProperties(obj : TTurtleComplex; result : TFhirMeasureGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Measure.group.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.population') do
      result.populationList.Add(parseMeasureGroupPopulation(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.stratifier') do
      result.stratifierList.Add(parseMeasureGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeIdentifier(this, 'Measure.group', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(this, 'Measure.group', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(this, 'Measure.group', 'stratifier', elem.stratifierList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupPopulation.create;
  try
    ParseMeasureGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureGroupPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Measure.group.population.identifier'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.population.code'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.description'));{q1}
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.criteria'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Measure.group.population', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.population', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.population', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeString(this, 'Measure.group.population', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupStratifier.create;
  try
    ParseMeasureGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifier);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.identifier'));{q3b}
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.criteria'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.path'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupStratifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Measure.group.stratifier', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier', 'path', elem.pathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureSupplementalData.create;
  try
    ParseMeasureSupplementalDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; result : TFhirMeasureSupplementalData);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Measure.supplementalData.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData.usage') do
      result.usageList.Add(parseCodeableConcept(item));
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.supplementalData.criteria'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.supplementalData.path'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureSupplementalData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureSupplementalData'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Measure.supplementalData', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usageList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure.supplementalData', 'usage', elem.usageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.supplementalData', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.supplementalData', 'path', elem.pathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMeasure(obj : TTurtleComplex) : TFhirMeasure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasure.create;
  try
    ParseMeasureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureProperties(obj : TTurtleComplex; result : TFhirMeasure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Measure.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Measure.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Measure.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Measure.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.usage'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Measure.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.contributor') do
      result.contributorList.Add(parseContributor(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.library') do
      result.library_List.Add(parseReference{TFhirLibrary}(item));
    result.disclaimerElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.disclaimer'));{q1}
    result.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.scoring'));{q3b}
    result.compositeScoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.compositeScoring'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.riskAdjustmentElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.riskAdjustment'));{q1}
    result.rateAggregationElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.rateAggregation'));{q1}
    result.rationaleElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.rationale'));{q1}
    result.clinicalRecommendationStatementElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.clinicalRecommendationStatement'));{q1}
    result.improvementNotationElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.improvementNotation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.definition') do
      result.definitionList.Add(parseMarkdown(item));
    result.guidanceElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.guidance'));{q1}
    result.set_Element := ParseString(obj.complex('http://hl7.org/fhir/Measure.set'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.group') do
      result.groupList.Add(parseMeasureGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData') do
      result.supplementalDataList.Add(parseMeasureSupplementalData(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Measure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Measure', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Measure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Measure', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Measure', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Measure', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Measure', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Measure', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Measure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Measure', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Measure', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Measure', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'Measure', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Measure', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Measure', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Measure', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Measure', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(this, 'Measure', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Measure', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Measure', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(this, 'Measure', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disclaimer') then
    ComposeMarkdown(this, 'Measure', 'disclaimer', elem.disclaimerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('scoring') then
    ComposeCodeableConcept(this, 'Measure', 'scoring', elem.scoringElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositeScoring') then
    ComposeCodeableConcept(this, 'Measure', 'compositeScoring', elem.compositeScoringElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskAdjustment') then
    ComposeString(this, 'Measure', 'riskAdjustment', elem.riskAdjustmentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rateAggregation') then
    ComposeString(this, 'Measure', 'rateAggregation', elem.rateAggregationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rationale') then
    ComposeMarkdown(this, 'Measure', 'rationale', elem.rationaleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalRecommendationStatement') then
    ComposeMarkdown(this, 'Measure', 'clinicalRecommendationStatement', elem.clinicalRecommendationStatementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeString(this, 'Measure', 'improvementNotation', elem.improvementNotationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeMarkdown(this, 'Measure', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('guidance') then
    ComposeMarkdown(this, 'Measure', 'guidance', elem.guidanceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('set_') then
    ComposeString(this, 'Measure', 'set', elem.set_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureGroup(this, 'Measure', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supplementalData') then
    for i := 0 to elem.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(this, 'Measure', 'supplementalData', elem.supplementalDataList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
function TFHIRTurtleParser.ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroup.create;
  try
    ParseMeasureReportGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MeasureReport.group.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.population') do
      result.populationList.Add(parseMeasureReportGroupPopulation(item));
    result.measureScoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MeasureReport.group.measureScore'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier') do
      result.stratifierList.Add(parseMeasureReportGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeIdentifier(this, 'MeasureReport.group', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(this, 'MeasureReport.group', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MeasureReport.group', 'measureScore', elem.measureScoreElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(this, 'MeasureReport.group', 'stratifier', elem.stratifierList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupPopulation.create;
  try
    ParseMeasureReportGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.identifier'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.code'));{q3b}
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.count'));{q1}
    result.patients := ParseReference{TFhirList}(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.patients'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MeasureReport.group.population', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.population', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(this, 'MeasureReport.group.population', 'patients', elem.patientsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifier.create;
  try
    ParseMeasureReportGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum') do
      result.stratumList.Add(parseMeasureReportGroupStratifierStratum(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'MeasureReport.group.stratifier', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(this, 'MeasureReport.group.stratifier', 'stratum', elem.stratumList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    ParseMeasureReportGroupStratifierStratumProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratum);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.value'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population') do
      result.populationList.Add(parseMeasureReportGroupStratifierStratumPopulation(item));
    result.measureScoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.measureScore'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratum'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'MeasureReport.group.stratifier.stratum', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(this, 'MeasureReport.group.stratifier.stratum', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MeasureReport.group.stratifier.stratum', 'measureScore', elem.measureScoreElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    ParseMeasureReportGroupStratifierStratumPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.identifier'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.code'));{q3b}
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.count'));{q1}
    result.patients := ParseReference{TFhirList}(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.patients'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratumPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MeasureReport.group.stratifier.stratum.population', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.stratifier.stratum.population', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(this, 'MeasureReport.group.stratifier.stratum.population', 'patients', elem.patientsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReport.create;
  try
    ParseMeasureReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportProperties(obj : TTurtleComplex; result : TFhirMeasureReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MeasureReport.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.status'), CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.type'), CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum);
    result.measure := ParseReference{TFhirMeasure}(obj.complex('http://hl7.org/fhir/MeasureReport.measure'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MeasureReport.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MeasureReport.date'));{q1}
    result.reportingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MeasureReport.reportingOrganization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/MeasureReport.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group') do
      result.groupList.Add(parseMeasureReportGroup(item));
    result.evaluatedResources := ParseReference{TFhirBundle}(obj.complex('http://hl7.org/fhir/MeasureReport.evaluatedResources'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'MeasureReport', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'MeasureReport', 'status', elem.StatusElement, CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'MeasureReport', 'type', elem.Type_Element, CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirMeasure}(this, 'MeasureReport', 'measure', elem.measureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'MeasureReport', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'MeasureReport', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reportingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'MeasureReport', 'reportingOrganization', elem.reportingOrganizationElement, false, -1);{x.2f}
  ComposePeriod(this, 'MeasureReport', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureReportGroup(this, 'MeasureReport', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evaluatedResources') then
    ComposeReference{TFhirBundle}(this, 'MeasureReport', 'evaluatedResources', elem.evaluatedResourcesElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
function TFHIRTurtleParser.ParseMedia(obj : TTurtleComplex) : TFhirMedia;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedia.create;
  try
    ParseMediaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Media.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Media.basedOn') do
      result.basedOnList.Add(parseReference{TFhirProcedureRequest}(item));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Media.type'), CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum);
    result.subtype := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.subtype'));{q3b}
    result.view := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.view'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Media.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Media.context'));{q3b}
    if obj.has('http://hl7.org/fhir/Media.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Media.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.operator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Media.operator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Media.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.bodySite'));{q3b}
    result.device := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Media.device'));{q3b}
    result.heightElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.height'));{q1}
    result.widthElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.width'));{q1}
    result.framesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.frames'));{q1}
    result.durationElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Media.duration'));{q1}
    result.content := ParseAttachment(obj.complex('http://hl7.org/fhir/Media.content'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Media.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Media'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Media', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirProcedureRequest}(this, 'Media', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  ComposeEnum(this, 'Media', 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    ComposeCodeableConcept(this, 'Media', 'subtype', elem.subtypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(this, 'Media', 'view', elem.viewElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Media', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Media', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'Media', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Media', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(this, 'Media', 'operator', elem.operatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Media', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'Media', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{Resource}(this, 'Media', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveInt(this, 'Media', 'height', elem.heightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveInt(this, 'Media', 'width', elem.widthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveInt(this, 'Media', 'frames', elem.framesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedInt(this, 'Media', 'duration', elem.durationElement, false, -1);{x.2ea}
  ComposeAttachment(this, 'Media', 'content', elem.contentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Media', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
function TFHIRTurtleParser.ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationIngredient.create;
  try
    ParseMedicationIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Medication.ingredient.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Medication.ingredient.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.isActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.ingredient.isActive'));{q1}
    result.amount := ParseRatio(obj.complex('http://hl7.org/fhir/Medication.ingredient.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Medication.ingredient', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'Medication.ingredient', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Medication.ingredient', 'isActive', elem.isActiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(this, 'Medication.ingredient', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationPackage(obj : TTurtleComplex) : TFhirMedicationPackage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationPackage.create;
  try
    ParseMedicationPackageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationPackageProperties(obj : TTurtleComplex; result : TFhirMedicationPackage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.container := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.package.container'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.package.content') do
      result.contentList.Add(parseMedicationPackageContent(item));
    for item in obj.complexes('http://hl7.org/fhir/Medication.package.batch') do
      result.batchList.Add(parseMedicationPackageBatch(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationPackage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationPackage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Medication.package', 'container', elem.containerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(this, 'Medication.package', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationPackageBatch(this, 'Medication.package', 'batch', elem.batchList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationPackageContent(obj : TTurtleComplex) : TFhirMedicationPackageContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationPackageContent.create;
  try
    ParseMedicationPackageContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationPackageContentProperties(obj : TTurtleComplex; result : TFhirMedicationPackageContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Medication.package.content.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Medication.package.content.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/Medication.package.content.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationPackageContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationPackageContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Medication.package.content', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'Medication.package.content', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Medication.package.content', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationPackageBatch(obj : TTurtleComplex) : TFhirMedicationPackageBatch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationPackageBatch.create;
  try
    ParseMedicationPackageBatchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationPackageBatchProperties(obj : TTurtleComplex; result : TFhirMedicationPackageBatch);
begin
    ParseBackboneElementProperties(obj, result);
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Medication.package.batch.lotNumber'));{q1}
    result.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Medication.package.batch.expirationDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicationPackageBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationPackageBatch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationPackageBatch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Medication.package.batch', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Medication.package.batch', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedication(obj : TTurtleComplex) : TFhirMedication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.code'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Medication.status'), CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum);
    result.isBrandElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.isBrand'));{q1}
    result.isOverTheCounterElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.isOverTheCounter'));{q1}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Medication.manufacturer'));{q3b}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.ingredient') do
      result.ingredientList.Add(parseMedicationIngredient(item));
    result.package := ParseMedicationPackage(obj.complex('http://hl7.org/fhir/Medication.package'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.image') do
      result.imageList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Medication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Medication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Medication', 'status', elem.StatusElement, CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBoolean(this, 'Medication', 'isBrand', elem.isBrandElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isOverTheCounter') then
    ComposeBoolean(this, 'Medication', 'isOverTheCounter', elem.isOverTheCounterElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Medication', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'Medication', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationIngredient(this, 'Medication', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('package') then
    ComposeMedicationPackage(this, 'Medication', 'package', elem.packageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'Medication', 'image', elem.imageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRTurtleParser.ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationPerformer.create;
  try
    ParseMedicationAdministrationPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.actor'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'MedicationAdministration.performer', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicationAdministration.performer', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.text'));{q1}
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.method'));{q3b}
    result.dose := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.dose'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateQuantity', item) then
      result.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationDosage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationAdministration.dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'dose', elem.doseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationAdministration.dosage', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'rateQuantity', TFhirQuantity(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.partOf') do
      result.partOfList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationAdministration.status'), CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationAdministration.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationAdministration.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.performer') do
      result.performerList.Add(parseMedicationAdministrationPerformer(item));
    result.notGivenElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationAdministration.notGiven'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonNotGiven') do
      result.reasonNotGivenList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    result.prescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/MedicationAdministration.prescription'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.device') do
      result.deviceList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.note') do
      result.noteList.Add(parseAnnotation(item));
    result.dosage := ParseMedicationAdministrationDosage(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministration'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationAdministration', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationAdministration', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationAdministration', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'MedicationAdministration', 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministration', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  ComposeReference{Resource}(this, 'MedicationAdministration', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'MedicationAdministration', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationAdministration', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationAdministration', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationAdministration', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(this, 'MedicationAdministration', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notGiven') then
    ComposeBoolean(this, 'MedicationAdministration', 'notGiven', elem.notGivenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotGiven') then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonNotGiven', elem.reasonNotGivenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationAdministration', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'MedicationAdministration', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'MedicationAdministration', 'device', elem.deviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationAdministration', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(this, 'MedicationAdministration', 'dosage', elem.dosageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationAdministration', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRTurtleParser.ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispensePerformer.create;
  try
    ParseMedicationDispensePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; result : TFhirMedicationDispensePerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.actor'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispensePerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'MedicationDispense.performer', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicationDispense.performer', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.wasSubstitutedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.wasSubstituted'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.responsibleParty') do
      result.responsiblePartyList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispenseSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'MedicationDispense.substitution', 'wasSubstituted', elem.wasSubstitutedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'MedicationDispense.substitution', 'responsibleParty', elem.responsiblePartyList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.partOf') do
      result.partOfList.Add(parseReference{TFhirProcedure}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationDispense.status'), CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationDispense.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationDispense.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.performer') do
      result.performerList.Add(parseMedicationDispensePerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.authorizingPrescription') do
      result.authorizingPrescriptionList.Add(parseReference{TFhirMedicationRequest}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.quantity'));{q3b}
    result.daysSupply := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.daysSupply'));{q3b}
    result.whenPreparedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenPrepared'));{q1}
    result.whenHandedOverElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenHandedOver'));{q1}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/MedicationDispense.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.receiver') do
      result.receiverList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.dosageInstruction') do
      result.dosageInstructionList.Add(parseDosage(item));
    result.substitution := ParseMedicationDispenseSubstitution(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.detectedIssue') do
      result.detectedIssueList.Add(parseReference{TFhirDetectedIssue}(item));
    result.notDoneElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationDispense.notDone'));{q1}
    if obj.has('http://hl7.org/fhir/MedicationDispense.notDoneReasonCodeableConcept', item) then
      result.notDoneReason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.notDoneReasonReference', item) {a3} then
      result.notDoneReason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispense'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationDispense', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'MedicationDispense', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'MedicationDispense', 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationDispense', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'MedicationDispense', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'MedicationDispense', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationDispense', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(this, 'MedicationDispense', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('authorizingPrescription') then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(this, 'MedicationDispense', 'authorizingPrescription', elem.authorizingPrescriptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'MedicationDispense', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'MedicationDispense', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('daysSupply') then
    ComposeQuantity(this, 'MedicationDispense', 'daysSupply', elem.daysSupplyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTime(this, 'MedicationDispense', 'whenPrepared', elem.whenPreparedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('whenHandedOver') then
    ComposeDateTime(this, 'MedicationDispense', 'whenHandedOver', elem.whenHandedOverElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'MedicationDispense', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationDispense', 'receiver', elem.receiverList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationDispense', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationDispense', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(this, 'MedicationDispense', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(this, 'MedicationDispense', 'detectedIssue', elem.detectedIssueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notDone') then
    ComposeBoolean(this, 'MedicationDispense', 'notDone', elem.notDoneElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.notDoneReason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'notDoneReasonCodeableConcept', TFhirCodeableConcept(elem.notDoneReason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.notDoneReason is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'notDoneReasonReference', TFhirReference(elem.notDoneReason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationDispense', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
function TFHIRTurtleParser.ParseMedicationRequestRequester(obj : TTurtleComplex) : TFhirMedicationRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestRequester.create;
  try
    ParseMedicationRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestRequesterProperties(obj : TTurtleComplex; result : TFhirMedicationRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'MedicationRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicationRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    ParseMedicationRequestDispenseRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequest);
begin
    ParseBackboneElementProperties(obj, result);
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.validityPeriod'));{q3b}
    result.numberOfRepeatsAllowedElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.numberOfRepeatsAllowed'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.quantity'));{q3b}
    result.expectedSupplyDuration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.expectedSupplyDuration'));{q3b}
    result.performer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.performer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDispenseRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'MedicationRequest.dispenseRequest', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'MedicationRequest.dispenseRequest', 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationRequest.dispenseRequest', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest', 'expectedSupplyDuration', elem.expectedSupplyDurationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicationRequest.dispenseRequest', 'performer', elem.performerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestSubstitution.create;
  try
    ParseMedicationRequestSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationRequestSubstitution);
begin
    ParseBackboneElementProperties(obj, result);
    result.allowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution.allowed'));{q1}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'MedicationRequest.substitution', 'allowed', elem.allowedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest.substitution', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequest.create;
  try
    ParseMedicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicationRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.status'), CODES_TFhirMedicationRequestStatusEnum, SYSTEMS_TFhirMedicationRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.intent'), CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.category'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.priority'), CODES_TFhirMedicationRequestPriorityEnum, SYSTEMS_TFhirMedicationRequestPriorityEnum);
    if obj.has('http://hl7.org/fhir/MedicationRequest.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationRequest.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationRequest.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationRequest.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationRequest.authoredOn'));{q1}
    result.requester := ParseMedicationRequestRequester(obj.complex('http://hl7.org/fhir/MedicationRequest.requester'));{q3b}
    result.recorder := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationRequest.recorder'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.dosageInstruction') do
      result.dosageInstructionList.Add(parseDosage(item));
    result.dispenseRequest := ParseMedicationRequestDispenseRequest(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest'));{q3b}
    result.substitution := ParseMedicationRequestSubstitution(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution'));{q3b}
    result.priorPrescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/MedicationRequest.priorPrescription'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.detectedIssue') do
      result.detectedIssueList.Add(parseReference{TFhirDetectedIssue}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationRequest', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'MedicationRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'MedicationRequest', 'status', elem.StatusElement, CODES_TFhirMedicationRequestStatusEnum, SYSTEMS_TFhirMedicationRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'MedicationRequest', 'intent', elem.IntentElement, CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationRequest', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'MedicationRequest', 'priority', elem.PriorityElement, CODES_TFhirMedicationRequestPriorityEnum, SYSTEMS_TFhirMedicationRequestPriorityEnum, false, -1);{x.d4}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationRequest', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationRequest', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  ComposeReference{Resource}(this, 'MedicationRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'MedicationRequest', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationRequest', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'MedicationRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeMedicationRequestRequester(this, 'MedicationRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationRequest', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationRequest', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationRequestDispenseRequest(this, 'MedicationRequest', 'dispenseRequest', elem.dispenseRequestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationRequestSubstitution(this, 'MedicationRequest', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'MedicationRequest', 'priorPrescription', elem.priorPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(this, 'MedicationRequest', 'detectedIssue', elem.detectedIssueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationRequest', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
function TFHIRTurtleParser.ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationStatement.create;
  try
    ParseMedicationStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.partOf') do
      result.partOfList.Add(parseReference{Resource}(item));
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationStatement.context'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationStatement.status'), CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationStatement.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.dateAssertedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationStatement.dateAsserted'));{q1}
    result.informationSource := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationStatement.informationSource'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MedicationStatement.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.derivedFrom') do
      result.derivedFromList.Add(parseReference{TFhirReference}(item));
    result.takenElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationStatement.taken'), CODES_TFhirMedicationStatementTakenEnum, SYSTEMS_TFhirMedicationStatementTakenEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonNotTaken') do
      result.reasonNotTakenList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.dosage') do
      result.dosageList.Add(parseDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationStatement', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationStatement', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'MedicationStatement', 'context', elem.contextElement, false, -1);{x.2f}
  ComposeEnum(this, 'MedicationStatement', 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationStatement', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationStatement', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationStatement', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTime(this, 'MedicationStatement', 'dateAsserted', elem.dateAssertedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('informationSource') then
    ComposeReference{Resource}(this, 'MedicationStatement', 'informationSource', elem.informationSourceElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'MedicationStatement', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationStatement', 'derivedFrom', elem.derivedFromList[i], false, i);{x.d3}
  ComposeEnum(this, 'MedicationStatement', 'taken', elem.TakenElement, CODES_TFhirMedicationStatementTakenEnum, SYSTEMS_TFhirMedicationStatementTakenEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotTaken') then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'reasonNotTaken', elem.reasonNotTakenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'MedicationStatement', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationStatement', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(this, 'MedicationStatement', 'dosage', elem.dosageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
function TFHIRTurtleParser.ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionFocus.create;
  try
    ParseMessageDefinitionFocusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionFocus);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.profile'));{q3b}
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.max'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionFocus'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'MessageDefinition.focus', 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'MessageDefinition.focus', 'profile', elem.profileElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.min <> '0')) then
    ComposeUnsignedInt(this, 'MessageDefinition.focus', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MessageDefinition.focus', 'max', elem.maxElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    ParseMessageDefinitionAllowedResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionAllowedResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.message := ParseReference{TFhirMessageDefinition}(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.message'));{q3b}
    result.situationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.situation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionAllowedResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirMessageDefinition}(this, 'MessageDefinition.allowedResponse', 'message', elem.messageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'MessageDefinition.allowedResponse', 'situation', elem.situationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinition.create;
  try
    ParseMessageDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionProperties(obj : TTurtleComplex; result : TFhirMessageDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageDefinition.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MessageDefinition.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MessageDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MessageDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.copyright'));{q1}
    result.base := ParseReference{TFhirMessageDefinition}(obj.complex('http://hl7.org/fhir/MessageDefinition.base'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.parent') do
      result.parentList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.replaces') do
      result.replacesList.Add(parseReference{TFhirMessageDefinition}(item));
    result.event := ParseCoding(obj.complex('http://hl7.org/fhir/MessageDefinition.event'));{q3b}
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.category'), CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.focus') do
      result.focusList.Add(parseMessageDefinitionFocus(item));
    result.responseRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MessageDefinition.responseRequired'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.allowedResponse') do
      result.allowedResponseList.Add(parseMessageDefinitionAllowedResponse(item));
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'MessageDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'MessageDefinition', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'MessageDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'MessageDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'MessageDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'MessageDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'MessageDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'MessageDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'MessageDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'MessageDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'MessageDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'MessageDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MessageDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'MessageDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'MessageDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeReference{TFhirMessageDefinition}(this, 'MessageDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{Resource}(this, 'MessageDefinition', 'parent', elem.parentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirMessageDefinition}(this, 'MessageDefinition', 'replaces', elem.replacesList[i], false, i);{x.d3}
  ComposeCoding(this, 'MessageDefinition', 'event', elem.eventElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(this, 'MessageDefinition', 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(this, 'MessageDefinition', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.responseRequired <> false)) and doCompose('responseRequired') then
    ComposeBoolean(this, 'MessageDefinition', 'responseRequired', elem.responseRequiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('allowedResponse') then
    for i := 0 to elem.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(this, 'MessageDefinition', 'allowedResponse', elem.allowedResponseList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRTurtleParser.ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.destination.name'));{q1}
    result.target := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/MessageHeader.destination.target'));{q3b}
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageHeader.destination.endpoint'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderDestination'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.destination', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'MessageHeader.destination', 'target', elem.targetElement, false, -1);{x.2f}
  ComposeUri(this, 'MessageHeader.destination', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.name'));{q1}
    result.softwareElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.software'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.version'));{q1}
    result.contact := ParseContactPoint(obj.complex('http://hl7.org/fhir/MessageHeader.source.contact'));{q3b}
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageHeader.source.endpoint'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'software', elem.softwareElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(this, 'MessageHeader.source', 'contact', elem.contactElement, false, -1);{x.2f}
  ComposeUri(this, 'MessageHeader.source', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseId(obj.complex('http://hl7.org/fhir/MessageHeader.response.identifier'));{q1}
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageHeader.response.code'), CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    result.details := ParseReference{TFhirOperationOutcome}(obj.complex('http://hl7.org/fhir/MessageHeader.response.details'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'MessageHeader.response', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeEnum(this, 'MessageHeader.response', 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(this, 'MessageHeader.response', 'details', elem.detailsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.event := ParseCoding(obj.complex('http://hl7.org/fhir/MessageHeader.event'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.destination') do
      result.destinationList.Add(parseMessageHeaderDestination(item));
    result.receiver := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MessageHeader.receiver'));{q3b}
    result.sender := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MessageHeader.sender'));{q3b}
    result.timestampElement := ParseInstant(obj.complex('http://hl7.org/fhir/MessageHeader.timestamp'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.enterer'));{q3b}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.author'));{q3b}
    result.source := ParseMessageHeaderSource(obj.complex('http://hl7.org/fhir/MessageHeader.source'));{q3b}
    result.responsible := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/MessageHeader.responsible'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MessageHeader.reason'));{q3b}
    result.response := ParseMessageHeaderResponse(obj.complex('http://hl7.org/fhir/MessageHeader.response'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.focus') do
      result.focusList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeader'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCoding(this, 'MessageHeader', 'event', elem.eventElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(this, 'MessageHeader', 'destination', elem.destinationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    ComposeReference{Resource}(this, 'MessageHeader', 'receiver', elem.receiverElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(this, 'MessageHeader', 'sender', elem.senderElement, false, -1);{x.2f}
  ComposeInstant(this, 'MessageHeader', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'author', elem.authorElement, false, -1);{x.2f}
  ComposeMessageHeaderSource(this, 'MessageHeader', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{Resource}(this, 'MessageHeader', 'responsible', elem.responsibleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'MessageHeader', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(this, 'MessageHeader', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MessageHeader', 'focus', elem.focusList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRTurtleParser.ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.type'), CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.value'));{q1}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.preferred'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.comment'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystemUniqueId'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'NamingSystem.uniqueId', 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'NamingSystem.uniqueId', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystem.uniqueId', 'preferred', elem.preferredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem.uniqueId', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'NamingSystem.uniqueId', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.kind'), CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NamingSystem.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.responsibleElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.responsible'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NamingSystem.type'));{q3b}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/NamingSystem.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.usage'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.uniqueId') do
      result.uniqueIdList.Add(parseNamingSystemUniqueId(item));
    result.replacedBy := ParseReference{TFhirNamingSystem}(obj.complex('http://hl7.org/fhir/NamingSystem.replacedBy'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeString(this, 'NamingSystem', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'NamingSystem', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'NamingSystem', 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, false, -1);{x.d4}
  ComposeDateTime(this, 'NamingSystem', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'NamingSystem', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeString(this, 'NamingSystem', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'NamingSystem', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'NamingSystem', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'NamingSystem', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'NamingSystem', 'usage', elem.usageElement, false, -1);{x.2ea}
  for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(this, 'NamingSystem', 'uniqueId', elem.uniqueIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('replacedBy') then
    ComposeReference{TFhirNamingSystem}(this, 'NamingSystem', 'replacedBy', elem.replacedByElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRTurtleParser.ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule') do
      result.scheduleList.Add(parseTiming(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient') do
      result.nutrientList.Add(parseNutritionOrderOralDietNutrient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.texture') do
      result.textureList.Add(parseNutritionOrderOralDietTexture(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.fluidConsistencyType') do
      result.fluidConsistencyTypeList.Add(parseCodeableConcept(item));
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDiet'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.oralDiet', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(this, 'NutritionOrder.oralDiet', 'nutrient', elem.nutrientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(this, 'NutritionOrder.oralDiet', 'texture', elem.textureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'fluidConsistencyType', elem.fluidConsistencyTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.oralDiet', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.modifier'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietNutrient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.nutrient', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.oralDiet.nutrient', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.modifier'));{q3b}
    result.foodType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.foodType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietTexture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'foodType', elem.foodTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.type'));{q3b}
    result.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.productName'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement.schedule') do
      result.scheduleList.Add(parseTiming(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.quantity'));{q3b}
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderSupplement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.supplement', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'productName', elem.productNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.supplement', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.supplement', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.baseFormulaType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaType'));{q3b}
    result.baseFormulaProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaProductName'));{q1}
    result.additiveType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveType'));{q3b}
    result.additiveProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveProductName'));{q1}
    result.caloricDensity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.caloricDensity'));{q3b}
    result.routeofAdministration := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.routeofAdministration'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration') do
      result.administrationList.Add(parseNutritionOrderEnteralFormulaAdministration(item));
    result.maxVolumeToDeliver := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.maxVolumeToDeliver'));{q3b}
    result.administrationInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administrationInstruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormula'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'baseFormulaType', elem.baseFormulaTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'baseFormulaProductName', elem.baseFormulaProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'additiveType', elem.additiveTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'additiveProductName', elem.additiveProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'caloricDensity', elem.caloricDensityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'routeofAdministration', elem.routeofAdministrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(this, 'NutritionOrder.enteralFormula', 'administration', elem.administrationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'maxVolumeToDeliver', elem.maxVolumeToDeliverElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'administrationInstruction', elem.administrationInstructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateQuantity', item) then
      result.rate := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateRatio', item) then
      result.rate := parseRatio(item);
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdministration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'NutritionOrder.enteralFormula.administration', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'rateQuantity', TFhirQuantity(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'NutritionOrder.enteralFormula.administration', 'rateRatio', TFhirRatio(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.status'), CODES_TFhirNutritionRequestStatusEnum, SYSTEMS_TFhirNutritionRequestStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/NutritionOrder.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/NutritionOrder.encounter'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionOrder.dateTime'));{q1}
    result.orderer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/NutritionOrder.orderer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.allergyIntolerance') do
      result.allergyIntoleranceList.Add(parseReference{TFhirAllergyIntolerance}(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.foodPreferenceModifier') do
      result.foodPreferenceModifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.excludeFoodModifier') do
      result.excludeFoodModifierList.Add(parseCodeableConcept(item));
    result.oralDiet := ParseNutritionOrderOralDiet(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement') do
      result.supplementList.Add(parseNutritionOrderSupplement(item));
    result.enteralFormula := ParseNutritionOrderEnteralFormula(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrder'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionOrder', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'NutritionOrder', 'status', elem.StatusElement, CODES_TFhirNutritionRequestStatusEnum, SYSTEMS_TFhirNutritionRequestStatusEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'NutritionOrder', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'NutritionOrder', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'NutritionOrder', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(this, 'NutritionOrder', 'orderer', elem.ordererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(this, 'NutritionOrder', 'allergyIntolerance', elem.allergyIntoleranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'foodPreferenceModifier', elem.foodPreferenceModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'excludeFoodModifier', elem.excludeFoodModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(this, 'NutritionOrder', 'oralDiet', elem.oralDietElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(this, 'NutritionOrder', 'supplement', elem.supplementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(this, 'NutritionOrder', 'enteralFormula', elem.enteralFormulaElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
function TFHIRTurtleParser.ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.high'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.referenceRange.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange.appliesTo') do
      result.appliesToList.Add(parseCodeableConcept(item));
    result.age := ParseRange(obj.complex('http://hl7.org/fhir/Observation.referenceRange.age'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.referenceRange.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationReferenceRange'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'high', elem.highElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.referenceRange', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation.referenceRange', 'appliesTo', elem.appliesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'Observation.referenceRange', 'age', elem.ageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation.referenceRange', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseObservationRelated(obj : TTurtleComplex) : TFhirObservationRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationRelated.create;
  try
    ParseObservationRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationRelatedProperties(obj : TTurtleComplex; result : TFhirObservationRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.related.type'), CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum);
    result.target := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.related.target'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeObservationRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Observation.related', 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, false, -1);{x.d4}
  ComposeReference{Resource}(this, 'Observation.related', 'target', elem.targetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.component.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.dataAbsentReason'));{q3b}
    result.interpretation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.interpretation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Observation.component', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation.component', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation.component', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation.component', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation.component', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation.component', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation.component', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation.component', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation.component', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation.component', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation.component', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.component', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.component', 'interpretation', elem.interpretationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation.component', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseObservation(obj : TTurtleComplex) : TFhirObservation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservation.create;
  try
    ParseObservationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Observation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Observation.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.context'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Observation.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Observation.performer') do
      result.performerList.Add(parseReference{Resource}(item));
    if obj.has('http://hl7.org/fhir/Observation.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Observation.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Observation.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.dataAbsentReason'));{q3b}
    result.interpretation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.interpretation'));{q3b}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.comment'));{q1}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.bodySite'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.method'));{q3b}
    result.specimen := ParseReference{TFhirSpecimen}(obj.complex('http://hl7.org/fhir/Observation.specimen'));{q3b}
    result.device := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Observation.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.related') do
      result.relatedList.Add(parseObservationRelated(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component') do
      result.componentList.Add(parseObservationComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Observation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Observation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'Observation', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  ComposeEnum(this, 'Observation', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Observation', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'Observation', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Observation', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'Observation', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(this, 'Observation', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Observation', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(this, 'Observation', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    ComposeCodeableConcept(this, 'Observation', 'interpretation', elem.interpretationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Observation', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'Observation', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'Observation', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(this, 'Observation', 'specimen', elem.specimenElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{Resource}(this, 'Observation', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(this, 'Observation', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(this, 'Observation', 'component', elem.componentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRTurtleParser.ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.name'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.max'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.documentation'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    result.searchTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.searchType'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.profile := ParseReference{TFhirStructureDefinition}(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.profile'));{q3b}
    result.binding := ParseOperationDefinitionParameterBinding(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.part') do
      result.partList.Add(parseOperationDefinitionParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'OperationDefinition.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition.parameter', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);{x.d4}
  ComposeInteger(this, 'OperationDefinition.parameter', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition.parameter', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.parameter', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'searchType', elem.SearchTypeElement, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(this, 'OperationDefinition.parameter', 'profile', elem.profileElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(this, 'OperationDefinition.parameter', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if obj.has('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSetReference', item) {a3} then
      result.valueSet := ParseReference(item);
    if obj.has('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSetUri', item) then
      result.valueSet := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterBinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationDefinition.parameter.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  if (elem.valueSet is TFhirReference) {2} then
    ComposeReference(this, 'OperationDefinition.parameter.binding', 'valueSetReference', TFhirReference(elem.valueSet), false,-1){x.d8}
  else if (elem.valueSet is TFhirUri) {6} then
    ComposeUri(this, 'OperationDefinition.parameter.binding', 'valueSetUri', TFhirUri(elem.valueSet), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionOverload.create;
  try
    ParseOperationDefinitionOverloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionOverload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload.parameterName') do
      result.parameterNameList.Add(parseString(item));
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.overload.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionOverload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterNameList.Count - 1 do
      ComposeString(this, 'OperationDefinition.overload', 'parameterName', elem.parameterNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.overload', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/OperationDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.kind'), CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/OperationDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.purpose'));{q1}
    result.idempotentElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.idempotent'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.code'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.comment'));{q1}
    result.base := ParseReference{TFhirOperationDefinition}(obj.complex('http://hl7.org/fhir/OperationDefinition.base'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.resource') do
      result.resource.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.systemElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.system'));{q1}
    result.type_Element := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.type'));{q1}
    result.instanceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.instance'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter') do
      result.parameterList.Add(parseOperationDefinitionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload') do
      result.overloadList.Add(parseOperationDefinitionOverload(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'OperationDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'OperationDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationDefinition', 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'OperationDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'OperationDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'OperationDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'OperationDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'OperationDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'OperationDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'OperationDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'OperationDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('idempotent') then
    ComposeBoolean(this, 'OperationDefinition', 'idempotent', elem.idempotentElement, false, -1);{x.2ea}
  ComposeCode(this, 'OperationDefinition', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'OperationDefinition', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeReference{TFhirOperationDefinition}(this, 'OperationDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', elem.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', elem.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeBoolean(this, 'OperationDefinition', 'system', elem.systemElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'OperationDefinition', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeBoolean(this, 'OperationDefinition', 'instance', elem.instanceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('overload') then
    for i := 0 to elem.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(this, 'OperationDefinition', 'overload', elem.overloadList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRTurtleParser.ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.severity'), CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.code'), CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    result.details := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.details'));{q3b}
    result.diagnosticsElement := ParseString(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.diagnostics'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.location') do
      result.locationList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.expression') do
      result.expressionList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcomeIssue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationOutcome.issue', 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationOutcome.issue', 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OperationOutcome.issue', 'details', elem.detailsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationOutcome.issue', 'diagnostics', elem.diagnosticsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.expressionList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'expression', elem.expressionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue') do
      result.issueList.Add(parseOperationOutcomeIssue(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcome'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(this, 'OperationOutcome', 'issue', elem.issueList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRTurtleParser.ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationContact.create;
  try
    ParseOrganizationContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.purpose := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Organization.contact.purpose'));{q3b}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Organization.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Organization.contact.address'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Organization.contact', 'purpose', elem.purposeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Organization.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Organization.contact', 'address', elem.addressElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseOrganization(obj : TTurtleComplex) : TFhirOrganization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Organization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Organization.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Organization.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Organization.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Organization.alias') do
      result.aliasList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.address') do
      result.addressList.Add(parseAddress(item));
    result.partOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Organization.partOf'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact') do
      result.contactList.Add(parseOrganizationContact(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Organization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Organization', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Organization', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Organization', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'Organization', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Organization', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(this, 'Organization', 'partOf', elem.partOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(this, 'Organization', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'Organization', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
function TFHIRTurtleParser.ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.relationship') do
      result.relationshipList.Add(parseCodeableConcept(item));
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Patient.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Patient.contact.address'));{q3b}
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.contact.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.contact.organization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Patient.contact.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'Patient.contact', 'relationship', elem.relationshipList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Patient.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Patient.contact', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Patient.contact', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Patient.contact', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Patient.contact', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePatientAnimal(obj : TTurtleComplex) : TFhirPatientAnimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientAnimal.create;
  try
    ParsePatientAnimalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientAnimalProperties(obj : TTurtleComplex; result : TFhirPatientAnimal);
begin
    ParseBackboneElementProperties(obj, result);
    result.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.species'));{q3b}
    result.breed := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.breed'));{q3b}
    result.genderStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.animal.genderStatus'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePatientAnimal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientAnimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientAnimal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Patient.animal', 'species', elem.speciesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Patient.animal', 'breed', elem.breedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Patient.animal', 'genderStatus', elem.genderStatusElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(obj, result);
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.communication.language'));{q3b}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.communication.preferred'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientCommunication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Patient.communication', 'language', elem.languageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Patient.communication', 'preferred', elem.preferredElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.other := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Patient.link.other'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.link.type'), CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Patient.link', 'other', elem.otherElement, false, -1);{x.2f}
  ComposeEnum(this, 'Patient.link', 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePatient(obj : TTurtleComplex) : TFhirPatient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatient.create;
  try
    ParsePatientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Patient.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Patient.birthDate'));{q1}
    if obj.has('http://hl7.org/fhir/Patient.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.deceasedDateTime', item) then
      result.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.address') do
      result.addressList.Add(parseAddress(item));
    result.maritalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.maritalStatus'));{q3b}
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthBoolean', item) then
      result.multipleBirth := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthInteger', item) then
      result.multipleBirth := parseInteger(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact') do
      result.contactList.Add(parsePatientContact(item));
    result.animal := ParsePatientAnimal(obj.complex('http://hl7.org/fhir/Patient.animal'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.communication') do
      result.communicationList.Add(parsePatientCommunication(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.generalPractitioner') do
      result.generalPractitionerList.Add(parseReference{Resource}(item));
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.managingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.link') do
      result.link_List.Add(parsePatientLink(item));
end;

procedure TFHIRTurtleComposer.ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Patient'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Patient', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Patient', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Patient', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Patient', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Patient', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Patient', 'deceasedDateTime', TFhirDateTime(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Patient', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(this, 'Patient', 'maritalStatus', elem.maritalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(this, 'Patient', 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Patient', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(this, 'Patient', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('animal') then
    ComposePatientAnimal(this, 'Patient', 'animal', elem.animalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(this, 'Patient', 'communication', elem.communicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('generalPractitioner') then
    for i := 0 to elem.generalPractitionerList.Count - 1 do
      ComposeReference{Resource}(this, 'Patient', 'generalPractitioner', elem.generalPractitionerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Patient', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(this, 'Patient', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRTurtleParser.ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentNotice.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentNotice.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.response'));{q3b}
    result.statusDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentNotice.statusDate'));{q1}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentNotice.created'));{q1}
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentNotice.target'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentNotice.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentNotice.organization'));{q3b}
    result.paymentStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentStatus'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentNotice'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentNotice', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'PaymentNotice', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('statusDate') then
    ComposeDate(this, 'PaymentNotice', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'PaymentNotice', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentNotice', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentStatus') then
    ComposeCodeableConcept(this, 'PaymentNotice', 'paymentStatus', elem.paymentStatusElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRTurtleParser.ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParsePaymentReconciliationDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.type'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.response'));{q3b}
    result.submitter := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.submitter'));{q3b}
    result.payee := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.payee'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.date'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'PaymentReconciliation.detail', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation.detail', 'submitter', elem.submitterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation.detail', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PaymentReconciliation.detail', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'PaymentReconciliation.detail', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    ParsePaymentReconciliationProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation.processNote', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation.processNote', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PaymentReconciliation.period'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentReconciliation.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.organization'));{q3b}
    result.request := ParseReference{TFhirProcessRequest}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.request'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.disposition'));{q1}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.detail') do
      result.detailList.Add(parsePaymentReconciliationDetail(item));
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.form'));{q3b}
    result.total := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.total'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.processNote') do
      result.processNoteList.Add(parsePaymentReconciliationProcessNote(item));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentReconciliation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'PaymentReconciliation', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'PaymentReconciliation', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'PaymentReconciliation', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirProcessRequest}(this, 'PaymentReconciliation', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'PaymentReconciliation', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(this, 'PaymentReconciliation', 'detail', elem.detailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(this, 'PaymentReconciliation', 'total', elem.totalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(this, 'PaymentReconciliation', 'processNote', elem.processNoteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
function TFHIRTurtleParser.ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.target := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Person.link.target'));{q3b}
    result.assuranceElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.link.assurance'), CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRTurtleComposer.ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PersonLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Person.link', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Person.link', 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePerson(obj : TTurtleComplex) : TFhirPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPerson.create;
  try
    ParsePersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Person.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Person.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.address') do
      result.addressList.Add(parseAddress(item));
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/Person.photo'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Person.managingOrganization'));{q3b}
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Person.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.link') do
      result.link_List.Add(parsePersonLink(item));
end;

procedure TFHIRTurtleComposer.ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Person'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Person', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Person', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Person', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Person', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Person', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Person', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'Person', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Person', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Person', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(this, 'Person', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
function TFHIRTurtleParser.ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoal.create;
  try
    ParsePlanDefinitionGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.category'));{q3b}
    result.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.description'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.priority'));{q3b}
    result.start := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.start'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.addresses') do
      result.addressesList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.target') do
      result.targetList.Add(parsePlanDefinitionGoalTarget(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'PlanDefinition.goal', 'description', elem.descriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'start', elem.startElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.goal', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.goal', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(this, 'PlanDefinition.goal', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    ParsePlanDefinitionGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.measure'));{q3b}
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailQuantity', item) then
      result.detail := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailRange', item) then
      result.detail := parseRange(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailCodeableConcept', item) then
      result.detail := parseCodeableConcept(item);
    result.due := ParseDuration(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.due'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoalTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'measure', elem.measureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'PlanDefinition.goal.target', 'detailQuantity', TFhirQuantity(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.goal.target', 'detailRange', TFhirRange(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'detailCodeableConcept', TFhirCodeableConcept(elem.detail), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'PlanDefinition.goal.target', 'due', elem.dueElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionAction.create;
  try
    ParsePlanDefinitionActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.label'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.description'));{q1}
    result.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.textEquivalent'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.goalId') do
      result.goalIdList.Add(parseId(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.triggerDefinition') do
      result.triggerDefinitionList.Add(parseTriggerDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.condition') do
      result.conditionList.Add(parsePlanDefinitionActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.input') do
      result.inputList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.output') do
      result.outputList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.relatedAction') do
      result.relatedActionList.Add(parsePlanDefinitionActionRelatedAction(item));
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingDuration', item) then
      result.timing := parseDuration(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingDateTime', item) then
      result.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.participant') do
      result.participantList.Add(parsePlanDefinitionActionParticipant(item));
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/PlanDefinition.action.type'));{q3b}
    result.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    result.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    result.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    result.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    result.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    result.definition := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/PlanDefinition.action.definition'));{q3b}
    result.transform := ParseReference{TFhirStructureMap}(obj.complex('http://hl7.org/fhir/PlanDefinition.action.transform'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.dynamicValue') do
      result.dynamicValueList.Add(parsePlanDefinitionActionDynamicValue(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.action') do
      result.actionList.Add(parsePlanDefinitionAction(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'textEquivalent', elem.textEquivalentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.action', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.action', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.action', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalIdList.Count - 1 do
      ComposeId(this, 'PlanDefinition.action', 'goalId', elem.goalIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.triggerDefinitionList.Count - 1 do
      ComposeTriggerDefinition(this, 'PlanDefinition.action', 'triggerDefinition', elem.triggerDefinitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(this, 'PlanDefinition.action', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeDataRequirement(this, 'PlanDefinition.action', 'input', elem.inputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeDataRequirement(this, 'PlanDefinition.action', 'output', elem.outputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(this, 'PlanDefinition.action', 'relatedAction', elem.relatedActionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'PlanDefinition.action', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action', 'timingDuration', TFhirDuration(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'PlanDefinition.action', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'PlanDefinition.action', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(this, 'PlanDefinition.action', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'PlanDefinition.action', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(this, 'PlanDefinition.action', 'definition', elem.definitionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureMap}(this, 'PlanDefinition.action', 'transform', elem.transformElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(this, 'PlanDefinition.action', 'dynamicValue', elem.dynamicValueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition.action', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionCondition.create;
  try
    ParsePlanDefinitionActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionCondition);
begin
    ParseBackboneElementProperties(obj, result);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.description'));{q1}
    result.languageElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'PlanDefinition.action.condition', 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.condition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.condition', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.condition', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    ParsePlanDefinitionActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actionIdElement := ParseId(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.actionId'));{q1}
    result.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.relatedAction.offsetDuration', item) then
      result.offset := parseDuration(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.relatedAction.offsetRange', item) then
      result.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionRelatedAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'PlanDefinition.action.relatedAction', 'actionId', elem.actionIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'PlanDefinition.action.relatedAction', 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action.relatedAction', 'offsetDuration', TFhirDuration(elem.offset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action.relatedAction', 'offsetRange', TFhirRange(elem.offset), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    ParsePlanDefinitionActionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'PlanDefinition.action.participant', 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action.participant', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    ParsePlanDefinitionActionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionDynamicValue);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.description'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.path'));{q1}
    result.languageElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionDynamicValue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinition.create;
  try
    ParsePlanDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionProperties(obj : TTurtleComplex; result : TFhirPlanDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/PlanDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.title'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.type'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PlanDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PlanDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.usage'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/PlanDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.contributor') do
      result.contributorList.Add(parseContributor(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.library') do
      result.library_List.Add(parseReference{TFhirLibrary}(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal') do
      result.goalList.Add(parsePlanDefinitionGoal(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action') do
      result.actionList.Add(parsePlanDefinitionAction(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'PlanDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PlanDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'PlanDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'PlanDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'PlanDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'PlanDefinition', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeEnum(this, 'PlanDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'PlanDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'PlanDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'PlanDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'PlanDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'PlanDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'PlanDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'PlanDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'PlanDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'PlanDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'PlanDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(this, 'PlanDefinition', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'PlanDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeReference{TFhirLibrary}(this, 'PlanDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposePlanDefinitionGoal(this, 'PlanDefinition', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition', 'action', elem.actionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRTurtleParser.ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Practitioner.qualification.code'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Practitioner.qualification.period'));{q3b}
    result.issuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Practitioner.qualification.issuer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerQualification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner.qualification', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Practitioner.qualification', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Practitioner.qualification', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Practitioner.qualification', 'issuer', elem.issuerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Practitioner.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.address') do
      result.addressList.Add(parseAddress(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Practitioner.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Practitioner.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification') do
      result.qualificationList.Add(parsePractitionerQualification(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.communication') do
      result.communicationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Practitioner'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Practitioner', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Practitioner', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Practitioner', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Practitioner', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Practitioner', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Practitioner', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Practitioner', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(this, 'Practitioner', 'qualification', elem.qualificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner', 'communication', elem.communicationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
function TFHIRTurtleParser.ParsePractitionerRoleAvailableTime(obj : TTurtleComplex) : TFhirPractitionerRoleAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    ParsePractitionerRoleAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleAvailableTimeProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.availableTime.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.allDay'));{q1}
    result.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.availableStartTime'));{q1}
    result.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.availableEndTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePractitionerRoleAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRoleAvailableTime'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'PractitionerRole.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'PractitionerRole.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'PractitionerRole.availableTime', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'PractitionerRole.availableTime', 'availableStartTime', elem.availableStartTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'PractitionerRole.availableTime', 'availableEndTime', elem.availableEndTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePractitionerRoleNotAvailable(obj : TTurtleComplex) : TFhirPractitionerRoleNotAvailable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    ParsePractitionerRoleNotAvailableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleNotAvailableProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleNotAvailable);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PractitionerRole.notAvailable.description'));{q1}
    result.during := ParsePeriod(obj.complex('http://hl7.org/fhir/PractitionerRole.notAvailable.during'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePractitionerRoleNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleNotAvailable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRoleNotAvailable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'PractitionerRole.notAvailable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'PractitionerRole.notAvailable', 'during', elem.duringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRole.create;
  try
    ParsePractitionerRoleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerRole);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PractitionerRole.active'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PractitionerRole.period'));{q3b}
    result.practitioner := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PractitionerRole.practitioner'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PractitionerRole.organization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.healthcareService') do
      result.healthcareServiceList.Add(parseReference{TFhirHealthcareService}(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.availableTime') do
      result.availableTimeList.Add(parsePractitionerRoleAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.notAvailable') do
      result.notAvailableList.Add(parsePractitionerRoleNotAvailable(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/PractitionerRole.availabilityExceptions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRole; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRole'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PractitionerRole', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'PractitionerRole', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'PractitionerRole', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{TFhirPractitioner}(this, 'PractitionerRole', 'practitioner', elem.practitionerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PractitionerRole', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'PractitionerRole', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(this, 'PractitionerRole', 'healthcareService', elem.healthcareServiceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'PractitionerRole', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposePractitionerRoleAvailableTime(this, 'PractitionerRole', 'availableTime', elem.availableTimeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposePractitionerRoleNotAvailable(this, 'PractitionerRole', 'notAvailable', elem.notAvailableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'PractitionerRole', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'PractitionerRole', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
function TFHIRTurtleParser.ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.performer.role'));{q3b}
    result.actor := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.performer.actor'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Procedure.performer.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedurePerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure.performer', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Procedure.performer', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Procedure.performer', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.action'));{q3b}
    result.manipulated := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.manipulated'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureFocalDevice'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Procedure.focalDevice', 'action', elem.actionElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'Procedure.focalDevice', 'manipulated', elem.manipulatedElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedure(obj : TTurtleComplex) : TFhirProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.partOf') do
      result.partOfList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Procedure.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    result.notDoneElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Procedure.notDone'));{q1}
    result.notDoneReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.notDoneReason'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Procedure.context'));{q3b}
    if obj.has('http://hl7.org/fhir/Procedure.performedPeriod', item) then
      result.performed := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedDateTime', item) then
      result.performed := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.performer') do
      result.performerList.Add(parseProcedurePerformer(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Procedure.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.outcome'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.report') do
      result.reportList.Add(parseReference{TFhirDiagnosticReport}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complication') do
      result.complicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complicationDetail') do
      result.complicationDetailList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.followUp') do
      result.followUpList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.focalDevice') do
      result.focalDeviceList.Add(parseProcedureFocalDevice(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.usedReference') do
      result.usedReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.usedCode') do
      result.usedCodeList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Procedure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Procedure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Procedure', 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.notDone <> false)) and doCompose('notDone') then
    ComposeBoolean(this, 'Procedure', 'notDone', elem.notDoneElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notDoneReason') then
    ComposeCodeableConcept(this, 'Procedure', 'notDoneReason', elem.notDoneReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Procedure', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Procedure', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Procedure', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Procedure', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(this, 'Procedure', 'performedPeriod', TFhirPeriod(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Procedure', 'performedDateTime', TFhirDateTime(elem.performed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(this, 'Procedure', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Procedure', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'Procedure', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('report') then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(this, 'Procedure', 'report', elem.reportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('complication') then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'complication', elem.complicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('complicationDetail') then
    for i := 0 to elem.complicationDetailList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Procedure', 'complicationDetail', elem.complicationDetailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'followUp', elem.followUpList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Procedure', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(this, 'Procedure', 'focalDevice', elem.focalDeviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usedReference') then
    for i := 0 to elem.usedReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'Procedure', 'usedReference', elem.usedReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usedCode') then
    for i := 0 to elem.usedCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'usedCode', elem.usedCodeList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
function TFHIRTurtleParser.ParseProcedureRequestRequester(obj : TTurtleComplex) : TFhirProcedureRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureRequestRequester.create;
  try
    ParseProcedureRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureRequestRequesterProperties(obj : TTurtleComplex; result : TFhirProcedureRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcedureRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedureRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'ProcedureRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ProcedureRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedureRequest(obj : TTurtleComplex) : TFhirProcedureRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureRequest.create;
  try
    ParseProcedureRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureRequestProperties(obj : TTurtleComplex; result : TFhirProcedureRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.replaces') do
      result.replacesList.Add(parseReference{TFhirReference}(item));
    result.requisition := ParseIdentifier(obj.complex('http://hl7.org/fhir/ProcedureRequest.requisition'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcedureRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcedureRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcedureRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ProcedureRequest.doNotPerform'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcedureRequest.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.context'));{q3b}
    if obj.has('http://hl7.org/fhir/ProcedureRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ProcedureRequest.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcedureRequest.authoredOn'));{q1}
    result.requester := ParseProcedureRequestRequester(obj.complex('http://hl7.org/fhir/ProcedureRequest.requester'));{q3b}
    result.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcedureRequest.performerType'));{q3b}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ProcedureRequest.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcedureRequest.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeProcedureRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcedureRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'ProcedureRequest', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ProcedureRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ProcedureRequest', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requisition') then
    ComposeIdentifier(this, 'ProcedureRequest', 'requisition', elem.requisitionElement, false, -1);{x.2f}
  ComposeEnum(this, 'ProcedureRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'ProcedureRequest', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'ProcedureRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.doNotPerform <> false)) and doCompose('doNotPerform') then
    ComposeBoolean(this, 'ProcedureRequest', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcedureRequest', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ProcedureRequest', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'ProcedureRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ProcedureRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ProcedureRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ProcedureRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ProcedureRequest', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'ProcedureRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeProcedureRequestRequester(this, 'ProcedureRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(this, 'ProcedureRequest', 'performerType', elem.performerTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(this, 'ProcedureRequest', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcedureRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'ProcedureRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ProcedureRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'ProcedureRequest', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcedureRequest', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ProcedureRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'ProcedureRequest', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
function TFHIRTurtleParser.ParseProcessRequestItem(obj : TTurtleComplex) : TFhirProcessRequestItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessRequestItem.create;
  try
    ParseProcessRequestItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessRequestItemProperties(obj : TTurtleComplex; result : TFhirProcessRequestItem);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceLinkIdElement := ParseInteger(obj.complex('http://hl7.org/fhir/ProcessRequest.item.sequenceLinkId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeProcessRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequestItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessRequestItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'ProcessRequest.item', 'sequenceLinkId', elem.sequenceLinkIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProcessRequest(obj : TTurtleComplex) : TFhirProcessRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessRequest.create;
  try
    ParseProcessRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessRequestProperties(obj : TTurtleComplex; result : TFhirProcessRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcessRequest.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcessRequest.action'), CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum);
    result.target := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessRequest.target'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcessRequest.created'));{q1}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ProcessRequest.provider'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessRequest.organization'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessRequest.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessRequest.response'));{q3b}
    result.nullifyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ProcessRequest.nullify'));{q1}
    result.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessRequest.reference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.item') do
      result.itemList.Add(parseProcessRequestItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.include') do
      result.includeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessRequest.exclude') do
      result.excludeList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ProcessRequest.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcessRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'ProcessRequest', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    ComposeEnum(this, 'ProcessRequest', 'action', elem.ActionElement, CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ProcessRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'ProcessRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessRequest', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(this, 'ProcessRequest', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('nullify') then
    ComposeBoolean(this, 'ProcessRequest', 'nullify', elem.nullifyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeString(this, 'ProcessRequest', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(this, 'ProcessRequest', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('include') then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'include', elem.includeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('exclude') then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(this, 'ProcessRequest', 'exclude', elem.excludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'ProcessRequest', 'period', elem.periodElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
function TFHIRTurtleParser.ParseProcessResponseProcessNote(obj : TTurtleComplex) : TFhirProcessResponseProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessResponseProcessNote.create;
  try
    ParseProcessResponseProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirProcessResponseProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcessResponse.processNote.type'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessResponse.processNote.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeProcessResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponseProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessResponseProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ProcessResponse.processNote', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ProcessResponse.processNote', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProcessResponse(obj : TTurtleComplex) : TFhirProcessResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcessResponse.create;
  try
    ParseProcessResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcessResponseProperties(obj : TTurtleComplex; result : TFhirProcessResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ProcessResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ProcessResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessResponse.organization'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ProcessResponse.request'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcessResponse.outcome'));{q3b}
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ProcessResponse.disposition'));{q1}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ProcessResponse.requestProvider'));{q3b}
    result.requestOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ProcessResponse.requestOrganization'));{q3b}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProcessResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.processNote') do
      result.processNoteList.Add(parseProcessResponseProcessNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.error') do
      result.errorList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ProcessResponse.communicationRequest') do
      result.communicationRequestList.Add(parseReference{TFhirCommunicationRequest}(item));
end;

procedure TFHIRTurtleComposer.ComposeProcessResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcessResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcessResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ProcessResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'ProcessResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'ProcessResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'ProcessResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'ProcessResponse', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'ProcessResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'ProcessResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ProcessResponse', 'requestOrganization', elem.requestOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'ProcessResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeProcessResponseProcessNote(this, 'ProcessResponse', 'processNote', elem.processNoteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCodeableConcept(this, 'ProcessResponse', 'error', elem.errorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') then
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(this, 'ProcessResponse', 'communicationRequest', elem.communicationRequestList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRTurtleParser.ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/Provenance.agent.whoReference', item) {a3} then
      result.who := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Provenance.agent.whoUri', item) then
      result.who := parseUri(item);
    if obj.has('http://hl7.org/fhir/Provenance.agent.onBehalfOfReference', item) {a3} then
      result.onBehalfOf := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Provenance.agent.onBehalfOfUri', item) then
      result.onBehalfOf := parseUri(item);
    result.relatedAgentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.agent.relatedAgentType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance.agent', 'role', elem.roleList[i], false, i);{x.d3}
  if (elem.who is TFhirReference) {2} then
    ComposeReference(this, 'Provenance.agent', 'whoReference', TFhirReference(elem.who), false,-1){x.d8}
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(this, 'Provenance.agent', 'whoUri', TFhirUri(elem.who), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.onBehalfOf is TFhirReference) {2} then
    ComposeReference(this, 'Provenance.agent', 'onBehalfOfReference', TFhirReference(elem.onBehalfOf), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.onBehalfOf is TFhirUri) {6} then
    ComposeUri(this, 'Provenance.agent', 'onBehalfOfUri', TFhirUri(elem.onBehalfOf), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Provenance.agent', 'relatedAgentType', elem.relatedAgentTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.roleElement := ParseEnum(obj.complex('http://hl7.org/fhir/Provenance.entity.role'), CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    if obj.has('http://hl7.org/fhir/Provenance.entity.whatReference', item) {a3} then
      result.what := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Provenance.entity.whatIdentifier', item) then
      result.what := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Provenance.entity.whatUri', item) then
      result.what := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity.agent') do
      result.agentList.Add(parseProvenanceAgent(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Provenance.entity', 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, false, -1);{x.d4}
  if (elem.what is TFhirReference) {2} then
    ComposeReference(this, 'Provenance.entity', 'whatReference', TFhirReference(elem.what), false,-1){x.d8}
  else if (elem.what is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Provenance.entity', 'whatIdentifier', TFhirIdentifier(elem.what), false, -1){x.d9}
  else if (elem.what is TFhirUri) {6} then
    ComposeUri(this, 'Provenance.entity', 'whatUri', TFhirUri(elem.what), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance.entity', 'agent', elem.agentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseProvenance(obj : TTurtleComplex) : TFhirProvenance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.target') do
      result.targetList.Add(parseReference{TFhirReference}(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Provenance.period'));{q3b}
    result.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Provenance.recorded'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.policy') do
      result.policyList.Add(parseUri(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Provenance.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.reason') do
      result.reasonList.Add(parseCoding(item));
    result.activity := ParseCoding(obj.complex('http://hl7.org/fhir/Provenance.activity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent') do
      result.agentList.Add(parseProvenanceAgent(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity') do
      result.entityList.Add(parseProvenanceEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.signature') do
      result.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Provenance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Provenance', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'Provenance', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeInstant(this, 'Provenance', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'Provenance', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Provenance', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCoding(this, 'Provenance', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    ComposeCoding(this, 'Provenance', 'activity', elem.activityElement, false, -1);{x.2f}
  for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance', 'agent', elem.agentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(this, 'Provenance', 'entity', elem.entityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('signature') then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Provenance', 'signature', elem.signatureList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRTurtleParser.ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItem.create;
  try
    ParseQuestionnaireItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.linkId'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.item.definition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.code') do
      result.codeList.Add(parseCoding(item));
    result.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.prefix'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.text'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.type'), CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.enableWhen') do
      result.enableWhenList.Add(parseQuestionnaireItemEnableWhen(item));
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.required'));{q1}
    result.repeatsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.repeats'));{q1}
    result.readOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.readOnly'));{q1}
    result.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/Questionnaire.item.maxLength'));{q1}
    result.options := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/Questionnaire.item.options'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.option') do
      result.optionList.Add(parseQuestionnaireItemOption(item));
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialAttachment', item) then
      result.initial := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialCoding', item) then
      result.initial := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialQuantity', item) then
      result.initial := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialReference', item) {a3} then
      result.initial := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialBoolean', item) then
      result.initial := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialDecimal', item) then
      result.initial := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialInteger', item) then
      result.initial := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialDate', item) then
      result.initial := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialDateTime', item) then
      result.initial := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialTime', item) then
      result.initial := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialString', item) then
      result.initial := parseString(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initialUri', item) then
      result.initial := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.item') do
      result.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Questionnaire.item', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Questionnaire.item', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.item', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.item', 'prefix', elem.prefixElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire.item', 'text', elem.textElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Questionnaire.item', 'type', elem.Type_Element, CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(this, 'Questionnaire.item', 'enableWhen', elem.enableWhenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(this, 'Questionnaire.item', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(this, 'Questionnaire.item', 'repeats', elem.repeatsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'readOnly', elem.readOnlyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'Questionnaire.item', 'maxLength', elem.maxLengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(this, 'Questionnaire.item', 'options', elem.optionsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeQuestionnaireItemOption(this, 'Questionnaire.item', 'option', elem.optionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Questionnaire.item', 'initialAttachment', TFhirAttachment(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item', 'initialCoding', TFhirCoding(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item', 'initialQuantity', TFhirQuantity(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item', 'initialReference', TFhirReference(elem.initial), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item', 'initialBoolean', TFhirBoolean(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item', 'initialDecimal', TFhirDecimal(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item', 'initialInteger', TFhirInteger(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item', 'initialDate', TFhirDate(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item', 'initialDateTime', TFhirDateTime(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item', 'initialTime', TFhirTime(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item', 'initialString', TFhirString(elem.initial), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.initial is TFhirUri) {6} then
    ComposeUri(this, 'Questionnaire.item', 'initialUri', TFhirUri(elem.initial), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire.item', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    ParseQuestionnaireItemEnableWhenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemEnableWhen);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.questionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.question'));{q1}
    result.hasAnswerElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.hasAnswer'));{q1}
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerAttachment', item) then
      result.answer := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerCoding', item) then
      result.answer := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerQuantity', item) then
      result.answer := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerReference', item) {a3} then
      result.answer := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerBoolean', item) then
      result.answer := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDecimal', item) then
      result.answer := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerInteger', item) then
      result.answer := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDate', item) then
      result.answer := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDateTime', item) then
      result.answer := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerTime', item) then
      result.answer := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerString', item) then
      result.answer := parseString(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerUri', item) then
      result.answer := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemEnableWhen'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Questionnaire.item.enableWhen', 'question', elem.questionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item.enableWhen', 'hasAnswer', elem.hasAnswerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Questionnaire.item.enableWhen', 'answerAttachment', TFhirAttachment(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.enableWhen', 'answerCoding', TFhirCoding(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item.enableWhen', 'answerQuantity', TFhirQuantity(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.enableWhen', 'answerReference', TFhirReference(elem.answer), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item.enableWhen', 'answerBoolean', TFhirBoolean(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item.enableWhen', 'answerDecimal', TFhirDecimal(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.enableWhen', 'answerInteger', TFhirInteger(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.enableWhen', 'answerDate', TFhirDate(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item.enableWhen', 'answerDateTime', TFhirDateTime(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.enableWhen', 'answerTime', TFhirTime(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.enableWhen', 'answerString', TFhirString(elem.answer), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.answer is TFhirUri) {6} then
    ComposeUri(this, 'Questionnaire.item.enableWhen', 'answerUri', TFhirUri(elem.answer), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseQuestionnaireItemOption(obj : TTurtleComplex) : TFhirQuestionnaireItemOption;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemOption.create;
  try
    ParseQuestionnaireItemOptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemOptionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemOption);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.option.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.option.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.option.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.option.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.option.valueString', item) then
      result.value := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemOption(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemOption; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemOption'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.option', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.option', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.option', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.option', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.option', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Questionnaire.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.purpose'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Questionnaire.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.code') do
      result.codeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.subjectType') do
      result.subjectType.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item') do
      result.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Questionnaire'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Questionnaire', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Questionnaire', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Questionnaire', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Questionnaire', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Questionnaire', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Questionnaire', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Questionnaire', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Questionnaire', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Questionnaire', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Questionnaire', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Questionnaire', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Questionnaire', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Questionnaire', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Questionnaire', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Questionnaire', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Questionnaire', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Questionnaire', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Questionnaire', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRTurtleParser.ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItem.create;
  try
    ParseQuestionnaireResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.linkId'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.definition'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.text'));{q1}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer') do
      result.answerList.Add(parseQuestionnaireResponseItemAnswer(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'QuestionnaireResponse.item', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'QuestionnaireResponse.item', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.item', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse.item', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(this, 'QuestionnaireResponse.item', 'answer', elem.answerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    ParseQuestionnaireResponseItemAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItemAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueUri', item) then
      result.value := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItemAnswer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'QuestionnaireResponse.item.answer', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'QuestionnaireResponse.item.answer', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'QuestionnaireResponse.item.answer', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'QuestionnaireResponse.item.answer', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'QuestionnaireResponse.item.answer', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'QuestionnaireResponse.item.answer', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'QuestionnaireResponse.item.answer', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'QuestionnaireResponse.item.answer', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'QuestionnaireResponse.item.answer', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'QuestionnaireResponse.item.answer', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'QuestionnaireResponse.item.answer', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'QuestionnaireResponse.item.answer', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item.answer', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.parent') do
      result.parentList.Add(parseReference{Resource}(item));
    result.questionnaire := ParseReference{TFhirQuestionnaire}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.questionnaire'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.status'), CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.context'));{q3b}
    result.authoredElement := ParseDateTime(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.authored'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.author'));{q3b}
    result.source := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'QuestionnaireResponse', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'QuestionnaireResponse', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{Resource}(this, 'QuestionnaireResponse', 'parent', elem.parentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeReference{TFhirQuestionnaire}(this, 'QuestionnaireResponse', 'questionnaire', elem.questionnaireElement, false, -1);{x.2f}
  ComposeEnum(this, 'QuestionnaireResponse', 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTime(this, 'QuestionnaireResponse', 'authored', elem.authoredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(this, 'QuestionnaireResponse', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
function TFHIRTurtleParser.ParseReferralRequestRequester(obj : TTurtleComplex) : TFhirReferralRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReferralRequestRequester.create;
  try
    ParseReferralRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferralRequestRequesterProperties(obj : TTurtleComplex; result : TFhirReferralRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ReferralRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ReferralRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeReferralRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ReferralRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'ReferralRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'ReferralRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseReferralRequest(obj : TTurtleComplex) : TFhirReferralRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReferralRequest.create;
  try
    ParseReferralRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferralRequestProperties(obj : TTurtleComplex; result : TFhirReferralRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.definition') do
      result.definitionList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.basedOn') do
      result.basedOnList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.replaces') do
      result.replacesList.Add(parseReference{TFhirReferralRequest}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ReferralRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ReferralRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ReferralRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.type'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ReferralRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.serviceRequested') do
      result.serviceRequestedList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ReferralRequest.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/ReferralRequest.context'));{q3b}
    if obj.has('http://hl7.org/fhir/ReferralRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ReferralRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ReferralRequest.authoredOn'));{q1}
    result.requester := ParseReferralRequestRequester(obj.complex('http://hl7.org/fhir/ReferralRequest.requester'));{q3b}
    result.specialty := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ReferralRequest.specialty'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{Resource}(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ReferralRequest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ReferralRequest.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeReferralRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReferralRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ReferralRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ReferralRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(this, 'ReferralRequest', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'ReferralRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'ReferralRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'ReferralRequest', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'ReferralRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceRequested') then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(this, 'ReferralRequest', 'serviceRequested', elem.serviceRequestedList[i], false, i);{x.d3}
  ComposeReference{Resource}(this, 'ReferralRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'ReferralRequest', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ReferralRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ReferralRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'ReferralRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReferralRequestRequester(this, 'ReferralRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specialty') then
    ComposeCodeableConcept(this, 'ReferralRequest', 'specialty', elem.specialtyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ReferralRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{Resource}(this, 'ReferralRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'ReferralRequest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ReferralRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ReferralRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'ReferralRequest', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRTurtleParser.ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/RelatedPerson.active'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/RelatedPerson.patient'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RelatedPerson.relationship'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedPerson.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RelatedPerson.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.address') do
      result.addressList.Add(parseAddress(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.photo') do
      result.photoList.Add(parseAttachment(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/RelatedPerson.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPerson'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RelatedPerson', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'RelatedPerson', 'active', elem.activeElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'RelatedPerson', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(this, 'RelatedPerson', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'RelatedPerson', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'RelatedPerson', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'RelatedPerson', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'RelatedPerson', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'RelatedPerson', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'RelatedPerson', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'RelatedPerson', 'period', elem.periodElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
function TFHIRTurtleParser.ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupAction.create;
  try
    ParseRequestGroupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.label'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.description'));{q1}
    result.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.textEquivalent'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.condition') do
      result.conditionList.Add(parseRequestGroupActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.relatedAction') do
      result.relatedActionList.Add(parseRequestGroupActionRelatedAction(item));
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingDuration', item) then
      result.timing := parseDuration(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingDateTime', item) then
      result.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.participant') do
      result.participantList.Add(parseReference{Resource}(item));
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/RequestGroup.action.type'));{q3b}
    result.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    result.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    result.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    result.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    result.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RequestGroup.action.resource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.action') do
      result.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'textEquivalent', elem.textEquivalentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'RequestGroup.action', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'RequestGroup.action', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(this, 'RequestGroup.action', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(this, 'RequestGroup.action', 'relatedAction', elem.relatedActionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'RequestGroup.action', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action', 'timingDuration', TFhirDuration(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'RequestGroup.action', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RequestGroup.action', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeReference{Resource}(this, 'RequestGroup.action', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'RequestGroup.action', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'RequestGroup.action', 'resource', elem.resourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup.action', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionCondition.create;
  try
    ParseRequestGroupActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionCondition);
begin
    ParseBackboneElementProperties(obj, result);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.description'));{q1}
    result.languageElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'RequestGroup.action.condition', 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action.condition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action.condition', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action.condition', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    ParseRequestGroupActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actionIdElement := ParseId(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.actionId'));{q1}
    result.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.relatedAction.offsetDuration', item) then
      result.offset := parseDuration(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.relatedAction.offsetRange', item) then
      result.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionRelatedAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'RequestGroup.action.relatedAction', 'actionId', elem.actionIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'RequestGroup.action.relatedAction', 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action.relatedAction', 'offsetDuration', TFhirDuration(elem.offset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action.relatedAction', 'offsetRange', TFhirRange(elem.offset), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroup.create;
  try
    ParseRequestGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupProperties(obj : TTurtleComplex; result : TFhirRequestGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.definition') do
      result.definitionList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.replaces') do
      result.replacesList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RequestGroup.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RequestGroup.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RequestGroup.context'));{q3b}
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RequestGroup.authoredOn'));{q1}
    result.author := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RequestGroup.author'));{q3b}
    if obj.has('http://hl7.org/fhir/RequestGroup.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action') do
      result.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroup'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RequestGroup', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RequestGroup', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RequestGroup', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RequestGroup', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'RequestGroup', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'RequestGroup', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'RequestGroup', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'RequestGroup', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'RequestGroup', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'RequestGroup', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'RequestGroup', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{Resource}(this, 'RequestGroup', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'RequestGroup', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'RequestGroup', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RequestGroup', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup', 'action', elem.actionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
function TFHIRTurtleParser.ParseResearchStudyArm(obj : TTurtleComplex) : TFhirResearchStudyArm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyArm.create;
  try
    ParseResearchStudyArmProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyArmProperties(obj : TTurtleComplex; result : TFhirResearchStudyArm);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.name'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyArm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyArm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyArm'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ResearchStudy.arm', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.arm', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.arm', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudy.create;
  try
    ParseResearchStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyProperties(obj : TTurtleComplex; result : TFhirResearchStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.protocol') do
      result.protocolList.Add(parseReference{TFhirPlanDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.partOf') do
      result.partOfList.Add(parseReference{TFhirResearchStudy}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchStudy.status'), CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.focus') do
      result.focusList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.contact') do
      result.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.keyword') do
      result.keywordList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.enrollment') do
      result.enrollmentList.Add(parseReference{TFhirGroup}(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchStudy.period'));{q3b}
    result.sponsor := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ResearchStudy.sponsor'));{q3b}
    result.principalInvestigator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ResearchStudy.principalInvestigator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.site') do
      result.siteList.Add(parseReference{TFhirLocation}(item));
    result.reasonStopped := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.reasonStopped'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.arm') do
      result.armList.Add(parseResearchStudyArm(item));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudy'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchStudy', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ResearchStudy', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeReference{TFhirPlanDefinition}(this, 'ResearchStudy', 'protocol', elem.protocolList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(this, 'ResearchStudy', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'ResearchStudy', 'status', elem.StatusElement, CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ResearchStudy', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ResearchStudy', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'keyword', elem.keywordList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ResearchStudy', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enrollment') then
    for i := 0 to elem.enrollmentList.Count - 1 do
      ComposeReference{TFhirGroup}(this, 'ResearchStudy', 'enrollment', elem.enrollmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'ResearchStudy', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sponsor') then
    ComposeReference{TFhirOrganization}(this, 'ResearchStudy', 'sponsor', elem.sponsorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('principalInvestigator') then
    ComposeReference{TFhirPractitioner}(this, 'ResearchStudy', 'principalInvestigator', elem.principalInvestigatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('site') then
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'ResearchStudy', 'site', elem.siteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonStopped') then
    ComposeCodeableConcept(this, 'ResearchStudy', 'reasonStopped', elem.reasonStoppedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ResearchStudy', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('arm') then
    for i := 0 to elem.armList.Count - 1 do
      ComposeResearchStudyArm(this, 'ResearchStudy', 'arm', elem.armList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
function TFHIRTurtleParser.ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchSubject.create;
  try
    ParseResearchSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchSubjectProperties(obj : TTurtleComplex; result : TFhirResearchSubject);
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ResearchSubject.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchSubject.status'), CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchSubject.period'));{q3b}
    result.study := ParseReference{TFhirResearchStudy}(obj.complex('http://hl7.org/fhir/ResearchSubject.study'));{q3b}
    result.individual := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ResearchSubject.individual'));{q3b}
    result.assignedArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.assignedArm'));{q1}
    result.actualArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.actualArm'));{q1}
    result.consent := ParseReference{TFhirConsent}(obj.complex('http://hl7.org/fhir/ResearchSubject.consent'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchSubject'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ResearchSubject', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'ResearchSubject', 'status', elem.StatusElement, CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'ResearchSubject', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeReference{TFhirResearchStudy}(this, 'ResearchSubject', 'study', elem.studyElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'ResearchSubject', 'individual', elem.individualElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('assignedArm') then
    ComposeString(this, 'ResearchSubject', 'assignedArm', elem.assignedArmElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('actualArm') then
    ComposeString(this, 'ResearchSubject', 'actualArm', elem.actualArmElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('consent') then
    ComposeReference{TFhirConsent}(this, 'ResearchSubject', 'consent', elem.consentElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRTurtleParser.ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.outcome'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityRange', item) then
      result.probability := parseRange(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityDecimal', item) then
      result.probability := parseDecimal(item);
    result.qualitativeRisk := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.qualitativeRisk'));{q3b}
    result.relativeRiskElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.relativeRisk'));{q1}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenPeriod', item) then
      result.when := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenRange', item) then
      result.when := parseRange(item);
    result.rationaleElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.rationale'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessmentPrediction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'probabilityRange', TFhirRange(elem.probability), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'probabilityDecimal', TFhirDecimal(elem.probability), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'qualitativeRisk', elem.qualitativeRiskElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'relativeRisk', elem.relativeRiskElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment.prediction', 'whenPeriod', TFhirPeriod(elem.when), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'whenRange', TFhirRange(elem.when), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment.prediction', 'rationale', elem.rationaleElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RiskAssessment.identifier'));{q3b}
    result.basedOn := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RiskAssessment.basedOn'));{q3b}
    result.parent := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RiskAssessment.parent'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RiskAssessment.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.method'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.code'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RiskAssessment.subject'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RiskAssessment.context'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/RiskAssessment.condition'));{q3b}
    result.performer := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/RiskAssessment.performer'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.basis') do
      result.basisList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.prediction') do
      result.predictionList.Add(parseRiskAssessmentPrediction(item));
    result.mitigationElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.mitigation'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'RiskAssessment', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basedOn', elem.basedOnElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirReference}(this, 'RiskAssessment', 'parent', elem.parentElement, false, -1);{x.2f}
  ComposeEnum(this, 'RiskAssessment', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'RiskAssessment', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'RiskAssessment', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(this, 'RiskAssessment', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'RiskAssessment', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RiskAssessment', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(this, 'RiskAssessment', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(this, 'RiskAssessment', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'RiskAssessment', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'RiskAssessment', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('basis') then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basis', elem.basisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(this, 'RiskAssessment', 'prediction', elem.predictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeString(this, 'RiskAssessment', 'mitigation', elem.mitigationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'RiskAssessment', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRTurtleParser.ParseSchedule(obj : TTurtleComplex) : TFhirSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Schedule.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Schedule.active'));{q1}
    result.serviceCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Schedule.serviceCategory'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Schedule.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.actor') do
      result.actorList.Add(parseReference{Resource}(item));
    result.planningHorizon := ParsePeriod(obj.complex('http://hl7.org/fhir/Schedule.planningHorizon'));{q3b}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Schedule.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Schedule'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Schedule', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(this, 'Schedule', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(this, 'Schedule', 'serviceCategory', elem.serviceCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  for i := 0 to elem.actorList.Count - 1 do
      ComposeReference{Resource}(this, 'Schedule', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(this, 'Schedule', 'planningHorizon', elem.planningHorizonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Schedule', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRTurtleParser.ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameterComponent.create;
  try
    ParseSearchParameterComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterComponentProperties(obj : TTurtleComplex; result : TFhirSearchParameterComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.definition := ParseReference{TFhirSearchParameter}(obj.complex('http://hl7.org/fhir/SearchParameter.component.definition'));{q3b}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.component.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameterComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirSearchParameter}(this, 'SearchParameter.component', 'definition', elem.definitionElement, false, -1);{x.2f}
  ComposeString(this, 'SearchParameter.component', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SearchParameter.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SearchParameter.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.contact') do
      result.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.purpose'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/SearchParameter.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.base') do
      result.base.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.derivedFromElement := ParseUri(obj.complex('http://hl7.org/fhir/SearchParameter.derivedFrom'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.description'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.expression'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.xpath'));{q1}
    result.xpathUsageElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.xpathUsage'), CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.target') do
      result.target.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.comparator') do
      result.comparatorList.Add(parseEnum(item, CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.modifier') do
      result.modifierList.Add(parseEnum(item, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.chain') do
      result.chainList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.component') do
      result.componentList.Add(parseSearchParameterComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'SearchParameter', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'SearchParameter', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'SearchParameter', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'SearchParameter', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'SearchParameter', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'SearchParameter', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'SearchParameter', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'SearchParameter', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'SearchParameter', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SearchParameter', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'SearchParameter', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  ComposeCode(this, 'SearchParameter', 'code', elem.codeElement, false, -1);{x.2ea}
  for i := 0 to elem.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', elem.base[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  for i := 0 to elem.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', elem.base[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeEnum(this, 'SearchParameter', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    ComposeUri(this, 'SearchParameter', 'derivedFrom', elem.derivedFromElement, false, -1);{x.2ea}
  ComposeMarkdown(this, 'SearchParameter', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expression') then
    ComposeString(this, 'SearchParameter', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeString(this, 'SearchParameter', 'xpath', elem.xpathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnum(this, 'SearchParameter', 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') then
    for i := 0 to elem.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') then
    for i := 0 to elem.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('chain') then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(this, 'SearchParameter', 'chain', elem.chainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeSearchParameterComponent(this, 'SearchParameter', 'component', elem.componentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
function TFHIRTurtleParser.ParseSequenceReferenceSeq(obj : TTurtleComplex) : TFhirSequenceReferenceSeq;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSequenceReferenceSeq.create;
  try
    ParseSequenceReferenceSeqProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSequenceReferenceSeqProperties(obj : TTurtleComplex; result : TFhirSequenceReferenceSeq);
begin
    ParseBackboneElementProperties(obj, result);
    result.chromosome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.chromosome'));{q3b}
    result.genomeBuildElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.genomeBuild'));{q1}
    result.referenceSeqId := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.referenceSeqId'));{q3b}
    result.referenceSeqPointer := ParseReference{TFhirSequence}(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.referenceSeqPointer'));{q3b}
    result.referenceSeqStringElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.referenceSeqString'));{q1}
    result.strandElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.strand'));{q1}
    result.windowStartElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.windowStart'));{q1}
    result.windowEndElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq.windowEnd'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSequenceReferenceSeq(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceReferenceSeq; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SequenceReferenceSeq'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Sequence.referenceSeq', 'chromosome', elem.chromosomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.referenceSeq', 'genomeBuild', elem.genomeBuildElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Sequence.referenceSeq', 'referenceSeqId', elem.referenceSeqIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirSequence}(this, 'Sequence.referenceSeq', 'referenceSeqPointer', elem.referenceSeqPointerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.referenceSeq', 'referenceSeqString', elem.referenceSeqStringElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Sequence.referenceSeq', 'strand', elem.strandElement, false, -1);{x.2ea}
  ComposeInteger(this, 'Sequence.referenceSeq', 'windowStart', elem.windowStartElement, false, -1);{x.2ea}
  ComposeInteger(this, 'Sequence.referenceSeq', 'windowEnd', elem.windowEndElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSequenceVariant(obj : TTurtleComplex) : TFhirSequenceVariant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSequenceVariant.create;
  try
    ParseSequenceVariantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSequenceVariantProperties(obj : TTurtleComplex; result : TFhirSequenceVariant);
begin
    ParseBackboneElementProperties(obj, result);
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.variant.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.variant.end'));{q1}
    result.observedAlleleElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.variant.observedAllele'));{q1}
    result.referenceAlleleElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.variant.referenceAllele'));{q1}
    result.cigarElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.variant.cigar'));{q1}
    result.variantPointer := ParseReference{TFhirObservation}(obj.complex('http://hl7.org/fhir/Sequence.variant.variantPointer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSequenceVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceVariant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SequenceVariant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Sequence.variant', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Sequence.variant', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.variant', 'observedAllele', elem.observedAlleleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.variant', 'referenceAllele', elem.referenceAlleleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.variant', 'cigar', elem.cigarElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirObservation}(this, 'Sequence.variant', 'variantPointer', elem.variantPointerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSequenceQuality(obj : TTurtleComplex) : TFhirSequenceQuality;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSequenceQuality.create;
  try
    ParseSequenceQualityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSequenceQualityProperties(obj : TTurtleComplex; result : TFhirSequenceQuality);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Sequence.quality.type'), CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum);
    result.standardSequence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Sequence.quality.standardSequence'));{q3b}
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.quality.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.quality.end'));{q1}
    result.score := ParseQuantity(obj.complex('http://hl7.org/fhir/Sequence.quality.score'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Sequence.quality.method'));{q3b}
    result.truthTPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.truthTP'));{q1}
    result.queryTPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.queryTP'));{q1}
    result.truthFNElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.truthFN'));{q1}
    result.queryFPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.queryFP'));{q1}
    result.gtFPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.gtFP'));{q1}
    result.precisionElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.precision'));{q1}
    result.recallElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.recall'));{q1}
    result.fScore_Element := ParseDecimal(obj.complex('http://hl7.org/fhir/Sequence.quality.fScore'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSequenceQuality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceQuality; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SequenceQuality'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Sequence.quality', 'type', elem.Type_Element, CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Sequence.quality', 'standardSequence', elem.standardSequenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Sequence.quality', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Sequence.quality', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Sequence.quality', 'score', elem.scoreElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Sequence.quality', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'truthTP', elem.truthTPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'queryTP', elem.queryTPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'truthFN', elem.truthFNElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'queryFP', elem.queryFPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'gtFP', elem.gtFPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'precision', elem.precisionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'recall', elem.recallElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Sequence.quality', 'fScore', elem.fScore_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSequenceRepository(obj : TTurtleComplex) : TFhirSequenceRepository;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSequenceRepository.create;
  try
    ParseSequenceRepositoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSequenceRepositoryProperties(obj : TTurtleComplex; result : TFhirSequenceRepository);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Sequence.repository.type'), CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Sequence.repository.url'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.repository.name'));{q1}
    result.datasetIdElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.repository.datasetId'));{q1}
    result.variantsetIdElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.repository.variantsetId'));{q1}
    result.readsetIdElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.repository.readsetId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSequenceRepository(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequenceRepository; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SequenceRepository'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Sequence.repository', 'type', elem.Type_Element, CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Sequence.repository', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.repository', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.repository', 'datasetId', elem.datasetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.repository', 'variantsetId', elem.variantsetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Sequence.repository', 'readsetId', elem.readsetIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSequence(obj : TTurtleComplex) : TFhirSequence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSequence.create;
  try
    ParseSequenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSequenceProperties(obj : TTurtleComplex; result : TFhirSequence);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Sequence.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_Element := ParseCode(obj.complex('http://hl7.org/fhir/Sequence.type'));{q1}
    result.coordinateSystemElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.coordinateSystem'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Sequence.patient'));{q3b}
    result.specimen := ParseReference{TFhirSpecimen}(obj.complex('http://hl7.org/fhir/Sequence.specimen'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Sequence.device'));{q3b}
    result.performer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Sequence.performer'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Sequence.quantity'));{q3b}
    result.referenceSeq := ParseSequenceReferenceSeq(obj.complex('http://hl7.org/fhir/Sequence.referenceSeq'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Sequence.variant') do
      result.variantList.Add(parseSequenceVariant(item));
    result.observedSeqElement := ParseString(obj.complex('http://hl7.org/fhir/Sequence.observedSeq'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Sequence.quality') do
      result.qualityList.Add(parseSequenceQuality(item));
    result.readCoverageElement := ParseInteger(obj.complex('http://hl7.org/fhir/Sequence.readCoverage'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Sequence.repository') do
      result.repositoryList.Add(parseSequenceRepository(item));
    for item in obj.complexes('http://hl7.org/fhir/Sequence.pointer') do
      result.pointerList.Add(parseReference{TFhirSequence}(item));
end;

procedure TFHIRTurtleComposer.ComposeSequence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSequence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Sequence'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Sequence', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCode(this, 'Sequence', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeInteger(this, 'Sequence', 'coordinateSystem', elem.coordinateSystemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Sequence', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(this, 'Sequence', 'specimen', elem.specimenElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(this, 'Sequence', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirOrganization}(this, 'Sequence', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'Sequence', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceSeq') then
    ComposeSequenceReferenceSeq(this, 'Sequence', 'referenceSeq', elem.referenceSeqElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('variant') then
    for i := 0 to elem.variantList.Count - 1 do
      ComposeSequenceVariant(this, 'Sequence', 'variant', elem.variantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('observedSeq') then
    ComposeString(this, 'Sequence', 'observedSeq', elem.observedSeqElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quality') then
    for i := 0 to elem.qualityList.Count - 1 do
      ComposeSequenceQuality(this, 'Sequence', 'quality', elem.qualityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('readCoverage') then
    ComposeInteger(this, 'Sequence', 'readCoverage', elem.readCoverageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repository') then
    for i := 0 to elem.repositoryList.Count - 1 do
      ComposeSequenceRepository(this, 'Sequence', 'repository', elem.repositoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pointer') then
    for i := 0 to elem.pointerList.Count - 1 do
      ComposeReference{TFhirSequence}(this, 'Sequence', 'pointer', elem.pointerList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
function TFHIRTurtleParser.ParseServiceDefinition(obj : TTurtleComplex) : TFhirServiceDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirServiceDefinition.create;
  try
    ParseServiceDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseServiceDefinitionProperties(obj : TTurtleComplex; result : TFhirServiceDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ServiceDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ServiceDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ServiceDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceDefinition.publisher'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ServiceDefinition.description'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ServiceDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceDefinition.usage'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ServiceDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ServiceDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ServiceDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.contributor') do
      result.contributorList.Add(parseContributor(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ServiceDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.trigger') do
      result.triggerList.Add(parseTriggerDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceDefinition.dataRequirement') do
      result.dataRequirementList.Add(parseDataRequirement(item));
    result.operationDefinition := ParseReference{TFhirOperationDefinition}(obj.complex('http://hl7.org/fhir/ServiceDefinition.operationDefinition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeServiceDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirServiceDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ServiceDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ServiceDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ServiceDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ServiceDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ServiceDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ServiceDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ServiceDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ServiceDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ServiceDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ServiceDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ServiceDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ServiceDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'ServiceDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ServiceDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ServiceDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ServiceDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ServiceDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeContributor(this, 'ServiceDefinition', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ServiceDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ServiceDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ServiceDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('trigger') then
    for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(this, 'ServiceDefinition', 'trigger', elem.triggerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'ServiceDefinition', 'dataRequirement', elem.dataRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('operationDefinition') then
    ComposeReference{TFhirOperationDefinition}(this, 'ServiceDefinition', 'operationDefinition', elem.operationDefinitionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
function TFHIRTurtleParser.ParseSlot(obj : TTurtleComplex) : TFhirSlot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSlot.create;
  try
    ParseSlotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Slot.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.serviceCategory := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Slot.serviceCategory'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Slot.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    result.appointmentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Slot.appointmentType'));{q3b}
    result.schedule := ParseReference{TFhirSchedule}(obj.complex('http://hl7.org/fhir/Slot.schedule'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Slot.status'), CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.end'));{q1}
    result.overbookedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Slot.overbooked'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Slot.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Slot'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Slot', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(this, 'Slot', 'serviceCategory', elem.serviceCategoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(this, 'Slot', 'appointmentType', elem.appointmentTypeElement, false, -1);{x.2f}
  ComposeReference{TFhirSchedule}(this, 'Slot', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  ComposeEnum(this, 'Slot', 'status', elem.StatusElement, CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, false, -1);{x.d4}
  ComposeInstant(this, 'Slot', 'start', elem.startElement, false, -1);{x.2ea}
  ComposeInstant(this, 'Slot', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBoolean(this, 'Slot', 'overbooked', elem.overbookedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Slot', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRTurtleParser.ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.collector := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Specimen.collection.collector'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedPeriod', item) then
      result.collected := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedDateTime', item) then
      result.collected := parseDateTime(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.collection.quantity'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.method'));{q3b}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.bodySite'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenCollection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Specimen.collection', 'collector', elem.collectorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.collection', 'collectedPeriod', TFhirPeriod(elem.collected), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.collection', 'collectedDateTime', TFhirDateTime(elem.collected), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.collection', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenProcessing.create;
  try
    ParseSpecimenProcessingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProcessingProperties(obj : TTurtleComplex; result : TFhirSpecimenProcessing);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.processing.description'));{q1}
    result.procedure_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.processing.procedure'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing.additive') do
      result.additiveList.Add(parseReference{TFhirSubstance}(item));
    if obj.has('http://hl7.org/fhir/Specimen.processing.timePeriod', item) then
      result.time := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Specimen.processing.timeDateTime', item) then
      result.time := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenProcessing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenProcessing'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.processing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.processing', 'procedure', elem.procedure_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(this, 'Specimen.processing', 'additive', elem.additiveList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.processing', 'timePeriod', TFhirPeriod(elem.time), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.processing', 'timeDateTime', TFhirDateTime(elem.time), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.container.description'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.container.type'));{q3b}
    result.capacity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.capacity'));{q3b}
    result.specimenQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.specimenQuantity'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveCodeableConcept', item) then
      result.additive := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveReference', item) {a3} then
      result.additive := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenContainer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen.container', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.container', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.container', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'capacity', elem.capacityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'specimenQuantity', elem.specimenQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Specimen.container', 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(this, 'Specimen.container', 'additiveReference', TFhirReference(elem.additive), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.accessionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Specimen.accessionIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Specimen.status'), CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.type'));{q3b}
    result.subject := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Specimen.subject'));{q3b}
    result.receivedTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Specimen.receivedTime'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.parent') do
      result.parentList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.request') do
      result.requestList.Add(parseReference{TFhirProcedureRequest}(item));
    result.collection := ParseSpecimenCollection(obj.complex('http://hl7.org/fhir/Specimen.collection'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing') do
      result.processingList.Add(parseSpecimenProcessing(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container') do
      result.containerList.Add(parseSpecimenContainer(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Specimen'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(this, 'Specimen', 'accessionIdentifier', elem.accessionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Specimen', 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Specimen', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeReference{Resource}(this, 'Specimen', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTime(this, 'Specimen', 'receivedTime', elem.receivedTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'Specimen', 'parent', elem.parentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirProcedureRequest}(this, 'Specimen', 'request', elem.requestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(this, 'Specimen', 'collection', elem.collectionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') then
    for i := 0 to elem.processingList.Count - 1 do
      ComposeSpecimenProcessing(this, 'Specimen', 'processing', elem.processingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('container') then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(this, 'Specimen', 'container', elem.containerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Specimen', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRTurtleParser.ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.identity'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.uri'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.name'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionMapping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'StructureDefinition.mapping', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.snapshot.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionSnapshot'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.snapshot', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.differential.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionDifferential'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.differential', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.keyword') do
      result.keywordList.Add(parseCoding(item));
    result.fhirVersionElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.fhirVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.mapping') do
      result.mappingList.Add(parseStructureDefinitionMapping(item));
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.kind'), CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.abstract'));{q1}
    result.contextTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.contextType'), CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.context') do
      result.contextList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contextInvariant') do
      result.contextInvariantList.Add(parseString(item));
    result.type_Element := ParseCode(obj.complex('http://hl7.org/fhir/StructureDefinition.type'));{q1}
    result.baseDefinitionElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.baseDefinition'));{q1}
    result.derivationElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.derivation'), CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum);
    result.snapshot := ParseStructureDefinitionSnapshot(obj.complex('http://hl7.org/fhir/StructureDefinition.snapshot'));{q3b}
    result.differential := ParseStructureDefinitionDifferential(obj.complex('http://hl7.org/fhir/StructureDefinition.differential'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'StructureDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'StructureDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'StructureDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'StructureDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'StructureDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'StructureDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'StructureDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'StructureDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'StructureDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCoding(this, 'StructureDefinition', 'keyword', elem.keywordList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(this, 'StructureDefinition', 'fhirVersion', elem.fhirVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(this, 'StructureDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
  ComposeEnum(this, 'StructureDefinition', 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'StructureDefinition', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnum(this, 'StructureDefinition', 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'context', elem.contextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextInvariant') then
    for i := 0 to elem.contextInvariantList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'contextInvariant', elem.contextInvariantList[i], false, i);{x.d3}
  ComposeCode(this, 'StructureDefinition', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('baseDefinition') then
    ComposeUri(this, 'StructureDefinition', 'baseDefinition', elem.baseDefinitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivation') then
    ComposeEnum(this, 'StructureDefinition', 'derivation', elem.DerivationElement, CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(this, 'StructureDefinition', 'snapshot', elem.snapshotElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(this, 'StructureDefinition', 'differential', elem.differentialElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
function TFHIRTurtleParser.ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapStructure.create;
  try
    ParseStructureMapStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapStructureProperties(obj : TTurtleComplex; result : TFhirStructureMapStructure);
begin
    ParseBackboneElementProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureMap.structure.url'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.structure.mode'), CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum);
    result.aliasElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.alias'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapStructure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureMap.structure', 'url', elem.urlElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.structure', 'mode', elem.ModeElement, CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.structure', 'alias', elem.aliasElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.structure', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroup.create;
  try
    ParseStructureMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupProperties(obj : TTurtleComplex; result : TFhirStructureMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.name'));{q1}
    result.extendsElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.extends'));{q1}
    result.typeModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.typeMode'), CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.input') do
      result.inputList.Add(parseStructureMapGroupInput(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule') do
      result.ruleList.Add(parseStructureMapGroupRule(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group', 'extends', elem.extendsElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.group', 'typeMode', elem.TypeModeElement, CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  for i := 0 to elem.inputList.Count - 1 do
      ComposeStructureMapGroupInput(this, 'StructureMap.group', 'input', elem.inputList[i], false, i);{x.d3}
  for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupInput.create;
  try
    ParseStructureMapGroupInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupInputProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupInput);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.input.name'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.type'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.input.mode'), CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupInput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.input', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.group.input', 'mode', elem.ModeElement, CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRule.create;
  try
    ParseStructureMapGroupRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.source') do
      result.sourceList.Add(parseStructureMapGroupRuleSource(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target') do
      result.targetList.Add(parseStructureMapGroupRuleTarget(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.rule') do
      result.ruleList.Add(parseStructureMapGroupRule(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent') do
      result.dependentList.Add(parseStructureMapGroupRuleDependent(item));
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule', 'name', elem.nameElement, false, -1);{x.2ea}
  for i := 0 to elem.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(this, 'StructureMap.group.rule', 'source', elem.sourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(this, 'StructureMap.group.rule', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group.rule', 'rule', elem.ruleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(this, 'StructureMap.group.rule', 'dependent', elem.dependentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.rule', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleSource.create;
  try
    ParseStructureMapGroupRuleSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.context'));{q1}
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.max'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.type'));{q1}
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCode', item) then
      result.defaultValue := parseCode(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueId', item) then
      result.defaultValue := parseId(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueMarkdown', item) then
      result.defaultValue := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueOid', item) then
      result.defaultValue := parseOid(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValuePositiveInt', item) then
      result.defaultValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUnsignedInt', item) then
      result.defaultValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAddress', item) then
      result.defaultValue := parseAddress(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAge', item) then
      result.defaultValue := parseAge(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAnnotation', item) then
      result.defaultValue := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAttachment', item) then
      result.defaultValue := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCodeableConcept', item) then
      result.defaultValue := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCoding', item) then
      result.defaultValue := parseCoding(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueContactPoint', item) then
      result.defaultValue := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCount', item) then
      result.defaultValue := parseCount(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDistance', item) then
      result.defaultValue := parseDistance(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDuration', item) then
      result.defaultValue := parseDuration(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueHumanName', item) then
      result.defaultValue := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueIdentifier', item) then
      result.defaultValue := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueMoney', item) then
      result.defaultValue := parseMoney(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValuePeriod', item) then
      result.defaultValue := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueQuantity', item) then
      result.defaultValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueRange', item) then
      result.defaultValue := parseRange(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueRatio', item) then
      result.defaultValue := parseRatio(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueReference', item) then
      result.defaultValue := parseReference(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueSampledData', item) then
      result.defaultValue := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueSignature', item) then
      result.defaultValue := parseSignature(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueTiming', item) then
      result.defaultValue := parseTiming(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueMeta', item) then
      result.defaultValue := parseMeta(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueBase64Binary', item) then
      result.defaultValue := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueBoolean', item) then
      result.defaultValue := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDate', item) then
      result.defaultValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDateTime', item) then
      result.defaultValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDecimal', item) then
      result.defaultValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueInstant', item) then
      result.defaultValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueInteger', item) then
      result.defaultValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueString', item) then
      result.defaultValue := parseString(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueTime', item) then
      result.defaultValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUri', item) then
      result.defaultValue := parseUri(item);
    result.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.element'));{q1}
    result.listModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.listMode'), CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum);
    result.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.variable'));{q1}
    result.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.condition'));{q1}
    result.checkElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.check'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule.source', 'context', elem.contextElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'StructureMap.group.rule.source', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(this, 'StructureMap.group.rule.source', 'defaultValueCode', TFhirCode(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(this, 'StructureMap.group.rule.source', 'defaultValueId', TFhirId(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'StructureMap.group.rule.source', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(this, 'StructureMap.group.rule.source', 'defaultValueOid', TFhirOid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'StructureMap.group.rule.source', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'StructureMap.group.rule.source', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(this, 'StructureMap.group.rule.source', 'defaultValueAddress', TFhirAddress(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(this, 'StructureMap.group.rule.source', 'defaultValueAge', TFhirAge(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'StructureMap.group.rule.source', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(this, 'StructureMap.group.rule.source', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'StructureMap.group.rule.source', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(this, 'StructureMap.group.rule.source', 'defaultValueCoding', TFhirCoding(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'StructureMap.group.rule.source', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(this, 'StructureMap.group.rule.source', 'defaultValueCount', TFhirCount(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(this, 'StructureMap.group.rule.source', 'defaultValueDistance', TFhirDistance(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(this, 'StructureMap.group.rule.source', 'defaultValueDuration', TFhirDuration(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(this, 'StructureMap.group.rule.source', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'StructureMap.group.rule.source', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(this, 'StructureMap.group.rule.source', 'defaultValueMoney', TFhirMoney(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(this, 'StructureMap.group.rule.source', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'StructureMap.group.rule.source', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(this, 'StructureMap.group.rule.source', 'defaultValueRange', TFhirRange(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(this, 'StructureMap.group.rule.source', 'defaultValueRatio', TFhirRatio(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(this, 'StructureMap.group.rule.source', 'defaultValueReference', TFhirReference(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(this, 'StructureMap.group.rule.source', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(this, 'StructureMap.group.rule.source', 'defaultValueSignature', TFhirSignature(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(this, 'StructureMap.group.rule.source', 'defaultValueTiming', TFhirTiming(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMeta) {6} then
    ComposeMeta(this, 'StructureMap.group.rule.source', 'defaultValueMeta', TFhirMeta(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'StructureMap.group.rule.source', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(this, 'StructureMap.group.rule.source', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(this, 'StructureMap.group.rule.source', 'defaultValueDate', TFhirDate(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'StructureMap.group.rule.source', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'StructureMap.group.rule.source', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(this, 'StructureMap.group.rule.source', 'defaultValueInstant', TFhirInstant(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(this, 'StructureMap.group.rule.source', 'defaultValueInteger', TFhirInteger(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(this, 'StructureMap.group.rule.source', 'defaultValueString', TFhirString(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(this, 'StructureMap.group.rule.source', 'defaultValueTime', TFhirTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(this, 'StructureMap.group.rule.source', 'defaultValueUri', TFhirUri(elem.defaultValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'element', elem.elementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.source', 'listMode', elem.ListModeElement, CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.source', 'variable', elem.variableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'condition', elem.conditionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'check', elem.checkElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    ParseStructureMapGroupRuleTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.context'));{q1}
    result.contextTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.contextType'), CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum);
    result.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.element'));{q1}
    result.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.variable'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.listMode') do
      result.listModeList.Add(parseEnum(item, CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum));
    result.listRuleIdElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.listRuleId'));{q1}
    result.transformElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.transform'), CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.parameter') do
      result.parameterList.Add(parseStructureMapGroupRuleTargetParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'context', elem.contextElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.target', 'contextType', elem.ContextTypeElement, CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.target', 'element', elem.elementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'variable', elem.variableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'listRuleId', elem.listRuleIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.target', 'transform', elem.TransformElement, CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(this, 'StructureMap.group.rule.target', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    ParseStructureMapGroupRuleTargetParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTargetParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTargetParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirId) {6} then
    ComposeId(this, 'StructureMap.group.rule.target.parameter', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'StructureMap.group.rule.target.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'StructureMap.group.rule.target.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'StructureMap.group.rule.target.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'StructureMap.group.rule.target.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    ParseStructureMapGroupRuleDependentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleDependent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.dependent.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent.variable') do
      result.variableList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleDependent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule.dependent', 'name', elem.nameElement, false, -1);{x.2ea}
  for i := 0 to elem.variableList.Count - 1 do
      ComposeString(this, 'StructureMap.group.rule.dependent', 'variable', elem.variableList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMap.create;
  try
    ParseStructureMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapProperties(obj : TTurtleComplex; result : TFhirStructureMap);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureMap.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureMap.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureMap.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.structure') do
      result.structureList.Add(parseStructureMapStructure(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.import') do
      result.importList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group') do
      result.groupList.Add(parseStructureMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMap'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureMap', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureMap', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'StructureMap', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'StructureMap', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'StructureMap', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'StructureMap', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'StructureMap', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'StructureMap', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureMap', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'StructureMap', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureMap', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureMap', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'StructureMap', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'StructureMap', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') then
    for i := 0 to elem.structureList.Count - 1 do
      ComposeStructureMapStructure(this, 'StructureMap', 'structure', elem.structureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('import') then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(this, 'StructureMap', 'import', elem.importList[i], false, i);{x.d3}
  for i := 0 to elem.groupList.Count - 1 do
      ComposeStructureMapGroup(this, 'StructureMap', 'group', elem.groupList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRTurtleParser.ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionChannel.create;
  try
    ParseSubscriptionChannelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.channel.type'), CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    result.endpointElement := ParseUri(obj.complex('http://hl7.org/fhir/Subscription.channel.endpoint'));{q1}
    result.payloadElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.channel.payload'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Subscription.channel.header') do
      result.headerList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionChannel'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Subscription.channel', 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Subscription.channel', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription.channel', 'payload', elem.payloadElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(this, 'Subscription.channel', 'header', elem.headerList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubscription(obj : TTurtleComplex) : TFhirSubscription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.status'), CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Subscription.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Subscription.end'));{q1}
    result.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.reason'));{q1}
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.criteria'));{q1}
    result.errorElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.error'));{q1}
    result.channel := ParseSubscriptionChannel(obj.complex('http://hl7.org/fhir/Subscription.channel'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Subscription.tag') do
      result.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Subscription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'Subscription', 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Subscription', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Subscription', 'end', elem.end_Element, false, -1);{x.2ea}
  ComposeString(this, 'Subscription', 'reason', elem.reasonElement, false, -1);{x.2ea}
  ComposeString(this, 'Subscription', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeString(this, 'Subscription', 'error', elem.errorElement, false, -1);{x.2ea}
  ComposeSubscriptionChannel(this, 'Subscription', 'channel', elem.channelElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tag') then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(this, 'Subscription', 'tag', elem.tagList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRTurtleParser.ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceInstance.create;
  try
    ParseSubstanceInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Substance.instance.identifier'));{q3b}
    result.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Substance.instance.expiry'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Substance.instance.quantity'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Substance.instance', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Substance.instance', 'expiry', elem.expiryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Substance.instance', 'quantity', elem.quantityElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseRatio(obj.complex('http://hl7.org/fhir/Substance.ingredient.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/Substance.ingredient.substanceCodeableConcept', item) then
      result.substance := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Substance.ingredient.substanceReference', item) {a3} then
      result.substance := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'Substance.ingredient', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (elem.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Substance.ingredient', 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance), false, -1){x.d9}
  else if (elem.substance is TFhirReference) {2} then
    ComposeReference(this, 'Substance.ingredient', 'substanceReference', TFhirReference(elem.substance), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSubstance(obj : TTurtleComplex) : TFhirSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Substance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Substance.status'), CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Substance.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Substance.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Substance.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Substance.instance') do
      result.instanceList.Add(parseSubstanceInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/Substance.ingredient') do
      result.ingredientList.Add(parseSubstanceIngredient(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Substance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Substance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Substance', 'status', elem.StatusElement, CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Substance', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Substance', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Substance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(this, 'Substance', 'instance', elem.instanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(this, 'Substance', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRTurtleParser.ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    ParseSupplyDeliverySuppliedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; result : TFhirSupplyDeliverySuppliedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyDelivery.suppliedItem.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.suppliedItem.itemReference', item) {a3} then
      result.item := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDeliverySuppliedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SupplyDelivery.suppliedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyDelivery.suppliedItem', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'SupplyDelivery.suppliedItem', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SupplyDelivery.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.basedOn') do
      result.basedOnList.Add(parseReference{TFhirSupplyRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.partOf') do
      result.partOfList.Add(parseReference{Resource}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyDelivery.status'), CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/SupplyDelivery.patient'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyDelivery.type'));{q3b}
    result.suppliedItem := ParseSupplyDeliverySuppliedItem(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.supplier := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyDelivery.supplier'));{q3b}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/SupplyDelivery.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.receiver') do
      result.receiverList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDelivery'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SupplyDelivery', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirSupplyRequest}(this, 'SupplyDelivery', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{Resource}(this, 'SupplyDelivery', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyDelivery', 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'SupplyDelivery', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'SupplyDelivery', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('suppliedItem') then
    ComposeSupplyDeliverySuppliedItem(this, 'SupplyDelivery', 'suppliedItem', elem.suppliedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyDelivery', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyDelivery', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyDelivery', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('supplier') then
    ComposeReference{Resource}(this, 'SupplyDelivery', 'supplier', elem.supplierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'SupplyDelivery', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'receiver', elem.receiverList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRTurtleParser.ParseSupplyRequestOrderedItem(obj : TTurtleComplex) : TFhirSupplyRequestOrderedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequestOrderedItem.create;
  try
    ParseSupplyRequestOrderedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestOrderedItemProperties(obj : TTurtleComplex; result : TFhirSupplyRequestOrderedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyRequest.orderedItem.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyRequest.orderedItem.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.orderedItem.itemReference', item) {a3} then
      result.item := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequestOrderedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestOrderedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequestOrderedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeQuantity(this, 'SupplyRequest.orderedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest.orderedItem', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'SupplyRequest.orderedItem', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSupplyRequestRequester(obj : TTurtleComplex) : TFhirSupplyRequestRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequestRequester.create;
  try
    ParseSupplyRequestRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestRequesterProperties(obj : TTurtleComplex; result : TFhirSupplyRequestRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyRequest.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/SupplyRequest.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequestRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequestRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'SupplyRequest.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'SupplyRequest.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SupplyRequest.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.status'), CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.category'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.orderedItem := ParseSupplyRequestOrderedItem(obj.complex('http://hl7.org/fhir/SupplyRequest.orderedItem'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SupplyRequest.authoredOn'));{q1}
    result.requester := ParseSupplyRequestRequester(obj.complex('http://hl7.org/fhir/SupplyRequest.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.supplier') do
      result.supplierList.Add(parseReference{TFhirOrganization}(item));
    if obj.has('http://hl7.org/fhir/SupplyRequest.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    result.deliverFrom := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverFrom'));{q3b}
    result.deliverTo := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverTo'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SupplyRequest', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyRequest', 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'SupplyRequest', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'SupplyRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedItem') then
    ComposeSupplyRequestOrderedItem(this, 'SupplyRequest', 'orderedItem', elem.orderedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'SupplyRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeSupplyRequestRequester(this, 'SupplyRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'supplier', elem.supplierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'SupplyRequest', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverFrom') then
    ComposeReference{Resource}(this, 'SupplyRequest', 'deliverFrom', elem.deliverFromElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverTo') then
    ComposeReference{Resource}(this, 'SupplyRequest', 'deliverTo', elem.deliverToElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
function TFHIRTurtleParser.ParseTaskRequester(obj : TTurtleComplex) : TFhirTaskRequester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskRequester.create;
  try
    ParseTaskRequesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskRequesterProperties(obj : TTurtleComplex; result : TFhirTaskRequester);
begin
    ParseBackboneElementProperties(obj, result);
    result.agent := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Task.requester.agent'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Task.requester.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTaskRequester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRequester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskRequester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{Resource}(this, 'Task.requester', 'agent', elem.agentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Task.requester', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskRestriction.create;
  try
    ParseTaskRestrictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskRestrictionProperties(obj : TTurtleComplex; result : TFhirTaskRestriction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.repetitionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Task.restriction.repetitions'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.restriction.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.restriction.recipient') do
      result.recipientList.Add(parseReference{Resource}(item));
end;

procedure TFHIRTurtleComposer.ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRestriction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskRestriction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Task.restriction', 'repetitions', elem.repetitionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Task.restriction', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(this, 'Task.restriction', 'recipient', elem.recipientList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskInput.create;
  try
    ParseTaskInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskInputProperties(obj : TTurtleComplex; result : TFhirTaskInput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.input.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Task.input.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Task.input.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Task.input.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueMeta', item) then
      result.value := parseMeta(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskInput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Task.input', 'type', elem.type_Element, false, -1);{x.2f}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.input', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'Task.input', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.input', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.input', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.input', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.input', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.input', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.input', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.input', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.input', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.input', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.input', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.input', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.input', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.input', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.input', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.input', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.input', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.input', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.input', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.input', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.input', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.input', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.input', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.input', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.input', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.input', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Task.input', 'valueMeta', TFhirMeta(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.input', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.input', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.input', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.input', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.input', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.input', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.input', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Task.input', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.input', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.input', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskOutput.create;
  try
    ParseTaskOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskOutputProperties(obj : TTurtleComplex; result : TFhirTaskOutput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.output.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Task.output.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Task.output.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Task.output.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueMeta', item) then
      result.value := parseMeta(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskOutput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Task.output', 'type', elem.type_Element, false, -1);{x.2f}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.output', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'Task.output', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.output', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.output', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.output', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.output', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.output', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.output', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.output', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.output', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.output', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.output', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.output', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.output', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.output', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.output', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.output', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.output', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.output', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.output', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.output', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.output', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.output', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.output', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.output', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.output', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.output', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Task.output', 'valueMeta', TFhirMeta(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.output', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.output', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.output', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.output', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.output', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.output', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.output', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Task.output', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.output', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.output', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseTask(obj : TTurtleComplex) : TFhirTask;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTask.create;
  try
    ParseTaskProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskProperties(obj : TTurtleComplex; result : TFhirTask);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Task.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    if obj.has('http://hl7.org/fhir/Task.definitionReference', item) {a3} then
      result.definition := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Task.definitionUri', item) then
      result.definition := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/Task.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Task.groupIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.partOf') do
      result.partOfList.Add(parseReference{TFhirTask}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.status'), CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.statusReason'));{q3b}
    result.businessStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.businessStatus'));{q3b}
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Task.description'));{q1}
    result.focus := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Task.focus'));{q3b}
    result.for_ := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Task.for'));{q3b}
    result.context := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Task.context'));{q3b}
    result.executionPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.executionPeriod'));{q3b}
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.authoredOn'));{q1}
    result.lastModifiedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.lastModified'));{q1}
    result.requester := ParseTaskRequester(obj.complex('http://hl7.org/fhir/Task.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.performerType') do
      result.performerTypeList.Add(parseCodeableConcept(item));
    result.owner := ParseReference{Resource}(obj.complex('http://hl7.org/fhir/Task.owner'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.reason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
    result.restriction := ParseTaskRestriction(obj.complex('http://hl7.org/fhir/Task.restriction'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.input') do
      result.inputList.Add(parseTaskInput(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.output') do
      result.outputList.Add(parseTaskOutput(item));
end;

procedure TFHIRTurtleComposer.ComposeTask(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTask; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Task'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Task', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.definition is TFhirReference) {2} then
    ComposeReference(this, 'Task', 'definitionReference', TFhirReference(elem.definition), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.definition is TFhirUri) {6} then
    ComposeUri(this, 'Task', 'definitionUri', TFhirUri(elem.definition), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Task', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'Task', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirTask}(this, 'Task', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Task', 'status', elem.StatusElement, CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Task', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('businessStatus') then
    ComposeCodeableConcept(this, 'Task', 'businessStatus', elem.businessStatusElement, false, -1);{x.2f}
  ComposeEnum(this, 'Task', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnum(this, 'Task', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Task', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Task', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    ComposeReference{TFhirReference}(this, 'Task', 'focus', elem.focusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('for_') then
    ComposeReference{TFhirReference}(this, 'Task', 'for', elem.for_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(this, 'Task', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('executionPeriod') then
    ComposePeriod(this, 'Task', 'executionPeriod', elem.executionPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'Task', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastModified') then
    ComposeDateTime(this, 'Task', 'lastModified', elem.lastModifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeTaskRequester(this, 'Task', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('performerType') then
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Task', 'performerType', elem.performerTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{Resource}(this, 'Task', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'Task', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Task', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'Task', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('restriction') then
    ComposeTaskRestriction(this, 'Task', 'restriction', elem.restrictionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('input') then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeTaskInput(this, 'Task', 'input', elem.inputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('output') then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeTaskOutput(this, 'Task', 'output', elem.outputList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
function TFHIRTurtleParser.ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportParticipant.create;
  try
    ParseTestReportParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportParticipantProperties(obj : TTurtleComplex; result : TFhirTestReportParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.participant.type'), CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum);
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.participant.uri'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.participant.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.participant', 'type', elem.Type_Element, CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum, false, -1);{x.d4}
  ComposeUri(this, 'TestReport.participant', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.participant', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetup.create;
  try
    ParseTestReportSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupProperties(obj : TTurtleComplex; result : TFhirTestReportSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.setup.action') do
      result.actionList.Add(parseTestReportSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportSetupAction(this, 'TestReport.setup', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupAction.create;
  try
    ParseTestReportSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionProperties(obj : TTurtleComplex; result : TFhirTestReportSetupAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation'));{q3b}
    result.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.setup.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.setup.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionOperation.create;
  try
    ParseTestReportSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.result'), CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    result.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.message'));{q1}
    result.detailElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.detail'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.setup.action.operation', 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.operation', 'message', elem.messageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestReport.setup.action.operation', 'detail', elem.detailElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionAssert.create;
  try
    ParseTestReportSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, result);
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.result'), CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    result.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.message'));{q1}
    result.detailElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.detail'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionAssert'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.setup.action.assert', 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.assert', 'message', elem.messageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.setup.action.assert', 'detail', elem.detailElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTest.create;
  try
    ParseTestReportTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestProperties(obj : TTurtleComplex; result : TFhirTestReportTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test.action') do
      result.actionList.Add(parseTestReportTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTestAction(this, 'TestReport.test', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTestAction.create;
  try
    ParseTestReportTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestActionProperties(obj : TTurtleComplex; result : TFhirTestReportTestAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.test.action.operation'));{q3b}
    result.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.test.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTestAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.test.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.test.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardown.create;
  try
    ParseTestReportTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownProperties(obj : TTurtleComplex; result : TFhirTestReportTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.teardown.action') do
      result.actionList.Add(parseTestReportTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardown'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTeardownAction(this, 'TestReport.teardown', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardownAction.create;
  try
    ParseTestReportTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestReportTeardownAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.teardown.action.operation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardownAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeTestReportSetupActionOperation(this, 'TestReport.teardown.action', 'operation', elem.operationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReport(obj : TTurtleComplex) : TFhirTestReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReport.create;
  try
    ParseTestReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportProperties(obj : TTurtleComplex; result : TFhirTestReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestReport.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.status'), CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum);
    result.testScript := ParseReference{TFhirTestScript}(obj.complex('http://hl7.org/fhir/TestReport.testScript'));{q3b}
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.result'), CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum);
    result.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/TestReport.score'));{q1}
    result.testerElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.tester'));{q1}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestReport.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.participant') do
      result.participantList.Add(parseTestReportParticipant(item));
    result.setup := ParseTestReportSetup(obj.complex('http://hl7.org/fhir/TestReport.setup'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test') do
      result.testList.Add(parseTestReportTest(item));
    result.teardown := ParseTestReportTeardown(obj.complex('http://hl7.org/fhir/TestReport.teardown'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'TestReport', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'TestReport', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TestReport', 'status', elem.StatusElement, CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum, false, -1);{x.d4}
  ComposeReference{TFhirTestScript}(this, 'TestReport', 'testScript', elem.testScriptElement, false, -1);{x.2f}
  ComposeEnum(this, 'TestReport', 'result', elem.ResultElement, CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('score') then
    ComposeDecimal(this, 'TestReport', 'score', elem.scoreElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tester') then
    ComposeString(this, 'TestReport', 'tester', elem.testerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(this, 'TestReport', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeTestReportParticipant(this, 'TestReport', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestReportSetup(this, 'TestReport', 'setup', elem.setupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestReportTest(this, 'TestReport', 'test', elem.testList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestReportTeardown(this, 'TestReport', 'teardown', elem.teardownElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRTurtleParser.ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptOrigin.create;
  try
    ParseTestScriptOriginProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptOriginProperties(obj : TTurtleComplex; result : TFhirTestScriptOrigin);
begin
    ParseBackboneElementProperties(obj, result);
    result.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.origin.index'));{q1}
    result.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.origin.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptOrigin; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptOrigin'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'TestScript.origin', 'index', elem.indexElement, false, -1);{x.2ea}
  ComposeCoding(this, 'TestScript.origin', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptDestination.create;
  try
    ParseTestScriptDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptDestinationProperties(obj : TTurtleComplex; result : TFhirTestScriptDestination);
begin
    ParseBackboneElementProperties(obj, result);
    result.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.destination.index'));{q1}
    result.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.destination.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptDestination'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'TestScript.destination', 'index', elem.indexElement, false, -1);{x.2ea}
  ComposeCoding(this, 'TestScript.destination', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.link') do
      result.link_List.Add(parseTestScriptMetadataLink(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability') do
      result.capabilityList.Add(parseTestScriptMetadataCapability(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadata'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(this, 'TestScript.metadata', 'link', elem.link_List[i], false, i);{x.d3}
  for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(this, 'TestScript.metadata', 'capability', elem.capabilityList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.url'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript.metadata.link', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.link', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.required'));{q1}
    result.validatedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.validated'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.origin') do
      result.originList.Add(parseInteger(item));
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.destination'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.link') do
      result.link_List.Add(parseUri(item));
    result.capabilities := ParseReference{TFhirCapabilityStatement}(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.capabilities'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataCapability'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(this, 'TestScript.metadata.capability', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBoolean(this, 'TestScript.metadata.capability', 'validated', elem.validatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.capability', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.originList.Count - 1 do
      ComposeInteger(this, 'TestScript.metadata.capability', 'origin', elem.originList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.metadata.capability', 'destination', elem.destinationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(this, 'TestScript.metadata.capability', 'link', elem.link_List[i], false, i);{x.d3}
  ComposeReference{TFhirCapabilityStatement}(this, 'TestScript.metadata.capability', 'capabilities', elem.capabilitiesElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(obj, result);
    result.autocreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autocreate'));{q1}
    result.autodeleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autodelete'));{q1}
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/TestScript.fixture.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptFixture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.autocreate <> false)) then
    ComposeBoolean(this, 'TestScript.fixture', 'autocreate', elem.autocreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.autodelete <> false)) then
    ComposeBoolean(this, 'TestScript.fixture', 'autodelete', elem.autodeleteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'TestScript.fixture', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.name'));{q1}
    result.defaultValueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.defaultValue'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.description'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.expression'));{q1}
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.headerField'));{q1}
    result.hintElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.hint'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.path'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.variable.sourceId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptVariable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.variable', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'defaultValue', elem.defaultValueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'hint', elem.hintElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.variable', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptRule(obj : TTurtleComplex) : TFhirTestScriptRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptRule.create;
  try
    ParseTestScriptRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/TestScript.rule.resource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.rule.param') do
      result.paramList.Add(parseTestScriptRuleParam(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirReference}(this, 'TestScript.rule', 'resource', elem.resourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptRuleParam(this, 'TestScript.rule', 'param', elem.paramList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptRuleParam(obj : TTurtleComplex) : TFhirTestScriptRuleParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptRuleParam.create;
  try
    ParseTestScriptRuleParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptRuleParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.rule.param.name'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.rule.param.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRuleParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptRuleParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.rule.param', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.rule.param', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptRuleset(obj : TTurtleComplex) : TFhirTestScriptRuleset;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptRuleset.create;
  try
    ParseTestScriptRulesetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptRulesetProperties(obj : TTurtleComplex; result : TFhirTestScriptRuleset);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/TestScript.ruleset.resource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.ruleset.rule') do
      result.ruleList.Add(parseTestScriptRulesetRule(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptRuleset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRuleset; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptRuleset'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirReference}(this, 'TestScript.ruleset', 'resource', elem.resourceElement, false, -1);{x.2f}
  for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptRulesetRule(this, 'TestScript.ruleset', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptRulesetRule(obj : TTurtleComplex) : TFhirTestScriptRulesetRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptRulesetRule.create;
  try
    ParseTestScriptRulesetRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptRulesetRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptRulesetRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.ruleIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.ruleset.rule.ruleId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.ruleset.rule.param') do
      result.paramList.Add(parseTestScriptRulesetRuleParam(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptRulesetRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRulesetRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptRulesetRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'TestScript.ruleset.rule', 'ruleId', elem.ruleIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptRulesetRuleParam(this, 'TestScript.ruleset.rule', 'param', elem.paramList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptRulesetRuleParam(obj : TTurtleComplex) : TFhirTestScriptRulesetRuleParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptRulesetRuleParam.create;
  try
    ParseTestScriptRulesetRuleParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptRulesetRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptRulesetRuleParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.ruleset.rule.param.name'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.ruleset.rule.param.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptRulesetRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptRulesetRuleParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptRulesetRuleParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.ruleset.rule.param', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.ruleset.rule.param', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action') do
      result.actionList.Add(parseTestScriptSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(this, 'TestScript.setup', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.setup.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.setup.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.type'));{q3b}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.resource'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.description'));{q1}
    result.acceptElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.accept'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.contentTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.contentType'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.destination'));{q1}
    result.encodeRequestUrlElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.encodeRequestUrl'));{q1}
    result.originElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.origin'));{q1}
    result.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.params'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader') do
      result.requestHeaderList.Add(parseTestScriptSetupActionOperationRequestHeader(item));
    result.requestIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestId'));{q1}
    result.responseIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.responseId'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.sourceId'));{q1}
    result.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.targetId'));{q1}
    result.urlElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'TestScript.setup.action.operation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'destination', elem.destinationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBoolean(this, 'TestScript.setup.action.operation', 'encodeRequestUrl', elem.encodeRequestUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'origin', elem.originElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'params', elem.paramsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(this, 'TestScript.setup.action.operation', 'requestHeader', elem.requestHeaderList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'requestId', elem.requestIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'responseId', elem.responseIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'targetId', elem.targetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(obj, result);
    result.fieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.field'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperationRequestHeader'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'field', elem.fieldElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.description'));{q1}
    result.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.direction'), CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    result.compareToSourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceId'));{q1}
    result.compareToSourceExpressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceExpression'));{q1}
    result.compareToSourcePathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourcePath'));{q1}
    result.contentTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.contentType'), CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.expression'));{q1}
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.headerField'));{q1}
    result.minimumIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.minimumId'));{q1}
    result.navigationLinksElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.navigationLinks'));{q1}
    result.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.operator'), CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.path'));{q1}
    result.requestMethodElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestMethod'), CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum);
    result.requestURLElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestURL'));{q1}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.resource'));{q1}
    result.responseElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.response'), CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    result.responseCodeElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.responseCode'));{q1}
    result.rule := ParseTestScriptSetupActionAssertRule(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.rule'));{q3b}
    result.ruleset := ParseTestScriptSetupActionAssertRuleset(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset'));{q3b}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.sourceId'));{q1}
    result.validateProfileIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.validateProfileId'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.value'));{q1}
    result.warningOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.warningOnly'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssert'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceId', elem.compareToSourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceExpression', elem.compareToSourceExpressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourcePath', elem.compareToSourcePathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'minimumId', elem.minimumIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'navigationLinks', elem.navigationLinksElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'requestMethod', elem.RequestMethodElement, CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'requestURL', elem.requestURLElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.assert', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'responseCode', elem.responseCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssertRule(this, 'TestScript.setup.action.assert', 'rule', elem.ruleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssertRuleset(this, 'TestScript.setup.action.assert', 'ruleset', elem.rulesetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'validateProfileId', elem.validateProfileIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'warningOnly', elem.warningOnlyElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssertRule(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssertRule.create;
  try
    ParseTestScriptSetupActionAssertRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.ruleIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.rule.ruleId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.assert.rule.param') do
      result.paramList.Add(parseTestScriptSetupActionAssertRuleParam(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssertRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssertRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'TestScript.setup.action.assert.rule', 'ruleId', elem.ruleIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptSetupActionAssertRuleParam(this, 'TestScript.setup.action.assert.rule', 'param', elem.paramList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssertRuleParam(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRuleParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssertRuleParam.create;
  try
    ParseTestScriptSetupActionAssertRuleParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRuleParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.rule.param.name'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.rule.param.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssertRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRuleParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssertRuleParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.setup.action.assert.rule.param', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript.setup.action.assert.rule.param', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssertRuleset(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRuleset;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssertRuleset.create;
  try
    ParseTestScriptSetupActionAssertRulesetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertRulesetProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRuleset);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.rulesetIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rulesetId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rule') do
      result.ruleList.Add(parseTestScriptSetupActionAssertRulesetRule(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssertRuleset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRuleset; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssertRuleset'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'TestScript.setup.action.assert.ruleset', 'rulesetId', elem.rulesetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptSetupActionAssertRulesetRule(this, 'TestScript.setup.action.assert.ruleset', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssertRulesetRule(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRulesetRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssertRulesetRule.create;
  try
    ParseTestScriptSetupActionAssertRulesetRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertRulesetRuleProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRulesetRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.ruleIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rule.ruleId'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rule.param') do
      result.paramList.Add(parseTestScriptSetupActionAssertRulesetRuleParam(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssertRulesetRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRulesetRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssertRulesetRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'TestScript.setup.action.assert.ruleset.rule', 'ruleId', elem.ruleIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeTestScriptSetupActionAssertRulesetRuleParam(this, 'TestScript.setup.action.assert.ruleset.rule', 'param', elem.paramList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssertRulesetRuleParam(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam.create;
  try
    ParseTestScriptSetupActionAssertRulesetRuleParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertRulesetRuleParamProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rule.param.name'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.ruleset.rule.param.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssertRulesetRuleParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssertRulesetRuleParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssertRulesetRuleParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.setup.action.assert.ruleset.rule.param', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript.setup.action.assert.ruleset.rule.param', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test.action') do
      result.actionList.Add(parseTestScriptTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(this, 'TestScript.test', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.test.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.test.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTestAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.test.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.test.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.teardown.action') do
      result.actionList.Add(parseTestScriptTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardown'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(this, 'TestScript.teardown', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.teardown.action.operation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardownAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeTestScriptSetupActionOperation(this, 'TestScript.teardown.action', 'operation', elem.operationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScript(obj : TTurtleComplex) : TFhirTestScript;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestScript.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestScript.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.origin') do
      result.originList.Add(parseTestScriptOrigin(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.destination') do
      result.destinationList.Add(parseTestScriptDestination(item));
    result.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.metadata'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.fixture') do
      result.fixtureList.Add(parseTestScriptFixture(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.profile') do
      result.profileList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.variable') do
      result.variableList.Add(parseTestScriptVariable(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.rule') do
      result.ruleList.Add(parseTestScriptRule(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.ruleset') do
      result.rulesetList.Add(parseTestScriptRuleset(item));
    result.setup := ParseTestScriptSetup(obj.complex('http://hl7.org/fhir/TestScript.setup'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test') do
      result.testList.Add(parseTestScriptTest(item));
    result.teardown := ParseTestScriptTeardown(obj.complex('http://hl7.org/fhir/TestScript.teardown'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScript'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'TestScript', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'TestScript', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'TestScript', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TestScript', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'TestScript', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'TestScript', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'TestScript', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'TestScript', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'TestScript', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'TestScript', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'TestScript', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'TestScript', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'TestScript', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('origin') then
    for i := 0 to elem.originList.Count - 1 do
      ComposeTestScriptOrigin(this, 'TestScript', 'origin', elem.originList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeTestScriptDestination(this, 'TestScript', 'destination', elem.destinationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(this, 'TestScript', 'metadata', elem.metadataElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(this, 'TestScript', 'fixture', elem.fixtureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'TestScript', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('variable') then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(this, 'TestScript', 'variable', elem.variableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeTestScriptRule(this, 'TestScript', 'rule', elem.ruleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('ruleset') then
    for i := 0 to elem.rulesetList.Count - 1 do
      ComposeTestScriptRuleset(this, 'TestScript', 'ruleset', elem.rulesetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(this, 'TestScript', 'setup', elem.setupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(this, 'TestScript', 'test', elem.testList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(this, 'TestScript', 'teardown', elem.teardownElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
function TFHIRTurtleParser.ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.lockedDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.compose.lockedDate'));{q1}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.compose.inactive'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include') do
      result.includeList.Add(parseValueSetComposeInclude(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.exclude') do
      result.excludeList.Add(parseValueSetComposeInclude(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCompose'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ValueSet.compose', 'lockedDate', elem.lockedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet.compose', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
  for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'include', elem.includeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'exclude', elem.excludeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.version'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept') do
      result.conceptList.Add(parseValueSetComposeIncludeConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.filter') do
      result.filterList.Add(parseValueSetComposeIncludeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.valueSet') do
      result.valueSetList.Add(parseUri(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeInclude'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSet.compose.include', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.compose.include', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(this, 'ValueSet.compose.include', 'concept', elem.conceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(this, 'ValueSet.compose.include', 'filter', elem.filterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueSetList.Count - 1 do
      ComposeUri(this, 'ValueSet.compose.include', 'valueSet', elem.valueSetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept.designation') do
      result.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.compose.include.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.compose.include.concept', 'designation', elem.designationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    ParseValueSetComposeIncludeConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConceptDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.use'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConceptDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.compose.include.concept.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ValueSet.compose.include.concept.designation', 'use', elem.useElement, false, -1);{x.2f}
  ComposeString(this, 'ValueSet.compose.include.concept.designation', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(obj, result);
    result.property_Element := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.property'));{q1}
    result.opElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.op'), CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    result.valueElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.filter', 'property', elem.property_Element, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet.compose.include.filter', 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, -1);{x.d4}
  ComposeCode(this, 'ValueSet.compose.include.filter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.identifier'));{q1}
    result.timestampElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.expansion.timestamp'));{q1}
    result.totalElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.total'));{q1}
    result.offsetElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.offset'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.parameter') do
      result.parameterList.Add(parseValueSetExpansionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ValueSet.expansion', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'ValueSet.expansion', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'offset', elem.offsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(this, 'ValueSet.expansion', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.parameter.name'));{q1}
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ValueSet.expansion.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ValueSet.expansion.parameter', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.system'));{q1}
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.abstract'));{q1}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.inactive'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.designation') do
      result.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContains'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion.contains', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.expansion.contains', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.expansion.contains', 'designation', elem.designationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion.contains', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSet(obj : TTurtleComplex) : TFhirValueSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.immutableElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.immutable'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.copyright'));{q1}
    result.extensibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.extensible'));{q1}
    result.compose := ParseValueSetCompose(obj.complex('http://hl7.org/fhir/ValueSet.compose'));{q3b}
    result.expansion := ParseValueSetExpansion(obj.complex('http://hl7.org/fhir/ValueSet.expansion'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSet'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ValueSet', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ValueSet', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ValueSet', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ValueSet', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ValueSet', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ValueSet', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ValueSet', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ValueSet', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ValueSet', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ValueSet', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBoolean(this, 'ValueSet', 'immutable', elem.immutableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ValueSet', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ValueSet', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBoolean(this, 'ValueSet', 'extensible', elem.extensibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(this, 'ValueSet', 'compose', elem.composeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(this, 'ValueSet', 'expansion', elem.expansionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseVisionPrescriptionDispense(obj : TTurtleComplex) : TFhirVisionPrescriptionDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionDispense.create;
  try
    ParseVisionPrescriptionDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionDispenseProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionDispense);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.product := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.product'));{q3b}
    result.eyeElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.eye'), CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    result.sphereElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.sphere'));{q1}
    result.cylinderElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.cylinder'));{q1}
    result.axisElement := ParseInteger(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.axis'));{q1}
    result.prismElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.prism'));{q1}
    result.baseElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.base'), CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
    result.addElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.add'));{q1}
    result.powerElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.power'));{q1}
    result.backCurveElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.backCurve'));{q1}
    result.diameterElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.diameter'));{q1}
    result.duration := ParseQuantity(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.duration'));{q3b}
    result.colorElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.color'));{q1}
    result.brandElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.dispense.brand'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.dispense.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionDispense'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'VisionPrescription.dispense', 'product', elem.productElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'VisionPrescription.dispense', 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'sphere', elem.sphereElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'cylinder', elem.cylinderElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'VisionPrescription.dispense', 'axis', elem.axisElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'prism', elem.prismElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'VisionPrescription.dispense', 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'add', elem.addElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'power', elem.powerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'backCurve', elem.backCurveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.dispense', 'diameter', elem.diameterElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'VisionPrescription.dispense', 'duration', elem.durationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.dispense', 'color', elem.colorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.dispense', 'brand', elem.brandElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'VisionPrescription.dispense', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/VisionPrescription.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/VisionPrescription.encounter'));{q3b}
    result.dateWrittenElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.dateWritten'));{q1}
    result.prescriber := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/VisionPrescription.prescriber'));{q3b}
    if obj.has('http://hl7.org/fhir/VisionPrescription.reasonCodeableConcept', item) then
      result.reason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/VisionPrescription.reasonReference', item) {a3} then
      result.reason := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.dispense') do
      result.dispenseList.Add(parseVisionPrescriptionDispense(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'VisionPrescription', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'VisionPrescription', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'VisionPrescription', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'VisionPrescription', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dateWritten') then
    ComposeDateTime(this, 'VisionPrescription', 'dateWritten', elem.dateWrittenElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(this, 'VisionPrescription', 'prescriber', elem.prescriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'VisionPrescription', 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(this, 'VisionPrescription', 'reasonReference', TFhirReference(elem.reason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('dispense') then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(this, 'VisionPrescription', 'dispense', elem.dispenseList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;
begin
   if SameText(type_, 'Element') then
    result := parseElement(obj)
  else if SameText(type_, 'BackboneElement') then
    result := parseBackboneElement(obj)
{$IFDEF FHIR_PARAMETERS}
  else if SameText(type_, 'Parameters') then
    result := parseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
  else if SameText(type_, 'Extension') then
    result := parseExtension(obj)
  else if SameText(type_, 'Narrative') then
    result := parseNarrative(obj)
  else if SameText(type_, 'Contributor') then
    result := parseContributor(obj)
  else if SameText(type_, 'Attachment') then
    result := parseAttachment(obj)
  else if SameText(type_, 'DataRequirement') then
    result := parseDataRequirement(obj)
  else if SameText(type_, 'Dosage') then
    result := parseDosage(obj)
  else if SameText(type_, 'Identifier') then
    result := parseIdentifier(obj)
  else if SameText(type_, 'Coding') then
    result := parseCoding(obj)
  else if SameText(type_, 'SampledData') then
    result := parseSampledData(obj)
  else if SameText(type_, 'Ratio') then
    result := parseRatio(obj)
  else if SameText(type_, 'Reference') then
    result := parseReference(obj)
  else if SameText(type_, 'TriggerDefinition') then
    result := parseTriggerDefinition(obj)
  else if SameText(type_, 'Period') then
    result := parsePeriod(obj)
  else if SameText(type_, 'Quantity') then
    result := parseQuantity(obj)
  else if SameText(type_, 'Range') then
    result := parseRange(obj)
  else if SameText(type_, 'RelatedArtifact') then
    result := parseRelatedArtifact(obj)
  else if SameText(type_, 'Annotation') then
    result := parseAnnotation(obj)
  else if SameText(type_, 'ContactDetail') then
    result := parseContactDetail(obj)
  else if SameText(type_, 'UsageContext') then
    result := parseUsageContext(obj)
  else if SameText(type_, 'Signature') then
    result := parseSignature(obj)
  else if SameText(type_, 'CodeableConcept') then
    result := parseCodeableConcept(obj)
  else if SameText(type_, 'ParameterDefinition') then
    result := parseParameterDefinition(obj)
  else if SameText(type_, 'ContactPoint') then
    result := parseContactPoint(obj)
  else if SameText(type_, 'HumanName') then
    result := parseHumanName(obj)
  else if SameText(type_, 'Meta') then
    result := parseMeta(obj)
  else if SameText(type_, 'Address') then
    result := parseAddress(obj)
  else if SameText(type_, 'ElementDefinition') then
    result := parseElementDefinition(obj)
  else if SameText(type_, 'Timing') then
    result := parseTiming(obj)
  else if SameText(type_, 'Count') then
    result := parseCount(obj)
  else if SameText(type_, 'Money') then
    result := parseMoney(obj)
  else if SameText(type_, 'Age') then
    result := parseAge(obj)
  else if SameText(type_, 'Distance') then
    result := parseDistance(obj)
  else if SameText(type_, 'Duration') then
    result := parseDuration(obj)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(type_, 'Account') then
    result := parseAccount(obj)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if SameText(type_, 'ActivityDefinition') then
    result := parseActivityDefinition(obj)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if SameText(type_, 'AdverseEvent') then
    result := parseAdverseEvent(obj)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(type_, 'AllergyIntolerance') then
    result := parseAllergyIntolerance(obj)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(type_, 'Appointment') then
    result := parseAppointment(obj)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(type_, 'AppointmentResponse') then
    result := parseAppointmentResponse(obj)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(type_, 'AuditEvent') then
    result := parseAuditEvent(obj)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(type_, 'Basic') then
    result := parseBasic(obj)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(type_, 'Binary') then
    result := parseBinary(obj)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if SameText(type_, 'BodySite') then
    result := parseBodySite(obj)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(type_, 'Bundle') then
    result := parseBundle(obj)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if SameText(type_, 'CapabilityStatement') then
    result := parseCapabilityStatement(obj)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(type_, 'CarePlan') then
    result := parseCarePlan(obj)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if SameText(type_, 'CareTeam') then
    result := parseCareTeam(obj)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if SameText(type_, 'ChargeItem') then
    result := parseChargeItem(obj)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  else if SameText(type_, 'Claim') then
    result := parseClaim(obj)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(type_, 'ClaimResponse') then
    result := parseClaimResponse(obj)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(type_, 'ClinicalImpression') then
    result := parseClinicalImpression(obj)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if SameText(type_, 'CodeSystem') then
    result := parseCodeSystem(obj)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(type_, 'Communication') then
    result := parseCommunication(obj)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(type_, 'CommunicationRequest') then
    result := parseCommunicationRequest(obj)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if SameText(type_, 'CompartmentDefinition') then
    result := parseCompartmentDefinition(obj)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(type_, 'Composition') then
    result := parseComposition(obj)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(type_, 'ConceptMap') then
    result := parseConceptMap(obj)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(type_, 'Condition') then
    result := parseCondition(obj)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if SameText(type_, 'Consent') then
    result := parseConsent(obj)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if SameText(type_, 'Contract') then
    result := parseContract(obj)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(type_, 'Coverage') then
    result := parseCoverage(obj)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if SameText(type_, 'DataElement') then
    result := parseDataElement(obj)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(type_, 'DetectedIssue') then
    result := parseDetectedIssue(obj)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(type_, 'Device') then
    result := parseDevice(obj)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if SameText(type_, 'DeviceComponent') then
    result := parseDeviceComponent(obj)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(type_, 'DeviceMetric') then
    result := parseDeviceMetric(obj)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if SameText(type_, 'DeviceRequest') then
    result := parseDeviceRequest(obj)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if SameText(type_, 'DeviceUseStatement') then
    result := parseDeviceUseStatement(obj)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(type_, 'DiagnosticReport') then
    result := parseDiagnosticReport(obj)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(type_, 'DocumentManifest') then
    result := parseDocumentManifest(obj)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(type_, 'DocumentReference') then
    result := parseDocumentReference(obj)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if SameText(type_, 'EligibilityRequest') then
    result := parseEligibilityRequest(obj)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if SameText(type_, 'EligibilityResponse') then
    result := parseEligibilityResponse(obj)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(type_, 'Encounter') then
    result := parseEncounter(obj)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if SameText(type_, 'Endpoint') then
    result := parseEndpoint(obj)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(type_, 'EnrollmentRequest') then
    result := parseEnrollmentRequest(obj)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(type_, 'EnrollmentResponse') then
    result := parseEnrollmentResponse(obj)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(type_, 'EpisodeOfCare') then
    result := parseEpisodeOfCare(obj)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  else if SameText(type_, 'ExpansionProfile') then
    result := parseExpansionProfile(obj)
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(type_, 'ExplanationOfBenefit') then
    result := parseExplanationOfBenefit(obj)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(type_, 'FamilyMemberHistory') then
    result := parseFamilyMemberHistory(obj)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(type_, 'Flag') then
    result := parseFlag(obj)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if SameText(type_, 'Goal') then
    result := parseGoal(obj)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if SameText(type_, 'GraphDefinition') then
    result := parseGraphDefinition(obj)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if SameText(type_, 'Group') then
    result := parseGroup(obj)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if SameText(type_, 'GuidanceResponse') then
    result := parseGuidanceResponse(obj)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(type_, 'HealthcareService') then
    result := parseHealthcareService(obj)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  else if SameText(type_, 'ImagingManifest') then
    result := parseImagingManifest(obj)
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(type_, 'ImagingStudy') then
    result := parseImagingStudy(obj)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(type_, 'Immunization') then
    result := parseImmunization(obj)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(type_, 'ImmunizationRecommendation') then
    result := parseImmunizationRecommendation(obj)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(type_, 'ImplementationGuide') then
    result := parseImplementationGuide(obj)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  else if SameText(type_, 'Library') then
    result := parseLibrary(obj)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if SameText(type_, 'Linkage') then
    result := parseLinkage(obj)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if SameText(type_, 'List') then
    result := parseList(obj)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(type_, 'Location') then
    result := parseLocation(obj)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if SameText(type_, 'Measure') then
    result := parseMeasure(obj)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if SameText(type_, 'MeasureReport') then
    result := parseMeasureReport(obj)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if SameText(type_, 'Media') then
    result := parseMedia(obj)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if SameText(type_, 'Medication') then
    result := parseMedication(obj)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(type_, 'MedicationAdministration') then
    result := parseMedicationAdministration(obj)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(type_, 'MedicationDispense') then
    result := parseMedicationDispense(obj)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if SameText(type_, 'MedicationRequest') then
    result := parseMedicationRequest(obj)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if SameText(type_, 'MedicationStatement') then
    result := parseMedicationStatement(obj)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if SameText(type_, 'MessageDefinition') then
    result := parseMessageDefinition(obj)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(type_, 'MessageHeader') then
    result := parseMessageHeader(obj)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(type_, 'NamingSystem') then
    result := parseNamingSystem(obj)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(type_, 'NutritionOrder') then
    result := parseNutritionOrder(obj)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(type_, 'Observation') then
    result := parseObservation(obj)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(type_, 'OperationDefinition') then
    result := parseOperationDefinition(obj)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(type_, 'OperationOutcome') then
    result := parseOperationOutcome(obj)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(type_, 'Organization') then
    result := parseOrganization(obj)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if SameText(type_, 'Patient') then
    result := parsePatient(obj)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(type_, 'PaymentNotice') then
    result := parsePaymentNotice(obj)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(type_, 'PaymentReconciliation') then
    result := parsePaymentReconciliation(obj)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if SameText(type_, 'Person') then
    result := parsePerson(obj)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if SameText(type_, 'PlanDefinition') then
    result := parsePlanDefinition(obj)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(type_, 'Practitioner') then
    result := parsePractitioner(obj)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if SameText(type_, 'PractitionerRole') then
    result := parsePractitionerRole(obj)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(type_, 'Procedure') then
    result := parseProcedure(obj)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if SameText(type_, 'ProcedureRequest') then
    result := parseProcedureRequest(obj)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if SameText(type_, 'ProcessRequest') then
    result := parseProcessRequest(obj)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if SameText(type_, 'ProcessResponse') then
    result := parseProcessResponse(obj)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(type_, 'Provenance') then
    result := parseProvenance(obj)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(type_, 'Questionnaire') then
    result := parseQuestionnaire(obj)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(type_, 'QuestionnaireResponse') then
    result := parseQuestionnaireResponse(obj)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if SameText(type_, 'ReferralRequest') then
    result := parseReferralRequest(obj)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(type_, 'RelatedPerson') then
    result := parseRelatedPerson(obj)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if SameText(type_, 'RequestGroup') then
    result := parseRequestGroup(obj)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if SameText(type_, 'ResearchStudy') then
    result := parseResearchStudy(obj)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if SameText(type_, 'ResearchSubject') then
    result := parseResearchSubject(obj)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(type_, 'RiskAssessment') then
    result := parseRiskAssessment(obj)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(type_, 'Schedule') then
    result := parseSchedule(obj)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(type_, 'SearchParameter') then
    result := parseSearchParameter(obj)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  else if SameText(type_, 'Sequence') then
    result := parseSequence(obj)
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  else if SameText(type_, 'ServiceDefinition') then
    result := parseServiceDefinition(obj)
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  else if SameText(type_, 'Slot') then
    result := parseSlot(obj)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(type_, 'Specimen') then
    result := parseSpecimen(obj)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(type_, 'StructureDefinition') then
    result := parseStructureDefinition(obj)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if SameText(type_, 'StructureMap') then
    result := parseStructureMap(obj)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(type_, 'Subscription') then
    result := parseSubscription(obj)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(type_, 'Substance') then
    result := parseSubstance(obj)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(type_, 'SupplyDelivery') then
    result := parseSupplyDelivery(obj)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(type_, 'SupplyRequest') then
    result := parseSupplyRequest(obj)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if SameText(type_, 'Task') then
    result := parseTask(obj)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  else if SameText(type_, 'TestReport') then
    result := parseTestReport(obj)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(type_, 'TestScript') then
    result := parseTestScript(obj)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if SameText(type_, 'ValueSet') then
    result := parseValueSet(obj)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(type_, 'VisionPrescription') then
    result := parseVisionPrescription(obj)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRTurtleParser.ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(obj)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(obj)
  else if (type_ = TFhirContributor) then
    result := parseContributor(obj)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(obj)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(obj)
  else if (type_ = TFhirDosage) then
    result := parseDosage(obj)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(obj)
  else if (type_ = TFhirCoding) then
    result := parseCoding(obj)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(obj)
  else if (type_ = TFhirRatio) then
    result := parseRatio(obj)
  else if (type_ = TFhirReference) then
    result := parseReference(obj)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(obj)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(obj)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(obj)
  else if (type_ = TFhirRange) then
    result := parseRange(obj)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(obj)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(obj)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(obj)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(obj)
  else if (type_ = TFhirSignature) then
    result := parseSignature(obj)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(obj)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(obj)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(obj)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(obj)
  else if (type_ = TFhirMeta) then
    result := parseMeta(obj)
  else if (type_ = TFhirAddress) then
    result := parseAddress(obj)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(obj)
  else if (type_ = TFhirTiming) then
    result := parseTiming(obj)
  else if (type_ = TFhirCount) then
    result := parseCount(obj)
  else if (type_ = TFhirMoney) then
    result := parseMoney(obj)
  else if (type_ = TFhirAge) then
    result := parseAge(obj)
  else if (type_ = TFhirDistance) then
    result := parseDistance(obj)
  else if (type_ = TFhirDuration) then
    result := parseDuration(obj)
  else
    raise ERdfException.create('Unknown Type');
end;

procedure TFHIRTurtleComposer.ComposeResource(parent : TTurtleComplex; resource : TFhirResource);
var
  this : TTurtleComplex;
begin
  if (resource = nil) Then
    Raise ERdfException.Create('error - resource is nil');
  this := parent;
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(this, '', 'Parameters', TFhirParameters(resource), true, -1);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(this, '', 'Account', TFhirAccount(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
     frtActivityDefinition: ComposeActivityDefinition(this, '', 'ActivityDefinition', TFhirActivityDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
     frtAdverseEvent: ComposeAdverseEvent(this, '', 'AdverseEvent', TFhirAdverseEvent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(this, '', 'AllergyIntolerance', TFhirAllergyIntolerance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(this, '', 'Appointment', TFhirAppointment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(this, '', 'AppointmentResponse', TFhirAppointmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(this, '', 'AuditEvent', TFhirAuditEvent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(this, '', 'Basic', TFhirBasic(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(this, '', 'Binary', TFhirBinary(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
     frtBodySite: ComposeBodySite(this, '', 'BodySite', TFhirBodySite(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(this, '', 'Bundle', TFhirBundle(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
     frtCapabilityStatement: ComposeCapabilityStatement(this, '', 'CapabilityStatement', TFhirCapabilityStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(this, '', 'CarePlan', TFhirCarePlan(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
     frtCareTeam: ComposeCareTeam(this, '', 'CareTeam', TFhirCareTeam(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
     frtChargeItem: ComposeChargeItem(this, '', 'ChargeItem', TFhirChargeItem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(this, '', 'Claim', TFhirClaim(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(this, '', 'ClaimResponse', TFhirClaimResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(this, '', 'ClinicalImpression', TFhirClinicalImpression(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
     frtCodeSystem: ComposeCodeSystem(this, '', 'CodeSystem', TFhirCodeSystem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(this, '', 'Communication', TFhirCommunication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(this, '', 'CommunicationRequest', TFhirCommunicationRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
     frtCompartmentDefinition: ComposeCompartmentDefinition(this, '', 'CompartmentDefinition', TFhirCompartmentDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(this, '', 'Composition', TFhirComposition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(this, '', 'ConceptMap', TFhirConceptMap(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(this, '', 'Condition', TFhirCondition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
     frtConsent: ComposeConsent(this, '', 'Consent', TFhirConsent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(this, '', 'Contract', TFhirContract(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(this, '', 'Coverage', TFhirCoverage(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
     frtDataElement: ComposeDataElement(this, '', 'DataElement', TFhirDataElement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(this, '', 'DetectedIssue', TFhirDetectedIssue(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(this, '', 'Device', TFhirDevice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
     frtDeviceComponent: ComposeDeviceComponent(this, '', 'DeviceComponent', TFhirDeviceComponent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(this, '', 'DeviceMetric', TFhirDeviceMetric(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
     frtDeviceRequest: ComposeDeviceRequest(this, '', 'DeviceRequest', TFhirDeviceRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(this, '', 'DeviceUseStatement', TFhirDeviceUseStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(this, '', 'DiagnosticReport', TFhirDiagnosticReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(this, '', 'DocumentManifest', TFhirDocumentManifest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(this, '', 'DocumentReference', TFhirDocumentReference(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
     frtEligibilityRequest: ComposeEligibilityRequest(this, '', 'EligibilityRequest', TFhirEligibilityRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
     frtEligibilityResponse: ComposeEligibilityResponse(this, '', 'EligibilityResponse', TFhirEligibilityResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(this, '', 'Encounter', TFhirEncounter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
     frtEndpoint: ComposeEndpoint(this, '', 'Endpoint', TFhirEndpoint(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(this, '', 'EnrollmentRequest', TFhirEnrollmentRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(this, '', 'EnrollmentResponse', TFhirEnrollmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(this, '', 'EpisodeOfCare', TFhirEpisodeOfCare(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  {$IFDEF FHIR_EXPANSIONPROFILE}
     frtExpansionProfile: ComposeExpansionProfile(this, '', 'ExpansionProfile', TFhirExpansionProfile(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(this, '', 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(this, '', 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(this, '', 'Flag', TFhirFlag(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(this, '', 'Goal', TFhirGoal(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
     frtGraphDefinition: ComposeGraphDefinition(this, '', 'GraphDefinition', TFhirGraphDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(this, '', 'Group', TFhirGroup(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
     frtGuidanceResponse: ComposeGuidanceResponse(this, '', 'GuidanceResponse', TFhirGuidanceResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(this, '', 'HealthcareService', TFhirHealthcareService(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  {$IFDEF FHIR_IMAGINGMANIFEST}
     frtImagingManifest: ComposeImagingManifest(this, '', 'ImagingManifest', TFhirImagingManifest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(this, '', 'ImagingStudy', TFhirImagingStudy(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(this, '', 'Immunization', TFhirImmunization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(this, '', 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(this, '', 'ImplementationGuide', TFhirImplementationGuide(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
     frtLibrary: ComposeLibrary(this, '', 'Library', TFhirLibrary(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
     frtLinkage: ComposeLinkage(this, '', 'Linkage', TFhirLinkage(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(this, '', 'List', TFhirList(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(this, '', 'Location', TFhirLocation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
     frtMeasure: ComposeMeasure(this, '', 'Measure', TFhirMeasure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
     frtMeasureReport: ComposeMeasureReport(this, '', 'MeasureReport', TFhirMeasureReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(this, '', 'Media', TFhirMedia(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(this, '', 'Medication', TFhirMedication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(this, '', 'MedicationAdministration', TFhirMedicationAdministration(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(this, '', 'MedicationDispense', TFhirMedicationDispense(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
     frtMedicationRequest: ComposeMedicationRequest(this, '', 'MedicationRequest', TFhirMedicationRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(this, '', 'MedicationStatement', TFhirMedicationStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
     frtMessageDefinition: ComposeMessageDefinition(this, '', 'MessageDefinition', TFhirMessageDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(this, '', 'MessageHeader', TFhirMessageHeader(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(this, '', 'NamingSystem', TFhirNamingSystem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(this, '', 'NutritionOrder', TFhirNutritionOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(this, '', 'Observation', TFhirObservation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(this, '', 'OperationDefinition', TFhirOperationDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(this, '', 'OperationOutcome', TFhirOperationOutcome(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(this, '', 'Organization', TFhirOrganization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(this, '', 'Patient', TFhirPatient(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(this, '', 'PaymentNotice', TFhirPaymentNotice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(this, '', 'PaymentReconciliation', TFhirPaymentReconciliation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(this, '', 'Person', TFhirPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
     frtPlanDefinition: ComposePlanDefinition(this, '', 'PlanDefinition', TFhirPlanDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(this, '', 'Practitioner', TFhirPractitioner(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
     frtPractitionerRole: ComposePractitionerRole(this, '', 'PractitionerRole', TFhirPractitionerRole(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(this, '', 'Procedure', TFhirProcedure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
     frtProcedureRequest: ComposeProcedureRequest(this, '', 'ProcedureRequest', TFhirProcedureRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
     frtProcessRequest: ComposeProcessRequest(this, '', 'ProcessRequest', TFhirProcessRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
     frtProcessResponse: ComposeProcessResponse(this, '', 'ProcessResponse', TFhirProcessResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(this, '', 'Provenance', TFhirProvenance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(this, '', 'Questionnaire', TFhirQuestionnaire(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(this, '', 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
     frtReferralRequest: ComposeReferralRequest(this, '', 'ReferralRequest', TFhirReferralRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(this, '', 'RelatedPerson', TFhirRelatedPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
     frtRequestGroup: ComposeRequestGroup(this, '', 'RequestGroup', TFhirRequestGroup(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
     frtResearchStudy: ComposeResearchStudy(this, '', 'ResearchStudy', TFhirResearchStudy(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
     frtResearchSubject: ComposeResearchSubject(this, '', 'ResearchSubject', TFhirResearchSubject(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(this, '', 'RiskAssessment', TFhirRiskAssessment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(this, '', 'Schedule', TFhirSchedule(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(this, '', 'SearchParameter', TFhirSearchParameter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  {$IFDEF FHIR_SEQUENCE}
     frtSequence: ComposeSequence(this, '', 'Sequence', TFhirSequence(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  {$IFDEF FHIR_SERVICEDEFINITION}
     frtServiceDefinition: ComposeServiceDefinition(this, '', 'ServiceDefinition', TFhirServiceDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(this, '', 'Slot', TFhirSlot(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(this, '', 'Specimen', TFhirSpecimen(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(this, '', 'StructureDefinition', TFhirStructureDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
     frtStructureMap: ComposeStructureMap(this, '', 'StructureMap', TFhirStructureMap(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(this, '', 'Subscription', TFhirSubscription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(this, '', 'Substance', TFhirSubstance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(this, '', 'SupplyDelivery', TFhirSupplyDelivery(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(this, '', 'SupplyRequest', TFhirSupplyRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
     frtTask: ComposeTask(this, '', 'Task', TFhirTask(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
     frtTestReport: ComposeTestReport(this, '', 'TestReport', TFhirTestReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(this, '', 'TestScript', TFhirTestScript(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(this, '', 'ValueSet', TFhirValueSet(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(this, '', 'VisionPrescription', TFhirVisionPrescription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRTurtleParser.ParseResource(obj : TTurtleComplex) : TFhirResource;
var
  s : String;
begin
  s := rdfsType(obj);
 {$IFDEF FHIR_PARAMETERS}
  if s = 'Parameters' Then
    result := ParseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if s = 'Account' Then
    result := ParseAccount(obj) 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
   else if s = 'ActivityDefinition' Then
    result := ParseActivityDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
   else if s = 'AdverseEvent' Then
    result := ParseAdverseEvent(obj) 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(obj) 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if s = 'Appointment' Then
    result := ParseAppointment(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if s = 'AuditEvent' Then
    result := ParseAuditEvent(obj) 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if s = 'Basic' Then
    result := ParseBasic(obj) 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if s = 'Binary' Then
    result := ParseBinary(obj) 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
   else if s = 'BodySite' Then
    result := ParseBodySite(obj) 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if s = 'Bundle' Then
    result := ParseBundle(obj) 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
   else if s = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if s = 'CarePlan' Then
    result := ParseCarePlan(obj) 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
   else if s = 'CareTeam' Then
    result := ParseCareTeam(obj) 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
   else if s = 'ChargeItem' Then
    result := ParseChargeItem(obj) 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if s = 'Claim' Then
    result := ParseClaim(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
   else if s = 'CodeSystem' Then
    result := ParseCodeSystem(obj) 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if s = 'Communication' Then
    result := ParseCommunication(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
   else if s = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if s = 'Composition' Then
    result := ParseComposition(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if s = 'ConceptMap' Then
    result := ParseConceptMap(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if s = 'Condition' Then
    result := ParseCondition(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
   else if s = 'Consent' Then
    result := ParseConsent(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if s = 'Contract' Then
    result := ParseContract(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if s = 'Coverage' Then
    result := ParseCoverage(obj) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
   else if s = 'DataElement' Then
    result := ParseDataElement(obj) 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(obj) 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if s = 'Device' Then
    result := ParseDevice(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
   else if s = 'DeviceComponent' Then
    result := ParseDeviceComponent(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
   else if s = 'DeviceRequest' Then
    result := ParseDeviceRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if s = 'DocumentReference' Then
    result := ParseDocumentReference(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
   else if s = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
   else if s = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if s = 'Encounter' Then
    result := ParseEncounter(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
   else if s = 'Endpoint' Then
    result := ParseEndpoint(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(obj) 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPANSIONPROFILE}
  {$IFDEF FHIR_EXPANSIONPROFILE}
   else if s = 'ExpansionProfile' Then
    result := ParseExpansionProfile(obj) 
  {$ENDIF}
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(obj) 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(obj) 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if s = 'Flag' Then
    result := ParseFlag(obj) 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if s = 'Goal' Then
    result := ParseGoal(obj) 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
   else if s = 'GraphDefinition' Then
    result := ParseGraphDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if s = 'Group' Then
    result := ParseGroup(obj) 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
   else if s = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if s = 'HealthcareService' Then
    result := ParseHealthcareService(obj) 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGMANIFEST}
  {$IFDEF FHIR_IMAGINGMANIFEST}
   else if s = 'ImagingManifest' Then
    result := ParseImagingManifest(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if s = 'Immunization' Then
    result := ParseImmunization(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
   else if s = 'Library' Then
    result := ParseLibrary(obj) 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
   else if s = 'Linkage' Then
    result := ParseLinkage(obj) 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if s = 'List' Then
    result := ParseList(obj) 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if s = 'Location' Then
    result := ParseLocation(obj) 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
   else if s = 'Measure' Then
    result := ParseMeasure(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
   else if s = 'MeasureReport' Then
    result := ParseMeasureReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if s = 'Media' Then
    result := ParseMedia(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if s = 'Medication' Then
    result := ParseMedication(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
   else if s = 'MedicationRequest' Then
    result := ParseMedicationRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
   else if s = 'MessageDefinition' Then
    result := ParseMessageDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if s = 'MessageHeader' Then
    result := ParseMessageHeader(obj) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if s = 'NamingSystem' Then
    result := ParseNamingSystem(obj) 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if s = 'Observation' Then
    result := ParseObservation(obj) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if s = 'Organization' Then
    result := ParseOrganization(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if s = 'Patient' Then
    result := ParsePatient(obj) 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if s = 'Person' Then
    result := ParsePerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
   else if s = 'PlanDefinition' Then
    result := ParsePlanDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if s = 'Practitioner' Then
    result := ParsePractitioner(obj) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
   else if s = 'PractitionerRole' Then
    result := ParsePractitionerRole(obj) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if s = 'Procedure' Then
    result := ParseProcedure(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
   else if s = 'ProcedureRequest' Then
    result := ParseProcedureRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
   else if s = 'ProcessRequest' Then
    result := ParseProcessRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
   else if s = 'ProcessResponse' Then
    result := ParseProcessResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if s = 'Provenance' Then
    result := ParseProvenance(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
   else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
   else if s = 'RequestGroup' Then
    result := ParseRequestGroup(obj) 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
   else if s = 'ResearchStudy' Then
    result := ParseResearchStudy(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
   else if s = 'ResearchSubject' Then
    result := ParseResearchSubject(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(obj) 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if s = 'Schedule' Then
    result := ParseSchedule(obj) 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if s = 'SearchParameter' Then
    result := ParseSearchParameter(obj) 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SEQUENCE}
  {$IFDEF FHIR_SEQUENCE}
   else if s = 'Sequence' Then
    result := ParseSequence(obj) 
  {$ENDIF}
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SERVICEDEFINITION}
  {$IFDEF FHIR_SERVICEDEFINITION}
   else if s = 'ServiceDefinition' Then
    result := ParseServiceDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if s = 'Slot' Then
    result := ParseSlot(obj) 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if s = 'Specimen' Then
    result := ParseSpecimen(obj) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
   else if s = 'StructureMap' Then
    result := ParseStructureMap(obj) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if s = 'Subscription' Then
    result := ParseSubscription(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if s = 'Substance' Then
    result := ParseSubstance(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
   else if s = 'Task' Then
    result := ParseTask(obj) 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
   else if s = 'TestReport' Then
    result := ParseTestReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if s = 'TestScript' Then
    result := ParseTestScript(obj) 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if s = 'ValueSet' Then
    result := ParseValueSet(obj) 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(obj) 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('error: the element '+s+' is not a valid resource name');
end;

end.

