unit fhir3_resources_other;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir3.inc}

interface

// FHIR v3.0.1 generated 2018-06-12T19:15:59+10:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir3_base, fhir3_types, fhir3_resources_base;

type
{$IFDEF FHIR_PARAMETERS}
  TFhirParametersParameter = class;
  TFhirParametersParameterList = class;
  TFhirParameters = class;
  TFhirParametersList = class;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_AUDITEVENT}
  TFhirAuditEventAgent = class;
  TFhirAuditEventAgentList = class;
  TFhirAuditEventAgentNetwork = class;
  TFhirAuditEventAgentNetworkList = class;
  TFhirAuditEventSource = class;
  TFhirAuditEventSourceList = class;
  TFhirAuditEventEntity = class;
  TFhirAuditEventEntityList = class;
  TFhirAuditEventEntityDetail = class;
  TFhirAuditEventEntityDetailList = class;
  TFhirAuditEvent = class;
  TFhirAuditEventList = class;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  TFhirBinary = class;
  TFhirBinaryList = class;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  TFhirBundleLink = class;
  TFhirBundleLinkList = class;
  TFhirBundleEntry = class;
  TFhirBundleEntryList = class;
  TFhirBundleEntrySearch = class;
  TFhirBundleEntrySearchList = class;
  TFhirBundleEntryRequest = class;
  TFhirBundleEntryRequestList = class;
  TFhirBundleEntryResponse = class;
  TFhirBundleEntryResponseList = class;
  TFhirBundle = class;
  TFhirBundleList = class;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CHARGEITEM}
  TFhirChargeItemParticipant = class;
  TFhirChargeItemParticipantList = class;
  TFhirChargeItem = class;
  TFhirChargeItemList = class;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  TFhirClaimRelated = class;
  TFhirClaimRelatedList = class;
  TFhirClaimPayee = class;
  TFhirClaimPayeeList = class;
  TFhirClaimCareTeam = class;
  TFhirClaimCareTeamList = class;
  TFhirClaimInformation = class;
  TFhirClaimInformationList = class;
  TFhirClaimDiagnosis = class;
  TFhirClaimDiagnosisList = class;
  TFhirClaimProcedure = class;
  TFhirClaimProcedureList = class;
  TFhirClaimInsurance = class;
  TFhirClaimInsuranceList = class;
  TFhirClaimAccident = class;
  TFhirClaimAccidentList = class;
  TFhirClaimItem = class;
  TFhirClaimItemList = class;
  TFhirClaimItemDetail = class;
  TFhirClaimItemDetailList = class;
  TFhirClaimItemDetailSubDetail = class;
  TFhirClaimItemDetailSubDetailList = class;
  TFhirClaim = class;
  TFhirClaimList = class;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  TFhirClaimResponseItem = class;
  TFhirClaimResponseItemList = class;
  TFhirClaimResponseItemAdjudication = class;
  TFhirClaimResponseItemAdjudicationList = class;
  TFhirClaimResponseItemDetail = class;
  TFhirClaimResponseItemDetailList = class;
  TFhirClaimResponseItemDetailSubDetail = class;
  TFhirClaimResponseItemDetailSubDetailList = class;
  TFhirClaimResponseAddItem = class;
  TFhirClaimResponseAddItemList = class;
  TFhirClaimResponseAddItemDetail = class;
  TFhirClaimResponseAddItemDetailList = class;
  TFhirClaimResponseError = class;
  TFhirClaimResponseErrorList = class;
  TFhirClaimResponsePayment = class;
  TFhirClaimResponsePaymentList = class;
  TFhirClaimResponseProcessNote = class;
  TFhirClaimResponseProcessNoteList = class;
  TFhirClaimResponseInsurance = class;
  TFhirClaimResponseInsuranceList = class;
  TFhirClaimResponse = class;
  TFhirClaimResponseList = class;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CONSENT}
  TFhirConsentActor = class;
  TFhirConsentActorList = class;
  TFhirConsentPolicy = class;
  TFhirConsentPolicyList = class;
  TFhirConsentData = class;
  TFhirConsentDataList = class;
  TFhirConsentExcept = class;
  TFhirConsentExceptList = class;
  TFhirConsentExceptActor = class;
  TFhirConsentExceptActorList = class;
  TFhirConsentExceptData = class;
  TFhirConsentExceptDataList = class;
  TFhirConsent = class;
  TFhirConsentList = class;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  TFhirContractAgent = class;
  TFhirContractAgentList = class;
  TFhirContractSigner = class;
  TFhirContractSignerList = class;
  TFhirContractValuedItem = class;
  TFhirContractValuedItemList = class;
  TFhirContractTerm = class;
  TFhirContractTermList = class;
  TFhirContractTermAgent = class;
  TFhirContractTermAgentList = class;
  TFhirContractTermValuedItem = class;
  TFhirContractTermValuedItemList = class;
  TFhirContractFriendly = class;
  TFhirContractFriendlyList = class;
  TFhirContractLegal = class;
  TFhirContractLegalList = class;
  TFhirContractRule = class;
  TFhirContractRuleList = class;
  TFhirContract = class;
  TFhirContractList = class;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  TFhirEligibilityRequest = class;
  TFhirEligibilityRequestList = class;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  TFhirEligibilityResponseInsurance = class;
  TFhirEligibilityResponseInsuranceList = class;
  TFhirEligibilityResponseInsuranceBenefitBalance = class;
  TFhirEligibilityResponseInsuranceBenefitBalanceList = class;
  TFhirEligibilityResponseInsuranceBenefitBalanceFinancial = class;
  TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList = class;
  TFhirEligibilityResponseError = class;
  TFhirEligibilityResponseErrorList = class;
  TFhirEligibilityResponse = class;
  TFhirEligibilityResponseList = class;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  TFhirEnrollmentRequest = class;
  TFhirEnrollmentRequestList = class;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  TFhirEnrollmentResponse = class;
  TFhirEnrollmentResponseList = class;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  TFhirExplanationOfBenefitRelated = class;
  TFhirExplanationOfBenefitRelatedList = class;
  TFhirExplanationOfBenefitPayee = class;
  TFhirExplanationOfBenefitPayeeList = class;
  TFhirExplanationOfBenefitInformation = class;
  TFhirExplanationOfBenefitInformationList = class;
  TFhirExplanationOfBenefitCareTeam = class;
  TFhirExplanationOfBenefitCareTeamList = class;
  TFhirExplanationOfBenefitDiagnosis = class;
  TFhirExplanationOfBenefitDiagnosisList = class;
  TFhirExplanationOfBenefitProcedure = class;
  TFhirExplanationOfBenefitProcedureList = class;
  TFhirExplanationOfBenefitInsurance = class;
  TFhirExplanationOfBenefitInsuranceList = class;
  TFhirExplanationOfBenefitAccident = class;
  TFhirExplanationOfBenefitAccidentList = class;
  TFhirExplanationOfBenefitItem = class;
  TFhirExplanationOfBenefitItemList = class;
  TFhirExplanationOfBenefitItemAdjudication = class;
  TFhirExplanationOfBenefitItemAdjudicationList = class;
  TFhirExplanationOfBenefitItemDetail = class;
  TFhirExplanationOfBenefitItemDetailList = class;
  TFhirExplanationOfBenefitItemDetailSubDetail = class;
  TFhirExplanationOfBenefitItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitAddItem = class;
  TFhirExplanationOfBenefitAddItemList = class;
  TFhirExplanationOfBenefitAddItemDetail = class;
  TFhirExplanationOfBenefitAddItemDetailList = class;
  TFhirExplanationOfBenefitPayment = class;
  TFhirExplanationOfBenefitPaymentList = class;
  TFhirExplanationOfBenefitProcessNote = class;
  TFhirExplanationOfBenefitProcessNoteList = class;
  TFhirExplanationOfBenefitBenefitBalance = class;
  TFhirExplanationOfBenefitBenefitBalanceList = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class;
  TFhirExplanationOfBenefit = class;
  TFhirExplanationOfBenefitList = class;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_GUIDANCERESPONSE}
  TFhirGuidanceResponse = class;
  TFhirGuidanceResponseList = class;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_LINKAGE}
  TFhirLinkageItem = class;
  TFhirLinkageItemList = class;
  TFhirLinkage = class;
  TFhirLinkageList = class;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirList = class;
  TFhirListList = class;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  TFhirMeasureReportGroup = class;
  TFhirMeasureReportGroupList = class;
  TFhirMeasureReportGroupPopulation = class;
  TFhirMeasureReportGroupPopulationList = class;
  TFhirMeasureReportGroupStratifier = class;
  TFhirMeasureReportGroupStratifierList = class;
  TFhirMeasureReportGroupStratifierStratum = class;
  TFhirMeasureReportGroupStratifierStratumList = class;
  TFhirMeasureReportGroupStratifierStratumPopulation = class;
  TFhirMeasureReportGroupStratifierStratumPopulationList = class;
  TFhirMeasureReport = class;
  TFhirMeasureReportList = class;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationIngredient = class;
  TFhirMedicationIngredientList = class;
  TFhirMedicationPackage = class;
  TFhirMedicationPackageList = class;
  TFhirMedicationPackageContent = class;
  TFhirMedicationPackageContentList = class;
  TFhirMedicationPackageBatch = class;
  TFhirMedicationPackageBatchList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOperationOutcome = class;
  TFhirOperationOutcomeList = class;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_MESSAGEHEADER}
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeader = class;
  TFhirMessageHeaderList = class;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_PAYMENTNOTICE}
  TFhirPaymentNotice = class;
  TFhirPaymentNoticeList = class;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  TFhirPaymentReconciliationDetail = class;
  TFhirPaymentReconciliationDetailList = class;
  TFhirPaymentReconciliationProcessNote = class;
  TFhirPaymentReconciliationProcessNoteList = class;
  TFhirPaymentReconciliation = class;
  TFhirPaymentReconciliationList = class;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PROCESSREQUEST}
  TFhirProcessRequestItem = class;
  TFhirProcessRequestItemList = class;
  TFhirProcessRequest = class;
  TFhirProcessRequestList = class;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  TFhirProcessResponseProcessNote = class;
  TFhirProcessResponseProcessNoteList = class;
  TFhirProcessResponse = class;
  TFhirProcessResponseList = class;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirProvenance = class;
  TFhirProvenanceList = class;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_RESEARCHSTUDY}
  TFhirResearchStudyArm = class;
  TFhirResearchStudyArmList = class;
  TFhirResearchStudy = class;
  TFhirResearchStudyList = class;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  TFhirResearchSubject = class;
  TFhirResearchSubjectList = class;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
  TFhirSubscriptionChannel = class;
  TFhirSubscriptionChannelList = class;
  TFhirSubscription = class;
  TFhirSubscriptionList = class;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_TASK}
  TFhirTaskRequester = class;
  TFhirTaskRequesterList = class;
  TFhirTaskRestriction = class;
  TFhirTaskRestrictionList = class;
  TFhirTaskInput = class;
  TFhirTaskInputList = class;
  TFhirTaskOutput = class;
  TFhirTaskOutputList = class;
  TFhirTask = class;
  TFhirTaskList = class;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  TFhirTestReportParticipant = class;
  TFhirTestReportParticipantList = class;
  TFhirTestReportSetup = class;
  TFhirTestReportSetupList = class;
  TFhirTestReportSetupAction = class;
  TFhirTestReportSetupActionList = class;
  TFhirTestReportSetupActionOperation = class;
  TFhirTestReportSetupActionOperationList = class;
  TFhirTestReportSetupActionAssert = class;
  TFhirTestReportSetupActionAssertList = class;
  TFhirTestReportTest = class;
  TFhirTestReportTestList = class;
  TFhirTestReportTestAction = class;
  TFhirTestReportTestActionList = class;
  TFhirTestReportTeardown = class;
  TFhirTestReportTeardownList = class;
  TFhirTestReportTeardownAction = class;
  TFhirTestReportTeardownActionList = class;
  TFhirTestReport = class;
  TFhirTestReportList = class;
{$ENDIF FHIR_TESTREPORT}

{$IFDEF FHIR_PARAMETERS}

  // A parameter passed to or received from the operation.
  TFhirParametersParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirType;
    FResource : TFhirResource;
    FpartList : TFhirParametersParameterList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetResource(value : TFhirResource);
    function GetPartList : TFhirParametersParameterList;
    function GetHasPartList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParametersParameter; overload;
    function Clone : TFhirParametersParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the parameter (reference to the operation definition).
    property name : String read GetNameST write SetNameST;
    // The name of the parameter (reference to the operation definition).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to If the parameter is a data type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // If the parameter is a data type.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to If the parameter is a whole resource. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // If the parameter is a whole resource.
    property resourceElement : TFhirResource read FResource write SetResource;

    // A named part of a multi-part parameter.
    property partList : TFhirParametersParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirParametersParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersParameterList;
    function GetCurrent : TFhirParametersParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParametersParameter read GetCurrent;
  end;

  TFhirParametersParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParametersParameter;
    procedure SetItemN(index : Integer; value : TFhirParametersParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersParameterList; Overload;
    function Clone : TFhirParametersParameterList; Overload;
    function GetEnumerator : TFhirParametersParameterListEnumerator;

    //  Add a FhirParametersParameter to the end of the list.
    function Append : TFhirParametersParameter;

    // Add an already existing FhirParametersParameter to the end of the list.
    procedure AddItem(value : TFhirParametersParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParametersParameter) : Integer;

    // Insert FhirParametersParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParametersParameter;

    // Insert an existing FhirParametersParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParametersParameter);

    // Get the iIndexth FhirParametersParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParametersParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirParametersParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirParametersParameters[index : Integer] : TFhirParametersParameter read GetItemN write SetItemN; default;
  End;

  // This special resource type is used to represent an operation request and response (operations.html). It has no other use, and there is no RESTful endpoint associated with it.
  TFhirParameters = class (TFhirResource)
  protected
    FparameterList : TFhirParametersParameterList;
    function GetParameterList : TFhirParametersParameterList;
    function GetHasParameterList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameters; overload;
    function Clone : TFhirParameters; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A parameter passed to or received from the operation.
    property parameterList : TFhirParametersParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirParametersListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersList;
    function GetCurrent : TFhirParameters;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameters read GetCurrent;
  end;

  TFhirParametersList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParameters;
    procedure SetItemN(index : Integer; value : TFhirParameters);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersList; Overload;
    function Clone : TFhirParametersList; Overload;
    function GetEnumerator : TFhirParametersListEnumerator;

    //  Add a FhirParameters to the end of the list.
    function Append : TFhirParameters;

    // Add an already existing FhirParameters to the end of the list.
    procedure AddItem(value : TFhirParameters); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameters) : Integer;

    // Insert FhirParameters before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameters;

    // Insert an existing FhirParameters before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameters);

    // Get the iIndexth FhirParameters. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameters);

    // The number of items in the collection
    function Item(index : Integer) : TFhirParameters;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirParameters[index : Integer] : TFhirParameters read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

  // An actor taking an active role in the event or activity that is logged.
  TFhirAuditEventAgent = class (TFhirBackboneElement)
  protected
    FroleList : TFhirCodeableConceptList;
    FReference : TFhirReference{Resource};
    FUserId : TFhirIdentifier;
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FLocation : TFhirReference{TFhirLocation};
    FpolicyList : TFhirUriList;
    FMedia : TFhirCoding;
    FNetwork : TFhirAuditEventAgentNetwork;
    FpurposeOfUseList : TFhirCodeableConceptList;
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    Procedure SetReference(value : TFhirReference{Resource});
    Procedure SetUserId(value : TFhirIdentifier);
    Procedure SetAltId(value : TFhirString);
    Function GetAltIdST : String;
    Procedure SetAltIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : Boolean;
    Procedure SetRequestorST(value : Boolean);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirAuditEventAgentNetwork);
    function GetPurposeOfUseList : TFhirCodeableConceptList;
    function GetHasPurposeOfUseList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgent; overload;
    function Clone : TFhirAuditEventAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The security role that the user was acting under, that come from local codes defined by the access control security system (e.g. RBAC, ABAC) used in the local context.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Direct reference to a resource that identifies the agent. (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // Direct reference to a resource that identifies the agent.
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

    // Typed access to Unique identifier for the user actively participating in the event. (defined for API consistency)
    property userId : TFhirIdentifier read FUserId write SetUserId;
    // Unique identifier for the user actively participating in the event.
    property userIdElement : TFhirIdentifier read FUserId write SetUserId;

    // Typed access to Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altId : String read GetAltIdST write SetAltIdST;
    // Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altIdElement : TFhirString read FAltId write SetAltId;

    // Typed access to Human-meaningful name for the agent.
    property name : String read GetNameST write SetNameST;
    // Human-meaningful name for the agent.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    // Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestorElement : TFhirBoolean read FRequestor write SetRequestor;

    // Typed access to Where the event occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the event occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The policy or plan that authorized the activity being recorded. Typically, a single activity may have multiple applicable policies, such as patient consent, guarantor funding, etc. The policy would also indicate the security token used.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Type of media involved. Used when the event is about exporting/importing onto media. (defined for API consistency)
    property media : TFhirCoding read FMedia write SetMedia;
    // Type of media involved. Used when the event is about exporting/importing onto media.
    property mediaElement : TFhirCoding read FMedia write SetMedia;

    // Typed access to Logical network location for application activity, if the activity has a network location. (defined for API consistency)
    property network : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;
    // Logical network location for application activity, if the activity has a network location.
    property networkElement : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;

    // The reason (purpose of use), specific to this agent, that was used during the event being recorded.
    property purposeOfUseList : TFhirCodeableConceptList read GetPurposeOfUseList;
    property hasPurposeOfUseList : boolean read GetHasPurposeOfUseList;

  end;

  TFhirAuditEventAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentList;
    function GetCurrent : TFhirAuditEventAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgent read GetCurrent;
  end;

  TFhirAuditEventAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventAgent;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventAgentList; Overload;
    function Clone : TFhirAuditEventAgentList; Overload;
    function GetEnumerator : TFhirAuditEventAgentListEnumerator;

    //  Add a FhirAuditEventAgent to the end of the list.
    function Append : TFhirAuditEventAgent;

    // Add an already existing FhirAuditEventAgent to the end of the list.
    procedure AddItem(value : TFhirAuditEventAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgent) : Integer;

    // Insert FhirAuditEventAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgent;

    // Insert an existing FhirAuditEventAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgent);

    // Get the iIndexth FhirAuditEventAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventAgents[index : Integer] : TFhirAuditEventAgent read GetItemN write SetItemN; default;
  End;

  // Logical network location for application activity, if the activity has a network location.
  TFhirAuditEventAgentNetwork = class (TFhirBackboneElement)
  protected
    FAddress : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkTypeEnum;
    Procedure SetType_ST(value : TFhirNetworkTypeEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgentNetwork; overload;
    function Clone : TFhirAuditEventAgentNetwork; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An identifier for the network access point of the user device for the audit event.
    property address : String read GetAddressST write SetAddressST;
    // An identifier for the network access point of the user device for the audit event.
    property addressElement : TFhirString read FAddress write SetAddress;

    // An identifier for the type of network access point that originated the audit event.
    property type_ : TFhirNetworkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirAuditEventAgentNetworkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentNetworkList;
    function GetCurrent : TFhirAuditEventAgentNetwork;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentNetworkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgentNetwork read GetCurrent;
  end;

  TFhirAuditEventAgentNetworkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventAgentNetwork;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgentNetwork);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventAgentNetworkList; Overload;
    function Clone : TFhirAuditEventAgentNetworkList; Overload;
    function GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;

    //  Add a FhirAuditEventAgentNetwork to the end of the list.
    function Append : TFhirAuditEventAgentNetwork;

    // Add an already existing FhirAuditEventAgentNetwork to the end of the list.
    procedure AddItem(value : TFhirAuditEventAgentNetwork); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgentNetwork) : Integer;

    // Insert FhirAuditEventAgentNetwork before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgentNetwork;

    // Insert an existing FhirAuditEventAgentNetwork before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgentNetwork);

    // Get the iIndexth FhirAuditEventAgentNetwork. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgentNetwork);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgentNetwork;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventAgentNetworks[index : Integer] : TFhirAuditEventAgentNetwork read GetItemN write SetItemN; default;
  End;

  // The system that is reporting the event.
  TFhirAuditEventSource = class (TFhirBackboneElement)
  protected
    FSite : TFhirString;
    FIdentifier : TFhirIdentifier;
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetType_List : TFhirCodingList;
    function GetHasType_List : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventSource; overload;
    function Clone : TFhirAuditEventSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property site : String read GetSiteST write SetSiteST;
    // Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property siteElement : TFhirString read FSite write SetSite;

    // Typed access to Identifier of the source where the event was detected. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier of the source where the event was detected.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Code specifying the type of source where event originated.
    property type_List : TFhirCodingList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

  end;

  TFhirAuditEventSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventSourceList;
    function GetCurrent : TFhirAuditEventSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventSource read GetCurrent;
  end;

  TFhirAuditEventSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventSource;
    procedure SetItemN(index : Integer; value : TFhirAuditEventSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventSourceList; Overload;
    function Clone : TFhirAuditEventSourceList; Overload;
    function GetEnumerator : TFhirAuditEventSourceListEnumerator;

    //  Add a FhirAuditEventSource to the end of the list.
    function Append : TFhirAuditEventSource;

    // Add an already existing FhirAuditEventSource to the end of the list.
    procedure AddItem(value : TFhirAuditEventSource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventSource) : Integer;

    // Insert FhirAuditEventSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventSource;

    // Insert an existing FhirAuditEventSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventSource);

    // Get the iIndexth FhirAuditEventSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventSource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventSource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventSources[index : Integer] : TFhirAuditEventSource read GetItemN write SetItemN; default;
  End;

  // Specific instances of data or objects that have been accessed.
  TFhirAuditEventEntity = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FReference : TFhirReference{TFhirReference};
    FType_ : TFhirCoding;
    FRole : TFhirCoding;
    FLifecycle : TFhirCoding;
    FsecurityLabelList : TFhirCodingList;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirAuditEventEntityDetailList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirReference{TFhirReference});
    Procedure SetType_(value : TFhirCoding);
    Procedure SetRole(value : TFhirCoding);
    Procedure SetLifecycle(value : TFhirCoding);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : TBytes;
    Procedure SetQueryST(value : TBytes);
    function GetDetailList : TFhirAuditEventEntityDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntity; overload;
    function Clone : TFhirAuditEventEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies a specific instance of the entity. The reference should always be version specific. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a specific instance of the entity. The reference should always be version specific.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Identifies a specific instance of the entity. The reference should be version specific. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // Identifies a specific instance of the entity. The reference should be version specific.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

    // Typed access to The type of the object that was involved in this audit event. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of the object that was involved in this audit event.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Code representing the role the entity played in the event being audited. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // Code representing the role the entity played in the event being audited.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to Identifier for the data life-cycle stage for the entity. (defined for API consistency)
    property lifecycle : TFhirCoding read FLifecycle write SetLifecycle;
    // Identifier for the data life-cycle stage for the entity.
    property lifecycleElement : TFhirCoding read FLifecycle write SetLifecycle;

    // Security labels for the identified entity.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to A name of the entity in the audit event.
    property name : String read GetNameST write SetNameST;
    // A name of the entity in the audit event.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Text that describes the entity in more detail.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text that describes the entity in more detail.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The query parameters for a query-type entities.
    property query : TBytes read GetQueryST write SetQueryST;
    // The query parameters for a query-type entities.
    property queryElement : TFhirBase64Binary read FQuery write SetQuery;

    // Tagged value pairs for conveying additional information about the entity.
    property detailList : TFhirAuditEventEntityDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirAuditEventEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityList;
    function GetCurrent : TFhirAuditEventEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntity read GetCurrent;
  end;

  TFhirAuditEventEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventEntity;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventEntityList; Overload;
    function Clone : TFhirAuditEventEntityList; Overload;
    function GetEnumerator : TFhirAuditEventEntityListEnumerator;

    //  Add a FhirAuditEventEntity to the end of the list.
    function Append : TFhirAuditEventEntity;

    // Add an already existing FhirAuditEventEntity to the end of the list.
    procedure AddItem(value : TFhirAuditEventEntity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntity) : Integer;

    // Insert FhirAuditEventEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntity;

    // Insert an existing FhirAuditEventEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntity);

    // Get the iIndexth FhirAuditEventEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventEntities[index : Integer] : TFhirAuditEventEntity read GetItemN write SetItemN; default;
  End;

  // Tagged value pairs for conveying additional information about the entity.
  TFhirAuditEventEntityDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirString;
    FValue : TFhirBase64Binary;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirBase64Binary);
    Function GetValueST : TBytes;
    Procedure SetValueST(value : TBytes);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntityDetail; overload;
    function Clone : TFhirAuditEventEntityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of extra detail provided in the value.
    property type_ : String read GetType_ST write SetType_ST;
    // The type of extra detail provided in the value.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to The details, base64 encoded. Used to carry bulk information.
    property value : TBytes read GetValueST write SetValueST;
    // The details, base64 encoded. Used to carry bulk information.
    property valueElement : TFhirBase64Binary read FValue write SetValue;

  end;

  TFhirAuditEventEntityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityDetailList;
    function GetCurrent : TFhirAuditEventEntityDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntityDetail read GetCurrent;
  end;

  TFhirAuditEventEntityDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventEntityDetail;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventEntityDetailList; Overload;
    function Clone : TFhirAuditEventEntityDetailList; Overload;
    function GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;

    //  Add a FhirAuditEventEntityDetail to the end of the list.
    function Append : TFhirAuditEventEntityDetail;

    // Add an already existing FhirAuditEventEntityDetail to the end of the list.
    procedure AddItem(value : TFhirAuditEventEntityDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntityDetail) : Integer;

    // Insert FhirAuditEventEntityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntityDetail;

    // Insert an existing FhirAuditEventEntityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntityDetail);

    // Get the iIndexth FhirAuditEventEntityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntityDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntityDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventEntityDetails[index : Integer] : TFhirAuditEventEntityDetail read GetItemN write SetItemN; default;
  End;

  // A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
  TFhirAuditEvent = class (TFhirDomainResource)
  protected
    FType_ : TFhirCoding;
    FsubtypeList : TFhirCodingList;
    FAction : TFhirEnum;
    FRecorded : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    FpurposeOfEventList : TFhirCodeableConceptList;
    FagentList : TFhirAuditEventAgentList;
    FSource : TFhirAuditEventSource;
    FentityList : TFhirAuditEventEntityList;
    Procedure SetType_(value : TFhirCoding);
    function GetSubtypeList : TFhirCodingList;
    function GetHasSubtypeList : Boolean;
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirAuditEventActionEnum;
    Procedure SetActionST(value : TFhirAuditEventActionEnum);
    Procedure SetRecorded(value : TFhirInstant);
    Function GetRecordedST : TFslDateTime;
    Procedure SetRecordedST(value : TFslDateTime);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirAuditEventOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
    function GetPurposeOfEventList : TFhirCodeableConceptList;
    function GetHasPurposeOfEventList : Boolean;
    function GetAgentList : TFhirAuditEventAgentList;
    function GetHasAgentList : Boolean;
    Procedure SetSource(value : TFhirAuditEventSource);
    function GetEntityList : TFhirAuditEventEntityList;
    function GetHasEntityList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEvent; overload;
    function Clone : TFhirAuditEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Identifier for the category of event.
    property subtypeList : TFhirCodingList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Indicator for type of action performed during the event that generated the audit.
    property action : TFhirAuditEventActionEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Typed access to The time when the event occurred on the source.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The time when the event occurred on the source.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Indicates whether the event succeeded or failed.
    property outcome : TFhirAuditEventOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A free text description of the outcome of the event.
    property outcomeDesc : String read GetOutcomeDescST write SetOutcomeDescST;
    // A free text description of the outcome of the event.
    property outcomeDescElement : TFhirString read FOutcomeDesc write SetOutcomeDesc;

    // The purposeOfUse (reason) that was used during the event being recorded.
    property purposeOfEventList : TFhirCodeableConceptList read GetPurposeOfEventList;
    property hasPurposeOfEventList : boolean read GetHasPurposeOfEventList;

    // An actor taking an active role in the event or activity that is logged.
    property agentList : TFhirAuditEventAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Typed access to The system that is reporting the event. (defined for API consistency)
    property source : TFhirAuditEventSource read FSource write SetSource;
    // The system that is reporting the event.
    property sourceElement : TFhirAuditEventSource read FSource write SetSource;

    // Specific instances of data or objects that have been accessed.
    property entityList : TFhirAuditEventEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

  end;

  TFhirAuditEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventList;
    function GetCurrent : TFhirAuditEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEvent read GetCurrent;
  end;

  TFhirAuditEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventList; Overload;
    function Clone : TFhirAuditEventList; Overload;
    function GetEnumerator : TFhirAuditEventListEnumerator;

    //  Add a FhirAuditEvent to the end of the list.
    function Append : TFhirAuditEvent;

    // Add an already existing FhirAuditEvent to the end of the list.
    procedure AddItem(value : TFhirAuditEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEvent) : Integer;

    // Insert FhirAuditEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEvent;

    // Insert an existing FhirAuditEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEvent);

    // Get the iIndexth FhirAuditEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEvents[index : Integer] : TFhirAuditEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

  // A binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  TFhirBinary = class (TFhirResource)
  protected
    FContentType : TFhirCode;
    FSecurityContext : TFhirReference{TFhirReference};
    FContent : TFhirBase64Binary;
    Procedure SetContentType(value : TFhirCode);
    Function GetContentTypeST : String;
    Procedure SetContentTypeST(value : String);
    Procedure SetSecurityContext(value : TFhirReference{TFhirReference});
    Procedure SetContent(value : TFhirBase64Binary);
    Function GetContentST : TBytes;
    Procedure SetContentST(value : TBytes);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBinary; overload;
    function Clone : TFhirBinary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to Treat this binary as if it was this other resource for access control purposes. (defined for API consistency)
    property securityContext : TFhirReference{TFhirReference} read FSecurityContext write SetSecurityContext;
    // Treat this binary as if it was this other resource for access control purposes.
    property securityContextElement : TFhirReference{TFhirReference} read FSecurityContext write SetSecurityContext;

    // Typed access to The actual content, base64 encoded.
    property content : TBytes read GetContentST write SetContentST;
    // The actual content, base64 encoded.
    property contentElement : TFhirBase64Binary read FContent write SetContent;

  end;

  TFhirBinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBinaryList;
    function GetCurrent : TFhirBinary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBinary read GetCurrent;
  end;

  TFhirBinaryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBinary;
    procedure SetItemN(index : Integer; value : TFhirBinary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBinaryList; Overload;
    function Clone : TFhirBinaryList; Overload;
    function GetEnumerator : TFhirBinaryListEnumerator;

    //  Add a FhirBinary to the end of the list.
    function Append : TFhirBinary;

    // Add an already existing FhirBinary to the end of the list.
    procedure AddItem(value : TFhirBinary); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBinary) : Integer;

    // Insert FhirBinary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBinary;

    // Insert an existing FhirBinary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBinary);

    // Get the iIndexth FhirBinary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBinary);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBinary;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBinaries[index : Integer] : TFhirBinary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

  // A series of links that provide context to this bundle.
  TFhirBundleLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirString;
    FUrl : TFhirUri;
    Procedure SetRelation(value : TFhirString);
    Function GetRelationST : String;
    Procedure SetRelationST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleLink; overload;
    function Clone : TFhirBundleLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relation : String read GetRelationST write SetRelationST;
    // A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relationElement : TFhirString read FRelation write SetRelation;

    // Typed access to The reference details for the link.
    property url : String read GetUrlST write SetUrlST;
    // The reference details for the link.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirBundleLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleLinkList;
    function GetCurrent : TFhirBundleLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleLink read GetCurrent;
  end;

  TFhirBundleLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleLink;
    procedure SetItemN(index : Integer; value : TFhirBundleLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleLinkList; Overload;
    function Clone : TFhirBundleLinkList; Overload;
    function GetEnumerator : TFhirBundleLinkListEnumerator;

    //  Add a FhirBundleLink to the end of the list.
    function Append : TFhirBundleLink;

    // Add an already existing FhirBundleLink to the end of the list.
    procedure AddItem(value : TFhirBundleLink); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleLink) : Integer;

    // Insert FhirBundleLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleLink;

    // Insert an existing FhirBundleLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleLink);

    // Get the iIndexth FhirBundleLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleLink);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleLink;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleLinks[index : Integer] : TFhirBundleLink read GetItemN write SetItemN; default;
  End;

  // An entry in a bundle resource - will either contain a resource, or information about a resource (transactions and history only).
  TFhirBundleEntry = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirBundleLinkList;
    FFullUrl : TFhirUri;
    FResource : TFhirResource;
    FSearch : TFhirBundleEntrySearch;
    FRequest : TFhirBundleEntryRequest;
    FResponse : TFhirBundleEntryResponse;
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    Procedure SetFullUrl(value : TFhirUri);
    Function GetFullUrlST : String;
    Procedure SetFullUrlST(value : String);
    Procedure SetResource(value : TFhirResource);
    Procedure SetSearch(value : TFhirBundleEntrySearch);
    Procedure SetRequest(value : TFhirBundleEntryRequest);
    Procedure SetResponse(value : TFhirBundleEntryResponse);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntry; overload;
    function Clone : TFhirBundleEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A series of links that provide context to this entry.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to The Absolute URL for the resource.  The fullUrl SHALL not disagree with the id in the resource. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrl : String read GetFullUrlST write SetFullUrlST;
    // The Absolute URL for the resource.  The fullUrl SHALL not disagree with the id in the resource. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrlElement : TFhirUri read FFullUrl write SetFullUrl;

    // Typed access to The Resources for the entry. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // The Resources for the entry.
    property resourceElement : TFhirResource read FResource write SetResource;

    // Typed access to Information about the search process that lead to the creation of this entry. (defined for API consistency)
    property search : TFhirBundleEntrySearch read FSearch write SetSearch;
    // Information about the search process that lead to the creation of this entry.
    property searchElement : TFhirBundleEntrySearch read FSearch write SetSearch;

    // Typed access to Additional information about how this entry should be processed as part of a transaction. (defined for API consistency)
    property request : TFhirBundleEntryRequest read FRequest write SetRequest;
    // Additional information about how this entry should be processed as part of a transaction.
    property requestElement : TFhirBundleEntryRequest read FRequest write SetRequest;

    // Typed access to Additional information about how this entry should be processed as part of a transaction. (defined for API consistency)
    property response : TFhirBundleEntryResponse read FResponse write SetResponse;
    // Additional information about how this entry should be processed as part of a transaction.
    property responseElement : TFhirBundleEntryResponse read FResponse write SetResponse;

  end;

  TFhirBundleEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryList;
    function GetCurrent : TFhirBundleEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntry read GetCurrent;
  end;

  TFhirBundleEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntry;
    procedure SetItemN(index : Integer; value : TFhirBundleEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryList; Overload;
    function Clone : TFhirBundleEntryList; Overload;
    function GetEnumerator : TFhirBundleEntryListEnumerator;

    //  Add a FhirBundleEntry to the end of the list.
    function Append : TFhirBundleEntry;

    // Add an already existing FhirBundleEntry to the end of the list.
    procedure AddItem(value : TFhirBundleEntry); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntry) : Integer;

    // Insert FhirBundleEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntry;

    // Insert an existing FhirBundleEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntry);

    // Get the iIndexth FhirBundleEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntry);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntry;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntries[index : Integer] : TFhirBundleEntry read GetItemN write SetItemN; default;
  End;

  // Information about the search process that lead to the creation of this entry.
  TFhirBundleEntrySearch = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FScore : TFhirDecimal;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirSearchEntryModeEnum;
    Procedure SetModeST(value : TFhirSearchEntryModeEnum);
    Procedure SetScore(value : TFhirDecimal);
    Function GetScoreST : String;
    Procedure SetScoreST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntrySearch; overload;
    function Clone : TFhirBundleEntrySearch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Why this entry is in the result set - whether it's included as a match or because of an _include requirement.
    property mode : TFhirSearchEntryModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When searching, the server's search ranking score for the entry.
    property score : String read GetScoreST write SetScoreST;
    // When searching, the server's search ranking score for the entry.
    property scoreElement : TFhirDecimal read FScore write SetScore;

  end;

  TFhirBundleEntrySearchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntrySearchList;
    function GetCurrent : TFhirBundleEntrySearch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntrySearchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntrySearch read GetCurrent;
  end;

  TFhirBundleEntrySearchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntrySearch;
    procedure SetItemN(index : Integer; value : TFhirBundleEntrySearch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntrySearchList; Overload;
    function Clone : TFhirBundleEntrySearchList; Overload;
    function GetEnumerator : TFhirBundleEntrySearchListEnumerator;

    //  Add a FhirBundleEntrySearch to the end of the list.
    function Append : TFhirBundleEntrySearch;

    // Add an already existing FhirBundleEntrySearch to the end of the list.
    procedure AddItem(value : TFhirBundleEntrySearch); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntrySearch) : Integer;

    // Insert FhirBundleEntrySearch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntrySearch;

    // Insert an existing FhirBundleEntrySearch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntrySearch);

    // Get the iIndexth FhirBundleEntrySearch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntrySearch);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntrySearch;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntrySearches[index : Integer] : TFhirBundleEntrySearch read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction.
  TFhirBundleEntryRequest = class (TFhirBackboneElement)
  protected
    FMethod : TFhirEnum;
    FUrl : TFhirUri;
    FIfNoneMatch : TFhirString;
    FIfModifiedSince : TFhirInstant;
    FIfMatch : TFhirString;
    FIfNoneExist : TFhirString;
    Procedure SetMethod(value : TFhirEnum);
    Function GetMethodST : TFhirHttpVerbEnum;
    Procedure SetMethodST(value : TFhirHttpVerbEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetIfNoneMatch(value : TFhirString);
    Function GetIfNoneMatchST : String;
    Procedure SetIfNoneMatchST(value : String);
    Procedure SetIfModifiedSince(value : TFhirInstant);
    Function GetIfModifiedSinceST : TFslDateTime;
    Procedure SetIfModifiedSinceST(value : TFslDateTime);
    Procedure SetIfMatch(value : TFhirString);
    Function GetIfMatchST : String;
    Procedure SetIfMatchST(value : String);
    Procedure SetIfNoneExist(value : TFhirString);
    Function GetIfNoneExistST : String;
    Procedure SetIfNoneExistST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryRequest; overload;
    function Clone : TFhirBundleEntryRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The HTTP verb for this entry in either a change history, or a transaction/ transaction response.
    property method : TFhirHttpVerbEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The URL for this entry, relative to the root (the address to which the request is posted).
    property url : String read GetUrlST write SetUrlST;
    // The URL for this entry, relative to the root (the address to which the request is posted).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatch : String read GetIfNoneMatchST write SetIfNoneMatchST;
    // If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatchElement : TFhirString read FIfNoneMatch write SetIfNoneMatch;

    // Typed access to Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSince : TFslDateTime read GetIfModifiedSinceST write SetIfModifiedSinceST;
    // Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSinceElement : TFhirInstant read FIfModifiedSince write SetIfModifiedSince;

    // Typed access to Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatch : String read GetIfMatchST write SetIfMatchST;
    // Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatchElement : TFhirString read FIfMatch write SetIfMatch;

    // Typed access to Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExist : String read GetIfNoneExistST write SetIfNoneExistST;
    // Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExistElement : TFhirString read FIfNoneExist write SetIfNoneExist;

  end;

  TFhirBundleEntryRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryRequestList;
    function GetCurrent : TFhirBundleEntryRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryRequest read GetCurrent;
  end;

  TFhirBundleEntryRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryRequest;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryRequestList; Overload;
    function Clone : TFhirBundleEntryRequestList; Overload;
    function GetEnumerator : TFhirBundleEntryRequestListEnumerator;

    //  Add a FhirBundleEntryRequest to the end of the list.
    function Append : TFhirBundleEntryRequest;

    // Add an already existing FhirBundleEntryRequest to the end of the list.
    procedure AddItem(value : TFhirBundleEntryRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryRequest) : Integer;

    // Insert FhirBundleEntryRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryRequest;

    // Insert an existing FhirBundleEntryRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryRequest);

    // Get the iIndexth FhirBundleEntryRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntryRequests[index : Integer] : TFhirBundleEntryRequest read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction.
  TFhirBundleEntryResponse = class (TFhirBackboneElement)
  protected
    FStatus : TFhirString;
    FLocation : TFhirUri;
    FEtag : TFhirString;
    FLastModified : TFhirInstant;
    FOutcome : TFhirResource;
    Procedure SetStatus(value : TFhirString);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetLocation(value : TFhirUri);
    Function GetLocationST : String;
    Procedure SetLocationST(value : String);
    Procedure SetEtag(value : TFhirString);
    Function GetEtagST : String;
    Procedure SetEtagST(value : String);
    Procedure SetLastModified(value : TFhirInstant);
    Function GetLastModifiedST : TFslDateTime;
    Procedure SetLastModifiedST(value : TFslDateTime);
    Procedure SetOutcome(value : TFhirResource);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryResponse; overload;
    function Clone : TFhirBundleEntryResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property status : String read GetStatusST write SetStatusST;
    // The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property statusElement : TFhirString read FStatus write SetStatus;

    // Typed access to The location header created by processing this operation.
    property location : String read GetLocationST write SetLocationST;
    // The location header created by processing this operation.
    property locationElement : TFhirUri read FLocation write SetLocation;

    // Typed access to The etag for the resource, it the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etag : String read GetEtagST write SetEtagST;
    // The etag for the resource, it the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etagElement : TFhirString read FEtag write SetEtag;

    // Typed access to The date/time that the resource was modified on the server.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date/time that the resource was modified on the server.
    property lastModifiedElement : TFhirInstant read FLastModified write SetLastModified;

    // Typed access to An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction. (defined for API consistency)
    property outcome : TFhirResource read FOutcome write SetOutcome;
    // An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
    property outcomeElement : TFhirResource read FOutcome write SetOutcome;

  end;

  TFhirBundleEntryResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryResponseList;
    function GetCurrent : TFhirBundleEntryResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryResponse read GetCurrent;
  end;

  TFhirBundleEntryResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryResponse;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryResponseList; Overload;
    function Clone : TFhirBundleEntryResponseList; Overload;
    function GetEnumerator : TFhirBundleEntryResponseListEnumerator;

    //  Add a FhirBundleEntryResponse to the end of the list.
    function Append : TFhirBundleEntryResponse;

    // Add an already existing FhirBundleEntryResponse to the end of the list.
    procedure AddItem(value : TFhirBundleEntryResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryResponse) : Integer;

    // Insert FhirBundleEntryResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryResponse;

    // Insert an existing FhirBundleEntryResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryResponse);

    // Get the iIndexth FhirBundleEntryResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntryResponses[index : Integer] : TFhirBundleEntryResponse read GetItemN write SetItemN; default;
  End;

  // A container for a collection of resources.
  TFhirBundle = class (TFhirResource)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirEnum;
    FTotal : TFhirUnsignedInt;
    Flink_List : TFhirBundleLinkList;
    FentryList : TFhirBundleEntryList;
    FSignature : TFhirSignature;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirBundleTypeEnum;
    Procedure SetType_ST(value : TFhirBundleTypeEnum);
    Procedure SetTotal(value : TFhirUnsignedInt);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    function GetEntryList : TFhirBundleEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetSignature(value : TFhirSignature);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundle; overload;
    function Clone : TFhirBundle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A persistent identifier for the batch that won't change as a batch is copied from server to server. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A persistent identifier for the batch that won't change as a batch is copied from server to server.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the purpose of this bundle - how it was intended to be used.
    property type_ : TFhirBundleTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If a set of search matches, this is the total number of matches for the search (as opposed to the number of results in this bundle).
    property total : String read GetTotalST write SetTotalST;
    // If a set of search matches, this is the total number of matches for the search (as opposed to the number of results in this bundle).
    property totalElement : TFhirUnsignedInt read FTotal write SetTotal;

    // A series of links that provide context to this bundle.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // An entry in a bundle resource - will either contain a resource, or information about a resource (transactions and history only).
    property entryList : TFhirBundleEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to Digital Signature - base64 encoded. XML-DSIg or a JWT. (defined for API consistency)
    property signature : TFhirSignature read FSignature write SetSignature;
    // Digital Signature - base64 encoded. XML-DSIg or a JWT.
    property signatureElement : TFhirSignature read FSignature write SetSignature;

  end;

  TFhirBundleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleList;
    function GetCurrent : TFhirBundle;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundle read GetCurrent;
  end;

  TFhirBundleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundle;
    procedure SetItemN(index : Integer; value : TFhirBundle);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleList; Overload;
    function Clone : TFhirBundleList; Overload;
    function GetEnumerator : TFhirBundleListEnumerator;

    //  Add a FhirBundle to the end of the list.
    function Append : TFhirBundle;

    // Add an already existing FhirBundle to the end of the list.
    procedure AddItem(value : TFhirBundle); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundle) : Integer;

    // Insert FhirBundle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundle;

    // Insert an existing FhirBundle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundle);

    // Get the iIndexth FhirBundle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundle);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundle;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundles[index : Integer] : TFhirBundle read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CHARGEITEM}

  // Indicates who or what performed or participated in the charged service.
  TFhirChargeItemParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemParticipant; overload;
    function Clone : TFhirChargeItemParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the type of performance or participation(e.g. primary surgeon, anaesthesiologiest, etc.). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of performance or participation(e.g. primary surgeon, anaesthesiologiest, etc.).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

  end;

  TFhirChargeItemParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemParticipantList;
    function GetCurrent : TFhirChargeItemParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemParticipant read GetCurrent;
  end;

  TFhirChargeItemParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirChargeItemParticipant;
    procedure SetItemN(index : Integer; value : TFhirChargeItemParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirChargeItemParticipantList; Overload;
    function Clone : TFhirChargeItemParticipantList; Overload;
    function GetEnumerator : TFhirChargeItemParticipantListEnumerator;

    //  Add a FhirChargeItemParticipant to the end of the list.
    function Append : TFhirChargeItemParticipant;

    // Add an already existing FhirChargeItemParticipant to the end of the list.
    procedure AddItem(value : TFhirChargeItemParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemParticipant) : Integer;

    // Insert FhirChargeItemParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemParticipant;

    // Insert an existing FhirChargeItemParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemParticipant);

    // Get the iIndexth FhirChargeItemParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirChargeItemParticipants[index : Integer] : TFhirChargeItemParticipant read GetItemN write SetItemN; default;
  End;

  // The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
  TFhirChargeItem = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FdefinitionList : TFhirUriList;
    FStatus : TFhirEnum;
    FpartOfList : TFhirReferenceList{TFhirChargeItem};
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FparticipantList : TFhirChargeItemParticipantList;
    FPerformingOrganization : TFhirReference{TFhirOrganization};
    FRequestingOrganization : TFhirReference{TFhirOrganization};
    FQuantity : TFhirQuantity;
    FbodysiteList : TFhirCodeableConceptList;
    FFactorOverride : TFhirDecimal;
    FPriceOverride : TFhirMoney;
    FOverrideReason : TFhirString;
    FEnterer : TFhirReference{Resource};
    FEnteredDate : TFhirDateTime;
    FreasonList : TFhirCodeableConceptList;
    FserviceList : TFhirReferenceList{Resource};
    FaccountList : TFhirReferenceList{TFhirAccount};
    FnoteList : TFhirAnnotationList;
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetDefinitionList : TFhirUriList;
    function GetHasDefinitionList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirChargeitemStatusEnum;
    Procedure SetStatusST(value : TFhirChargeitemStatusEnum);
    function GetPartOfList : TFhirReferenceList{TFhirChargeItem};
    function GetHasPartOfList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    function GetParticipantList : TFhirChargeItemParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetPerformingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetQuantity(value : TFhirQuantity);
    function GetBodysiteList : TFhirCodeableConceptList;
    function GetHasBodysiteList : Boolean;
    Procedure SetFactorOverride(value : TFhirDecimal);
    Function GetFactorOverrideST : String;
    Procedure SetFactorOverrideST(value : String);
    Procedure SetPriceOverride(value : TFhirMoney);
    Procedure SetOverrideReason(value : TFhirString);
    Function GetOverrideReasonST : String;
    Procedure SetOverrideReasonST(value : String);
    Procedure SetEnterer(value : TFhirReference{Resource});
    Procedure SetEnteredDate(value : TFhirDateTime);
    Function GetEnteredDateST : TFslDateTime;
    Procedure SetEnteredDateST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetServiceList : TFhirReferenceList{Resource};
    function GetHasServiceList : Boolean;
    function GetAccountList : TFhirReferenceList{TFhirAccount};
    function GetHasAccountList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItem; overload;
    function Clone : TFhirChargeItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifiers assigned to this event performer or other systems. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifiers assigned to this event performer or other systems.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // References the source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionList : TFhirUriList read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // The current state of the ChargeItem.
    property status : TFhirChargeitemStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // ChargeItems can be grouped to larger ChargeItems covering the whole set.
    property partOfList : TFhirReferenceList{TFhirChargeItem} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to A code that identifies the charge, like a billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the charge, like a billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The individual or set of individuals the action is being or was performed on. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The individual or set of individuals the action is being or was performed on.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Date/time(s) or duration when the charged service was applied. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // Date/time(s) or duration when the charged service was applied.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Indicates who or what performed or participated in the charged service.
    property participantList : TFhirChargeItemParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The organization requesting the service. (defined for API consistency)
    property performingOrganization : TFhirReference{TFhirOrganization} read FPerformingOrganization write SetPerformingOrganization;
    // The organization requesting the service.
    property performingOrganizationElement : TFhirReference{TFhirOrganization} read FPerformingOrganization write SetPerformingOrganization;

    // Typed access to The organization performing the service. (defined for API consistency)
    property requestingOrganization : TFhirReference{TFhirOrganization} read FRequestingOrganization write SetRequestingOrganization;
    // The organization performing the service.
    property requestingOrganizationElement : TFhirReference{TFhirOrganization} read FRequestingOrganization write SetRequestingOrganization;

    // Typed access to Quantity of which the charge item has been serviced. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Quantity of which the charge item has been serviced.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The anatomical location where the related service has been applied.
    property bodysiteList : TFhirCodeableConceptList read GetBodysiteList;
    property hasBodysiteList : boolean read GetHasBodysiteList;

    // Typed access to Factor overriding the factor determined by the rules associated with the code.
    property factorOverride : String read GetFactorOverrideST write SetFactorOverrideST;
    // Factor overriding the factor determined by the rules associated with the code.
    property factorOverrideElement : TFhirDecimal read FFactorOverride write SetFactorOverride;

    // Typed access to Total price of the charge overriding the list price associated with the code. (defined for API consistency)
    property priceOverride : TFhirMoney read FPriceOverride write SetPriceOverride;
    // Total price of the charge overriding the list price associated with the code.
    property priceOverrideElement : TFhirMoney read FPriceOverride write SetPriceOverride;

    // Typed access to If the list price or the rule based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReason : String read GetOverrideReasonST write SetOverrideReasonST;
    // If the list price or the rule based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReasonElement : TFhirString read FOverrideReason write SetOverrideReason;

    // Typed access to The device, practitioner, etc. who entered the charge item. (defined for API consistency)
    property enterer : TFhirReference{Resource} read FEnterer write SetEnterer;
    // The device, practitioner, etc. who entered the charge item.
    property entererElement : TFhirReference{Resource} read FEnterer write SetEnterer;

    // Typed access to Date the charge item was entered.
    property enteredDate : TFslDateTime read GetEnteredDateST write SetEnteredDateST;
    // Date the charge item was entered.
    property enteredDateElement : TFhirDateTime read FEnteredDate write SetEnteredDate;

    // Describes why the event occurred in coded or textual form.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Indicated the rendered service that caused this charge.
    property serviceList : TFhirReferenceList{Resource} read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Account into which this ChargeItems belongs.
    property accountList : TFhirReferenceList{TFhirAccount} read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Comments made about the event by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Further information supporting the this charge.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

  end;

  TFhirChargeItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemList;
    function GetCurrent : TFhirChargeItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItem read GetCurrent;
  end;

  TFhirChargeItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirChargeItem;
    procedure SetItemN(index : Integer; value : TFhirChargeItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirChargeItemList; Overload;
    function Clone : TFhirChargeItemList; Overload;
    function GetEnumerator : TFhirChargeItemListEnumerator;

    //  Add a FhirChargeItem to the end of the list.
    function Append : TFhirChargeItem;

    // Add an already existing FhirChargeItem to the end of the list.
    procedure AddItem(value : TFhirChargeItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItem) : Integer;

    // Insert FhirChargeItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItem;

    // Insert an existing FhirChargeItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItem);

    // Get the iIndexth FhirChargeItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirChargeItems[index : Integer] : TFhirChargeItem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEM}

{$IFDEF FHIR_CLAIM}

  // Other claims which are related to this claim such as prior claim versions or for related services.
  TFhirClaimRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference{TFhirClaim};
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirIdentifier);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimRelated; overload;
    function Clone : TFhirClaimRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Other claims which are related to this claim such as prior claim versions or for related services. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // Other claims which are related to this claim such as prior claim versions or for related services.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to For example prior or umbrella. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // For example prior or umbrella.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # . (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # .
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirClaimRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimRelatedList;
    function GetCurrent : TFhirClaimRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimRelated read GetCurrent;
  end;

  TFhirClaimRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimRelated;
    procedure SetItemN(index : Integer; value : TFhirClaimRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimRelatedList; Overload;
    function Clone : TFhirClaimRelatedList; Overload;
    function GetEnumerator : TFhirClaimRelatedListEnumerator;

    //  Add a FhirClaimRelated to the end of the list.
    function Append : TFhirClaimRelated;

    // Add an already existing FhirClaimRelated to the end of the list.
    procedure AddItem(value : TFhirClaimRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimRelated) : Integer;

    // Insert FhirClaimRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimRelated;

    // Insert an existing FhirClaimRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimRelated);

    // Get the iIndexth FhirClaimRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimRelateds[index : Integer] : TFhirClaimRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for the services.
  TFhirClaimPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FResourceType : TFhirCoding;
    FParty : TFhirReference{Resource};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetResourceType(value : TFhirCoding);
    Procedure SetParty(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimPayee; overload;
    function Clone : TFhirClaimPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to organization | patient | practitioner | relatedperson. (defined for API consistency)
    property resourceType : TFhirCoding read FResourceType write SetResourceType;
    // organization | patient | practitioner | relatedperson.
    property resourceTypeElement : TFhirCoding read FResourceType write SetResourceType;

    // Typed access to Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Party to be reimbursed: Subscriber, provider, other.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

  end;

  TFhirClaimPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimPayeeList;
    function GetCurrent : TFhirClaimPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimPayee read GetCurrent;
  end;

  TFhirClaimPayeeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimPayee;
    procedure SetItemN(index : Integer; value : TFhirClaimPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimPayeeList; Overload;
    function Clone : TFhirClaimPayeeList; Overload;
    function GetEnumerator : TFhirClaimPayeeListEnumerator;

    //  Add a FhirClaimPayee to the end of the list.
    function Append : TFhirClaimPayee;

    // Add an already existing FhirClaimPayee to the end of the list.
    procedure AddItem(value : TFhirClaimPayee); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimPayee) : Integer;

    // Insert FhirClaimPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimPayee;

    // Insert an existing FhirClaimPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimPayee);

    // Get the iIndexth FhirClaimPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimPayee);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimPayee;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimPayees[index : Integer] : TFhirClaimPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
  TFhirClaimCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference{Resource};
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetProvider(value : TFhirReference{Resource});
    Procedure SetResponsible(value : TFhirBoolean);
    Function GetResponsibleST : Boolean;
    Procedure SetResponsibleST(value : Boolean);
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetQualification(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimCareTeam; overload;
    function Clone : TFhirClaimCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of the careTeam which serves to order and provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of the careTeam which serves to order and provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the overall service. (defined for API consistency)
    property provider : TFhirReference{Resource} read FProvider write SetProvider;
    // Member of the team who provided the overall service.
    property providerElement : TFhirReference{Resource} read FProvider write SetProvider;

    // Typed access to The party who is billing and responsible for the claimed good or service rendered to the patient.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and responsible for the claimed good or service rendered to the patient.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirClaimCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimCareTeamList;
    function GetCurrent : TFhirClaimCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimCareTeam read GetCurrent;
  end;

  TFhirClaimCareTeamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimCareTeam;
    procedure SetItemN(index : Integer; value : TFhirClaimCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimCareTeamList; Overload;
    function Clone : TFhirClaimCareTeamList; Overload;
    function GetEnumerator : TFhirClaimCareTeamListEnumerator;

    //  Add a FhirClaimCareTeam to the end of the list.
    function Append : TFhirClaimCareTeam;

    // Add an already existing FhirClaimCareTeam to the end of the list.
    procedure AddItem(value : TFhirClaimCareTeam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimCareTeam) : Integer;

    // Insert FhirClaimCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimCareTeam;

    // Insert an existing FhirClaimCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimCareTeam);

    // Get the iIndexth FhirClaimCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimCareTeam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimCareTeam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimCareTeams[index : Integer] : TFhirClaimCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
  TFhirClaimInformation = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FValue : TFhirType;
    FReason : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetValue(value : TFhirType);
    Procedure SetReason(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimInformation; overload;
    function Clone : TFhirClaimInformation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of the information element which serves to provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of the information element which serves to provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought which may influence the adjudication. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought which may influence the adjudication.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirClaimInformationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimInformationList;
    function GetCurrent : TFhirClaimInformation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimInformationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimInformation read GetCurrent;
  end;

  TFhirClaimInformationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimInformation;
    procedure SetItemN(index : Integer; value : TFhirClaimInformation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimInformationList; Overload;
    function Clone : TFhirClaimInformationList; Overload;
    function GetEnumerator : TFhirClaimInformationListEnumerator;

    //  Add a FhirClaimInformation to the end of the list.
    function Append : TFhirClaimInformation;

    // Add an already existing FhirClaimInformation to the end of the list.
    procedure AddItem(value : TFhirClaimInformation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimInformation) : Integer;

    // Insert FhirClaimInformation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimInformation;

    // Insert an existing FhirClaimInformation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimInformation);

    // Get the iIndexth FhirClaimInformation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimInformation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimInformation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimInformations[index : Integer] : TFhirClaimInformation read GetItemN write SetItemN; default;
  End;

  // List of patient diagnosis for which care is sought.
  TFhirClaimDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirType;
    Ftype_List : TFhirCodeableConceptList;
    FPackageCode : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDiagnosis(value : TFhirType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetPackageCode(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimDiagnosis; overload;
    function Clone : TFhirClaimDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of diagnosis which serves to provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of diagnosis which serves to provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The diagnosis. (defined for API consistency)
    property diagnosis : TFhirType read FDiagnosis write SetDiagnosis;
    // The diagnosis.
    property diagnosisElement : TFhirType read FDiagnosis write SetDiagnosis;

    // The type of the Diagnosis, for example: admitting, primary, secondary, discharge.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The package billing code, for example DRG, based on the assigned grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // The package billing code, for example DRG, based on the assigned grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirClaimDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimDiagnosisList;
    function GetCurrent : TFhirClaimDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimDiagnosis read GetCurrent;
  end;

  TFhirClaimDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirClaimDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimDiagnosisList; Overload;
    function Clone : TFhirClaimDiagnosisList; Overload;
    function GetEnumerator : TFhirClaimDiagnosisListEnumerator;

    //  Add a FhirClaimDiagnosis to the end of the list.
    function Append : TFhirClaimDiagnosis;

    // Add an already existing FhirClaimDiagnosis to the end of the list.
    procedure AddItem(value : TFhirClaimDiagnosis); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimDiagnosis) : Integer;

    // Insert FhirClaimDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimDiagnosis;

    // Insert an existing FhirClaimDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimDiagnosis);

    // Get the iIndexth FhirClaimDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimDiagnosis);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimDiagnosis;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimDiagnoses[index : Integer] : TFhirClaimDiagnosis read GetItemN write SetItemN; default;
  End;

  // Ordered list of patient procedures performed to support the adjudication.
  TFhirClaimProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirType;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetProcedure_(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimProcedure; overload;
    function Clone : TFhirClaimProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of procedures which serves to order and provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of procedures which serves to order and provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Date and optionally time the procedure was performed .
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed .
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The procedure code. (defined for API consistency)
    property procedure_ : TFhirType read FProcedure_ write SetProcedure_;
    // The procedure code.
    property procedure_Element : TFhirType read FProcedure_ write SetProcedure_;

  end;

  TFhirClaimProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimProcedureList;
    function GetCurrent : TFhirClaimProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimProcedure read GetCurrent;
  end;

  TFhirClaimProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimProcedure;
    procedure SetItemN(index : Integer; value : TFhirClaimProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimProcedureList; Overload;
    function Clone : TFhirClaimProcedureList; Overload;
    function GetEnumerator : TFhirClaimProcedureListEnumerator;

    //  Add a FhirClaimProcedure to the end of the list.
    function Append : TFhirClaimProcedure;

    // Add an already existing FhirClaimProcedure to the end of the list.
    procedure AddItem(value : TFhirClaimProcedure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimProcedure) : Integer;

    // Insert FhirClaimProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimProcedure;

    // Insert an existing FhirClaimProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimProcedure);

    // Get the iIndexth FhirClaimProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimProcedure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimProcedure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimProcedures[index : Integer] : TFhirClaimProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instrument by which payment information for health care.
  TFhirClaimInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimInsurance; overload;
    function Clone : TFhirClaimInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of coverage which serves to provide a link and convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of coverage which serves to provide a link and convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract number of a business agreement which describes the terms and conditions.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // The contract number of a business agreement which describes the terms and conditions.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // A list of references from the Insurer to which these services pertain.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The Coverages adjudication details. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The Coverages adjudication details.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimInsuranceList;
    function GetCurrent : TFhirClaimInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimInsurance read GetCurrent;
  end;

  TFhirClaimInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimInsuranceList; Overload;
    function Clone : TFhirClaimInsuranceList; Overload;
    function GetEnumerator : TFhirClaimInsuranceListEnumerator;

    //  Add a FhirClaimInsurance to the end of the list.
    function Append : TFhirClaimInsurance;

    // Add an already existing FhirClaimInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimInsurance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimInsurance) : Integer;

    // Insert FhirClaimInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimInsurance;

    // Insert an existing FhirClaimInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimInsurance);

    // Get the iIndexth FhirClaimInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimInsurance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimInsurance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimInsurances[index : Integer] : TFhirClaimInsurance read GetItemN write SetItemN; default;
  End;

  // An accident which resulted in the need for healthcare services.
  TFhirClaimAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirType;
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimAccident; overload;
    function Clone : TFhirClaimAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date of an accident which these services are addressing.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident which these services are addressing.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Type of accident: work, auto, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of accident: work, auto, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Accident Place. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Accident Place.
    property locationElement : TFhirType read FLocation write SetLocation;

  end;

  TFhirClaimAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimAccidentList;
    function GetCurrent : TFhirClaimAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimAccident read GetCurrent;
  end;

  TFhirClaimAccidentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimAccident;
    procedure SetItemN(index : Integer; value : TFhirClaimAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimAccidentList; Overload;
    function Clone : TFhirClaimAccidentList; Overload;
    function GetEnumerator : TFhirClaimAccidentListEnumerator;

    //  Add a FhirClaimAccident to the end of the list.
    function Append : TFhirClaimAccident;

    // Add an already existing FhirClaimAccident to the end of the list.
    procedure AddItem(value : TFhirClaimAccident); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimAccident) : Integer;

    // Insert FhirClaimAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimAccident;

    // Insert an existing FhirClaimAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimAccident);

    // Get the iIndexth FhirClaimAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimAccident);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimAccident;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimAccidents[index : Integer] : TFhirClaimAccident read GetItemN write SetItemN; default;
  End;

  // First tier of goods and services.
  TFhirClaimItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamLinkIdList : TFhirPositiveIntList;
    FdiagnosisLinkIdList : TFhirPositiveIntList;
    FprocedureLinkIdList : TFhirPositiveIntList;
    FinformationLinkIdList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList{TFhirEncounter};
    FdetailList : TFhirClaimItemDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetCareTeamLinkIdList : TFhirPositiveIntList;
    function GetHasCareTeamLinkIdList : Boolean;
    function GetDiagnosisLinkIdList : TFhirPositiveIntList;
    function GetHasDiagnosisLinkIdList : Boolean;
    function GetProcedureLinkIdList : TFhirPositiveIntList;
    function GetHasProcedureLinkIdList : Boolean;
    function GetInformationLinkIdList : TFhirPositiveIntList;
    function GetHasInformationLinkIdList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList{TFhirEncounter};
    function GetHasEncounterList : Boolean;
    function GetDetailList : TFhirClaimItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItem; overload;
    function Clone : TFhirClaimItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // CareTeam applicable for this service or product line.
    property careTeamLinkIdList : TFhirPositiveIntList read GetCareTeamLinkIdList;
    property hasCareTeamLinkIdList : boolean read GetHasCareTeamLinkIdList;

    // Diagnosis applicable for this service or product line.
    property diagnosisLinkIdList : TFhirPositiveIntList read GetDiagnosisLinkIdList;
    property hasDiagnosisLinkIdList : boolean read GetHasDiagnosisLinkIdList;

    // Procedures applicable for this service or product line.
    property procedureLinkIdList : TFhirPositiveIntList read GetProcedureLinkIdList;
    property hasProcedureLinkIdList : boolean read GetHasProcedureLinkIdList;

    // Exceptions, special conditions and supporting information pplicable for this service or product line.
    property informationLinkIdList : TFhirPositiveIntList read GetInformationLinkIdList;
    property hasInformationLinkIdList : boolean read GetHasInformationLinkIdList;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,RXNorm,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reason codes for the inclusion or covering of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the site, eg. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // A billed item may include goods or services provided in multiple encounters.
    property encounterList : TFhirReferenceList{TFhirEncounter} read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // Second tier of goods and services.
    property detailList : TFhirClaimItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemList;
    function GetCurrent : TFhirClaimItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItem read GetCurrent;
  end;

  TFhirClaimItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItem;
    procedure SetItemN(index : Integer; value : TFhirClaimItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemList; Overload;
    function Clone : TFhirClaimItemList; Overload;
    function GetEnumerator : TFhirClaimItemListEnumerator;

    //  Add a FhirClaimItem to the end of the list.
    function Append : TFhirClaimItem;

    // Add an already existing FhirClaimItem to the end of the list.
    procedure AddItem(value : TFhirClaimItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItem) : Integer;

    // Insert FhirClaimItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItem;

    // Insert an existing FhirClaimItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItem);

    // Get the iIndexth FhirClaimItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItems[index : Integer] : TFhirClaimItem read GetItemN write SetItemN; default;
  End;

  // Second tier of goods and services.
  TFhirClaimItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FsubDetailList : TFhirClaimItemDetailSubDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetSubDetailList : TFhirClaimItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetail; overload;
    function Clone : TFhirClaimItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Third tier of goods and services.
    property subDetailList : TFhirClaimItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailList;
    function GetCurrent : TFhirClaimItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetail read GetCurrent;
  end;

  TFhirClaimItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailList; Overload;
    function Clone : TFhirClaimItemDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailListEnumerator;

    //  Add a FhirClaimItemDetail to the end of the list.
    function Append : TFhirClaimItemDetail;

    // Add an already existing FhirClaimItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetail) : Integer;

    // Insert FhirClaimItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetail;

    // Insert an existing FhirClaimItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetail);

    // Get the iIndexth FhirClaimItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItemDetails[index : Integer] : TFhirClaimItemDetail read GetItemN write SetItemN; default;
  End;

  // Third tier of goods and services.
  TFhirClaimItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetailSubDetail; overload;
    function Clone : TFhirClaimItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The fee for an addittional service or product or charge. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // The fee for an addittional service or product or charge.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailSubDetailList;
    function GetCurrent : TFhirClaimItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;

    //  Add a FhirClaimItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimItemDetailSubDetail;

    // Add an already existing FhirClaimItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetailSubDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetailSubDetail) : Integer;

    // Insert FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetailSubDetail;

    // Insert an existing FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetailSubDetail);

    // Get the iIndexth FhirClaimItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetailSubDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetailSubDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItemDetailSubDetails[index : Integer] : TFhirClaimItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
  TFhirClaim = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FUse : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FPriority : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirClaimRelatedList;
    FPrescription : TFhirReference{Resource};
    FOriginalPrescription : TFhirReference{TFhirMedicationRequest};
    FPayee : TFhirClaimPayee;
    FReferral : TFhirReference{TFhirReferralRequest};
    FFacility : TFhirReference{TFhirLocation};
    FcareTeamList : TFhirClaimCareTeamList;
    FinformationList : TFhirClaimInformationList;
    FdiagnosisList : TFhirClaimDiagnosisList;
    Fprocedure_List : TFhirClaimProcedureList;
    FinsuranceList : TFhirClaimInsuranceList;
    FAccident : TFhirClaimAccident;
    FEmploymentImpacted : TFhirPeriod;
    FHospitalization : TFhirPeriod;
    FitemList : TFhirClaimItemList;
    FTotal : TFhirMoney;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirClaimUseEnum;
    Procedure SetUseST(value : TFhirClaimUseEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetBillablePeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirClaimRelatedList;
    function GetHasRelatedList : Boolean;
    Procedure SetPrescription(value : TFhirReference{Resource});
    Procedure SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
    Procedure SetPayee(value : TFhirClaimPayee);
    Procedure SetReferral(value : TFhirReference{TFhirReferralRequest});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    function GetCareTeamList : TFhirClaimCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetInformationList : TFhirClaimInformationList;
    function GetHasInformationList : Boolean;
    function GetDiagnosisList : TFhirClaimDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirClaimProcedureList;
    function GetHasProcedure_List : Boolean;
    function GetInsuranceList : TFhirClaimInsuranceList;
    function GetHasInsuranceList : Boolean;
    Procedure SetAccident(value : TFhirClaimAccident);
    Procedure SetEmploymentImpacted(value : TFhirPeriod);
    Procedure SetHospitalization(value : TFhirPeriod);
    function GetItemList : TFhirClaimItemList;
    function GetHasItemList : Boolean;
    Procedure SetTotal(value : TFhirMoney);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaim; overload;
    function Clone : TFhirClaim; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The business identifier for the instance: claim number, pre-determination or pre-authorization number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, eg, oral, pharmacy, vision, insitutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, eg, oral, pharmacy, vision, insitutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A finer grained suite of claim subtype codes which may convey Inpatient vs Outpatient and/or a specialty service. In the US the BillType.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Complete (Bill or Claim), Proposed (Pre-Authorization), Exploratory (Pre-determination).
    property use : TFhirClaimUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to Patient Resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient Resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The billable period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The billable period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Person who created the invoice/claim/pre-determination or pre-authorization. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Person who created the invoice/claim/pre-determination or pre-authorization.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The Insurer who is target of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who is target of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the bill, claim pre-determination, pre-authorization. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the bill, claim pre-determination, pre-authorization.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the bill, claim pre-determination, pre-authorization. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the bill, claim pre-determination, pre-authorization.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Immediate (STAT), best effort (NORMAL), deferred (DEFER). (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Immediate (STAT), best effort (NORMAL), deferred (DEFER).
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior claim versions or for related services.
    property relatedList : TFhirClaimRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of Pharmacy or Vision products. (defined for API consistency)
    property prescription : TFhirReference{Resource} read FPrescription write SetPrescription;
    // Prescription to support the dispensing of Pharmacy or Vision products.
    property prescriptionElement : TFhirReference{Resource} read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superceded by this prescription to support the dispensing of pharmacy services, medications or products. For example, a physician may prescribe a medication which the pharmacy determines is contraindicated, or for which the patient has an intolerance, and therefor issues a new precription for an alternate medication which has the same theraputic intent. The prescription from the pharmacy becomes the 'prescription' and that from the physician becomes the 'original prescription'. (defined for API consistency)
    property originalPrescription : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superceded by this prescription to support the dispensing of pharmacy services, medications or products. For example, a physician may prescribe a medication which the pharmacy determines is contraindicated, or for which the patient has an intolerance, and therefor issues a new precription for an alternate medication which has the same theraputic intent. The prescription from the pharmacy becomes the 'prescription' and that from the physician becomes the 'original prescription'.
    property originalPrescriptionElement : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for the services. (defined for API consistency)
    property payee : TFhirClaimPayee read FPayee write SetPayee;
    // The party to be reimbursed for the services.
    property payeeElement : TFhirClaimPayee read FPayee write SetPayee;

    // Typed access to The referral resource which lists the date, practitioner, reason and other supporting information. (defined for API consistency)
    property referral : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;
    // The referral resource which lists the date, practitioner, reason and other supporting information.
    property referralElement : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
    property careTeamList : TFhirClaimCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
    property informationList : TFhirClaimInformationList read GetInformationList;
    property hasInformationList : boolean read GetHasInformationList;

    // List of patient diagnosis for which care is sought.
    property diagnosisList : TFhirClaimDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Ordered list of patient procedures performed to support the adjudication.
    property procedure_List : TFhirClaimProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Financial instrument by which payment information for health care.
    property insuranceList : TFhirClaimInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to An accident which resulted in the need for healthcare services. (defined for API consistency)
    property accident : TFhirClaimAccident read FAccident write SetAccident;
    // An accident which resulted in the need for healthcare services.
    property accidentElement : TFhirClaimAccident read FAccident write SetAccident;

    // Typed access to The start and optional end dates of when the patient was precluded from working due to the treatable condition(s). (defined for API consistency)
    property employmentImpacted : TFhirPeriod read FEmploymentImpacted write SetEmploymentImpacted;
    // The start and optional end dates of when the patient was precluded from working due to the treatable condition(s).
    property employmentImpactedElement : TFhirPeriod read FEmploymentImpacted write SetEmploymentImpacted;

    // Typed access to The start and optional end dates of when the patient was confined to a treatment center. (defined for API consistency)
    property hospitalization : TFhirPeriod read FHospitalization write SetHospitalization;
    // The start and optional end dates of when the patient was confined to a treatment center.
    property hospitalizationElement : TFhirPeriod read FHospitalization write SetHospitalization;

    // First tier of goods and services.
    property itemList : TFhirClaimItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Typed access to The total value of the claim. (defined for API consistency)
    property total : TFhirMoney read FTotal write SetTotal;
    // The total value of the claim.
    property totalElement : TFhirMoney read FTotal write SetTotal;

  end;

  TFhirClaimListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimList;
    function GetCurrent : TFhirClaim;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaim read GetCurrent;
  end;

  TFhirClaimList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaim;
    procedure SetItemN(index : Integer; value : TFhirClaim);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimList; Overload;
    function Clone : TFhirClaimList; Overload;
    function GetEnumerator : TFhirClaimListEnumerator;

    //  Add a FhirClaim to the end of the list.
    function Append : TFhirClaim;

    // Add an already existing FhirClaim to the end of the list.
    procedure AddItem(value : TFhirClaim); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaim) : Integer;

    // Insert FhirClaim before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaim;

    // Insert an existing FhirClaim before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaim);

    // Get the iIndexth FhirClaim. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaim);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaim;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaims[index : Integer] : TFhirClaim read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

  // The first tier service adjudications for submitted services.
  TFhirClaimResponseItem = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseItemDetailList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItem; overload;
    function Clone : TFhirClaimResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second tier service adjudications for submitted services.
    property detailList : TFhirClaimResponseItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemList;
    function GetCurrent : TFhirClaimResponseItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItem read GetCurrent;
  end;

  TFhirClaimResponseItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemList; Overload;
    function Clone : TFhirClaimResponseItemList; Overload;
    function GetEnumerator : TFhirClaimResponseItemListEnumerator;

    //  Add a FhirClaimResponseItem to the end of the list.
    function Append : TFhirClaimResponseItem;

    // Add an already existing FhirClaimResponseItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItem) : Integer;

    // Insert FhirClaimResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItem;

    // Insert an existing FhirClaimResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItem);

    // Get the iIndexth FhirClaimResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItems[index : Integer] : TFhirClaimResponseItem read GetItemN write SetItemN; default;
  End;

  // The adjudication results.
  TFhirClaimResponseItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemAdjudication; overload;
    function Clone : TFhirClaimResponseItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Adjudication reason such as limit reached. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Adjudication reason such as limit reached.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemAdjudicationList; Overload;
    function Clone : TFhirClaimResponseItemAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;

    //  Add a FhirClaimResponseItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemAdjudication;

    // Add an already existing FhirClaimResponseItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemAdjudication) : Integer;

    // Insert FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemAdjudication;

    // Insert an existing FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemAdjudication);

    // Get the iIndexth FhirClaimResponseItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemAdjudications[index : Integer] : TFhirClaimResponseItemAdjudication read GetItemN write SetItemN; default;
  End;

  // The second tier service adjudications for submitted services.
  TFhirClaimResponseItemDetail = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetail; overload;
    function Clone : TFhirClaimResponseItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third tier service adjudications for submitted services.
    property subDetailList : TFhirClaimResponseItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailList;
    function GetCurrent : TFhirClaimResponseItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;

    //  Add a FhirClaimResponseItemDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetail;

    // Add an already existing FhirClaimResponseItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetail) : Integer;

    // Insert FhirClaimResponseItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetail;

    // Insert an existing FhirClaimResponseItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetail);

    // Get the iIndexth FhirClaimResponseItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetails[index : Integer] : TFhirClaimResponseItemDetail read GetItemN write SetItemN; default;
  End;

  // The third tier service adjudications for submitted services.
  TFhirClaimResponseItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;

    //  Add a FhirClaimResponseItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetail;

    // Add an already existing FhirClaimResponseItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetail) : Integer;

    // Insert FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetail;

    // Insert an existing FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);

    // Get the iIndexth FhirClaimResponseItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetailSubDetails[index : Integer] : TFhirClaimResponseItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first tier service adjudications for payor added services.
  TFhirClaimResponseAddItem = class (TFhirBackboneElement)
  protected
    FsequenceLinkIdList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FFee : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseAddItemDetailList;
    function GetSequenceLinkIdList : TFhirPositiveIntList;
    function GetHasSequenceLinkIdList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetFee(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseAddItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItem; overload;
    function Clone : TFhirClaimResponseAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // List of input service items which this service line is intended to replace.
    property sequenceLinkIdList : TFhirPositiveIntList read GetSequenceLinkIdList;
    property hasSequenceLinkIdList : boolean read GetHasSequenceLinkIdList;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // A code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The fee charged for the professional service or product.. (defined for API consistency)
    property fee : TFhirMoney read FFee write SetFee;
    // The fee charged for the professional service or product..
    property feeElement : TFhirMoney read FFee write SetFee;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second tier service adjudications for payor added services.
    property detailList : TFhirClaimResponseAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemList;
    function GetCurrent : TFhirClaimResponseAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItem read GetCurrent;
  end;

  TFhirClaimResponseAddItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemList; Overload;
    function Clone : TFhirClaimResponseAddItemList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemListEnumerator;

    //  Add a FhirClaimResponseAddItem to the end of the list.
    function Append : TFhirClaimResponseAddItem;

    // Add an already existing FhirClaimResponseAddItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItem) : Integer;

    // Insert FhirClaimResponseAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItem;

    // Insert an existing FhirClaimResponseAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItem);

    // Get the iIndexth FhirClaimResponseAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItems[index : Integer] : TFhirClaimResponseAddItem read GetItemN write SetItemN; default;
  End;

  // The second tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetail = class (TFhirBackboneElement)
  protected
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FFee : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetFee(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // A code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The fee charged for the professional service or product.. (defined for API consistency)
    property fee : TFhirMoney read FFee write SetFee;
    // The fee charged for the professional service or product..
    property feeElement : TFhirMoney read FFee write SetFee;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemDetailList; Overload;
    function Clone : TFhirClaimResponseAddItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;

    //  Add a FhirClaimResponseAddItemDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetail;

    // Add an already existing FhirClaimResponseAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetail) : Integer;

    // Insert FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetail;

    // Insert an existing FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetail);

    // Get the iIndexth FhirClaimResponseAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItemDetails[index : Integer] : TFhirClaimResponseAddItemDetail read GetItemN write SetItemN; default;
  End;

  // Mutually exclusive with Services Provided (Item).
  TFhirClaimResponseError = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FDetailSequenceLinkId : TFhirPositiveInt;
    FSubdetailSequenceLinkId : TFhirPositiveInt;
    FCode : TFhirCodeableConcept;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    Procedure SetDetailSequenceLinkId(value : TFhirPositiveInt);
    Function GetDetailSequenceLinkIdST : String;
    Procedure SetDetailSequenceLinkIdST(value : String);
    Procedure SetSubdetailSequenceLinkId(value : TFhirPositiveInt);
    Function GetSubdetailSequenceLinkIdST : String;
    Procedure SetSubdetailSequenceLinkIdST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseError; overload;
    function Clone : TFhirClaimResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // Typed access to The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property detailSequenceLinkId : String read GetDetailSequenceLinkIdST write SetDetailSequenceLinkIdST;
    // The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property detailSequenceLinkIdElement : TFhirPositiveInt read FDetailSequenceLinkId write SetDetailSequenceLinkId;

    // Typed access to The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property subdetailSequenceLinkId : String read GetSubdetailSequenceLinkIdST write SetSubdetailSequenceLinkIdST;
    // The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property subdetailSequenceLinkIdElement : TFhirPositiveInt read FSubdetailSequenceLinkId write SetSubdetailSequenceLinkId;

    // Typed access to An error code,from a specified code system, which details why the claim could not be adjudicated. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code,from a specified code system, which details why the claim could not be adjudicated.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirClaimResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseErrorList;
    function GetCurrent : TFhirClaimResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseError read GetCurrent;
  end;

  TFhirClaimResponseErrorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseError;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseErrorList; Overload;
    function Clone : TFhirClaimResponseErrorList; Overload;
    function GetEnumerator : TFhirClaimResponseErrorListEnumerator;

    //  Add a FhirClaimResponseError to the end of the list.
    function Append : TFhirClaimResponseError;

    // Add an already existing FhirClaimResponseError to the end of the list.
    procedure AddItem(value : TFhirClaimResponseError); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseError) : Integer;

    // Insert FhirClaimResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseError;

    // Insert an existing FhirClaimResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseError);

    // Get the iIndexth FhirClaimResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseError);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseError;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseErrors[index : Integer] : TFhirClaimResponseError read GetItemN write SetItemN; default;
  End;

  // Payment details for the claim if the claim has been paid.
  TFhirClaimResponsePayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAdjustment(value : TFhirMoney);
    Procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetIdentifier(value : TFhirIdentifier);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponsePayment; overload;
    function Clone : TFhirClaimResponsePayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the claim. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the claim.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Adjustment to the payment of this transaction which is not related to adjudication of this transaction. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated payment data.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated payment data.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Payment identifier. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Payment identifier.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirClaimResponsePaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponsePaymentList;
    function GetCurrent : TFhirClaimResponsePayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponsePaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponsePayment read GetCurrent;
  end;

  TFhirClaimResponsePaymentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponsePayment;
    procedure SetItemN(index : Integer; value : TFhirClaimResponsePayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponsePaymentList; Overload;
    function Clone : TFhirClaimResponsePaymentList; Overload;
    function GetEnumerator : TFhirClaimResponsePaymentListEnumerator;

    //  Add a FhirClaimResponsePayment to the end of the list.
    function Append : TFhirClaimResponsePayment;

    // Add an already existing FhirClaimResponsePayment to the end of the list.
    procedure AddItem(value : TFhirClaimResponsePayment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponsePayment) : Integer;

    // Insert FhirClaimResponsePayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponsePayment;

    // Insert an existing FhirClaimResponsePayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponsePayment);

    // Get the iIndexth FhirClaimResponsePayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponsePayment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponsePayment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponsePayments[index : Integer] : TFhirClaimResponsePayment read GetItemN write SetItemN; default;
  End;

  // Note text.
  TFhirClaimResponseProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirCodeableConcept;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    Procedure SetNumber(value : TFhirPositiveInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetLanguage(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseProcessNote; overload;
    function Clone : TFhirClaimResponseProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An integer associated with each note which may be referred to from each service line item.
    property number : String read GetNumberST write SetNumberST;
    // An integer associated with each note which may be referred to from each service line item.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirClaimResponseProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseProcessNoteList;
    function GetCurrent : TFhirClaimResponseProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseProcessNote read GetCurrent;
  end;

  TFhirClaimResponseProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseProcessNote;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseProcessNoteList; Overload;
    function Clone : TFhirClaimResponseProcessNoteList; Overload;
    function GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;

    //  Add a FhirClaimResponseProcessNote to the end of the list.
    function Append : TFhirClaimResponseProcessNote;

    // Add an already existing FhirClaimResponseProcessNote to the end of the list.
    procedure AddItem(value : TFhirClaimResponseProcessNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseProcessNote) : Integer;

    // Insert FhirClaimResponseProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseProcessNote;

    // Insert an existing FhirClaimResponseProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseProcessNote);

    // Get the iIndexth FhirClaimResponseProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseProcessNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseProcessNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseProcessNotes[index : Integer] : TFhirClaimResponseProcessNote read GetItemN write SetItemN; default;
  End;

  // Financial instrument by which payment information for health care.
  TFhirClaimResponseInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseInsurance; overload;
    function Clone : TFhirClaimResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line item.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line item.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focal : Boolean read GetFocalST write SetFocalST;
    // The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract number of a business agreement which describes the terms and conditions.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // The contract number of a business agreement which describes the terms and conditions.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // A list of references from the Insurer to which these services pertain.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The Coverages adjudication details. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The Coverages adjudication details.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseInsuranceList;
    function GetCurrent : TFhirClaimResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseInsurance read GetCurrent;
  end;

  TFhirClaimResponseInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseInsuranceList; Overload;
    function Clone : TFhirClaimResponseInsuranceList; Overload;
    function GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;

    //  Add a FhirClaimResponseInsurance to the end of the list.
    function Append : TFhirClaimResponseInsurance;

    // Add an already existing FhirClaimResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimResponseInsurance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseInsurance) : Integer;

    // Insert FhirClaimResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseInsurance;

    // Insert an existing FhirClaimResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseInsurance);

    // Get the iIndexth FhirClaimResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseInsurance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseInsurance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseInsurances[index : Integer] : TFhirClaimResponseInsurance read GetItemN write SetItemN; default;
  End;

  // This resource provides the adjudication details from the processing of a Claim resource.
  TFhirClaimResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirClaim};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FPayeeType : TFhirCodeableConcept;
    FitemList : TFhirClaimResponseItemList;
    FaddItemList : TFhirClaimResponseAddItemList;
    FerrorList : TFhirClaimResponseErrorList;
    FTotalCost : TFhirMoney;
    FUnallocDeductable : TFhirMoney;
    FTotalBenefit : TFhirMoney;
    FPayment : TFhirClaimResponsePayment;
    FReserved : TFhirCoding;
    FForm : TFhirCodeableConcept;
    FprocessNoteList : TFhirClaimResponseProcessNoteList;
    FcommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    FinsuranceList : TFhirClaimResponseInsuranceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirClaim});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetPayeeType(value : TFhirCodeableConcept);
    function GetItemList : TFhirClaimResponseItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirClaimResponseAddItemList;
    function GetHasAddItemList : Boolean;
    function GetErrorList : TFhirClaimResponseErrorList;
    function GetHasErrorList : Boolean;
    Procedure SetTotalCost(value : TFhirMoney);
    Procedure SetUnallocDeductable(value : TFhirMoney);
    Procedure SetTotalBenefit(value : TFhirMoney);
    Procedure SetPayment(value : TFhirClaimResponsePayment);
    Procedure SetReserved(value : TFhirCoding);
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirClaimResponseProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    function GetHasCommunicationRequestList : Boolean;
    function GetInsuranceList : TFhirClaimResponseInsuranceList;
    function GetHasInsuranceList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponse; overload;
    function Clone : TFhirClaimResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Patient Resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient Resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who produced this adjudicated response.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // Typed access to Original request resource referrence. (defined for API consistency)
    property request : TFhirReference{TFhirClaim} read FRequest write SetRequest;
    // Original request resource referrence.
    property requestElement : TFhirReference{TFhirClaim} read FRequest write SetRequest;

    // Typed access to Processing outcome errror, partial or complete processing. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Processing outcome errror, partial or complete processing.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property payeeType : TFhirCodeableConcept read FPayeeType write SetPayeeType;
    // Party to be reimbursed: Subscriber, provider, other.
    property payeeTypeElement : TFhirCodeableConcept read FPayeeType write SetPayeeType;

    // The first tier service adjudications for submitted services.
    property itemList : TFhirClaimResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first tier service adjudications for payor added services.
    property addItemList : TFhirClaimResponseAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // Mutually exclusive with Services Provided (Item).
    property errorList : TFhirClaimResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

    // Typed access to The total cost of the services reported. (defined for API consistency)
    property totalCost : TFhirMoney read FTotalCost write SetTotalCost;
    // The total cost of the services reported.
    property totalCostElement : TFhirMoney read FTotalCost write SetTotalCost;

    // Typed access to The amount of deductible applied which was not allocated to any particular service line. (defined for API consistency)
    property unallocDeductable : TFhirMoney read FUnallocDeductable write SetUnallocDeductable;
    // The amount of deductible applied which was not allocated to any particular service line.
    property unallocDeductableElement : TFhirMoney read FUnallocDeductable write SetUnallocDeductable;

    // Typed access to Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible). (defined for API consistency)
    property totalBenefit : TFhirMoney read FTotalBenefit write SetTotalBenefit;
    // Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
    property totalBenefitElement : TFhirMoney read FTotalBenefit write SetTotalBenefit;

    // Typed access to Payment details for the claim if the claim has been paid. (defined for API consistency)
    property payment : TFhirClaimResponsePayment read FPayment write SetPayment;
    // Payment details for the claim if the claim has been paid.
    property paymentElement : TFhirClaimResponsePayment read FPayment write SetPayment;

    // Typed access to Status of funds reservation (For provider, for Patient, None). (defined for API consistency)
    property reserved : TFhirCoding read FReserved write SetReserved;
    // Status of funds reservation (For provider, for Patient, None).
    property reservedElement : TFhirCoding read FReserved write SetReserved;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Note text.
    property processNoteList : TFhirClaimResponseProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Request for additional supporting or authorizing information, such as: documents, images or resources.
    property communicationRequestList : TFhirReferenceList{TFhirCommunicationRequest} read GetCommunicationRequestList;
    property hasCommunicationRequestList : boolean read GetHasCommunicationRequestList;

    // Financial instrument by which payment information for health care.
    property insuranceList : TFhirClaimResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

  end;

  TFhirClaimResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseList;
    function GetCurrent : TFhirClaimResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponse read GetCurrent;
  end;

  TFhirClaimResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponse;
    procedure SetItemN(index : Integer; value : TFhirClaimResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseList; Overload;
    function Clone : TFhirClaimResponseList; Overload;
    function GetEnumerator : TFhirClaimResponseListEnumerator;

    //  Add a FhirClaimResponse to the end of the list.
    function Append : TFhirClaimResponse;

    // Add an already existing FhirClaimResponse to the end of the list.
    procedure AddItem(value : TFhirClaimResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponse) : Integer;

    // Insert FhirClaimResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponse;

    // Insert an existing FhirClaimResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponse);

    // Get the iIndexth FhirClaimResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponses[index : Integer] : TFhirClaimResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_CONSENT}

  // Who or what is controlled by this consent. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
  TFhirConsentActor = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FReference : TFhirReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentActor; overload;
    function Clone : TFhirConsentActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to How the individual is involved in the resources content that is described in the consent. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the individual is involved in the resources content that is described in the consent.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers'). (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

  end;

  TFhirConsentActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentActorList;
    function GetCurrent : TFhirConsentActor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentActor read GetCurrent;
  end;

  TFhirConsentActorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentActor;
    procedure SetItemN(index : Integer; value : TFhirConsentActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentActorList; Overload;
    function Clone : TFhirConsentActorList; Overload;
    function GetEnumerator : TFhirConsentActorListEnumerator;

    //  Add a FhirConsentActor to the end of the list.
    function Append : TFhirConsentActor;

    // Add an already existing FhirConsentActor to the end of the list.
    procedure AddItem(value : TFhirConsentActor); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentActor) : Integer;

    // Insert FhirConsentActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentActor;

    // Insert an existing FhirConsentActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentActor);

    // Get the iIndexth FhirConsentActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentActor);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentActor;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentActors[index : Integer] : TFhirConsentActor read GetItemN write SetItemN; default;
  End;

  // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
  TFhirConsentPolicy = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirUri;
    FUri : TFhirUri;
    Procedure SetAuthority(value : TFhirUri);
    Function GetAuthorityST : String;
    Procedure SetAuthorityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentPolicy; overload;
    function Clone : TFhirConsentPolicy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Entity or Organization having regulatory jurisdiction or accountability for ?enforcing policies pertaining to Consent Directives.
    property authority : String read GetAuthorityST write SetAuthorityST;
    // Entity or Organization having regulatory jurisdiction or accountability for ?enforcing policies pertaining to Consent Directives.
    property authorityElement : TFhirUri read FAuthority write SetAuthority;

    // Typed access to The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uri : String read GetUriST write SetUriST;
    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uriElement : TFhirUri read FUri write SetUri;

  end;

  TFhirConsentPolicyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentPolicyList;
    function GetCurrent : TFhirConsentPolicy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentPolicyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentPolicy read GetCurrent;
  end;

  TFhirConsentPolicyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentPolicy;
    procedure SetItemN(index : Integer; value : TFhirConsentPolicy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentPolicyList; Overload;
    function Clone : TFhirConsentPolicyList; Overload;
    function GetEnumerator : TFhirConsentPolicyListEnumerator;

    //  Add a FhirConsentPolicy to the end of the list.
    function Append : TFhirConsentPolicy;

    // Add an already existing FhirConsentPolicy to the end of the list.
    procedure AddItem(value : TFhirConsentPolicy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentPolicy) : Integer;

    // Insert FhirConsentPolicy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentPolicy;

    // Insert an existing FhirConsentPolicy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentPolicy);

    // Get the iIndexth FhirConsentPolicy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentPolicy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentPolicy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentPolicies[index : Integer] : TFhirConsentPolicy read GetItemN write SetItemN; default;
  End;

  // The resources controlled by this consent, if specific resources are referenced.
  TFhirConsentData = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference{TFhirReference};
    Procedure SetMeaning(value : TFhirEnum);
    Function GetMeaningST : TFhirConsentDataMeaningEnum;
    Procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    Procedure SetReference(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentData; overload;
    function Clone : TFhirConsentData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

  end;

  TFhirConsentDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentDataList;
    function GetCurrent : TFhirConsentData;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentData read GetCurrent;
  end;

  TFhirConsentDataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentData;
    procedure SetItemN(index : Integer; value : TFhirConsentData);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentDataList; Overload;
    function Clone : TFhirConsentDataList; Overload;
    function GetEnumerator : TFhirConsentDataListEnumerator;

    //  Add a FhirConsentData to the end of the list.
    function Append : TFhirConsentData;

    // Add an already existing FhirConsentData to the end of the list.
    procedure AddItem(value : TFhirConsentData); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentData) : Integer;

    // Insert FhirConsentData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentData;

    // Insert an existing FhirConsentData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentData);

    // Get the iIndexth FhirConsentData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentData);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentData;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentData[index : Integer] : TFhirConsentData read GetItemN write SetItemN; default;
  End;

  // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
  TFhirConsentExcept = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FPeriod : TFhirPeriod;
    FactorList : TFhirConsentExceptActorList;
    FactionList : TFhirCodeableConceptList;
    FsecurityLabelList : TFhirCodingList;
    FpurposeList : TFhirCodingList;
    Fclass_List : TFhirCodingList;
    FcodeList : TFhirCodingList;
    FDataPeriod : TFhirPeriod;
    FdataList : TFhirConsentExceptDataList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConsentExceptTypeEnum;
    Procedure SetType_ST(value : TFhirConsentExceptTypeEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetActorList : TFhirConsentExceptActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetPurposeList : TFhirCodingList;
    function GetHasPurposeList : Boolean;
    function GetClass_List : TFhirCodingList;
    function GetHasClass_List : Boolean;
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    Procedure SetDataPeriod(value : TFhirPeriod);
    function GetDataList : TFhirConsentExceptDataList;
    function GetHasDataList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentExcept; overload;
    function Clone : TFhirConsentExcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Action  to take - permit or deny - when the exception conditions are met.
    property type_ : TFhirConsentExceptTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The timeframe in this exception is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe in this exception is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Who or what is controlled by this Exception. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property actorList : TFhirConsentExceptActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this Exception.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // A set of security labels that define which resources are controlled by this exception. If more than one label is specified, all resources must have all the specified labels.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The context of the activities a user is taking - why the user is accessing the data - that are controlled by this exception.
    property purposeList : TFhirCodingList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

    // The class of information covered by this exception. The type can be a FHIR resource type, a profile on a type, or a CDA document, or some other type that indicates what sort of information the consent relates to.
    property class_List : TFhirCodingList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // If this code is found in an instance, then the exception applies.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Clinical or Operational Relevant period of time that bounds the data controlled by this exception. (defined for API consistency)
    property dataPeriod : TFhirPeriod read FDataPeriod write SetDataPeriod;
    // Clinical or Operational Relevant period of time that bounds the data controlled by this exception.
    property dataPeriodElement : TFhirPeriod read FDataPeriod write SetDataPeriod;

    // The resources controlled by this exception, if specific resources are referenced.
    property dataList : TFhirConsentExceptDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

  end;

  TFhirConsentExceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentExceptList;
    function GetCurrent : TFhirConsentExcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentExceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentExcept read GetCurrent;
  end;

  TFhirConsentExceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentExcept;
    procedure SetItemN(index : Integer; value : TFhirConsentExcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentExceptList; Overload;
    function Clone : TFhirConsentExceptList; Overload;
    function GetEnumerator : TFhirConsentExceptListEnumerator;

    //  Add a FhirConsentExcept to the end of the list.
    function Append : TFhirConsentExcept;

    // Add an already existing FhirConsentExcept to the end of the list.
    procedure AddItem(value : TFhirConsentExcept); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentExcept) : Integer;

    // Insert FhirConsentExcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentExcept;

    // Insert an existing FhirConsentExcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentExcept);

    // Get the iIndexth FhirConsentExcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentExcept);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentExcept;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentExcepts[index : Integer] : TFhirConsentExcept read GetItemN write SetItemN; default;
  End;

  // Who or what is controlled by this Exception. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
  TFhirConsentExceptActor = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FReference : TFhirReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentExceptActor; overload;
    function Clone : TFhirConsentExceptActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to How the individual is involved in the resources content that is described in the exception. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the individual is involved in the resources content that is described in the exception.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers'). (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // The resource that identifies the actor. To identify a actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

  end;

  TFhirConsentExceptActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentExceptActorList;
    function GetCurrent : TFhirConsentExceptActor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentExceptActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentExceptActor read GetCurrent;
  end;

  TFhirConsentExceptActorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentExceptActor;
    procedure SetItemN(index : Integer; value : TFhirConsentExceptActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentExceptActorList; Overload;
    function Clone : TFhirConsentExceptActorList; Overload;
    function GetEnumerator : TFhirConsentExceptActorListEnumerator;

    //  Add a FhirConsentExceptActor to the end of the list.
    function Append : TFhirConsentExceptActor;

    // Add an already existing FhirConsentExceptActor to the end of the list.
    procedure AddItem(value : TFhirConsentExceptActor); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentExceptActor) : Integer;

    // Insert FhirConsentExceptActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentExceptActor;

    // Insert an existing FhirConsentExceptActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentExceptActor);

    // Get the iIndexth FhirConsentExceptActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentExceptActor);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentExceptActor;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentExceptActors[index : Integer] : TFhirConsentExceptActor read GetItemN write SetItemN; default;
  End;

  // The resources controlled by this exception, if specific resources are referenced.
  TFhirConsentExceptData = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference{TFhirReference};
    Procedure SetMeaning(value : TFhirEnum);
    Function GetMeaningST : TFhirConsentDataMeaningEnum;
    Procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    Procedure SetReference(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentExceptData; overload;
    function Clone : TFhirConsentExceptData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

  end;

  TFhirConsentExceptDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentExceptDataList;
    function GetCurrent : TFhirConsentExceptData;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentExceptDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentExceptData read GetCurrent;
  end;

  TFhirConsentExceptDataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentExceptData;
    procedure SetItemN(index : Integer; value : TFhirConsentExceptData);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentExceptDataList; Overload;
    function Clone : TFhirConsentExceptDataList; Overload;
    function GetEnumerator : TFhirConsentExceptDataListEnumerator;

    //  Add a FhirConsentExceptData to the end of the list.
    function Append : TFhirConsentExceptData;

    // Add an already existing FhirConsentExceptData to the end of the list.
    procedure AddItem(value : TFhirConsentExceptData); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentExceptData) : Integer;

    // Insert FhirConsentExceptData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentExceptData;

    // Insert an existing FhirConsentExceptData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentExceptData);

    // Get the iIndexth FhirConsentExceptData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentExceptData);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentExceptData;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsentExceptData[index : Integer] : TFhirConsentExceptData read GetItemN write SetItemN; default;
  End;

  // A record of a healthcare consumer?s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
  TFhirConsent = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPatient : TFhirReference{TFhirPatient};
    FPeriod : TFhirPeriod;
    FDateTime : TFhirDateTime;
    FconsentingPartyList : TFhirReferenceList{Resource};
    FactorList : TFhirConsentActorList;
    FactionList : TFhirCodeableConceptList;
    ForganizationList : TFhirReferenceList{TFhirOrganization};
    FSource : TFhirType;
    FpolicyList : TFhirConsentPolicyList;
    FPolicyRule : TFhirUri;
    FsecurityLabelList : TFhirCodingList;
    FpurposeList : TFhirCodingList;
    FDataPeriod : TFhirPeriod;
    FdataList : TFhirConsentDataList;
    Fexcept_List : TFhirConsentExceptList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConsentStateCodesEnum;
    Procedure SetStatusST(value : TFhirConsentStateCodesEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    function GetConsentingPartyList : TFhirReferenceList{Resource};
    function GetHasConsentingPartyList : Boolean;
    function GetActorList : TFhirConsentActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetOrganizationList : TFhirReferenceList{TFhirOrganization};
    function GetHasOrganizationList : Boolean;
    Procedure SetSource(value : TFhirType);
    function GetPolicyList : TFhirConsentPolicyList;
    function GetHasPolicyList : Boolean;
    Procedure SetPolicyRule(value : TFhirUri);
    Function GetPolicyRuleST : String;
    Procedure SetPolicyRuleST(value : String);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetPurposeList : TFhirCodingList;
    function GetHasPurposeList : Boolean;
    Procedure SetDataPeriod(value : TFhirPeriod);
    function GetDataList : TFhirConsentDataList;
    function GetHasDataList : Boolean;
    function GetExcept_List : TFhirConsentExceptList;
    function GetHasExcept_List : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsent; overload;
    function Clone : TFhirConsent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for this copy of the Consent Statement. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this copy of the Consent Statement.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the current state of this consent.
    property status : TFhirConsentStateCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The patient/healthcare consumer to whom this consent applies. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient/healthcare consumer to whom this consent applies.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Relevant time or time-period when this Consent is applicable. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Relevant time or time-period when this Consent is applicable.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to When this  Consent was issued / created / indexed.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // When this  Consent was issued / created / indexed.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Either the Grantor, which is the entity responsible for granting the rights listed in a Consent Directive or the Grantee, which is the entity responsible for complying with the Consent Directive, including any obligations or limitations on authorizations and enforcement of prohibitions.
    property consentingPartyList : TFhirReferenceList{Resource} read GetConsentingPartyList;
    property hasConsentingPartyList : boolean read GetHasConsentingPartyList;

    // Who or what is controlled by this consent. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property actorList : TFhirConsentActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this consent.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // The organization that manages the consent, and the framework within which it is executed.
    property organizationList : TFhirReferenceList{TFhirOrganization} read GetOrganizationList;
    property hasOrganizationList : boolean read GetHasOrganizationList;

    // Typed access to The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document.
    property sourceElement : TFhirType read FSource write SetSource;

    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property policyList : TFhirConsentPolicyList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to A referece to the specific computable policy.
    property policyRule : String read GetPolicyRuleST write SetPolicyRuleST;
    // A referece to the specific computable policy.
    property policyRuleElement : TFhirUri read FPolicyRule write SetPolicyRule;

    // A set of security labels that define which resources are controlled by this consent. If more than one label is specified, all resources must have all the specified labels.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The context of the activities a user is taking - why the user is accessing the data - that are controlled by this consent.
    property purposeList : TFhirCodingList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

    // Typed access to Clinical or Operational Relevant period of time that bounds the data controlled by this consent. (defined for API consistency)
    property dataPeriod : TFhirPeriod read FDataPeriod write SetDataPeriod;
    // Clinical or Operational Relevant period of time that bounds the data controlled by this consent.
    property dataPeriodElement : TFhirPeriod read FDataPeriod write SetDataPeriod;

    // The resources controlled by this consent, if specific resources are referenced.
    property dataList : TFhirConsentDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
    property except_List : TFhirConsentExceptList read GetExcept_List;
    property hasExcept_List : boolean read GetHasExcept_List;

  end;

  TFhirConsentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentList;
    function GetCurrent : TFhirConsent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsent read GetCurrent;
  end;

  TFhirConsentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsent;
    procedure SetItemN(index : Integer; value : TFhirConsent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentList; Overload;
    function Clone : TFhirConsentList; Overload;
    function GetEnumerator : TFhirConsentListEnumerator;

    //  Add a FhirConsent to the end of the list.
    function Append : TFhirConsent;

    // Add an already existing FhirConsent to the end of the list.
    procedure AddItem(value : TFhirConsent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsent) : Integer;

    // Insert FhirConsent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsent;

    // Insert an existing FhirConsent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsent);

    // Get the iIndexth FhirConsent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConsent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConsents[index : Integer] : TFhirConsent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONSENT}

{$IFDEF FHIR_CONTRACT}

  // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirContractAgent = class (TFhirBackboneElement)
  protected
    FActor : TFhirReference{Resource};
    FroleList : TFhirCodeableConceptList;
    Procedure SetActor(value : TFhirReference{Resource});
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractAgent; overload;
    function Clone : TFhirContractAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Who or what parties are assigned roles in this Contract. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // Who or what parties are assigned roles in this Contract.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Role type of agent assigned roles in this Contract.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

  end;

  TFhirContractAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractAgentList;
    function GetCurrent : TFhirContractAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractAgent read GetCurrent;
  end;

  TFhirContractAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractAgent;
    procedure SetItemN(index : Integer; value : TFhirContractAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractAgentList; Overload;
    function Clone : TFhirContractAgentList; Overload;
    function GetEnumerator : TFhirContractAgentListEnumerator;

    //  Add a FhirContractAgent to the end of the list.
    function Append : TFhirContractAgent;

    // Add an already existing FhirContractAgent to the end of the list.
    procedure AddItem(value : TFhirContractAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractAgent) : Integer;

    // Insert FhirContractAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractAgent;

    // Insert an existing FhirContractAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractAgent);

    // Get the iIndexth FhirContractAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractAgents[index : Integer] : TFhirContractAgent read GetItemN write SetItemN; default;
  End;

  // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
  TFhirContractSigner = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FParty : TFhirReference{Resource};
    FsignatureList : TFhirSignatureList;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetParty(value : TFhirReference{Resource});
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractSigner; overload;
    function Clone : TFhirContractSigner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Role of this Contract signer, e.g. notary, grantee. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Role of this Contract signer, e.g. notary, grantee.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Party which is a signator to this Contract. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Party which is a signator to this Contract.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

    // Legally binding Contract DSIG signature contents in Base64.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirContractSignerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractSignerList;
    function GetCurrent : TFhirContractSigner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractSignerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractSigner read GetCurrent;
  end;

  TFhirContractSignerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractSigner;
    procedure SetItemN(index : Integer; value : TFhirContractSigner);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractSignerList; Overload;
    function Clone : TFhirContractSignerList; Overload;
    function GetEnumerator : TFhirContractSignerListEnumerator;

    //  Add a FhirContractSigner to the end of the list.
    function Append : TFhirContractSigner;

    // Add an already existing FhirContractSigner to the end of the list.
    procedure AddItem(value : TFhirContractSigner); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractSigner) : Integer;

    // Insert FhirContractSigner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractSigner;

    // Insert an existing FhirContractSigner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractSigner);

    // Get the iIndexth FhirContractSigner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractSigner);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractSigner;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractSigners[index : Integer] : TFhirContractSigner read GetItemN write SetItemN; default;
  End;

  // Contract Valued Item List.
  TFhirContractValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirMoney;
    Procedure SetEntity(value : TFhirType);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetEffectiveTime(value : TFhirDateTime);
    Function GetEffectiveTimeST : TFslDateTime;
    Procedure SetEffectiveTimeST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirMoney);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractValuedItem; overload;
    function Clone : TFhirContractValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specific type of Contract Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirType read FEntity write SetEntity;
    // Specific type of Contract Valued Item that may be priced.
    property entityElement : TFhirType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // A Contract Valued Item unit valuation measure.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

  end;

  TFhirContractValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractValuedItemList;
    function GetCurrent : TFhirContractValuedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractValuedItem read GetCurrent;
  end;

  TFhirContractValuedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractValuedItemList; Overload;
    function Clone : TFhirContractValuedItemList; Overload;
    function GetEnumerator : TFhirContractValuedItemListEnumerator;

    //  Add a FhirContractValuedItem to the end of the list.
    function Append : TFhirContractValuedItem;

    // Add an already existing FhirContractValuedItem to the end of the list.
    procedure AddItem(value : TFhirContractValuedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractValuedItem) : Integer;

    // Insert FhirContractValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractValuedItem;

    // Insert an existing FhirContractValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractValuedItem);

    // Get the iIndexth FhirContractValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractValuedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractValuedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractValuedItems[index : Integer] : TFhirContractValuedItem read GetItemN write SetItemN; default;
  End;

  // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
  TFhirContractTerm = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FtopicList : TFhirReferenceList{TFhirReference};
    FactionList : TFhirCodeableConceptList;
    FactionReasonList : TFhirCodeableConceptList;
    FsecurityLabelList : TFhirCodingList;
    FagentList : TFhirContractTermAgentList;
    FText : TFhirString;
    FvaluedItemList : TFhirContractTermValuedItemList;
    FgroupList : TFhirContractTermList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    function GetTopicList : TFhirReferenceList{TFhirReference};
    function GetHasTopicList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetActionReasonList : TFhirCodeableConceptList;
    function GetHasActionReasonList : Boolean;
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetAgentList : TFhirContractTermAgentList;
    function GetHasAgentList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetValuedItemList : TFhirContractTermValuedItemList;
    function GetHasValuedItemList : Boolean;
    function GetGroupList : TFhirContractTermList;
    function GetHasGroupList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTerm; overload;
    function Clone : TFhirContractTerm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for this particular Contract Provision. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this particular Contract Provision.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this Contract Provision was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this Contract Provision was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract Provision is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract Provision is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Subtype of this Contract Provision, e.g. life time maximum payment for a contract term for specific valued item, e.g. disability payment. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // Subtype of this Contract Provision, e.g. life time maximum payment for a contract term for specific valued item, e.g. disability payment.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // The matter of concern in the context of this provision of the agrement.
    property topicList : TFhirReferenceList{TFhirReference} read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // Action stipulated by this Contract Provision.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Reason or purpose for the action stipulated by this Contract Provision.
    property actionReasonList : TFhirCodeableConceptList read GetActionReasonList;
    property hasActionReasonList : boolean read GetHasActionReasonList;

    // A set of security labels that define which terms are controlled by this condition.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirContractTermAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Typed access to Human readable form of this Contract Provision.
    property text : String read GetTextST write SetTextST;
    // Human readable form of this Contract Provision.
    property textElement : TFhirString read FText write SetText;

    // Contract Provision Valued Item List.
    property valuedItemList : TFhirContractTermValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

    // Nested group of Contract Provisions.
    property groupList : TFhirContractTermList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirContractTermListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermList;
    function GetCurrent : TFhirContractTerm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTerm read GetCurrent;
  end;

  TFhirContractTermList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTerm;
    procedure SetItemN(index : Integer; value : TFhirContractTerm);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermList; Overload;
    function Clone : TFhirContractTermList; Overload;
    function GetEnumerator : TFhirContractTermListEnumerator;

    //  Add a FhirContractTerm to the end of the list.
    function Append : TFhirContractTerm;

    // Add an already existing FhirContractTerm to the end of the list.
    procedure AddItem(value : TFhirContractTerm); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTerm) : Integer;

    // Insert FhirContractTerm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTerm;

    // Insert an existing FhirContractTerm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTerm);

    // Get the iIndexth FhirContractTerm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTerm);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTerm;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTerms[index : Integer] : TFhirContractTerm read GetItemN write SetItemN; default;
  End;

  // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirContractTermAgent = class (TFhirBackboneElement)
  protected
    FActor : TFhirReference{Resource};
    FroleList : TFhirCodeableConceptList;
    Procedure SetActor(value : TFhirReference{Resource});
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAgent; overload;
    function Clone : TFhirContractTermAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The agent assigned a role in this Contract Provision. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The agent assigned a role in this Contract Provision.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Role played by the agent assigned this role in the execution of this Contract Provision.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

  end;

  TFhirContractTermAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAgentList;
    function GetCurrent : TFhirContractTermAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAgent read GetCurrent;
  end;

  TFhirContractTermAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermAgent;
    procedure SetItemN(index : Integer; value : TFhirContractTermAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermAgentList; Overload;
    function Clone : TFhirContractTermAgentList; Overload;
    function GetEnumerator : TFhirContractTermAgentListEnumerator;

    //  Add a FhirContractTermAgent to the end of the list.
    function Append : TFhirContractTermAgent;

    // Add an already existing FhirContractTermAgent to the end of the list.
    procedure AddItem(value : TFhirContractTermAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAgent) : Integer;

    // Insert FhirContractTermAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAgent;

    // Insert an existing FhirContractTermAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAgent);

    // Get the iIndexth FhirContractTermAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTermAgents[index : Integer] : TFhirContractTermAgent read GetItemN write SetItemN; default;
  End;

  // Contract Provision Valued Item List.
  TFhirContractTermValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirMoney;
    Procedure SetEntity(value : TFhirType);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetEffectiveTime(value : TFhirDateTime);
    Function GetEffectiveTimeST : TFslDateTime;
    Procedure SetEffectiveTimeST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirMoney);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermValuedItem; overload;
    function Clone : TFhirContractTermValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specific type of Contract Provision Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirType read FEntity write SetEntity;
    // Specific type of Contract Provision Valued Item that may be priced.
    property entityElement : TFhirType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Provision Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Provision Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract Term ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract Term ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Provision Valued Item is measured or counted, and quantifies the countable or measurable Contract Term Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Provision Valued Item is measured or counted, and quantifies the countable or measurable Contract Term Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Provision Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // A Contract Provision Valued Item unit valuation measure.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Provision Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Provision Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Provision Valued Item delivered. The concept of Points allows for assignment of point values for a Contract ProvisionValued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Provision Valued Item delivered. The concept of Points allows for assignment of point values for a Contract ProvisionValued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Provision Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // Expresses the product of the Contract Provision Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

  end;

  TFhirContractTermValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermValuedItemList;
    function GetCurrent : TFhirContractTermValuedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermValuedItem read GetCurrent;
  end;

  TFhirContractTermValuedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractTermValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermValuedItemList; Overload;
    function Clone : TFhirContractTermValuedItemList; Overload;
    function GetEnumerator : TFhirContractTermValuedItemListEnumerator;

    //  Add a FhirContractTermValuedItem to the end of the list.
    function Append : TFhirContractTermValuedItem;

    // Add an already existing FhirContractTermValuedItem to the end of the list.
    procedure AddItem(value : TFhirContractTermValuedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermValuedItem) : Integer;

    // Insert FhirContractTermValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermValuedItem;

    // Insert an existing FhirContractTermValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermValuedItem);

    // Get the iIndexth FhirContractTermValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermValuedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermValuedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTermValuedItems[index : Integer] : TFhirContractTermValuedItem read GetItemN write SetItemN; default;
  End;

  // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
  TFhirContractFriendly = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractFriendly; overload;
    function Clone : TFhirContractFriendly; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractFriendlyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractFriendlyList;
    function GetCurrent : TFhirContractFriendly;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractFriendlyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractFriendly read GetCurrent;
  end;

  TFhirContractFriendlyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractFriendly;
    procedure SetItemN(index : Integer; value : TFhirContractFriendly);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractFriendlyList; Overload;
    function Clone : TFhirContractFriendlyList; Overload;
    function GetEnumerator : TFhirContractFriendlyListEnumerator;

    //  Add a FhirContractFriendly to the end of the list.
    function Append : TFhirContractFriendly;

    // Add an already existing FhirContractFriendly to the end of the list.
    procedure AddItem(value : TFhirContractFriendly); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractFriendly) : Integer;

    // Insert FhirContractFriendly before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractFriendly;

    // Insert an existing FhirContractFriendly before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractFriendly);

    // Get the iIndexth FhirContractFriendly. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractFriendly);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractFriendly;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractFriendlies[index : Integer] : TFhirContractFriendly read GetItemN write SetItemN; default;
  End;

  // List of Legal expressions or representations of this Contract.
  TFhirContractLegal = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractLegal; overload;
    function Clone : TFhirContractLegal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Contract legal text in human renderable form. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Contract legal text in human renderable form.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractLegalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractLegalList;
    function GetCurrent : TFhirContractLegal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractLegalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractLegal read GetCurrent;
  end;

  TFhirContractLegalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractLegal;
    procedure SetItemN(index : Integer; value : TFhirContractLegal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractLegalList; Overload;
    function Clone : TFhirContractLegalList; Overload;
    function GetEnumerator : TFhirContractLegalListEnumerator;

    //  Add a FhirContractLegal to the end of the list.
    function Append : TFhirContractLegal;

    // Add an already existing FhirContractLegal to the end of the list.
    procedure AddItem(value : TFhirContractLegal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractLegal) : Integer;

    // Insert FhirContractLegal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractLegal;

    // Insert an existing FhirContractLegal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractLegal);

    // Get the iIndexth FhirContractLegal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractLegal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractLegal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractLegals[index : Integer] : TFhirContractLegal read GetItemN write SetItemN; default;
  End;

  // List of Computable Policy Rule Language Representations of this Contract.
  TFhirContractRule = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractRule; overload;
    function Clone : TFhirContractRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractRuleList;
    function GetCurrent : TFhirContractRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractRule read GetCurrent;
  end;

  TFhirContractRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractRule;
    procedure SetItemN(index : Integer; value : TFhirContractRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractRuleList; Overload;
    function Clone : TFhirContractRuleList; Overload;
    function GetEnumerator : TFhirContractRuleListEnumerator;

    //  Add a FhirContractRule to the end of the list.
    function Append : TFhirContractRule;

    // Add an already existing FhirContractRule to the end of the list.
    procedure AddItem(value : TFhirContractRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractRule) : Integer;

    // Insert FhirContractRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractRule;

    // Insert an existing FhirContractRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractRule);

    // Get the iIndexth FhirContractRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractRules[index : Integer] : TFhirContractRule read GetItemN write SetItemN; default;
  End;

  // A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
  TFhirContract = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FsubjectList : TFhirReferenceList{TFhirReference};
    FtopicList : TFhirReferenceList{TFhirReference};
    FauthorityList : TFhirReferenceList{TFhirOrganization};
    FdomainList : TFhirReferenceList{TFhirLocation};
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FactionList : TFhirCodeableConceptList;
    FactionReasonList : TFhirCodeableConceptList;
    FDecisionType : TFhirCodeableConcept;
    FContentDerivative : TFhirCodeableConcept;
    FsecurityLabelList : TFhirCodingList;
    FagentList : TFhirContractAgentList;
    FsignerList : TFhirContractSignerList;
    FvaluedItemList : TFhirContractValuedItemList;
    FtermList : TFhirContractTermList;
    FBinding : TFhirType;
    FfriendlyList : TFhirContractFriendlyList;
    FlegalList : TFhirContractLegalList;
    FruleList : TFhirContractRuleList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirContractStatusEnum;
    Procedure SetStatusST(value : TFhirContractStatusEnum);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    function GetSubjectList : TFhirReferenceList{TFhirReference};
    function GetHasSubjectList : Boolean;
    function GetTopicList : TFhirReferenceList{TFhirReference};
    function GetHasTopicList : Boolean;
    function GetAuthorityList : TFhirReferenceList{TFhirOrganization};
    function GetHasAuthorityList : Boolean;
    function GetDomainList : TFhirReferenceList{TFhirLocation};
    function GetHasDomainList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetActionReasonList : TFhirCodeableConceptList;
    function GetHasActionReasonList : Boolean;
    Procedure SetDecisionType(value : TFhirCodeableConcept);
    Procedure SetContentDerivative(value : TFhirCodeableConcept);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetAgentList : TFhirContractAgentList;
    function GetHasAgentList : Boolean;
    function GetSignerList : TFhirContractSignerList;
    function GetHasSignerList : Boolean;
    function GetValuedItemList : TFhirContractValuedItemList;
    function GetHasValuedItemList : Boolean;
    function GetTermList : TFhirContractTermList;
    function GetHasTermList : Boolean;
    Procedure SetBinding(value : TFhirType);
    function GetFriendlyList : TFhirContractFriendlyList;
    function GetHasFriendlyList : Boolean;
    function GetLegalList : TFhirContractLegalList;
    function GetHasLegalList : Boolean;
    function GetRuleList : TFhirContractRuleList;
    function GetHasRuleList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContract; overload;
    function Clone : TFhirContract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for this Contract. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this Contract.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The status of the resource instance.
    property status : TFhirContractStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When this  Contract was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this  Contract was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // The target entity impacted by or of interest to parties to the agreement.
    property subjectList : TFhirReferenceList{TFhirReference} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // The matter of concern in the context of this agreement.
    property topicList : TFhirReferenceList{TFhirReference} read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
    property authorityList : TFhirReferenceList{TFhirOrganization} read GetAuthorityList;
    property hasAuthorityList : boolean read GetHasAuthorityList;

    // Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
    property domainList : TFhirReferenceList{TFhirLocation} read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // Typed access to Type of Contract such as an insurance policy, real estate contract, a will, power of attorny, Privacy or Security policy , trust framework agreement, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract such as an insurance policy, real estate contract, a will, power of attorny, Privacy or Security policy , trust framework agreement, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // More specific type or specialization of an overarching or more general contract such as auto insurance, home owner  insurance, prenupial agreement, Advanced-Directive, or privacy consent.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Action stipulated by this Contract.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Reason for action stipulated by this Contract.
    property actionReasonList : TFhirCodeableConceptList read GetActionReasonList;
    property hasActionReasonList : boolean read GetHasActionReasonList;

    // Typed access to The type of decision made by a grantor with respect to an offer made by a grantee. (defined for API consistency)
    property decisionType : TFhirCodeableConcept read FDecisionType write SetDecisionType;
    // The type of decision made by a grantor with respect to an offer made by a grantee.
    property decisionTypeElement : TFhirCodeableConcept read FDecisionType write SetDecisionType;

    // Typed access to The minimal content derived from the basal information source at a specific stage in its lifecycle. (defined for API consistency)
    property contentDerivative : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;
    // The minimal content derived from the basal information source at a specific stage in its lifecycle.
    property contentDerivativeElement : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;

    // A set of security labels that define which resources are controlled by this consent. If more than one label is specified, all resources must have all the specified labels.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirContractAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
    property signerList : TFhirContractSignerList read GetSignerList;
    property hasSignerList : boolean read GetHasSignerList;

    // Contract Valued Item List.
    property valuedItemList : TFhirContractValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

    // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
    property termList : TFhirContractTermList read GetTermList;
    property hasTermList : boolean read GetHasTermList;

    // Typed access to Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract. (defined for API consistency)
    property binding : TFhirType read FBinding write SetBinding;
    // Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
    property bindingElement : TFhirType read FBinding write SetBinding;

    // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
    property friendlyList : TFhirContractFriendlyList read GetFriendlyList;
    property hasFriendlyList : boolean read GetHasFriendlyList;

    // List of Legal expressions or representations of this Contract.
    property legalList : TFhirContractLegalList read GetLegalList;
    property hasLegalList : boolean read GetHasLegalList;

    // List of Computable Policy Rule Language Representations of this Contract.
    property ruleList : TFhirContractRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirContractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractList;
    function GetCurrent : TFhirContract;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContract read GetCurrent;
  end;

  TFhirContractList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContract;
    procedure SetItemN(index : Integer; value : TFhirContract);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractList; Overload;
    function Clone : TFhirContractList; Overload;
    function GetEnumerator : TFhirContractListEnumerator;

    //  Add a FhirContract to the end of the list.
    function Append : TFhirContract;

    // Add an already existing FhirContract to the end of the list.
    procedure AddItem(value : TFhirContract); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContract) : Integer;

    // Insert FhirContract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContract;

    // Insert an existing FhirContract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContract);

    // Get the iIndexth FhirContract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContract);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContract;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContracts[index : Integer] : TFhirContract read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_ELIGIBILITYREQUEST}

  // The EligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an EligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.
  TFhirEligibilityRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPriority : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FServiced : TFhirType;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FInsurer : TFhirReference{TFhirOrganization};
    FFacility : TFhirReference{TFhirLocation};
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FBenefitCategory : TFhirCodeableConcept;
    FBenefitSubCategory : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetServiced(value : TFhirType);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    Procedure SetBenefitCategory(value : TFhirCodeableConcept);
    Procedure SetBenefitSubCategory(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityRequest; overload;
    function Clone : TFhirEligibilityRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Immediate (STAT), best effort (NORMAL), deferred (DEFER). (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Immediate (STAT), best effort (NORMAL), deferred (DEFER).
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to Patient Resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient Resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Person who created the invoice/claim/pre-determination or pre-authorization. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Person who created the invoice/claim/pre-determination or pre-authorization.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who is target  of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Typed access to Financial instrument by which payment information for health care. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Financial instrument by which payment information for health care.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract number of a business agreement which describes the terms and conditions.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // The contract number of a business agreement which describes the terms and conditions.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to Dental, Vision, Medical, Pharmacy, Rehab etc. (defined for API consistency)
    property benefitCategory : TFhirCodeableConcept read FBenefitCategory write SetBenefitCategory;
    // Dental, Vision, Medical, Pharmacy, Rehab etc.
    property benefitCategoryElement : TFhirCodeableConcept read FBenefitCategory write SetBenefitCategory;

    // Typed access to Dental: basic, major, ortho; Vision exam, glasses, contacts; etc. (defined for API consistency)
    property benefitSubCategory : TFhirCodeableConcept read FBenefitSubCategory write SetBenefitSubCategory;
    // Dental: basic, major, ortho; Vision exam, glasses, contacts; etc.
    property benefitSubCategoryElement : TFhirCodeableConcept read FBenefitSubCategory write SetBenefitSubCategory;

  end;

  TFhirEligibilityRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityRequestList;
    function GetCurrent : TFhirEligibilityRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityRequest read GetCurrent;
  end;

  TFhirEligibilityRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityRequest;
    procedure SetItemN(index : Integer; value : TFhirEligibilityRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityRequestList; Overload;
    function Clone : TFhirEligibilityRequestList; Overload;
    function GetEnumerator : TFhirEligibilityRequestListEnumerator;

    //  Add a FhirEligibilityRequest to the end of the list.
    function Append : TFhirEligibilityRequest;

    // Add an already existing FhirEligibilityRequest to the end of the list.
    procedure AddItem(value : TFhirEligibilityRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityRequest) : Integer;

    // Insert FhirEligibilityRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityRequest;

    // Insert an existing FhirEligibilityRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityRequest);

    // Get the iIndexth FhirEligibilityRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityRequests[index : Integer] : TFhirEligibilityRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ELIGIBILITYREQUEST}

{$IFDEF FHIR_ELIGIBILITYRESPONSE}

  // The insurer may provide both the details for the requested coverage as well as details for additional coverages known to the insurer.
  TFhirEligibilityResponseInsurance = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference{TFhirCoverage};
    FContract : TFhirReference{TFhirContract};
    FbenefitBalanceList : TFhirEligibilityResponseInsuranceBenefitBalanceList;
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetContract(value : TFhirReference{TFhirContract});
    function GetBenefitBalanceList : TFhirEligibilityResponseInsuranceBenefitBalanceList;
    function GetHasBenefitBalanceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponseInsurance; overload;
    function Clone : TFhirEligibilityResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A suite of updated or additional Coverages from the Insurer. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // A suite of updated or additional Coverages from the Insurer.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract resource which may provide more detailed information. (defined for API consistency)
    property contract : TFhirReference{TFhirContract} read FContract write SetContract;
    // The contract resource which may provide more detailed information.
    property contractElement : TFhirReference{TFhirContract} read FContract write SetContract;

    // Benefits and optionally current balances by Category.
    property benefitBalanceList : TFhirEligibilityResponseInsuranceBenefitBalanceList read GetBenefitBalanceList;
    property hasBenefitBalanceList : boolean read GetHasBenefitBalanceList;

  end;

  TFhirEligibilityResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseInsuranceList;
    function GetCurrent : TFhirEligibilityResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponseInsurance read GetCurrent;
  end;

  TFhirEligibilityResponseInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseInsuranceList; Overload;
    function Clone : TFhirEligibilityResponseInsuranceList; Overload;
    function GetEnumerator : TFhirEligibilityResponseInsuranceListEnumerator;

    //  Add a FhirEligibilityResponseInsurance to the end of the list.
    function Append : TFhirEligibilityResponseInsurance;

    // Add an already existing FhirEligibilityResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponseInsurance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponseInsurance) : Integer;

    // Insert FhirEligibilityResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponseInsurance;

    // Insert an existing FhirEligibilityResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponseInsurance);

    // Get the iIndexth FhirEligibilityResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponseInsurance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponseInsurance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponseInsurances[index : Integer] : TFhirEligibilityResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Benefits and optionally current balances by Category.
  TFhirEligibilityResponseInsuranceBenefitBalance = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FSubCategory : TFhirCodeableConcept;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FfinancialList : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSubCategory(value : TFhirCodeableConcept);
    Procedure SetExcluded(value : TFhirBoolean);
    Function GetExcludedST : Boolean;
    Procedure SetExcludedST(value : Boolean);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNetwork(value : TFhirCodeableConcept);
    Procedure SetUnit_(value : TFhirCodeableConcept);
    Procedure SetTerm(value : TFhirCodeableConcept);
    function GetFinancialList : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
    function GetHasFinancialList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponseInsuranceBenefitBalance; overload;
    function Clone : TFhirEligibilityResponseInsuranceBenefitBalance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Dental, Vision, Medical, Pharmacy, Rehab etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Dental, Vision, Medical, Pharmacy, Rehab etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Dental: basic, major, ortho; Vision exam, glasses, contacts; etc. (defined for API consistency)
    property subCategory : TFhirCodeableConcept read FSubCategory write SetSubCategory;
    // Dental: basic, major, ortho; Vision exam, glasses, contacts; etc.
    property subCategoryElement : TFhirCodeableConcept read FSubCategory write SetSubCategory;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit, for example MED01, or DENT2.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit, for example MED01, or DENT2.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Network designation. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Network designation.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Unit designation: individual or family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Unit designation: individual or family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits Used to date.
    property financialList : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList read GetFinancialList;
    property hasFinancialList : boolean read GetHasFinancialList;

  end;

  TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseInsuranceBenefitBalanceList;
    function GetCurrent : TFhirEligibilityResponseInsuranceBenefitBalance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseInsuranceBenefitBalanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponseInsuranceBenefitBalance read GetCurrent;
  end;

  TFhirEligibilityResponseInsuranceBenefitBalanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalance;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseInsuranceBenefitBalanceList; Overload;
    function Clone : TFhirEligibilityResponseInsuranceBenefitBalanceList; Overload;
    function GetEnumerator : TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator;

    //  Add a FhirEligibilityResponseInsuranceBenefitBalance to the end of the list.
    function Append : TFhirEligibilityResponseInsuranceBenefitBalance;

    // Add an already existing FhirEligibilityResponseInsuranceBenefitBalance to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponseInsuranceBenefitBalance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponseInsuranceBenefitBalance) : Integer;

    // Insert FhirEligibilityResponseInsuranceBenefitBalance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalance;

    // Insert an existing FhirEligibilityResponseInsuranceBenefitBalance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalance);

    // Get the iIndexth FhirEligibilityResponseInsuranceBenefitBalance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponseInsuranceBenefitBalances[index : Integer] : TFhirEligibilityResponseInsuranceBenefitBalance read GetItemN write SetItemN; default;
  End;

  // Benefits Used to date.
  TFhirEligibilityResponseInsuranceBenefitBalanceFinancial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirType;
    FUsed : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAllowed(value : TFhirType);
    Procedure SetUsed(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; overload;
    function Clone : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Deductable, visits, benefit amount. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Deductable, visits, benefit amount.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Benefits allowed. (defined for API consistency)
    property allowed : TFhirType read FAllowed write SetAllowed;
    // Benefits allowed.
    property allowedElement : TFhirType read FAllowed write SetAllowed;

    // Typed access to Benefits used. (defined for API consistency)
    property used : TFhirType read FUsed write SetUsed;
    // Benefits used.
    property usedElement : TFhirType read FUsed write SetUsed;

  end;

  TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
    function GetCurrent : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial read GetCurrent;
  end;

  TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList; Overload;
    function Clone : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList; Overload;
    function GetEnumerator : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator;

    //  Add a FhirEligibilityResponseInsuranceBenefitBalanceFinancial to the end of the list.
    function Append : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;

    // Add an already existing FhirEligibilityResponseInsuranceBenefitBalanceFinancial to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial) : Integer;

    // Insert FhirEligibilityResponseInsuranceBenefitBalanceFinancial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;

    // Insert an existing FhirEligibilityResponseInsuranceBenefitBalanceFinancial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);

    // Get the iIndexth FhirEligibilityResponseInsuranceBenefitBalanceFinancial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponseInsuranceBenefitBalanceFinancials[index : Integer] : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial read GetItemN write SetItemN; default;
  End;

  // Mutually exclusive with Services Provided (Item).
  TFhirEligibilityResponseError = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    Procedure SetCode(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponseError; overload;
    function Clone : TFhirEligibilityResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An error code,from a specified code system, which details why the eligibility check could not be performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code,from a specified code system, which details why the eligibility check could not be performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirEligibilityResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseErrorList;
    function GetCurrent : TFhirEligibilityResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponseError read GetCurrent;
  end;

  TFhirEligibilityResponseErrorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponseError;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseErrorList; Overload;
    function Clone : TFhirEligibilityResponseErrorList; Overload;
    function GetEnumerator : TFhirEligibilityResponseErrorListEnumerator;

    //  Add a FhirEligibilityResponseError to the end of the list.
    function Append : TFhirEligibilityResponseError;

    // Add an already existing FhirEligibilityResponseError to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponseError); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponseError) : Integer;

    // Insert FhirEligibilityResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponseError;

    // Insert an existing FhirEligibilityResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponseError);

    // Get the iIndexth FhirEligibilityResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponseError);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponseError;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponseErrors[index : Integer] : TFhirEligibilityResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides eligibility and plan details from the processing of an Eligibility resource.
  TFhirEligibilityResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirEligibilityRequest};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FInsurer : TFhirReference{TFhirOrganization};
    FInforce : TFhirBoolean;
    FinsuranceList : TFhirEligibilityResponseInsuranceList;
    FForm : TFhirCodeableConcept;
    FerrorList : TFhirEligibilityResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirEligibilityRequest});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetInforce(value : TFhirBoolean);
    Function GetInforceST : Boolean;
    Procedure SetInforceST(value : Boolean);
    function GetInsuranceList : TFhirEligibilityResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetErrorList : TFhirEligibilityResponseErrorList;
    function GetHasErrorList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponse; overload;
    function Clone : TFhirEligibilityResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirEligibilityRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirEligibilityRequest} read FRequest write SetRequest;

    // Typed access to Transaction status: error, complete. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Transaction status: error, complete.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who produced this adjudicated response.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to Flag indicating if the coverage provided is inforce currently  if no service date(s) specified or for the whole duration of the service dates.
    property inforce : Boolean read GetInforceST write SetInforceST;
    // Flag indicating if the coverage provided is inforce currently  if no service date(s) specified or for the whole duration of the service dates.
    property inforceElement : TFhirBoolean read FInforce write SetInforce;

    // The insurer may provide both the details for the requested coverage as well as details for additional coverages known to the insurer.
    property insuranceList : TFhirEligibilityResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Mutually exclusive with Services Provided (Item).
    property errorList : TFhirEligibilityResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirEligibilityResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseList;
    function GetCurrent : TFhirEligibilityResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponse read GetCurrent;
  end;

  TFhirEligibilityResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponse;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseList; Overload;
    function Clone : TFhirEligibilityResponseList; Overload;
    function GetEnumerator : TFhirEligibilityResponseListEnumerator;

    //  Add a FhirEligibilityResponse to the end of the list.
    function Append : TFhirEligibilityResponse;

    // Add an already existing FhirEligibilityResponse to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponse) : Integer;

    // Insert FhirEligibilityResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponse;

    // Insert an existing FhirEligibilityResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponse);

    // Get the iIndexth FhirEligibilityResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponses[index : Integer] : TFhirEligibilityResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

  // This resource provides the insurance enrollment details to the insurer regarding a specified coverage.
  TFhirEnrollmentRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FSubject : TFhirReference{TFhirPatient};
    FCoverage : TFhirReference{TFhirCoverage};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentRequest; overload;
    function Clone : TFhirEnrollmentRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who is target  of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Patient Resource. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // Patient Resource.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

  end;

  TFhirEnrollmentRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentRequestList;
    function GetCurrent : TFhirEnrollmentRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentRequest read GetCurrent;
  end;

  TFhirEnrollmentRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentRequest;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentRequestList; Overload;
    function Clone : TFhirEnrollmentRequestList; Overload;
    function GetEnumerator : TFhirEnrollmentRequestListEnumerator;

    //  Add a FhirEnrollmentRequest to the end of the list.
    function Append : TFhirEnrollmentRequest;

    // Add an already existing FhirEnrollmentRequest to the end of the list.
    procedure AddItem(value : TFhirEnrollmentRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentRequest) : Integer;

    // Insert FhirEnrollmentRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentRequest;

    // Insert an existing FhirEnrollmentRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentRequest);

    // Get the iIndexth FhirEnrollmentRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEnrollmentRequests[index : Integer] : TFhirEnrollmentRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

  // This resource provides enrollment and plan details from the processing of an Enrollment resource.
  TFhirEnrollmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference{TFhirEnrollmentRequest};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentResponse; overload;
    function Clone : TFhirEnrollmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;

    // Typed access to Processing status: error, complete. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Processing status: error, complete.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

  end;

  TFhirEnrollmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentResponseList;
    function GetCurrent : TFhirEnrollmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentResponse read GetCurrent;
  end;

  TFhirEnrollmentResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentResponse;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentResponseList; Overload;
    function Clone : TFhirEnrollmentResponseList; Overload;
    function GetEnumerator : TFhirEnrollmentResponseListEnumerator;

    //  Add a FhirEnrollmentResponse to the end of the list.
    function Append : TFhirEnrollmentResponse;

    // Add an already existing FhirEnrollmentResponse to the end of the list.
    procedure AddItem(value : TFhirEnrollmentResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentResponse) : Integer;

    // Insert FhirEnrollmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentResponse;

    // Insert an existing FhirEnrollmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentResponse);

    // Get the iIndexth FhirEnrollmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEnrollmentResponses[index : Integer] : TFhirEnrollmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

  // Other claims which are related to this claim such as prior claim versions or for related services.
  TFhirExplanationOfBenefitRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference{TFhirClaim};
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirIdentifier);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitRelated; overload;
    function Clone : TFhirExplanationOfBenefitRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Other claims which are related to this claim such as prior claim versions or for related services. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // Other claims which are related to this claim such as prior claim versions or for related services.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to For example prior or umbrella. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // For example prior or umbrella.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # . (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains - eg Property/Casualy insurer claim # or Workers Compensation case # .
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirExplanationOfBenefitRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitRelatedList;
    function GetCurrent : TFhirExplanationOfBenefitRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitRelated read GetCurrent;
  end;

  TFhirExplanationOfBenefitRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitRelated;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitRelatedList; Overload;
    function Clone : TFhirExplanationOfBenefitRelatedList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;

    //  Add a FhirExplanationOfBenefitRelated to the end of the list.
    function Append : TFhirExplanationOfBenefitRelated;

    // Add an already existing FhirExplanationOfBenefitRelated to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitRelated) : Integer;

    // Insert FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitRelated;

    // Insert an existing FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitRelated);

    // Get the iIndexth FhirExplanationOfBenefitRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitRelateds[index : Integer] : TFhirExplanationOfBenefitRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for the services.
  TFhirExplanationOfBenefitPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FResourceType : TFhirCodeableConcept;
    FParty : TFhirReference{Resource};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetResourceType(value : TFhirCodeableConcept);
    Procedure SetParty(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayee; overload;
    function Clone : TFhirExplanationOfBenefitPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to organization | patient | practitioner | relatedperson. (defined for API consistency)
    property resourceType : TFhirCodeableConcept read FResourceType write SetResourceType;
    // organization | patient | practitioner | relatedperson.
    property resourceTypeElement : TFhirCodeableConcept read FResourceType write SetResourceType;

    // Typed access to Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Party to be reimbursed: Subscriber, provider, other.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

  end;

  TFhirExplanationOfBenefitPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPayeeList;
    function GetCurrent : TFhirExplanationOfBenefitPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayee read GetCurrent;
  end;

  TFhirExplanationOfBenefitPayeeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayee;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitPayeeList; Overload;
    function Clone : TFhirExplanationOfBenefitPayeeList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;

    //  Add a FhirExplanationOfBenefitPayee to the end of the list.
    function Append : TFhirExplanationOfBenefitPayee;

    // Add an already existing FhirExplanationOfBenefitPayee to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayee); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayee) : Integer;

    // Insert FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayee;

    // Insert an existing FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayee);

    // Get the iIndexth FhirExplanationOfBenefitPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayee);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayee;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitPayees[index : Integer] : TFhirExplanationOfBenefitPayee read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
  TFhirExplanationOfBenefitInformation = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FValue : TFhirType;
    FReason : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetValue(value : TFhirType);
    Procedure SetReason(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitInformation; overload;
    function Clone : TFhirExplanationOfBenefitInformation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of the information element which serves to provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of the information element which serves to provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought which may influence the adjudication. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought which may influence the adjudication.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCoding read FReason write SetReason;
    // For example, provides the reason for: the additional stay, or missing tooth or any other situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCoding read FReason write SetReason;

  end;

  TFhirExplanationOfBenefitInformationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitInformationList;
    function GetCurrent : TFhirExplanationOfBenefitInformation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitInformationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitInformation read GetCurrent;
  end;

  TFhirExplanationOfBenefitInformationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitInformation;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitInformation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitInformationList; Overload;
    function Clone : TFhirExplanationOfBenefitInformationList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitInformationListEnumerator;

    //  Add a FhirExplanationOfBenefitInformation to the end of the list.
    function Append : TFhirExplanationOfBenefitInformation;

    // Add an already existing FhirExplanationOfBenefitInformation to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitInformation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitInformation) : Integer;

    // Insert FhirExplanationOfBenefitInformation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitInformation;

    // Insert an existing FhirExplanationOfBenefitInformation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitInformation);

    // Get the iIndexth FhirExplanationOfBenefitInformation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitInformation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitInformation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitInformations[index : Integer] : TFhirExplanationOfBenefitInformation read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
  TFhirExplanationOfBenefitCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference{Resource};
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetProvider(value : TFhirReference{Resource});
    Procedure SetResponsible(value : TFhirBoolean);
    Function GetResponsibleST : Boolean;
    Procedure SetResponsibleST(value : Boolean);
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetQualification(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitCareTeam; overload;
    function Clone : TFhirExplanationOfBenefitCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of careteam which serves to order and provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of careteam which serves to order and provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The members of the team who provided the overall service. (defined for API consistency)
    property provider : TFhirReference{Resource} read FProvider write SetProvider;
    // The members of the team who provided the overall service.
    property providerElement : TFhirReference{Resource} read FProvider write SetProvider;

    // Typed access to The practitioner who is billing and responsible for the claimed services rendered to the patient.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The practitioner who is billing and responsible for the claimed services rendered to the patient.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisiplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirExplanationOfBenefitCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitCareTeamList;
    function GetCurrent : TFhirExplanationOfBenefitCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitCareTeam read GetCurrent;
  end;

  TFhirExplanationOfBenefitCareTeamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitCareTeamList; Overload;
    function Clone : TFhirExplanationOfBenefitCareTeamList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;

    //  Add a FhirExplanationOfBenefitCareTeam to the end of the list.
    function Append : TFhirExplanationOfBenefitCareTeam;

    // Add an already existing FhirExplanationOfBenefitCareTeam to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitCareTeam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitCareTeam) : Integer;

    // Insert FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitCareTeam;

    // Insert an existing FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitCareTeam);

    // Get the iIndexth FhirExplanationOfBenefitCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitCareTeam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitCareTeam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitCareTeams[index : Integer] : TFhirExplanationOfBenefitCareTeam read GetItemN write SetItemN; default;
  End;

  // Ordered list of patient diagnosis for which care is sought.
  TFhirExplanationOfBenefitDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirType;
    Ftype_List : TFhirCodeableConceptList;
    FPackageCode : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDiagnosis(value : TFhirType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetPackageCode(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitDiagnosis; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of diagnosis which serves to provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of diagnosis which serves to provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The diagnosis. (defined for API consistency)
    property diagnosis : TFhirType read FDiagnosis write SetDiagnosis;
    // The diagnosis.
    property diagnosisElement : TFhirType read FDiagnosis write SetDiagnosis;

    // The type of the Diagnosis, for example: admitting, primary, secondary, discharge.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The package billing code, for example DRG, based on the assigned grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // The package billing code, for example DRG, based on the assigned grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirExplanationOfBenefitDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitDiagnosisList;
    function GetCurrent : TFhirExplanationOfBenefitDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitDiagnosis read GetCurrent;
  end;

  TFhirExplanationOfBenefitDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitDiagnosisList; Overload;
    function Clone : TFhirExplanationOfBenefitDiagnosisList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;

    //  Add a FhirExplanationOfBenefitDiagnosis to the end of the list.
    function Append : TFhirExplanationOfBenefitDiagnosis;

    // Add an already existing FhirExplanationOfBenefitDiagnosis to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitDiagnosis); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitDiagnosis) : Integer;

    // Insert FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitDiagnosis;

    // Insert an existing FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);

    // Get the iIndexth FhirExplanationOfBenefitDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitDiagnosis;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitDiagnoses[index : Integer] : TFhirExplanationOfBenefitDiagnosis read GetItemN write SetItemN; default;
  End;

  // Ordered list of patient procedures performed to support the adjudication.
  TFhirExplanationOfBenefitProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirType;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetProcedure_(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcedure; overload;
    function Clone : TFhirExplanationOfBenefitProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence of procedures which serves to order and provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of procedures which serves to order and provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Date and optionally time the procedure was performed .
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed .
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The procedure code. (defined for API consistency)
    property procedure_ : TFhirType read FProcedure_ write SetProcedure_;
    // The procedure code.
    property procedure_Element : TFhirType read FProcedure_ write SetProcedure_;

  end;

  TFhirExplanationOfBenefitProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcedureList;
    function GetCurrent : TFhirExplanationOfBenefitProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcedure read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcedure;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitProcedureList; Overload;
    function Clone : TFhirExplanationOfBenefitProcedureList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;

    //  Add a FhirExplanationOfBenefitProcedure to the end of the list.
    function Append : TFhirExplanationOfBenefitProcedure;

    // Add an already existing FhirExplanationOfBenefitProcedure to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcedure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcedure) : Integer;

    // Insert FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcedure;

    // Insert an existing FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcedure);

    // Get the iIndexth FhirExplanationOfBenefitProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcedure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcedure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitProcedures[index : Integer] : TFhirExplanationOfBenefitProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instrument by which payment information for health care.
  TFhirExplanationOfBenefitInsurance = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference{TFhirCoverage};
    FpreAuthRefList : TFhirStringList;
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitInsurance; overload;
    function Clone : TFhirExplanationOfBenefitInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // A list of references from the Insurer to which these services pertain.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

  end;

  TFhirExplanationOfBenefitInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitInsuranceList;
    function GetCurrent : TFhirExplanationOfBenefitInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitInsurance read GetCurrent;
  end;

  TFhirExplanationOfBenefitInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitInsurance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitInsuranceList; Overload;
    function Clone : TFhirExplanationOfBenefitInsuranceList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;

    //  Add a FhirExplanationOfBenefitInsurance to the end of the list.
    function Append : TFhirExplanationOfBenefitInsurance;

    // Add an already existing FhirExplanationOfBenefitInsurance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitInsurance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitInsurance) : Integer;

    // Insert FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitInsurance;

    // Insert an existing FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitInsurance);

    // Get the iIndexth FhirExplanationOfBenefitInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitInsurance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitInsurance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitInsurances[index : Integer] : TFhirExplanationOfBenefitInsurance read GetItemN write SetItemN; default;
  End;

  // An accident which resulted in the need for healthcare services.
  TFhirExplanationOfBenefitAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirType;
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAccident; overload;
    function Clone : TFhirExplanationOfBenefitAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date of an accident which these services are addressing.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident which these services are addressing.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Type of accident: work, auto, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of accident: work, auto, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Where the accident occurred. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the accident occurred.
    property locationElement : TFhirType read FLocation write SetLocation;

  end;

  TFhirExplanationOfBenefitAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAccidentList;
    function GetCurrent : TFhirExplanationOfBenefitAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAccident read GetCurrent;
  end;

  TFhirExplanationOfBenefitAccidentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAccident;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAccidentList; Overload;
    function Clone : TFhirExplanationOfBenefitAccidentList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;

    //  Add a FhirExplanationOfBenefitAccident to the end of the list.
    function Append : TFhirExplanationOfBenefitAccident;

    // Add an already existing FhirExplanationOfBenefitAccident to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAccident); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAccident) : Integer;

    // Insert FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAccident;

    // Insert an existing FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAccident);

    // Get the iIndexth FhirExplanationOfBenefitAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAccident);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAccident;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitAccidents[index : Integer] : TFhirExplanationOfBenefitAccident read GetItemN write SetItemN; default;
  End;

  // First tier of goods and services.
  TFhirExplanationOfBenefitItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamLinkIdList : TFhirPositiveIntList;
    FdiagnosisLinkIdList : TFhirPositiveIntList;
    FprocedureLinkIdList : TFhirPositiveIntList;
    FinformationLinkIdList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList{TFhirEncounter};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitItemDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetCareTeamLinkIdList : TFhirPositiveIntList;
    function GetHasCareTeamLinkIdList : Boolean;
    function GetDiagnosisLinkIdList : TFhirPositiveIntList;
    function GetHasDiagnosisLinkIdList : Boolean;
    function GetProcedureLinkIdList : TFhirPositiveIntList;
    function GetHasProcedureLinkIdList : Boolean;
    function GetInformationLinkIdList : TFhirPositiveIntList;
    function GetHasInformationLinkIdList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList{TFhirEncounter};
    function GetHasEncounterList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItem; overload;
    function Clone : TFhirExplanationOfBenefitItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Careteam applicable for this service or product line.
    property careTeamLinkIdList : TFhirPositiveIntList read GetCareTeamLinkIdList;
    property hasCareTeamLinkIdList : boolean read GetHasCareTeamLinkIdList;

    // Diagnosis applicable for this service or product line.
    property diagnosisLinkIdList : TFhirPositiveIntList read GetDiagnosisLinkIdList;
    property hasDiagnosisLinkIdList : boolean read GetHasDiagnosisLinkIdList;

    // Procedures applicable for this service or product line.
    property procedureLinkIdList : TFhirPositiveIntList read GetProcedureLinkIdList;
    property hasProcedureLinkIdList : boolean read GetHasProcedureLinkIdList;

    // Exceptions, special conditions and supporting information pplicable for this service or product line.
    property informationLinkIdList : TFhirPositiveIntList read GetInformationLinkIdList;
    property hasInformationLinkIdList : boolean read GetHasInformationLinkIdList;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the site, eg. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // A billed item may include goods or services provided in multiple encounters.
    property encounterList : TFhirReferenceList{TFhirEncounter} read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Second tier of goods and services.
    property detailList : TFhirExplanationOfBenefitItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemList;
    function GetCurrent : TFhirExplanationOfBenefitItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemList; Overload;
    function Clone : TFhirExplanationOfBenefitItemList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;

    //  Add a FhirExplanationOfBenefitItem to the end of the list.
    function Append : TFhirExplanationOfBenefitItem;

    // Add an already existing FhirExplanationOfBenefitItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItem) : Integer;

    // Insert FhirExplanationOfBenefitItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItem;

    // Insert an existing FhirExplanationOfBenefitItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItem);

    // Get the iIndexth FhirExplanationOfBenefitItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitItems[index : Integer] : TFhirExplanationOfBenefitItem read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirExplanationOfBenefitItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemAdjudication; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code indicating: Co-Pay, deductable, elegible, benefit, tax, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Adjudication reason such as limit reached. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Adjudication reason such as limit reached.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monitory amount associated with the code. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monitory amount associated with the code.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirExplanationOfBenefitItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemAdjudication read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemAdjudicationList; Overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudicationList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;

    //  Add a FhirExplanationOfBenefitItemAdjudication to the end of the list.
    function Append : TFhirExplanationOfBenefitItemAdjudication;

    // Add an already existing FhirExplanationOfBenefitItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemAdjudication) : Integer;

    // Insert FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;

    // Insert an existing FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);

    // Get the iIndexth FhirExplanationOfBenefitItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitItemAdjudications[index : Integer] : TFhirExplanationOfBenefitItemAdjudication read GetItemN write SetItemN; default;
  End;

  // Second tier of goods and services.
  TFhirExplanationOfBenefitItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FType_ : TFhirCodeableConcept;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of product or service. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of product or service.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Third tier of goods and services.
    property subDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitItemDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;

    //  Add a FhirExplanationOfBenefitItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetail;

    // Add an already existing FhirExplanationOfBenefitItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetail) : Integer;

    // Insert FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetail;

    // Insert an existing FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetail);

    // Get the iIndexth FhirExplanationOfBenefitItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitItemDetails[index : Integer] : TFhirExplanationOfBenefitItemDetail read GetItemN write SetItemN; default;
  End;

  // Third tier of goods and services.
  TFhirExplanationOfBenefitItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FType_ : TFhirCodeableConcept;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of product or service. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of product or service.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // For programs which require reson codes for the inclusion, covering, of this billed item under the program or sub-program.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The fee for an addittional service or product or charge. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // The fee for an addittional service or product or charge.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an addittional service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // List of Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemDetailSubDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;

    //  Add a FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetailSubDetail;

    // Add an already existing FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetailSubDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetailSubDetail) : Integer;

    // Insert FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;

    // Insert an existing FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);

    // Get the iIndexth FhirExplanationOfBenefitItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItem = class (TFhirBackboneElement)
  protected
    FsequenceLinkIdList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FFee : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetSequenceLinkIdList : TFhirPositiveIntList;
    function GetHasSequenceLinkIdList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetFee(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItem; overload;
    function Clone : TFhirExplanationOfBenefitAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // List of input service items which this service line is intended to replace.
    property sequenceLinkIdList : TFhirPositiveIntList read GetSequenceLinkIdList;
    property hasSequenceLinkIdList : boolean read GetHasSequenceLinkIdList;

    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'. (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // If this is an actual service or product line, ie. not a Group, then use code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). If a grouping item then use a group code to indicate the type of thing being grouped eg. 'glasses' or 'compound'.
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The fee charged for the professional service or product. (defined for API consistency)
    property fee : TFhirMoney read FFee write SetFee;
    // The fee charged for the professional service or product.
    property feeElement : TFhirMoney read FFee write SetFee;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second tier service adjudications for payor added services.
    property detailList : TFhirExplanationOfBenefitAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemList;
    function GetCurrent : TFhirExplanationOfBenefitAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAddItemList; Overload;
    function Clone : TFhirExplanationOfBenefitAddItemList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;

    //  Add a FhirExplanationOfBenefitAddItem to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItem;

    // Add an already existing FhirExplanationOfBenefitAddItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItem) : Integer;

    // Insert FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItem;

    // Insert an existing FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItem);

    // Get the iIndexth FhirExplanationOfBenefitAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitAddItems[index : Integer] : TFhirExplanationOfBenefitAddItem read GetItemN write SetItemN; default;
  End;

  // The second tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetail = class (TFhirBackboneElement)
  protected
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FFee : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetFee(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of reveneu or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of reveneu or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Health Care Service Type Codes  to identify the classification of service or benefits. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Health Care Service Type Codes  to identify the classification of service or benefits.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI). (defined for API consistency)
    property service : TFhirCodeableConcept read FService write SetService;
    // A code to indicate the Professional Service or Product supplied (eg. CTP, HCPCS,USCLS,ICD10, NCPDP,DIN,ACHI,CCI).
    property serviceElement : TFhirCodeableConcept read FService write SetService;

    // Item typification or modifiers codes, eg for Oral whether the treatment is cosmetic or associated with TMJ, or for medical whether the treatment was outside the clinic or out of office hours.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The fee charged for the professional service or product. (defined for API consistency)
    property fee : TFhirMoney read FFee write SetFee;
    // The fee charged for the professional service or product.
    property feeElement : TFhirMoney read FFee write SetFee;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAddItemDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;

    //  Add a FhirExplanationOfBenefitAddItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetail;

    // Add an already existing FhirExplanationOfBenefitAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetail) : Integer;

    // Insert FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;

    // Insert an existing FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);

    // Get the iIndexth FhirExplanationOfBenefitAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitAddItemDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetail read GetItemN write SetItemN; default;
  End;

  // Payment details for the claim if the claim has been paid.
  TFhirExplanationOfBenefitPayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAdjustment(value : TFhirMoney);
    Procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetIdentifier(value : TFhirIdentifier);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayment; overload;
    function Clone : TFhirExplanationOfBenefitPayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the claim. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the claim.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Adjustment to the payment of this transaction which is not related to adjudication of this transaction. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated payment date.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated payment date.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Payment identifer. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Payment identifer.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirExplanationOfBenefitPaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPaymentList;
    function GetCurrent : TFhirExplanationOfBenefitPayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayment read GetCurrent;
  end;

  TFhirExplanationOfBenefitPaymentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayment;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitPaymentList; Overload;
    function Clone : TFhirExplanationOfBenefitPaymentList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;

    //  Add a FhirExplanationOfBenefitPayment to the end of the list.
    function Append : TFhirExplanationOfBenefitPayment;

    // Add an already existing FhirExplanationOfBenefitPayment to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayment) : Integer;

    // Insert FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayment;

    // Insert an existing FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayment);

    // Get the iIndexth FhirExplanationOfBenefitPayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitPayments[index : Integer] : TFhirExplanationOfBenefitPayment read GetItemN write SetItemN; default;
  End;

  // Note text.
  TFhirExplanationOfBenefitProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirCodeableConcept;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    Procedure SetNumber(value : TFhirPositiveInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetLanguage(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcessNote; overload;
    function Clone : TFhirExplanationOfBenefitProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An integer associated with each note which may be referred to from each service line item.
    property number : String read GetNumberST write SetNumberST;
    // An integer associated with each note which may be referred to from each service line item.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirExplanationOfBenefitProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcessNoteList;
    function GetCurrent : TFhirExplanationOfBenefitProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcessNote read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitProcessNoteList; Overload;
    function Clone : TFhirExplanationOfBenefitProcessNoteList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;

    //  Add a FhirExplanationOfBenefitProcessNote to the end of the list.
    function Append : TFhirExplanationOfBenefitProcessNote;

    // Add an already existing FhirExplanationOfBenefitProcessNote to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcessNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcessNote) : Integer;

    // Insert FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcessNote;

    // Insert an existing FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcessNote);

    // Get the iIndexth FhirExplanationOfBenefitProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcessNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcessNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitProcessNotes[index : Integer] : TFhirExplanationOfBenefitProcessNote read GetItemN write SetItemN; default;
  End;

  // Balance by Benefit Category.
  TFhirExplanationOfBenefitBenefitBalance = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FSubCategory : TFhirCodeableConcept;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FfinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSubCategory(value : TFhirCodeableConcept);
    Procedure SetExcluded(value : TFhirBoolean);
    Function GetExcludedST : Boolean;
    Procedure SetExcludedST(value : Boolean);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNetwork(value : TFhirCodeableConcept);
    Procedure SetUnit_(value : TFhirCodeableConcept);
    Procedure SetTerm(value : TFhirCodeableConcept);
    function GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetHasFinancialList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalance; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Dental, Vision, Medical, Pharmacy, Rehab etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Dental, Vision, Medical, Pharmacy, Rehab etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Dental: basic, major, ortho; Vision exam, glasses, contacts; etc. (defined for API consistency)
    property subCategory : TFhirCodeableConcept read FSubCategory write SetSubCategory;
    // Dental: basic, major, ortho; Vision exam, glasses, contacts; etc.
    property subCategoryElement : TFhirCodeableConcept read FSubCategory write SetSubCategory;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicated the service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit, for example MED01, or DENT2.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit, for example MED01, or DENT2.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit, for example 'DENT2 covers 100% of basic, 50% of major but exclused Ortho, Implants and Costmetic services'.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Network designation. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Network designation.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Unit designation: individual or family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Unit designation: individual or family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual vistis'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits Used to date.
    property financialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList read GetFinancialList;
    property hasFinancialList : boolean read GetHasFinancialList;

  end;

  TFhirExplanationOfBenefitBenefitBalanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalance read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitBenefitBalanceList; Overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;

    //  Add a FhirExplanationOfBenefitBenefitBalance to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalance;

    // Add an already existing FhirExplanationOfBenefitBenefitBalance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalance) : Integer;

    // Insert FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;

    // Insert an existing FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);

    // Get the iIndexth FhirExplanationOfBenefitBenefitBalance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitBenefitBalances[index : Integer] : TFhirExplanationOfBenefitBenefitBalance read GetItemN write SetItemN; default;
  End;

  // Benefits Used to date.
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirType;
    FUsed : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAllowed(value : TFhirType);
    Procedure SetUsed(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Deductable, visits, benefit amount. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Deductable, visits, benefit amount.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Benefits allowed. (defined for API consistency)
    property allowed : TFhirType read FAllowed write SetAllowed;
    // Benefits allowed.
    property allowedElement : TFhirType read FAllowed write SetAllowed;

    // Typed access to Benefits used. (defined for API consistency)
    property used : TFhirType read FUsed write SetUsed;
    // Benefits used.
    property usedElement : TFhirType read FUsed write SetUsed;

  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancialList; Overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancialList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;

    //  Add a FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalanceFinancial;

    // Add an already existing FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalanceFinancial) : Integer;

    // Insert FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;

    // Insert an existing FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);

    // Get the iIndexth FhirExplanationOfBenefitBenefitBalanceFinancial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefitBenefitBalanceFinancials[index : Integer] : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetItemN write SetItemN; default;
  End;

  // This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
  TFhirExplanationOfBenefit = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FPatient : TFhirReference{TFhirPatient};
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FReferral : TFhirReference{TFhirReferralRequest};
    FFacility : TFhirReference{TFhirLocation};
    FClaim : TFhirReference{TFhirClaim};
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FrelatedList : TFhirExplanationOfBenefitRelatedList;
    FPrescription : TFhirReference{Resource};
    FOriginalPrescription : TFhirReference{TFhirMedicationRequest};
    FPayee : TFhirExplanationOfBenefitPayee;
    FinformationList : TFhirExplanationOfBenefitInformationList;
    FcareTeamList : TFhirExplanationOfBenefitCareTeamList;
    FdiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    Fprocedure_List : TFhirExplanationOfBenefitProcedureList;
    FPrecedence : TFhirPositiveInt;
    FInsurance : TFhirExplanationOfBenefitInsurance;
    FAccident : TFhirExplanationOfBenefitAccident;
    FEmploymentImpacted : TFhirPeriod;
    FHospitalization : TFhirPeriod;
    FitemList : TFhirExplanationOfBenefitItemList;
    FaddItemList : TFhirExplanationOfBenefitAddItemList;
    FTotalCost : TFhirMoney;
    FUnallocDeductable : TFhirMoney;
    FTotalBenefit : TFhirMoney;
    FPayment : TFhirExplanationOfBenefitPayment;
    FForm : TFhirCodeableConcept;
    FprocessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    FbenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirExplanationofbenefitStatusEnum;
    Procedure SetStatusST(value : TFhirExplanationofbenefitStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetBillablePeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetReferral(value : TFhirReference{TFhirReferralRequest});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    function GetRelatedList : TFhirExplanationOfBenefitRelatedList;
    function GetHasRelatedList : Boolean;
    Procedure SetPrescription(value : TFhirReference{Resource});
    Procedure SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
    Procedure SetPayee(value : TFhirExplanationOfBenefitPayee);
    function GetInformationList : TFhirExplanationOfBenefitInformationList;
    function GetHasInformationList : Boolean;
    function GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
    function GetHasProcedure_List : Boolean;
    Procedure SetPrecedence(value : TFhirPositiveInt);
    Function GetPrecedenceST : String;
    Procedure SetPrecedenceST(value : String);
    Procedure SetInsurance(value : TFhirExplanationOfBenefitInsurance);
    Procedure SetAccident(value : TFhirExplanationOfBenefitAccident);
    Procedure SetEmploymentImpacted(value : TFhirPeriod);
    Procedure SetHospitalization(value : TFhirPeriod);
    function GetItemList : TFhirExplanationOfBenefitItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirExplanationOfBenefitAddItemList;
    function GetHasAddItemList : Boolean;
    Procedure SetTotalCost(value : TFhirMoney);
    Procedure SetUnallocDeductable(value : TFhirMoney);
    Procedure SetTotalBenefit(value : TFhirMoney);
    Procedure SetPayment(value : TFhirExplanationOfBenefitPayment);
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetHasBenefitBalanceList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefit; overload;
    function Clone : TFhirExplanationOfBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The EOB Business Identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirExplanationofbenefitStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, eg, oral, pharmacy, vision, insitutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, eg, oral, pharmacy, vision, insitutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A finer grained suite of claim subtype codes which may convey Inpatient vs Outpatient and/or a specialty service. In the US the BillType.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Typed access to Patient Resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient Resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The billable period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The billable period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date when the EOB was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the EOB was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The person who created the explanation of benefit. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // The person who created the explanation of benefit.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The insurer which is responsible for the explanation of benefit. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The insurer which is responsible for the explanation of benefit.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the claim.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The provider which is responsible for the claim. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The provider which is responsible for the claim.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The referral resource which lists the date, practitioner, reason and other supporting information. (defined for API consistency)
    property referral : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;
    // The referral resource which lists the date, practitioner, reason and other supporting information.
    property referralElement : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Typed access to The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

    // Typed access to Processing outcome errror, partial or complete processing. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Processing outcome errror, partial or complete processing.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Other claims which are related to this claim such as prior claim versions or for related services.
    property relatedList : TFhirExplanationOfBenefitRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of Pharmacy or Vision products. (defined for API consistency)
    property prescription : TFhirReference{Resource} read FPrescription write SetPrescription;
    // Prescription to support the dispensing of Pharmacy or Vision products.
    property prescriptionElement : TFhirReference{Resource} read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superceded by this prescription to support the dispensing of pharmacy services, medications or products. For example, a physician may prescribe a medication which the pharmacy determines is contraindicated, or for which the patient has an intolerance, and therefor issues a new precription for an alternate medication which has the same theraputic intent. The prescription from the pharmacy becomes the 'prescription' and that from the physician becomes the 'original prescription'. (defined for API consistency)
    property originalPrescription : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superceded by this prescription to support the dispensing of pharmacy services, medications or products. For example, a physician may prescribe a medication which the pharmacy determines is contraindicated, or for which the patient has an intolerance, and therefor issues a new precription for an alternate medication which has the same theraputic intent. The prescription from the pharmacy becomes the 'prescription' and that from the physician becomes the 'original prescription'.
    property originalPrescriptionElement : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for the services. (defined for API consistency)
    property payee : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;
    // The party to be reimbursed for the services.
    property payeeElement : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues. Often there are mutiple jurisdiction specific valuesets which are required.
    property informationList : TFhirExplanationOfBenefitInformationList read GetInformationList;
    property hasInformationList : boolean read GetHasInformationList;

    // The members of the team who provided the overall service as well as their role and whether responsible and qualifications.
    property careTeamList : TFhirExplanationOfBenefitCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Ordered list of patient diagnosis for which care is sought.
    property diagnosisList : TFhirExplanationOfBenefitDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Ordered list of patient procedures performed to support the adjudication.
    property procedure_List : TFhirExplanationOfBenefitProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to Precedence (primary, secondary, etc.).
    property precedence : String read GetPrecedenceST write SetPrecedenceST;
    // Precedence (primary, secondary, etc.).
    property precedenceElement : TFhirPositiveInt read FPrecedence write SetPrecedence;

    // Typed access to Financial instrument by which payment information for health care. (defined for API consistency)
    property insurance : TFhirExplanationOfBenefitInsurance read FInsurance write SetInsurance;
    // Financial instrument by which payment information for health care.
    property insuranceElement : TFhirExplanationOfBenefitInsurance read FInsurance write SetInsurance;

    // Typed access to An accident which resulted in the need for healthcare services. (defined for API consistency)
    property accident : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;
    // An accident which resulted in the need for healthcare services.
    property accidentElement : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;

    // Typed access to The start and optional end dates of when the patient was precluded from working due to the treatable condition(s). (defined for API consistency)
    property employmentImpacted : TFhirPeriod read FEmploymentImpacted write SetEmploymentImpacted;
    // The start and optional end dates of when the patient was precluded from working due to the treatable condition(s).
    property employmentImpactedElement : TFhirPeriod read FEmploymentImpacted write SetEmploymentImpacted;

    // Typed access to The start and optional end dates of when the patient was confined to a treatment center. (defined for API consistency)
    property hospitalization : TFhirPeriod read FHospitalization write SetHospitalization;
    // The start and optional end dates of when the patient was confined to a treatment center.
    property hospitalizationElement : TFhirPeriod read FHospitalization write SetHospitalization;

    // First tier of goods and services.
    property itemList : TFhirExplanationOfBenefitItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first tier service adjudications for payor added services.
    property addItemList : TFhirExplanationOfBenefitAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // Typed access to The total cost of the services reported. (defined for API consistency)
    property totalCost : TFhirMoney read FTotalCost write SetTotalCost;
    // The total cost of the services reported.
    property totalCostElement : TFhirMoney read FTotalCost write SetTotalCost;

    // Typed access to The amount of deductable applied which was not allocated to any particular service line. (defined for API consistency)
    property unallocDeductable : TFhirMoney read FUnallocDeductable write SetUnallocDeductable;
    // The amount of deductable applied which was not allocated to any particular service line.
    property unallocDeductableElement : TFhirMoney read FUnallocDeductable write SetUnallocDeductable;

    // Typed access to Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductable). (defined for API consistency)
    property totalBenefit : TFhirMoney read FTotalBenefit write SetTotalBenefit;
    // Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductable).
    property totalBenefitElement : TFhirMoney read FTotalBenefit write SetTotalBenefit;

    // Typed access to Payment details for the claim if the claim has been paid. (defined for API consistency)
    property payment : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;
    // Payment details for the claim if the claim has been paid.
    property paymentElement : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Note text.
    property processNoteList : TFhirExplanationOfBenefitProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Balance by Benefit Category.
    property benefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList read GetBenefitBalanceList;
    property hasBenefitBalanceList : boolean read GetHasBenefitBalanceList;

  end;

  TFhirExplanationOfBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitList;
    function GetCurrent : TFhirExplanationOfBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefit read GetCurrent;
  end;

  TFhirExplanationOfBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefit;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitList; Overload;
    function Clone : TFhirExplanationOfBenefitList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitListEnumerator;

    //  Add a FhirExplanationOfBenefit to the end of the list.
    function Append : TFhirExplanationOfBenefit;

    // Add an already existing FhirExplanationOfBenefit to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefit); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefit) : Integer;

    // Insert FhirExplanationOfBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefit;

    // Insert an existing FhirExplanationOfBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefit);

    // Get the iIndexth FhirExplanationOfBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefit);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefit;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefits[index : Integer] : TFhirExplanationOfBenefit read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_GUIDANCERESPONSE}

  // A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.
  TFhirGuidanceResponse = class (TFhirDomainResource)
  protected
    FRequestId : TFhirId;
    FIdentifier : TFhirIdentifier;
    FModule : TFhirReference{TFhirServiceDefinition};
    FStatus : TFhirEnum;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrenceDateTime : TFhirDateTime;
    FPerformer : TFhirReference{TFhirDevice};
    FReason : TFhirType;
    FnoteList : TFhirAnnotationList;
    FevaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
    FOutputParameters : TFhirReference{TFhirParameters};
    FResult : TFhirReference{Resource};
    FdataRequirementList : TFhirDataRequirementList;
    Procedure SetRequestId(value : TFhirId);
    Function GetRequestIdST : String;
    Procedure SetRequestIdST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetModule(value : TFhirReference{TFhirServiceDefinition});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirGuidanceResponseStatusEnum;
    Procedure SetStatusST(value : TFhirGuidanceResponseStatusEnum);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrenceDateTime(value : TFhirDateTime);
    Function GetOccurrenceDateTimeST : TFslDateTime;
    Procedure SetOccurrenceDateTimeST(value : TFslDateTime);
    Procedure SetPerformer(value : TFhirReference{TFhirDevice});
    Procedure SetReason(value : TFhirType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEvaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
    function GetHasEvaluationMessageList : Boolean;
    Procedure SetOutputParameters(value : TFhirReference{TFhirParameters});
    Procedure SetResult(value : TFhirReference{Resource});
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGuidanceResponse; overload;
    function Clone : TFhirGuidanceResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The id of the request associated with this response. If an id was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario.
    property requestId : String read GetRequestIdST write SetRequestIdST;
    // The id of the request associated with this response. If an id was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario.
    property requestIdElement : TFhirId read FRequestId write SetRequestId;

    // Typed access to Allows a service to provide a unique, business identifier for the response. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Allows a service to provide a unique, business identifier for the response.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A reference to the knowledge module that was invoked. (defined for API consistency)
    property module : TFhirReference{TFhirServiceDefinition} read FModule write SetModule;
    // A reference to the knowledge module that was invoked.
    property moduleElement : TFhirReference{TFhirServiceDefinition} read FModule write SetModule;

    // The status of the response. If the evaluation is completed successfully, the status will indicate success. However, in order to complete the evaluation, the engine may require more information. In this case, the status will be data-required, and the response will contain a description of the additional required information. If the evaluation completed successfully, but the engine determines that a potentially more accurate response could be provided if more data was available, the status will be data-requested, and the response will contain a description of the additional requested information.
    property status : TFhirGuidanceResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient for which the request was processed. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient for which the request was processed.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Allows the context of the guidance response to be provided if available. In a service context, this would likely be unavailable. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // Allows the context of the guidance response to be provided if available. In a service context, this would likely be unavailable.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Indicates when the guidance response was processed.
    property occurrenceDateTime : TFslDateTime read GetOccurrenceDateTimeST write SetOccurrenceDateTimeST;
    // Indicates when the guidance response was processed.
    property occurrenceDateTimeElement : TFhirDateTime read FOccurrenceDateTime write SetOccurrenceDateTime;

    // Typed access to Provides a reference to the device that performed the guidance. (defined for API consistency)
    property performer : TFhirReference{TFhirDevice} read FPerformer write SetPerformer;
    // Provides a reference to the device that performed the guidance.
    property performerElement : TFhirReference{TFhirDevice} read FPerformer write SetPerformer;

    // Typed access to Indicates the reason the request was initiated. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Indicates the reason the request was initiated. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response.
    property reasonElement : TFhirType read FReason write SetReason;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Messages resulting from the evaluation of the artifact or artifacts. As part of evaluating the request, the engine may produce informational or warning messages. These messages will be provided by this element.
    property evaluationMessageList : TFhirReferenceList{TFhirOperationOutcome} read GetEvaluationMessageList;
    property hasEvaluationMessageList : boolean read GetHasEvaluationMessageList;

    // Typed access to The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element. (defined for API consistency)
    property outputParameters : TFhirReference{TFhirParameters} read FOutputParameters write SetOutputParameters;
    // The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element.
    property outputParametersElement : TFhirReference{TFhirParameters} read FOutputParameters write SetOutputParameters;

    // Typed access to The actions, if any, produced by the evaluation of the artifact. (defined for API consistency)
    property result : TFhirReference{Resource} read FResult write SetResult;
    // The actions, if any, produced by the evaluation of the artifact.
    property resultElement : TFhirReference{Resource} read FResult write SetResult;

    // If the evaluation could not be completed due to lack of information, or additional information would potentially result in a more accurate response, this element will a description of the data required in order to proceed with the evaluation. A subsequent request to the service should include this data.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

  end;

  TFhirGuidanceResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGuidanceResponseList;
    function GetCurrent : TFhirGuidanceResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGuidanceResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGuidanceResponse read GetCurrent;
  end;

  TFhirGuidanceResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGuidanceResponse;
    procedure SetItemN(index : Integer; value : TFhirGuidanceResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGuidanceResponseList; Overload;
    function Clone : TFhirGuidanceResponseList; Overload;
    function GetEnumerator : TFhirGuidanceResponseListEnumerator;

    //  Add a FhirGuidanceResponse to the end of the list.
    function Append : TFhirGuidanceResponse;

    // Add an already existing FhirGuidanceResponse to the end of the list.
    procedure AddItem(value : TFhirGuidanceResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGuidanceResponse) : Integer;

    // Insert FhirGuidanceResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGuidanceResponse;

    // Insert an existing FhirGuidanceResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGuidanceResponse);

    // Get the iIndexth FhirGuidanceResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGuidanceResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGuidanceResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGuidanceResponses[index : Integer] : TFhirGuidanceResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GUIDANCERESPONSE}

{$IFDEF FHIR_LINKAGE}

  // Identifies one of the records that is considered to refer to the same real-world occurrence as well as how the items hould be evaluated within the collection of linked items.
  TFhirLinkageItem = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FResource : TFhirReference;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirLinkageTypeEnum;
    Procedure SetType_ST(value : TFhirLinkageTypeEnum);
    Procedure SetResource(value : TFhirReference);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkageItem; overload;
    function Clone : TFhirLinkageItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
    property type_ : TFhirLinkageTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The resource instance being linked as part of the group. (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource instance being linked as part of the group.
    property resourceElement : TFhirReference read FResource write SetResource;

  end;

  TFhirLinkageItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageItemList;
    function GetCurrent : TFhirLinkageItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLinkageItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkageItem read GetCurrent;
  end;

  TFhirLinkageItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLinkageItem;
    procedure SetItemN(index : Integer; value : TFhirLinkageItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLinkageItemList; Overload;
    function Clone : TFhirLinkageItemList; Overload;
    function GetEnumerator : TFhirLinkageItemListEnumerator;

    //  Add a FhirLinkageItem to the end of the list.
    function Append : TFhirLinkageItem;

    // Add an already existing FhirLinkageItem to the end of the list.
    procedure AddItem(value : TFhirLinkageItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkageItem) : Integer;

    // Insert FhirLinkageItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkageItem;

    // Insert an existing FhirLinkageItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkageItem);

    // Get the iIndexth FhirLinkageItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkageItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkageItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirLinkageItems[index : Integer] : TFhirLinkageItem read GetItemN write SetItemN; default;
  End;

  // Identifies two or more records (resource instances) that are referring to the same real-world "occurrence".
  TFhirLinkage = class (TFhirDomainResource)
  protected
    FActive : TFhirBoolean;
    FAuthor : TFhirReference{Resource};
    FitemList : TFhirLinkageItemList;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetAuthor(value : TFhirReference{Resource});
    function GetItemList : TFhirLinkageItemList;
    function GetHasItemList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkage; overload;
    function Clone : TFhirLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates whether the asserted set of linkages are considered to be "in effect".
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the asserted set of linkages are considered to be "in effect".
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to Identifies the user or organization responsible for asserting the linkages and who establishes the context for evaluating the nature of each linkage. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Identifies the user or organization responsible for asserting the linkages and who establishes the context for evaluating the nature of each linkage.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Identifies one of the records that is considered to refer to the same real-world occurrence as well as how the items hould be evaluated within the collection of linked items.
    property itemList : TFhirLinkageItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageList;
    function GetCurrent : TFhirLinkage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkage read GetCurrent;
  end;

  TFhirLinkageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLinkage;
    procedure SetItemN(index : Integer; value : TFhirLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLinkageList; Overload;
    function Clone : TFhirLinkageList; Overload;
    function GetEnumerator : TFhirLinkageListEnumerator;

    //  Add a FhirLinkage to the end of the list.
    function Append : TFhirLinkage;

    // Add an already existing FhirLinkage to the end of the list.
    procedure AddItem(value : TFhirLinkage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkage) : Integer;

    // Insert FhirLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkage;

    // Insert an existing FhirLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkage);

    // Get the iIndexth FhirLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirLinkages[index : Integer] : TFhirLinkage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LINKAGE}

{$IFDEF FHIR_LIST}

  // Entries in this list.
  TFhirListEntry = class (TFhirBackboneElement)
  protected
    FFlag : TFhirCodeableConcept;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirReference{TFhirReference};
    Procedure SetFlag(value : TFhirCodeableConcept);
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : Boolean;
    Procedure SetDeletedST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetItem(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The flag allows the system constructing the list to indicate the role and significance of the item in the list. (defined for API consistency)
    property flag : TFhirCodeableConcept read FFlag write SetFlag;
    // The flag allows the system constructing the list to indicate the role and significance of the item in the list.
    property flagElement : TFhirCodeableConcept read FFlag write SetFlag;

    // Typed access to True if this item is marked as deleted in the list.
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    // True if this item is marked as deleted in the list.
    property deletedElement : TFhirBoolean read FDeleted write SetDeleted;

    // Typed access to When this item was added to the list.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When this item was added to the list.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A reference to the actual resource from which data was derived. (defined for API consistency)
    property item : TFhirReference{TFhirReference} read FItem write SetItem;
    // A reference to the actual resource from which data was derived.
    property itemElement : TFhirReference{TFhirReference} read FItem write SetItem;

  end;

  TFhirListEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;

  TFhirListEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    function GetEnumerator : TFhirListEntryListEnumerator;

    //  Add a FhirListEntry to the end of the list.
    function Append : TFhirListEntry;

    // Add an already existing FhirListEntry to the end of the list.
    procedure AddItem(value : TFhirListEntry); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirListEntry) : Integer;

    // Insert FhirListEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirListEntry;

    // Insert an existing FhirListEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirListEntry);

    // Get the iIndexth FhirListEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);

    // The number of items in the collection
    function Item(index : Integer) : TFhirListEntry;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;

  // A set of information summarized from a list of other resources.
  TFhirList = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FMode : TFhirEnum;
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FDate : TFhirDateTime;
    FSource : TFhirReference{Resource};
    FOrderedBy : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FentryList : TFhirListEntryList;
    FEmptyReason : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirListStatusEnum;
    Procedure SetStatusST(value : TFhirListStatusEnum);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirListModeEnum;
    Procedure SetModeST(value : TFhirListModeEnum);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEntryList : TFhirListEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetEmptyReason(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirList; overload;
    function Clone : TFhirList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for the List assigned for business purposes outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this list.
    property status : TFhirListStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A label for the list assigned by the author.
    property title : String read GetTitleST write SetTitleST;
    // A label for the list assigned by the author.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to This code defines the purpose of the list - why it was created. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // This code defines the purpose of the list - why it was created.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The common subject (or patient) of the resources that are in the list, if there is one. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The common subject (or patient) of the resources that are in the list, if there is one.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter that is the context in which this list was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter that is the context in which this list was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The date that the list was prepared.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that the list was prepared.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to What order applies to the items in the list. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // What order applies to the items in the list.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Comments that apply to the overall list.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Entries in this list.
    property entryList : TFhirListEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the list is empty, why the list is empty. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the list is empty, why the list is empty.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

  end;

  TFhirListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListList;
    function GetCurrent : TFhirList;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirList read GetCurrent;
  end;

  TFhirListList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirList;
    procedure SetItemN(index : Integer; value : TFhirList);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListList; Overload;
    function Clone : TFhirListList; Overload;
    function GetEnumerator : TFhirListListEnumerator;

    //  Add a FhirList to the end of the list.
    function Append : TFhirList;

    // Add an already existing FhirList to the end of the list.
    procedure AddItem(value : TFhirList); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirList) : Integer;

    // Insert FhirList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirList;

    // Insert an existing FhirList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirList);

    // Get the iIndexth FhirList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirList);

    // The number of items in the collection
    function Item(index : Integer) : TFhirList;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirLists[index : Integer] : TFhirList read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEASUREREPORT}

  // The results of the calculation, one for each population group in the measure.
  TFhirMeasureReportGroup = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FpopulationList : TFhirMeasureReportGroupPopulationList;
    FMeasureScore : TFhirDecimal;
    FstratifierList : TFhirMeasureReportGroupStratifierList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetPopulationList : TFhirMeasureReportGroupPopulationList;
    function GetHasPopulationList : Boolean;
    Procedure SetMeasureScore(value : TFhirDecimal);
    Function GetMeasureScoreST : String;
    Procedure SetMeasureScoreST(value : String);
    function GetStratifierList : TFhirMeasureReportGroupStratifierList;
    function GetHasStratifierList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroup; overload;
    function Clone : TFhirMeasureReportGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of the population group as defined in the measure definition. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier of the population group as defined in the measure definition.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The populations that make up the population group, one for each type of population appropriate for the measure.
    property populationList : TFhirMeasureReportGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
    property measureScore : String read GetMeasureScoreST write SetMeasureScoreST;
    // The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
    property measureScoreElement : TFhirDecimal read FMeasureScore write SetMeasureScore;

    // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
    property stratifierList : TFhirMeasureReportGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureReportGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupList;
    function GetCurrent : TFhirMeasureReportGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroup read GetCurrent;
  end;

  TFhirMeasureReportGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupList; Overload;
    function Clone : TFhirMeasureReportGroupList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupListEnumerator;

    //  Add a FhirMeasureReportGroup to the end of the list.
    function Append : TFhirMeasureReportGroup;

    // Add an already existing FhirMeasureReportGroup to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroup) : Integer;

    // Insert FhirMeasureReportGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroup;

    // Insert an existing FhirMeasureReportGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroup);

    // Get the iIndexth FhirMeasureReportGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReportGroups[index : Integer] : TFhirMeasureReportGroup read GetItemN write SetItemN; default;
  End;

  // The populations that make up the population group, one for each type of population appropriate for the measure.
  TFhirMeasureReportGroupPopulation = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FPatients : TFhirReference{TFhirList};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetCount(value : TFhirInteger);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    Procedure SetPatients(value : TFhirReference{TFhirList});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupPopulation; overload;
    function Clone : TFhirMeasureReportGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of the population being reported, as defined by the population element of the measure. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier of the population being reported, as defined by the population element of the measure.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of patient level MeasureReport resources, one for each patient in this population. (defined for API consistency)
    property patients : TFhirReference{TFhirList} read FPatients write SetPatients;
    // This element refers to a List of patient level MeasureReport resources, one for each patient in this population.
    property patientsElement : TFhirReference{TFhirList} read FPatients write SetPatients;

  end;

  TFhirMeasureReportGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupPopulationList;
    function GetCurrent : TFhirMeasureReportGroupPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupPopulationList; Overload;
    function Clone : TFhirMeasureReportGroupPopulationList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;

    //  Add a FhirMeasureReportGroupPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupPopulation;

    // Add an already existing FhirMeasureReportGroupPopulation to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupPopulation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupPopulation) : Integer;

    // Insert FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupPopulation;

    // Insert an existing FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupPopulation);

    // Get the iIndexth FhirMeasureReportGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupPopulation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupPopulation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReportGroupPopulations[index : Integer] : TFhirMeasureReportGroupPopulation read GetItemN write SetItemN; default;
  End;

  // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
  TFhirMeasureReportGroupStratifier = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FstratumList : TFhirMeasureReportGroupStratifierStratumList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetHasStratumList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifier; overload;
    function Clone : TFhirMeasureReportGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of this stratifier, as defined in the measure definition. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier of this stratifier, as defined in the measure definition.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
    property stratumList : TFhirMeasureReportGroupStratifierStratumList read GetStratumList;
    property hasStratumList : boolean read GetHasStratumList;

  end;

  TFhirMeasureReportGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierList;
    function GetCurrent : TFhirMeasureReportGroupStratifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifier read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;

    //  Add a FhirMeasureReportGroupStratifier to the end of the list.
    function Append : TFhirMeasureReportGroupStratifier;

    // Add an already existing FhirMeasureReportGroupStratifier to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifier); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifier) : Integer;

    // Insert FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifier;

    // Insert an existing FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifier);

    // Get the iIndexth FhirMeasureReportGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifier);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifier;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReportGroupStratifiers[index : Integer] : TFhirMeasureReportGroupStratifier read GetItemN write SetItemN; default;
  End;

  // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
  TFhirMeasureReportGroupStratifierStratum = class (TFhirBackboneElement)
  protected
    FValue : TFhirString;
    FpopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    FMeasureScore : TFhirDecimal;
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    function GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetHasPopulationList : Boolean;
    Procedure SetMeasureScore(value : TFhirDecimal);
    Function GetMeasureScoreST : String;
    Procedure SetMeasureScoreST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratum; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratum; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The value for this stratum, expressed as a string. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
    property value : String read GetValueST write SetValueST;
    // The value for this stratum, expressed as a string. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
    property valueElement : TFhirString read FValue write SetValue;

    // The populations that make up the stratum, one for each type of population appropriate to the measure.
    property populationList : TFhirMeasureReportGroupStratifierStratumPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
    property measureScore : String read GetMeasureScoreST write SetMeasureScoreST;
    // The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
    property measureScoreElement : TFhirDecimal read FMeasureScore write SetMeasureScore;

  end;

  TFhirMeasureReportGroupStratifierStratumListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratum;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratum read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierStratumList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;

    //  Add a FhirMeasureReportGroupStratifierStratum to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratum;

    // Add an already existing FhirMeasureReportGroupStratifierStratum to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifierStratum); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratum) : Integer;

    // Insert FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratum;

    // Insert an existing FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);

    // Get the iIndexth FhirMeasureReportGroupStratifierStratum. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratum;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReportGroupStratifierStrata[index : Integer] : TFhirMeasureReportGroupStratifierStratum read GetItemN write SetItemN; default;
  End;

  // The populations that make up the stratum, one for each type of population appropriate to the measure.
  TFhirMeasureReportGroupStratifierStratumPopulation = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FPatients : TFhirReference{TFhirList};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetCount(value : TFhirInteger);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    Procedure SetPatients(value : TFhirReference{TFhirList});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of the population being reported, as defined by the population element of the measure. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier of the population being reported, as defined by the population element of the measure.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population in this stratum.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population in this stratum.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of patient level MeasureReport resources, one for each patient in this population in this stratum. (defined for API consistency)
    property patients : TFhirReference{TFhirList} read FPatients write SetPatients;
    // This element refers to a List of patient level MeasureReport resources, one for each patient in this population in this stratum.
    property patientsElement : TFhirReference{TFhirList} read FPatients write SetPatients;

  end;

  TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierStratumPopulationList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulationList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;

    //  Add a FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumPopulation;

    // Add an already existing FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifierStratumPopulation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumPopulation) : Integer;

    // Insert FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;

    // Insert an existing FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);

    // Get the iIndexth FhirMeasureReportGroupStratifierStratumPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReportGroupStratifierStratumPopulations[index : Integer] : TFhirMeasureReportGroupStratifierStratumPopulation read GetItemN write SetItemN; default;
  End;

  // The MeasureReport resource contains the results of evaluating a measure.
  TFhirMeasureReport = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FMeasure : TFhirReference{TFhirMeasure};
    FPatient : TFhirReference{TFhirPatient};
    FDate : TFhirDateTime;
    FReportingOrganization : TFhirReference{TFhirOrganization};
    FPeriod : TFhirPeriod;
    FgroupList : TFhirMeasureReportGroupList;
    FEvaluatedResources : TFhirReference{TFhirBundle};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMeasureReportStatusEnum;
    Procedure SetStatusST(value : TFhirMeasureReportStatusEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirMeasureReportTypeEnum;
    Procedure SetType_ST(value : TFhirMeasureReportTypeEnum);
    Procedure SetMeasure(value : TFhirReference{TFhirMeasure});
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetReportingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPeriod(value : TFhirPeriod);
    function GetGroupList : TFhirMeasureReportGroupList;
    function GetHasGroupList : Boolean;
    Procedure SetEvaluatedResources(value : TFhirReference{TFhirBundle});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReport; overload;
    function Clone : TFhirMeasureReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A formal identifier that is used to identify this report when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this report when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The report status. No data will be available until the report status is complete.
    property status : TFhirMeasureReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of measure report. This may be an individual report, which provides a single patient's score for the measure; a patient listing, which returns the list of patients that meet the various criteria in the measure; or a summary report, which returns a population count for each of the criteria in the measure.
    property type_ : TFhirMeasureReportTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the Measure that was evaluated to produce this report. (defined for API consistency)
    property measure : TFhirReference{TFhirMeasure} read FMeasure write SetMeasure;
    // A reference to the Measure that was evaluated to produce this report.
    property measureElement : TFhirReference{TFhirMeasure} read FMeasure write SetMeasure;

    // Typed access to Optional Patient if the report was requested for a single patient. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Optional Patient if the report was requested for a single patient.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date this measure report was generated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this measure report was generated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Reporting Organization. (defined for API consistency)
    property reportingOrganization : TFhirReference{TFhirOrganization} read FReportingOrganization write SetReportingOrganization;
    // Reporting Organization.
    property reportingOrganizationElement : TFhirReference{TFhirOrganization} read FReportingOrganization write SetReportingOrganization;

    // Typed access to The reporting period for which the report was calculated. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The reporting period for which the report was calculated.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The results of the calculation, one for each population group in the measure.
    property groupList : TFhirMeasureReportGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // Typed access to A reference to a Bundle containing the Resources that were used in the evaluation of this report. (defined for API consistency)
    property evaluatedResources : TFhirReference{TFhirBundle} read FEvaluatedResources write SetEvaluatedResources;
    // A reference to a Bundle containing the Resources that were used in the evaluation of this report.
    property evaluatedResourcesElement : TFhirReference{TFhirBundle} read FEvaluatedResources write SetEvaluatedResources;

  end;

  TFhirMeasureReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportList;
    function GetCurrent : TFhirMeasureReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReport read GetCurrent;
  end;

  TFhirMeasureReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReport;
    procedure SetItemN(index : Integer; value : TFhirMeasureReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportList; Overload;
    function Clone : TFhirMeasureReportList; Overload;
    function GetEnumerator : TFhirMeasureReportListEnumerator;

    //  Add a FhirMeasureReport to the end of the list.
    function Append : TFhirMeasureReport;

    // Add an already existing FhirMeasureReport to the end of the list.
    procedure AddItem(value : TFhirMeasureReport); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReport) : Integer;

    // Insert FhirMeasureReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReport;

    // Insert an existing FhirMeasureReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReport);

    // Get the iIndexth FhirMeasureReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReport);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReport;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureReports[index : Integer] : TFhirMeasureReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASUREREPORT}

{$IFDEF FHIR_MESSAGEHEADER}

  // The destination application which the message is intended for.
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTarget : TFhirReference{TFhirDevice};
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable name for the target system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the target system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the target end system in situations where the initial message transmission is to an intermediary system. (defined for API consistency)
    property target : TFhirReference{TFhirDevice} read FTarget write SetTarget;
    // Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    property targetElement : TFhirReference{TFhirDevice} read FTarget write SetTarget;

    // Typed access to Indicates where the message should be routed to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Indicates where the message should be routed to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;

  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderDestinationList; Overload;
    function Clone : TFhirMessageHeaderDestinationList; Overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;

    //  Add a FhirMessageHeaderDestination to the end of the list.
    function Append : TFhirMessageHeaderDestination;

    // Add an already existing FhirMessageHeaderDestination to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderDestination); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;

    // Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderDestination;

    // Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);

    // Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderDestination;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;

  // The source application from which this message originated.
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContactPoint;
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContactPoint);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable name for the source system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the source system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to May include configuration or other information useful in debugging.
    property software : String read GetSoftwareST write SetSoftwareST;
    // May include configuration or other information useful in debugging.
    property softwareElement : TFhirString read FSoftware write SetSoftware;

    // Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property version : String read GetVersionST write SetVersionST;
    // Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to An e-mail, phone, website or other contact point to use to resolve issues with message communications. (defined for API consistency)
    property contact : TFhirContactPoint read FContact write SetContact;
    // An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    property contactElement : TFhirContactPoint read FContact write SetContact;

    // Typed access to Identifies the routing target to send acknowledgements to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Identifies the routing target to send acknowledgements to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;

  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderSourceList; Overload;
    function Clone : TFhirMessageHeaderSourceList; Overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;

    //  Add a FhirMessageHeaderSource to the end of the list.
    function Append : TFhirMessageHeaderSource;

    // Add an already existing FhirMessageHeaderSource to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderSource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;

    // Insert FhirMessageHeaderSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderSource;

    // Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);

    // Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderSource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;

  // Information about the message that this message is a response to.  Only present if this message is a response.
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCodeEnum;
    Procedure SetCodeST(value : TFhirResponseCodeEnum);
    Procedure SetDetails(value : TFhirReference{TFhirOperationOutcome});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The MessageHeader.id of the message to which this message is a response.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // The MessageHeader.id of the message to which this message is a response.
    property identifierElement : TFhirId read FIdentifier write SetIdentifier;

    // Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    property code : TFhirResponseCodeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Full details of any issues found in the message. (defined for API consistency)
    property details : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;
    // Full details of any issues found in the message.
    property detailsElement : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;

  TFhirMessageHeaderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;

  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderResponseList; Overload;
    function Clone : TFhirMessageHeaderResponseList; Overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;

    //  Add a FhirMessageHeaderResponse to the end of the list.
    function Append : TFhirMessageHeaderResponse;

    // Add an already existing FhirMessageHeaderResponse to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;

    // Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderResponse;

    // Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);

    // Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;

  // The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  TFhirMessageHeader = class (TFhirDomainResource)
  protected
    FEvent : TFhirCoding;
    FdestinationList : TFhirMessageHeaderDestinationList;
    FReceiver : TFhirReference{Resource};
    FSender : TFhirReference{Resource};
    FTimestamp : TFhirInstant;
    FEnterer : TFhirReference{TFhirPractitioner};
    FAuthor : TFhirReference{TFhirPractitioner};
    FSource : TFhirMessageHeaderSource;
    FResponsible : TFhirReference{Resource};
    FReason : TFhirCodeableConcept;
    FResponse : TFhirMessageHeaderResponse;
    FfocusList : TFhirReferenceList{TFhirReference};
    Procedure SetEvent(value : TFhirCoding);
    function GetDestinationList : TFhirMessageHeaderDestinationList;
    function GetHasDestinationList : Boolean;
    Procedure SetReceiver(value : TFhirReference{Resource});
    Procedure SetSender(value : TFhirReference{Resource});
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TFslDateTime;
    Procedure SetTimestampST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});
    Procedure SetSource(value : TFhirMessageHeaderSource);
    Procedure SetResponsible(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetResponse(value : TFhirMessageHeaderResponse);
    function GetFocusList : TFhirReferenceList{TFhirReference};
    function GetHasFocusList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeader; overload;
    function Clone : TFhirMessageHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://hl7.org/fhir/message-events". (defined for API consistency)
    property event : TFhirCoding read FEvent write SetEvent;
    // Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://hl7.org/fhir/message-events".
    property eventElement : TFhirCoding read FEvent write SetEvent;

    // The destination application which the message is intended for.
    property destinationList : TFhirMessageHeaderDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient. (defined for API consistency)
    property receiver : TFhirReference{Resource} read FReceiver write SetReceiver;
    // Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    property receiverElement : TFhirReference{Resource} read FReceiver write SetReceiver;

    // Typed access to Identifies the sending system to allow the use of a trust relationship. (defined for API consistency)
    property sender : TFhirReference{Resource} read FSender write SetSender;
    // Identifies the sending system to allow the use of a trust relationship.
    property senderElement : TFhirReference{Resource} read FSender write SetSender;

    // Typed access to The time that the message was sent.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The time that the message was sent.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

    // Typed access to The source application from which this message originated. (defined for API consistency)
    property source : TFhirMessageHeaderSource read FSource write SetSource;
    // The source application from which this message originated.
    property sourceElement : TFhirMessageHeaderSource read FSource write SetSource;

    // Typed access to The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party. (defined for API consistency)
    property responsible : TFhirReference{Resource} read FResponsible write SetResponsible;
    // The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    property responsibleElement : TFhirReference{Resource} read FResponsible write SetResponsible;

    // Typed access to Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Information about the message that this message is a response to.  Only present if this message is a response. (defined for API consistency)
    property response : TFhirMessageHeaderResponse read FResponse write SetResponse;
    // Information about the message that this message is a response to.  Only present if this message is a response.
    property responseElement : TFhirMessageHeaderResponse read FResponse write SetResponse;

    // The actual data of the message - a reference to the root/focus class of the event.
    property focusList : TFhirReferenceList{TFhirReference} read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

  end;

  TFhirMessageHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderList;
    function GetCurrent : TFhirMessageHeader;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeader read GetCurrent;
  end;

  TFhirMessageHeaderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeader;
    procedure SetItemN(index : Integer; value : TFhirMessageHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderList; Overload;
    function Clone : TFhirMessageHeaderList; Overload;
    function GetEnumerator : TFhirMessageHeaderListEnumerator;

    //  Add a FhirMessageHeader to the end of the list.
    function Append : TFhirMessageHeader;

    // Add an already existing FhirMessageHeader to the end of the list.
    procedure AddItem(value : TFhirMessageHeader); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeader) : Integer;

    // Insert FhirMessageHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeader;

    // Insert an existing FhirMessageHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeader);

    // Get the iIndexth FhirMessageHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeader);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeader;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaders[index : Integer] : TFhirMessageHeader read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_MEDICATION}

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    FIsActive : TFhirBoolean;
    FAmount : TFhirRatio;
    Procedure SetItem(value : TFhirType);
    Procedure SetIsActive(value : TFhirBoolean);
    Function GetIsActiveST : Boolean;
    Procedure SetIsActiveST(value : Boolean);
    Procedure SetAmount(value : TFhirRatio);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationIngredient; overload;
    function Clone : TFhirMedicationIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication.
    property itemElement : TFhirType read FItem write SetItem;

    // Typed access to Indication of whether this?ingredient affects?the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this?ingredient affects?the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet. (defined for API consistency)
    property amount : TFhirRatio read FAmount write SetAmount;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet.
    property amountElement : TFhirRatio read FAmount write SetAmount;

  end;

  TFhirMedicationIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationIngredientList;
    function GetCurrent : TFhirMedicationIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationIngredient read GetCurrent;
  end;

  TFhirMedicationIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationIngredientList; Overload;
    function Clone : TFhirMedicationIngredientList; Overload;
    function GetEnumerator : TFhirMedicationIngredientListEnumerator;

    //  Add a FhirMedicationIngredient to the end of the list.
    function Append : TFhirMedicationIngredient;

    // Add an already existing FhirMedicationIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationIngredient); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationIngredient) : Integer;

    // Insert FhirMedicationIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationIngredient;

    // Insert an existing FhirMedicationIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationIngredient);

    // Get the iIndexth FhirMedicationIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationIngredient);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationIngredient;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationIngredients[index : Integer] : TFhirMedicationIngredient read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationPackage = class (TFhirBackboneElement)
  protected
    FContainer : TFhirCodeableConcept;
    FcontentList : TFhirMedicationPackageContentList;
    FbatchList : TFhirMedicationPackageBatchList;
    Procedure SetContainer(value : TFhirCodeableConcept);
    function GetContentList : TFhirMedicationPackageContentList;
    function GetHasContentList : Boolean;
    function GetBatchList : TFhirMedicationPackageBatchList;
    function GetHasBatchList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationPackage; overload;
    function Clone : TFhirMedicationPackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The kind of container that this package comes as. (defined for API consistency)
    property container : TFhirCodeableConcept read FContainer write SetContainer;
    // The kind of container that this package comes as.
    property containerElement : TFhirCodeableConcept read FContainer write SetContainer;

    // A set of components that go to make up the described item.
    property contentList : TFhirMedicationPackageContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Information about a group of medication produced or packaged from one production run.
    property batchList : TFhirMedicationPackageBatchList read GetBatchList;
    property hasBatchList : boolean read GetHasBatchList;

  end;

  TFhirMedicationPackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageList;
    function GetCurrent : TFhirMedicationPackage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationPackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackage read GetCurrent;
  end;

  TFhirMedicationPackageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationPackage;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationPackageList; Overload;
    function Clone : TFhirMedicationPackageList; Overload;
    function GetEnumerator : TFhirMedicationPackageListEnumerator;

    //  Add a FhirMedicationPackage to the end of the list.
    function Append : TFhirMedicationPackage;

    // Add an already existing FhirMedicationPackage to the end of the list.
    procedure AddItem(value : TFhirMedicationPackage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationPackage) : Integer;

    // Insert FhirMedicationPackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationPackage;

    // Insert an existing FhirMedicationPackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationPackage);

    // Get the iIndexth FhirMedicationPackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationPackage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationPackages[index : Integer] : TFhirMedicationPackage read GetItemN write SetItemN; default;
  End;

  // A set of components that go to make up the described item.
  TFhirMedicationPackageContent = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    FAmount : TFhirQuantity;
    Procedure SetItem(value : TFhirType);
    Procedure SetAmount(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationPackageContent; overload;
    function Clone : TFhirMedicationPackageContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies one of the items in the package. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // Identifies one of the items in the package.
    property itemElement : TFhirType read FItem write SetItem;

    // Typed access to The amount of the product that is in the package. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The amount of the product that is in the package.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirMedicationPackageContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageContentList;
    function GetCurrent : TFhirMedicationPackageContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationPackageContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackageContent read GetCurrent;
  end;

  TFhirMedicationPackageContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationPackageContent;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationPackageContentList; Overload;
    function Clone : TFhirMedicationPackageContentList; Overload;
    function GetEnumerator : TFhirMedicationPackageContentListEnumerator;

    //  Add a FhirMedicationPackageContent to the end of the list.
    function Append : TFhirMedicationPackageContent;

    // Add an already existing FhirMedicationPackageContent to the end of the list.
    procedure AddItem(value : TFhirMedicationPackageContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationPackageContent) : Integer;

    // Insert FhirMedicationPackageContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationPackageContent;

    // Insert an existing FhirMedicationPackageContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageContent);

    // Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationPackageContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationPackageContents[index : Integer] : TFhirMedicationPackageContent read GetItemN write SetItemN; default;
  End;

  // Information about a group of medication produced or packaged from one production run.
  TFhirMedicationPackageBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetExpirationDate(value : TFhirDateTime);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationPackageBatch; overload;
    function Clone : TFhirMedicationPackageBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationPackageBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageBatchList;
    function GetCurrent : TFhirMedicationPackageBatch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationPackageBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackageBatch read GetCurrent;
  end;

  TFhirMedicationPackageBatchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationPackageBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationPackageBatchList; Overload;
    function Clone : TFhirMedicationPackageBatchList; Overload;
    function GetEnumerator : TFhirMedicationPackageBatchListEnumerator;

    //  Add a FhirMedicationPackageBatch to the end of the list.
    function Append : TFhirMedicationPackageBatch;

    // Add an already existing FhirMedicationPackageBatch to the end of the list.
    procedure AddItem(value : TFhirMedicationPackageBatch); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationPackageBatch) : Integer;

    // Insert FhirMedicationPackageBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationPackageBatch;

    // Insert an existing FhirMedicationPackageBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageBatch);

    // Get the iIndexth FhirMedicationPackageBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageBatch);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationPackageBatch;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationPackageBatches[index : Integer] : TFhirMedicationPackageBatch read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FIsBrand : TFhirBoolean;
    FIsOverTheCounter : TFhirBoolean;
    FManufacturer : TFhirReference{TFhirOrganization};
    FForm : TFhirCodeableConcept;
    FingredientList : TFhirMedicationIngredientList;
    FPackage : TFhirMedicationPackage;
    FimageList : TFhirAttachmentList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationStatusEnum);
    Procedure SetIsBrand(value : TFhirBoolean);
    Function GetIsBrandST : Boolean;
    Procedure SetIsBrandST(value : Boolean);
    Procedure SetIsOverTheCounter(value : TFhirBoolean);
    Function GetIsOverTheCounterST : Boolean;
    Procedure SetIsOverTheCounterST(value : Boolean);
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetIngredientList : TFhirMedicationIngredientList;
    function GetHasIngredientList : Boolean;
    Procedure SetPackage(value : TFhirMedicationPackage);
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.
    property status : TFhirMedicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Set to true if the item is attributable to a specific manufacturer.
    property isBrand : Boolean read GetIsBrandST write SetIsBrandST;
    // Set to true if the item is attributable to a specific manufacturer.
    property isBrandElement : TFhirBoolean read FIsBrand write SetIsBrand;

    // Typed access to Set to true if the medication can be obtained without an order from a prescriber.
    property isOverTheCounter : Boolean read GetIsOverTheCounterST write SetIsOverTheCounterST;
    // Set to true if the medication can be obtained without an order from a prescriber.
    property isOverTheCounterElement : TFhirBoolean read FIsOverTheCounter write SetIsOverTheCounter;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property package : TFhirMedicationPackage read FPackage write SetPackage;
    // Information that only applies to packages (not products).
    property packageElement : TFhirMedicationPackage read FPackage write SetPackage;

    // Photo(s) or graphic representation(s) of the medication.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationList; Overload;
    function Clone : TFhirMedicationList; Overload;
    function GetEnumerator : TFhirMedicationListEnumerator;

    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;

    // Add an already existing FhirMedication to the end of the list.
    procedure AddItem(value : TFhirMedication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;

    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;

    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);

    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_OPERATIONOUTCOME}

  // An error, warning or information message that results from a system action.
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  protected
    FSeverity : TFhirEnum;
    FCode : TFhirEnum;
    FDetails : TFhirCodeableConcept;
    FDiagnostics : TFhirString;
    FlocationList : TFhirStringList;
    FexpressionList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverityEnum;
    Procedure SetSeverityST(value : TFhirIssueSeverityEnum);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirIssueTypeEnum;
    Procedure SetCodeST(value : TFhirIssueTypeEnum);
    Procedure SetDetails(value : TFhirCodeableConcept);
    Procedure SetDiagnostics(value : TFhirString);
    Function GetDiagnosticsST : String;
    Procedure SetDiagnosticsST(value : String);
    function GetLocationList : TFhirStringList;
    function GetHasLocationList : Boolean;
    function GetExpressionList : TFhirStringList;
    function GetHasExpressionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates whether the issue indicates a variation from successful processing.
    property severity : TFhirIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Describes the type of the issue. The system that creates an OperationOutcome SHALL choose the most applicable code from the IssueType value set, and may additional provide its own code for the error in the details element.
    property code : TFhirIssueTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Additional details about the error. This may be a text description of the error, or a system code that identifies the error. (defined for API consistency)
    property details : TFhirCodeableConcept read FDetails write SetDetails;
    // Additional details about the error. This may be a text description of the error, or a system code that identifies the error.
    property detailsElement : TFhirCodeableConcept read FDetails write SetDetails;

    // Typed access to Additional diagnostic information about the issue.  Typically, this may be a description of how a value is erroneous, or a stack dump to help trace the issue.
    property diagnostics : String read GetDiagnosticsST write SetDiagnosticsST;
    // Additional diagnostic information about the issue.  Typically, this may be a description of how a value is erroneous, or a stack dump to help trace the issue.
    property diagnosticsElement : TFhirString read FDiagnostics write SetDiagnostics;

    // For resource issues, this will be a simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.  For HTTP errors, will be "http." + the parameter name.
    property locationList : TFhirStringList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // A simple FHIRPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    property expressionList : TFhirStringList read GetExpressionList;
    property hasExpressionList : boolean read GetHasExpressionList;

  end;

  TFhirOperationOutcomeIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;

  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;

    //  Add a FhirOperationOutcomeIssue to the end of the list.
    function Append : TFhirOperationOutcomeIssue;

    // Add an already existing FhirOperationOutcomeIssue to the end of the list.
    procedure AddItem(value : TFhirOperationOutcomeIssue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;

    // Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;

    // Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);

    // Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcomeIssue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;

  // A collection of error, warning or information messages that result from a system action.
  TFhirOperationOutcome = class (TFhirDomainResource)
  protected
    FissueList : TFhirOperationOutcomeIssueList;
    function GetIssueList : TFhirOperationOutcomeIssueList;
    function GetHasIssueList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcome; overload;
    function Clone : TFhirOperationOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An error, warning or information message that results from a system action.
    property issueList : TFhirOperationOutcomeIssueList read GetIssueList;
    property hasIssueList : boolean read GetHasIssueList;

  end;

  TFhirOperationOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeList;
    function GetCurrent : TFhirOperationOutcome;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcome read GetCurrent;
  end;

  TFhirOperationOutcomeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcome;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeList; Overload;
    function Clone : TFhirOperationOutcomeList; Overload;
    function GetEnumerator : TFhirOperationOutcomeListEnumerator;

    //  Add a FhirOperationOutcome to the end of the list.
    function Append : TFhirOperationOutcome;

    // Add an already existing FhirOperationOutcome to the end of the list.
    procedure AddItem(value : TFhirOperationOutcome); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcome) : Integer;

    // Insert FhirOperationOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcome;

    // Insert an existing FhirOperationOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcome);

    // Get the iIndexth FhirOperationOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcome);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcome;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationOutcomes[index : Integer] : TFhirOperationOutcome read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_PAYMENTNOTICE}

  // This resource provides the status of the payment for goods and services rendered, and the request and response resource references.
  TFhirPaymentNotice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FStatusDate : TFhirDate;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FPaymentStatus : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetStatusDate(value : TFhirDate);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPaymentStatus(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentNotice; overload;
    function Clone : TFhirPaymentNotice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The notice business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Reference of resource for which payment is being made. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Reference of resource for which payment is being made.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Reference of response to resource for which payment is being made. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // Reference of response to resource for which payment is being made.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to The date when the above payment action occurrred.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date when the above payment action occurrred.
    property statusDateElement : TFhirDate read FStatusDate write SetStatusDate;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The Insurer who is target  of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The payment status, typically paid: payment sent, cleared: payment received. (defined for API consistency)
    property paymentStatus : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;
    // The payment status, typically paid: payment sent, cleared: payment received.
    property paymentStatusElement : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;

  end;

  TFhirPaymentNoticeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentNoticeList;
    function GetCurrent : TFhirPaymentNotice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentNoticeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentNotice read GetCurrent;
  end;

  TFhirPaymentNoticeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentNotice;
    procedure SetItemN(index : Integer; value : TFhirPaymentNotice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentNoticeList; Overload;
    function Clone : TFhirPaymentNoticeList; Overload;
    function GetEnumerator : TFhirPaymentNoticeListEnumerator;

    //  Add a FhirPaymentNotice to the end of the list.
    function Append : TFhirPaymentNotice;

    // Add an already existing FhirPaymentNotice to the end of the list.
    procedure AddItem(value : TFhirPaymentNotice); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentNotice) : Integer;

    // Insert FhirPaymentNotice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentNotice;

    // Insert an existing FhirPaymentNotice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentNotice);

    // Get the iIndexth FhirPaymentNotice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentNotice);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentNotice;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentNotices[index : Integer] : TFhirPaymentNotice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

  // List of individual settlement amounts and the corresponding transaction.
  TFhirPaymentReconciliationDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FSubmitter : TFhirReference{TFhirOrganization};
    FPayee : TFhirReference{TFhirOrganization};
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetSubmitter(value : TFhirReference{TFhirOrganization});
    Procedure SetPayee(value : TFhirReference{TFhirOrganization});
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirMoney);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationDetail; overload;
    function Clone : TFhirPaymentReconciliationDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code to indicate the nature of the payment, adjustment, funds advance, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code to indicate the nature of the payment, adjustment, funds advance, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The claim or financial resource. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // The claim or financial resource.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to The claim response resource. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // The claim response resource.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to The Organization which submitted the claim or financial transaction. (defined for API consistency)
    property submitter : TFhirReference{TFhirOrganization} read FSubmitter write SetSubmitter;
    // The Organization which submitted the claim or financial transaction.
    property submitterElement : TFhirReference{TFhirOrganization} read FSubmitter write SetSubmitter;

    // Typed access to The organization which is receiving the payment. (defined for API consistency)
    property payee : TFhirReference{TFhirOrganization} read FPayee write SetPayee;
    // The organization which is receiving the payment.
    property payeeElement : TFhirReference{TFhirOrganization} read FPayee write SetPayee;

    // Typed access to The date of the invoice or financial resource.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date of the invoice or financial resource.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Amount paid for this detail. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Amount paid for this detail.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirPaymentReconciliationDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationDetailList;
    function GetCurrent : TFhirPaymentReconciliationDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationDetail read GetCurrent;
  end;

  TFhirPaymentReconciliationDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationDetail;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationDetailList; Overload;
    function Clone : TFhirPaymentReconciliationDetailList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;

    //  Add a FhirPaymentReconciliationDetail to the end of the list.
    function Append : TFhirPaymentReconciliationDetail;

    // Add an already existing FhirPaymentReconciliationDetail to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationDetail) : Integer;

    // Insert FhirPaymentReconciliationDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationDetail;

    // Insert an existing FhirPaymentReconciliationDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationDetail);

    // Get the iIndexth FhirPaymentReconciliationDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliationDetails[index : Integer] : TFhirPaymentReconciliationDetail read GetItemN write SetItemN; default;
  End;

  // Suite of notes.
  TFhirPaymentReconciliationProcessNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FText : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationProcessNote; overload;
    function Clone : TFhirPaymentReconciliationProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirPaymentReconciliationProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationProcessNoteList;
    function GetCurrent : TFhirPaymentReconciliationProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationProcessNote read GetCurrent;
  end;

  TFhirPaymentReconciliationProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationProcessNote;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationProcessNoteList; Overload;
    function Clone : TFhirPaymentReconciliationProcessNoteList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;

    //  Add a FhirPaymentReconciliationProcessNote to the end of the list.
    function Append : TFhirPaymentReconciliationProcessNote;

    // Add an already existing FhirPaymentReconciliationProcessNote to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationProcessNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationProcessNote) : Integer;

    // Insert FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationProcessNote;

    // Insert an existing FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationProcessNote);

    // Get the iIndexth FhirPaymentReconciliationProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationProcessNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationProcessNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliationProcessNotes[index : Integer] : TFhirPaymentReconciliationProcessNote read GetItemN write SetItemN; default;
  End;

  // This resource provides payment details and claim references supporting a bulk payment.
  TFhirPaymentReconciliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirProcessRequest};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FdetailList : TFhirPaymentReconciliationDetailList;
    FForm : TFhirCodeableConcept;
    FTotal : TFhirMoney;
    FprocessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirProcessRequest});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    function GetDetailList : TFhirPaymentReconciliationDetailList;
    function GetHasDetailList : Boolean;
    Procedure SetForm(value : TFhirCodeableConcept);
    Procedure SetTotal(value : TFhirMoney);
    function GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetHasProcessNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliation; overload;
    function Clone : TFhirPaymentReconciliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period of time for which payments have been gathered into this bulk payment for settlement. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time for which payments have been gathered into this bulk payment for settlement.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirProcessRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirProcessRequest} read FRequest write SetRequest;

    // Typed access to Transaction status: error, complete. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Transaction status: error, complete.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // List of individual settlement amounts and the corresponding transaction.
    property detailList : TFhirPaymentReconciliationDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Typed access to Total payment amount. (defined for API consistency)
    property total : TFhirMoney read FTotal write SetTotal;
    // Total payment amount.
    property totalElement : TFhirMoney read FTotal write SetTotal;

    // Suite of notes.
    property processNoteList : TFhirPaymentReconciliationProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

  end;

  TFhirPaymentReconciliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationList;
    function GetCurrent : TFhirPaymentReconciliation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliation read GetCurrent;
  end;

  TFhirPaymentReconciliationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliation;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationList; Overload;
    function Clone : TFhirPaymentReconciliationList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationListEnumerator;

    //  Add a FhirPaymentReconciliation to the end of the list.
    function Append : TFhirPaymentReconciliation;

    // Add an already existing FhirPaymentReconciliation to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliation) : Integer;

    // Insert FhirPaymentReconciliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliation;

    // Insert an existing FhirPaymentReconciliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliation);

    // Get the iIndexth FhirPaymentReconciliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliations[index : Integer] : TFhirPaymentReconciliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_PROCESSREQUEST}

  // List of top level items to be re-adjudicated, if none specified then the entire submission is re-adjudicated.
  TFhirProcessRequestItem = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirInteger;
    Procedure SetSequenceLinkId(value : TFhirInteger);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessRequestItem; overload;
    function Clone : TFhirProcessRequestItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirInteger read FSequenceLinkId write SetSequenceLinkId;

  end;

  TFhirProcessRequestItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessRequestItemList;
    function GetCurrent : TFhirProcessRequestItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessRequestItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessRequestItem read GetCurrent;
  end;

  TFhirProcessRequestItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessRequestItem;
    procedure SetItemN(index : Integer; value : TFhirProcessRequestItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessRequestItemList; Overload;
    function Clone : TFhirProcessRequestItemList; Overload;
    function GetEnumerator : TFhirProcessRequestItemListEnumerator;

    //  Add a FhirProcessRequestItem to the end of the list.
    function Append : TFhirProcessRequestItem;

    // Add an already existing FhirProcessRequestItem to the end of the list.
    procedure AddItem(value : TFhirProcessRequestItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessRequestItem) : Integer;

    // Insert FhirProcessRequestItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessRequestItem;

    // Insert an existing FhirProcessRequestItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessRequestItem);

    // Get the iIndexth FhirProcessRequestItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessRequestItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessRequestItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessRequestItems[index : Integer] : TFhirProcessRequestItem read GetItemN write SetItemN; default;
  End;

  // This resource provides the target, request and response, and action details for an action to be performed by the target on or about existing resources.
  TFhirProcessRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FAction : TFhirEnum;
    FTarget : TFhirReference{TFhirOrganization};
    FCreated : TFhirDateTime;
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FNullify : TFhirBoolean;
    FReference : TFhirString;
    FitemList : TFhirProcessRequestItemList;
    FincludeList : TFhirStringList;
    FexcludeList : TFhirStringList;
    FPeriod : TFhirPeriod;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirActionlistEnum;
    Procedure SetActionST(value : TFhirActionlistEnum);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetNullify(value : TFhirBoolean);
    Function GetNullifyST : Boolean;
    Procedure SetNullifyST(value : Boolean);
    Procedure SetReference(value : TFhirString);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    function GetItemList : TFhirProcessRequestItemList;
    function GetHasItemList : Boolean;
    function GetIncludeList : TFhirStringList;
    function GetHasIncludeList : Boolean;
    function GetExcludeList : TFhirStringList;
    function GetHasExcludeList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessRequest; overload;
    function Clone : TFhirProcessRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The ProcessRequest business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of processing action being requested, for example Reversal, Readjudication, StatusRequest,PendedRequest.
    property action : TFhirActionlistEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Typed access to The organization which is the target of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The organization which is the target of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The practitioner who is responsible for the action specified in this request. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the action specified in this request.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the action speccified in this request. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the action speccified in this request.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Reference of resource which is the target or subject of this action. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Reference of resource which is the target or subject of this action.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Reference of a prior response to resource which is the target or subject of this action. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // Reference of a prior response to resource which is the target or subject of this action.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to If true remove all history excluding audit.
    property nullify : Boolean read GetNullifyST write SetNullifyST;
    // If true remove all history excluding audit.
    property nullifyElement : TFhirBoolean read FNullify write SetNullify;

    // Typed access to A reference to supply which authenticates the process.
    property reference : String read GetReferenceST write SetReferenceST;
    // A reference to supply which authenticates the process.
    property referenceElement : TFhirString read FReference write SetReference;

    // List of top level items to be re-adjudicated, if none specified then the entire submission is re-adjudicated.
    property itemList : TFhirProcessRequestItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Names of resource types to include.
    property includeList : TFhirStringList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Names of resource types to exclude.
    property excludeList : TFhirStringList read GetExcludeList;
    property hasExcludeList : boolean read GetHasExcludeList;

    // Typed access to A period of time during which the fulfilling resources would have been created. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // A period of time during which the fulfilling resources would have been created.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirProcessRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessRequestList;
    function GetCurrent : TFhirProcessRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessRequest read GetCurrent;
  end;

  TFhirProcessRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessRequest;
    procedure SetItemN(index : Integer; value : TFhirProcessRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessRequestList; Overload;
    function Clone : TFhirProcessRequestList; Overload;
    function GetEnumerator : TFhirProcessRequestListEnumerator;

    //  Add a FhirProcessRequest to the end of the list.
    function Append : TFhirProcessRequest;

    // Add an already existing FhirProcessRequest to the end of the list.
    procedure AddItem(value : TFhirProcessRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessRequest) : Integer;

    // Insert FhirProcessRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessRequest;

    // Insert an existing FhirProcessRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessRequest);

    // Get the iIndexth FhirProcessRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessRequests[index : Integer] : TFhirProcessRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCESSREQUEST}

{$IFDEF FHIR_PROCESSRESPONSE}

  // Suite of processing notes or additional requirements if the processing has been held.
  TFhirProcessResponseProcessNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FText : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessResponseProcessNote; overload;
    function Clone : TFhirProcessResponseProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirProcessResponseProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessResponseProcessNoteList;
    function GetCurrent : TFhirProcessResponseProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessResponseProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessResponseProcessNote read GetCurrent;
  end;

  TFhirProcessResponseProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessResponseProcessNote;
    procedure SetItemN(index : Integer; value : TFhirProcessResponseProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessResponseProcessNoteList; Overload;
    function Clone : TFhirProcessResponseProcessNoteList; Overload;
    function GetEnumerator : TFhirProcessResponseProcessNoteListEnumerator;

    //  Add a FhirProcessResponseProcessNote to the end of the list.
    function Append : TFhirProcessResponseProcessNote;

    // Add an already existing FhirProcessResponseProcessNote to the end of the list.
    procedure AddItem(value : TFhirProcessResponseProcessNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessResponseProcessNote) : Integer;

    // Insert FhirProcessResponseProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessResponseProcessNote;

    // Insert an existing FhirProcessResponseProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessResponseProcessNote);

    // Get the iIndexth FhirProcessResponseProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessResponseProcessNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessResponseProcessNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessResponseProcessNotes[index : Integer] : TFhirProcessResponseProcessNote read GetItemN write SetItemN; default;
  End;

  // This resource provides processing status, errors and notes from the processing of a resource.
  TFhirProcessResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirReference};
    FOutcome : TFhirCodeableConcept;
    FDisposition : TFhirString;
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FForm : TFhirCodeableConcept;
    FprocessNoteList : TFhirProcessResponseProcessNoteList;
    FerrorList : TFhirCodeableConceptList;
    FcommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirProcessResponseProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetErrorList : TFhirCodeableConceptList;
    function GetHasErrorList : Boolean;
    function GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    function GetHasCommunicationRequestList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessResponse; overload;
    function Clone : TFhirProcessResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The organization who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Transaction status: error, complete, held. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Transaction status: error, complete, held.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication or processing.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication or processing.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Suite of processing notes or additional requirements if the processing has been held.
    property processNoteList : TFhirProcessResponseProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Processing errors.
    property errorList : TFhirCodeableConceptList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

    // Request for additional supporting or authorizing information, such as: documents, images or resources.
    property communicationRequestList : TFhirReferenceList{TFhirCommunicationRequest} read GetCommunicationRequestList;
    property hasCommunicationRequestList : boolean read GetHasCommunicationRequestList;

  end;

  TFhirProcessResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessResponseList;
    function GetCurrent : TFhirProcessResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessResponse read GetCurrent;
  end;

  TFhirProcessResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessResponse;
    procedure SetItemN(index : Integer; value : TFhirProcessResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessResponseList; Overload;
    function Clone : TFhirProcessResponseList; Overload;
    function GetEnumerator : TFhirProcessResponseListEnumerator;

    //  Add a FhirProcessResponse to the end of the list.
    function Append : TFhirProcessResponse;

    // Add an already existing FhirProcessResponse to the end of the list.
    procedure AddItem(value : TFhirProcessResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessResponse) : Integer;

    // Insert FhirProcessResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessResponse;

    // Insert an existing FhirProcessResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessResponse);

    // Get the iIndexth FhirProcessResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessResponses[index : Integer] : TFhirProcessResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCESSRESPONSE}

{$IFDEF FHIR_PROVENANCE}

  // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  protected
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirType;
    FOnBehalfOf : TFhirType;
    FRelatedAgentType : TFhirCodeableConcept;
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    Procedure SetWho(value : TFhirType);
    Procedure SetOnBehalfOf(value : TFhirType);
    Procedure SetRelatedAgentType(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The function of the agent with respect to the activity. The security role enabling the agent with respect to the activity.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to The individual, device or organization that participated in the event. (defined for API consistency)
    property who : TFhirType read FWho write SetWho;
    // The individual, device or organization that participated in the event.
    property whoElement : TFhirType read FWho write SetWho;

    // Typed access to The individual, device, or organization for whom the change was made. (defined for API consistency)
    property onBehalfOf : TFhirType read FOnBehalfOf write SetOnBehalfOf;
    // The individual, device, or organization for whom the change was made.
    property onBehalfOfElement : TFhirType read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to The type of relationship between agents. (defined for API consistency)
    property relatedAgentType : TFhirCodeableConcept read FRelatedAgentType write SetRelatedAgentType;
    // The type of relationship between agents.
    property relatedAgentTypeElement : TFhirCodeableConcept read FRelatedAgentType write SetRelatedAgentType;

  end;

  TFhirProvenanceAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;

  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;

    //  Add a FhirProvenanceAgent to the end of the list.
    function Append : TFhirProvenanceAgent;

    // Add an already existing FhirProvenanceAgent to the end of the list.
    procedure AddItem(value : TFhirProvenanceAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgent) : Integer;

    // Insert FhirProvenanceAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgent;

    // Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);

    // Get the iIndexth FhirProvenanceAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;

  // An entity used in this activity.
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FWhat : TFhirType;
    FagentList : TFhirProvenanceAgentList;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRoleEnum;
    Procedure SetRoleST(value : TFhirProvenanceEntityRoleEnum);
    Procedure SetWhat(value : TFhirType);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the entity was used during the activity.
    property role : TFhirProvenanceEntityRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. (defined for API consistency)
    property what : TFhirType read FWhat write SetWhat;
    // Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property whatElement : TFhirType read FWhat write SetWhat;

    // The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

  end;

  TFhirProvenanceEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;

  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;

    //  Add a FhirProvenanceEntity to the end of the list.
    function Append : TFhirProvenanceEntity;

    // Add an already existing FhirProvenanceEntity to the end of the list.
    procedure AddItem(value : TFhirProvenanceEntity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceEntity) : Integer;

    // Insert FhirProvenanceEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceEntity;

    // Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);

    // Get the iIndexth FhirProvenanceEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceEntity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;

  // Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
  TFhirProvenance = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList{TFhirReference};
    FPeriod : TFhirPeriod;
    FRecorded : TFhirInstant;
    FpolicyList : TFhirUriList;
    FLocation : TFhirReference{TFhirLocation};
    FreasonList : TFhirCodingList;
    FActivity : TFhirCoding;
    FagentList : TFhirProvenanceAgentList;
    FentityList : TFhirProvenanceEntityList;
    FsignatureList : TFhirSignatureList;
    function GetTargetList : TFhirReferenceList{TFhirReference};
    function GetHasTargetList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetRecorded(value : TFhirInstant);
    Function GetRecordedST : TFslDateTime;
    Procedure SetRecordedST(value : TFslDateTime);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetReasonList : TFhirCodingList;
    function GetHasReasonList : Boolean;
    Procedure SetActivity(value : TFhirCoding);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
    function GetEntityList : TFhirProvenanceEntityList;
    function GetHasEntityList : Boolean;
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenance; overload;
    function Clone : TFhirProvenance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Reference(s) that were generated or updated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    property targetList : TFhirReferenceList{TFhirReference} read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the activity occurred.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The instant of time at which the activity was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The instant of time at which the activity was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Where the activity occurred, if relevant. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the activity occurred, if relevant.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The reason that the activity was taking place.
    property reasonList : TFhirCodingList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. (defined for API consistency)
    property activity : TFhirCoding read FActivity write SetActivity;
    // An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities.
    property activityElement : TFhirCoding read FActivity write SetActivity;

    // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // An entity used in this activity.
    property entityList : TFhirProvenanceEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

    // A digital signature on the target Reference(s). The signer should match a Provenance.agent. The purpose of the signature is indicated.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirProvenanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceList;
    function GetCurrent : TFhirProvenance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenance read GetCurrent;
  end;

  TFhirProvenanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenance;
    procedure SetItemN(index : Integer; value : TFhirProvenance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceList; Overload;
    function Clone : TFhirProvenanceList; Overload;
    function GetEnumerator : TFhirProvenanceListEnumerator;

    //  Add a FhirProvenance to the end of the list.
    function Append : TFhirProvenance;

    // Add an already existing FhirProvenance to the end of the list.
    procedure AddItem(value : TFhirProvenance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenance) : Integer;

    // Insert FhirProvenance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenance;

    // Insert an existing FhirProvenance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenance);

    // Get the iIndexth FhirProvenance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenances[index : Integer] : TFhirProvenance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_RESEARCHSTUDY}

  // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
  TFhirResearchStudyArm = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyArm; overload;
    function Clone : TFhirResearchStudyArm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique, human-readable label for this arm of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this arm of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Categorization of study arm, e.g. experimental, active comparator, placebo comparater. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Categorization of study arm, e.g. experimental, active comparator, placebo comparater.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirResearchStudyArmListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyArmList;
    function GetCurrent : TFhirResearchStudyArm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyArmList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyArm read GetCurrent;
  end;

  TFhirResearchStudyArmList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchStudyArm;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyArm);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchStudyArmList; Overload;
    function Clone : TFhirResearchStudyArmList; Overload;
    function GetEnumerator : TFhirResearchStudyArmListEnumerator;

    //  Add a FhirResearchStudyArm to the end of the list.
    function Append : TFhirResearchStudyArm;

    // Add an already existing FhirResearchStudyArm to the end of the list.
    procedure AddItem(value : TFhirResearchStudyArm); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyArm) : Integer;

    // Insert FhirResearchStudyArm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyArm;

    // Insert an existing FhirResearchStudyArm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyArm);

    // Get the iIndexth FhirResearchStudyArm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyArm);

    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyArm;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirResearchStudyArms[index : Integer] : TFhirResearchStudyArm read GetItemN write SetItemN; default;
  End;

  // A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
  TFhirResearchStudy = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FTitle : TFhirString;
    FprotocolList : TFhirReferenceList{TFhirPlanDefinition};
    FpartOfList : TFhirReferenceList{TFhirResearchStudy};
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FfocusList : TFhirCodeableConceptList;
    FcontactList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FkeywordList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FenrollmentList : TFhirReferenceList{TFhirGroup};
    FPeriod : TFhirPeriod;
    FSponsor : TFhirReference{TFhirOrganization};
    FPrincipalInvestigator : TFhirReference{TFhirPractitioner};
    FsiteList : TFhirReferenceList{TFhirLocation};
    FReasonStopped : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FarmList : TFhirResearchStudyArmList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    function GetProtocolList : TFhirReferenceList{TFhirPlanDefinition};
    function GetHasProtocolList : Boolean;
    function GetPartOfList : TFhirReferenceList{TFhirResearchStudy};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirResearchStudyStatusEnum;
    Procedure SetStatusST(value : TFhirResearchStudyStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetFocusList : TFhirCodeableConceptList;
    function GetHasFocusList : Boolean;
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetKeywordList : TFhirCodeableConceptList;
    function GetHasKeywordList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    Procedure SetDescription(value : TFhirMarkdown);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetEnrollmentList : TFhirReferenceList{TFhirGroup};
    function GetHasEnrollmentList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetSponsor(value : TFhirReference{TFhirOrganization});
    Procedure SetPrincipalInvestigator(value : TFhirReference{TFhirPractitioner});
    function GetSiteList : TFhirReferenceList{TFhirLocation};
    function GetHasSiteList : Boolean;
    Procedure SetReasonStopped(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetArmList : TFhirResearchStudyArmList;
    function GetHasArmList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudy; overload;
    function Clone : TFhirResearchStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this research study by the sponsor or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A short, descriptive user-friendly label for the study.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive user-friendly label for the study.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The set of steps expected to be performed as part of the execution of the study.
    property protocolList : TFhirReferenceList{TFhirPlanDefinition} read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // A larger research study of which this particular study is a component or step.
    property partOfList : TFhirReferenceList{TFhirResearchStudy} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current state of the study.
    property status : TFhirResearchStudyStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Codes categorizing the type of study such as investigational vs. observational, type of blinding, type of randomization, safety vs. efficacy, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The condition(s), medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
    property focusList : TFhirCodeableConceptList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Contact details to assist a user in learning more about or engaging with the study.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Citations, references and other related documents.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Key terms to aid in searching for or filtering the study.
    property keywordList : TFhirCodeableConceptList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // Indicates a country, state or other region where the study is taking place.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A full description of how the study is being conducted.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A full description of how the study is being conducted.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Reference to a Group that defines the criteria for and quantity of subjects participating in the study.  E.g. " 200 female Europeans between the ages of 20 and 45 with early onset diabetes".
    property enrollmentList : TFhirReferenceList{TFhirGroup} read GetEnrollmentList;
    property hasEnrollmentList : boolean read GetHasEnrollmentList;

    // Typed access to Identifies the start date and the expected (or actual, depending on status) end date for the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the start date and the expected (or actual, depending on status) end date for the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The organization responsible for the execution of the study. (defined for API consistency)
    property sponsor : TFhirReference{TFhirOrganization} read FSponsor write SetSponsor;
    // The organization responsible for the execution of the study.
    property sponsorElement : TFhirReference{TFhirOrganization} read FSponsor write SetSponsor;

    // Typed access to Indicates the individual who has primary oversite of the execution of the study. (defined for API consistency)
    property principalInvestigator : TFhirReference{TFhirPractitioner} read FPrincipalInvestigator write SetPrincipalInvestigator;
    // Indicates the individual who has primary oversite of the execution of the study.
    property principalInvestigatorElement : TFhirReference{TFhirPractitioner} read FPrincipalInvestigator write SetPrincipalInvestigator;

    // Clinic, hospital or other healthcare location that is participating in the study.
    property siteList : TFhirReferenceList{TFhirLocation} read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A description and/or code explaining the premature termination of the study. (defined for API consistency)
    property reasonStopped : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;
    // A description and/or code explaining the premature termination of the study.
    property reasonStoppedElement : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;

    // Comments made about the event by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
    property armList : TFhirResearchStudyArmList read GetArmList;
    property hasArmList : boolean read GetHasArmList;

  end;

  TFhirResearchStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyList;
    function GetCurrent : TFhirResearchStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudy read GetCurrent;
  end;

  TFhirResearchStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchStudy;
    procedure SetItemN(index : Integer; value : TFhirResearchStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchStudyList; Overload;
    function Clone : TFhirResearchStudyList; Overload;
    function GetEnumerator : TFhirResearchStudyListEnumerator;

    //  Add a FhirResearchStudy to the end of the list.
    function Append : TFhirResearchStudy;

    // Add an already existing FhirResearchStudy to the end of the list.
    procedure AddItem(value : TFhirResearchStudy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudy) : Integer;

    // Insert FhirResearchStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudy;

    // Insert an existing FhirResearchStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudy);

    // Get the iIndexth FhirResearchStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirResearchStudies[index : Integer] : TFhirResearchStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSTUDY}

{$IFDEF FHIR_RESEARCHSUBJECT}

  // A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
  TFhirResearchSubject = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FStudy : TFhirReference{TFhirResearchStudy};
    FIndividual : TFhirReference{TFhirPatient};
    FAssignedArm : TFhirString;
    FActualArm : TFhirString;
    FConsent : TFhirReference{TFhirConsent};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirResearchSubjectStatusEnum;
    Procedure SetStatusST(value : TFhirResearchSubjectStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetStudy(value : TFhirReference{TFhirResearchStudy});
    Procedure SetIndividual(value : TFhirReference{TFhirPatient});
    Procedure SetAssignedArm(value : TFhirString);
    Function GetAssignedArmST : String;
    Procedure SetAssignedArmST(value : String);
    Procedure SetActualArm(value : TFhirString);
    Function GetActualArmST : String;
    Procedure SetActualArmST(value : String);
    Procedure SetConsent(value : TFhirReference{TFhirConsent});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchSubject; overload;
    function Clone : TFhirResearchSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifiers assigned to this research study by the sponsor or other systems. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifiers assigned to this research study by the sponsor or other systems.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The current state of the subject.
    property status : TFhirResearchSubjectStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The dates the subject began and ended their participation in the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The dates the subject began and ended their participation in the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Reference to the study the subject is participating in. (defined for API consistency)
    property study : TFhirReference{TFhirResearchStudy} read FStudy write SetStudy;
    // Reference to the study the subject is participating in.
    property studyElement : TFhirReference{TFhirResearchStudy} read FStudy write SetStudy;

    // Typed access to The record of the person or animal who is involved in the study. (defined for API consistency)
    property individual : TFhirReference{TFhirPatient} read FIndividual write SetIndividual;
    // The record of the person or animal who is involved in the study.
    property individualElement : TFhirReference{TFhirPatient} read FIndividual write SetIndividual;

    // Typed access to The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArm : String read GetAssignedArmST write SetAssignedArmST;
    // The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArmElement : TFhirString read FAssignedArm write SetAssignedArm;

    // Typed access to The name of the arm in the study the subject actually followed as part of this study.
    property actualArm : String read GetActualArmST write SetActualArmST;
    // The name of the arm in the study the subject actually followed as part of this study.
    property actualArmElement : TFhirString read FActualArm write SetActualArm;

    // Typed access to A record of the patient's informed agreement to participate in the study. (defined for API consistency)
    property consent : TFhirReference{TFhirConsent} read FConsent write SetConsent;
    // A record of the patient's informed agreement to participate in the study.
    property consentElement : TFhirReference{TFhirConsent} read FConsent write SetConsent;

  end;

  TFhirResearchSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchSubjectList;
    function GetCurrent : TFhirResearchSubject;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchSubject read GetCurrent;
  end;

  TFhirResearchSubjectList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchSubject;
    procedure SetItemN(index : Integer; value : TFhirResearchSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchSubjectList; Overload;
    function Clone : TFhirResearchSubjectList; Overload;
    function GetEnumerator : TFhirResearchSubjectListEnumerator;

    //  Add a FhirResearchSubject to the end of the list.
    function Append : TFhirResearchSubject;

    // Add an already existing FhirResearchSubject to the end of the list.
    procedure AddItem(value : TFhirResearchSubject); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchSubject) : Integer;

    // Insert FhirResearchSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchSubject;

    // Insert an existing FhirResearchSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchSubject);

    // Get the iIndexth FhirResearchSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchSubject);

    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchSubject;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirResearchSubjects[index : Integer] : TFhirResearchSubject read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSUBJECT}

{$IFDEF FHIR_SUBSCRIPTION}

  // Details where to send notifications when resources are received that meet the criteria.
  TFhirSubscriptionChannel = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FEndpoint : TFhirUri;
    FPayload : TFhirString;
    FheaderList : TFhirStringList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSubscriptionChannelTypeEnum;
    Procedure SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetPayload(value : TFhirString);
    Function GetPayloadST : String;
    Procedure SetPayloadST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionChannel; overload;
    function Clone : TFhirSubscriptionChannel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of channel to send notifications on.
    property type_ : TFhirSubscriptionChannelTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri that describes the actual end-point to send messages to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // The uri that describes the actual end-point to send messages to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

    // Typed access to The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification.
    property payload : String read GetPayloadST write SetPayloadST;
    // The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification.
    property payloadElement : TFhirString read FPayload write SetPayload;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirSubscriptionChannelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionChannelList;
    function GetCurrent : TFhirSubscriptionChannel;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionChannelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionChannel read GetCurrent;
  end;

  TFhirSubscriptionChannelList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscriptionChannel;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionChannel);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionChannelList; Overload;
    function Clone : TFhirSubscriptionChannelList; Overload;
    function GetEnumerator : TFhirSubscriptionChannelListEnumerator;

    //  Add a FhirSubscriptionChannel to the end of the list.
    function Append : TFhirSubscriptionChannel;

    // Add an already existing FhirSubscriptionChannel to the end of the list.
    procedure AddItem(value : TFhirSubscriptionChannel); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionChannel) : Integer;

    // Insert FhirSubscriptionChannel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionChannel;

    // Insert an existing FhirSubscriptionChannel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionChannel);

    // Get the iIndexth FhirSubscriptionChannel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionChannel);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionChannel;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSubscriptionChannels[index : Integer] : TFhirSubscriptionChannel read GetItemN write SetItemN; default;
  End;

  // The subscription resource is used to define a push based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system is able to take an appropriate action.
  TFhirSubscription = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FcontactList : TFhirContactPointList;
    FEnd_ : TFhirInstant;
    FReason : TFhirString;
    FCriteria : TFhirString;
    FError : TFhirString;
    FChannel : TFhirSubscriptionChannel;
    FtagList : TFhirCodingList;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSubscriptionStatusEnum;
    Procedure SetStatusST(value : TFhirSubscriptionStatusEnum);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    Procedure SetReason(value : TFhirString);
    Function GetReasonST : String;
    Procedure SetReasonST(value : String);
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);
    Procedure SetError(value : TFhirString);
    Function GetErrorST : String;
    Procedure SetErrorST(value : String);
    Procedure SetChannel(value : TFhirSubscriptionChannel);
    function GetTagList : TFhirCodingList;
    function GetHasTagList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscription; overload;
    function Clone : TFhirSubscription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The time for the server to turn the subscription off.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The time for the server to turn the subscription off.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to A description of why this subscription is defined.
    property reason : String read GetReasonST write SetReasonST;
    // A description of why this subscription is defined.
    property reasonElement : TFhirString read FReason write SetReason;

    // Typed access to The rules that the server should use to determine when to generate notifications for this subscription.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The rules that the server should use to determine when to generate notifications for this subscription.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Typed access to A record of the last error that occurred when the server processed a notification.
    property error : String read GetErrorST write SetErrorST;
    // A record of the last error that occurred when the server processed a notification.
    property errorElement : TFhirString read FError write SetError;

    // Typed access to Details where to send notifications when resources are received that meet the criteria. (defined for API consistency)
    property channel : TFhirSubscriptionChannel read FChannel write SetChannel;
    // Details where to send notifications when resources are received that meet the criteria.
    property channelElement : TFhirSubscriptionChannel read FChannel write SetChannel;

    // A tag to add to any resource that matches the criteria, after the subscription is processed.
    property tagList : TFhirCodingList read GetTagList;
    property hasTagList : boolean read GetHasTagList;

  end;

  TFhirSubscriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionList;
    function GetCurrent : TFhirSubscription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscription read GetCurrent;
  end;

  TFhirSubscriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscription;
    procedure SetItemN(index : Integer; value : TFhirSubscription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionList; Overload;
    function Clone : TFhirSubscriptionList; Overload;
    function GetEnumerator : TFhirSubscriptionListEnumerator;

    //  Add a FhirSubscription to the end of the list.
    function Append : TFhirSubscription;

    // Add an already existing FhirSubscription to the end of the list.
    procedure AddItem(value : TFhirSubscription); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscription) : Integer;

    // Insert FhirSubscription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscription;

    // Insert an existing FhirSubscription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscription);

    // Get the iIndexth FhirSubscription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscription);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscription;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSubscriptions[index : Integer] : TFhirSubscription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTION}

{$IFDEF FHIR_TASK}

  // The creator of the task.
  TFhirTaskRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskRequester; overload;
    function Clone : TFhirTaskRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who initiated the task. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner, etc. who initiated the task.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of when they initiated the task. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of when they initiated the task.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirTaskRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskRequesterList;
    function GetCurrent : TFhirTaskRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskRequester read GetCurrent;
  end;

  TFhirTaskRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskRequester;
    procedure SetItemN(index : Integer; value : TFhirTaskRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskRequesterList; Overload;
    function Clone : TFhirTaskRequesterList; Overload;
    function GetEnumerator : TFhirTaskRequesterListEnumerator;

    //  Add a FhirTaskRequester to the end of the list.
    function Append : TFhirTaskRequester;

    // Add an already existing FhirTaskRequester to the end of the list.
    procedure AddItem(value : TFhirTaskRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskRequester) : Integer;

    // Insert FhirTaskRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskRequester;

    // Insert an existing FhirTaskRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskRequester);

    // Get the iIndexth FhirTaskRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTaskRequesters[index : Integer] : TFhirTaskRequester read GetItemN write SetItemN; default;
  End;

  // If the Task.focus is a request resource and the task is seeking fulfillment (i.e is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
  TFhirTaskRestriction = class (TFhirBackboneElement)
  protected
    FRepetitions : TFhirPositiveInt;
    FPeriod : TFhirPeriod;
    FrecipientList : TFhirReferenceList{Resource};
    Procedure SetRepetitions(value : TFhirPositiveInt);
    Function GetRepetitionsST : String;
    Procedure SetRepetitionsST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskRestriction; overload;
    function Clone : TFhirTaskRestriction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates the number of times the requested action should occur.
    property repetitions : String read GetRepetitionsST write SetRepetitionsST;
    // Indicates the number of times the requested action should occur.
    property repetitionsElement : TFhirPositiveInt read FRepetitions write SetRepetitions;

    // Typed access to Over what time-period is fulfillment sought. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Over what time-period is fulfillment sought.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought?
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

  end;

  TFhirTaskRestrictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskRestrictionList;
    function GetCurrent : TFhirTaskRestriction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskRestrictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskRestriction read GetCurrent;
  end;

  TFhirTaskRestrictionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskRestriction;
    procedure SetItemN(index : Integer; value : TFhirTaskRestriction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskRestrictionList; Overload;
    function Clone : TFhirTaskRestrictionList; Overload;
    function GetEnumerator : TFhirTaskRestrictionListEnumerator;

    //  Add a FhirTaskRestriction to the end of the list.
    function Append : TFhirTaskRestriction;

    // Add an already existing FhirTaskRestriction to the end of the list.
    procedure AddItem(value : TFhirTaskRestriction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskRestriction) : Integer;

    // Insert FhirTaskRestriction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskRestriction;

    // Insert an existing FhirTaskRestriction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskRestriction);

    // Get the iIndexth FhirTaskRestriction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskRestriction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskRestriction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTaskRestrictions[index : Integer] : TFhirTaskRestriction read GetItemN write SetItemN; default;
  End;

  // Additional information that may be needed in the execution of the task.
  TFhirTaskInput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskInput; overload;
    function Clone : TFhirTaskInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code or description indicating how the input is intended to be used as part of the task execution. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code or description indicating how the input is intended to be used as part of the task execution.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the input parameter as a basic type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the input parameter as a basic type.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirTaskInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskInputList;
    function GetCurrent : TFhirTaskInput;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskInput read GetCurrent;
  end;

  TFhirTaskInputList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskInput;
    procedure SetItemN(index : Integer; value : TFhirTaskInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskInputList; Overload;
    function Clone : TFhirTaskInputList; Overload;
    function GetEnumerator : TFhirTaskInputListEnumerator;

    //  Add a FhirTaskInput to the end of the list.
    function Append : TFhirTaskInput;

    // Add an already existing FhirTaskInput to the end of the list.
    procedure AddItem(value : TFhirTaskInput); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskInput) : Integer;

    // Insert FhirTaskInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskInput;

    // Insert an existing FhirTaskInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskInput);

    // Get the iIndexth FhirTaskInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskInput);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskInput;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTaskInputs[index : Integer] : TFhirTaskInput read GetItemN write SetItemN; default;
  End;

  // Outputs produced by the Task.
  TFhirTaskOutput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskOutput; overload;
    function Clone : TFhirTaskOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the Output parameter. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The name of the Output parameter.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the Output parameter as a basic type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the Output parameter as a basic type.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirTaskOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskOutputList;
    function GetCurrent : TFhirTaskOutput;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskOutput read GetCurrent;
  end;

  TFhirTaskOutputList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskOutput;
    procedure SetItemN(index : Integer; value : TFhirTaskOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskOutputList; Overload;
    function Clone : TFhirTaskOutputList; Overload;
    function GetEnumerator : TFhirTaskOutputListEnumerator;

    //  Add a FhirTaskOutput to the end of the list.
    function Append : TFhirTaskOutput;

    // Add an already existing FhirTaskOutput to the end of the list.
    procedure AddItem(value : TFhirTaskOutput); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskOutput) : Integer;

    // Insert FhirTaskOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskOutput;

    // Insert an existing FhirTaskOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskOutput);

    // Get the iIndexth FhirTaskOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskOutput);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskOutput;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTaskOutputs[index : Integer] : TFhirTaskOutput read GetItemN write SetItemN; default;
  End;

  // A task to be performed.
  TFhirTask = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDefinition : TFhirType;
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FGroupIdentifier : TFhirIdentifier;
    FpartOfList : TFhirReferenceList{TFhirTask};
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FBusinessStatus : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FFocus : TFhirReference{TFhirReference};
    FFor_ : TFhirReference{TFhirReference};
    FContext : TFhirReference{Resource};
    FExecutionPeriod : TFhirPeriod;
    FAuthoredOn : TFhirDateTime;
    FLastModified : TFhirDateTime;
    FRequester : TFhirTaskRequester;
    FperformerTypeList : TFhirCodeableConceptList;
    FOwner : TFhirReference{Resource};
    FReason : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    FRestriction : TFhirTaskRestriction;
    FinputList : TFhirTaskInputList;
    FoutputList : TFhirTaskOutputList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDefinition(value : TFhirType);
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    function GetPartOfList : TFhirReferenceList{TFhirTask};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirTaskStatusEnum;
    Procedure SetStatusST(value : TFhirTaskStatusEnum);
    Procedure SetStatusReason(value : TFhirCodeableConcept);
    Procedure SetBusinessStatus(value : TFhirCodeableConcept);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirRequestIntentEnum;
    Procedure SetIntentST(value : TFhirRequestIntentEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetFocus(value : TFhirReference{TFhirReference});
    Procedure SetFor_(value : TFhirReference{TFhirReference});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetExecutionPeriod(value : TFhirPeriod);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetLastModified(value : TFhirDateTime);
    Function GetLastModifiedST : TFslDateTime;
    Procedure SetLastModifiedST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirTaskRequester);
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    Procedure SetOwner(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;
    Procedure SetRestriction(value : TFhirTaskRestriction);
    function GetInputList : TFhirTaskInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirTaskOutputList;
    function GetHasOutputList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTask; overload;
    function Clone : TFhirTask; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The business identifier for this task.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A reference to a formal or informal definition of the task.  For example, a protocol, a step within a defined workflow definition, etc. (defined for API consistency)
    property definition : TFhirType read FDefinition write SetDefinition;
    // A reference to a formal or informal definition of the task.  For example, a protocol, a step within a defined workflow definition, etc.
    property definitionElement : TFhirType read FDefinition write SetDefinition;

    // BasedOn refers to a higher-level authorization that triggered the creation of the task.  It references a "request" resource such as a ProcedureRequest, MedicationRequest, ProcedureRequest, CarePlan, etc. which is distinct from the "request" resource the task is seeking to fulfil.  This latter resource is referenced by FocusOn.  For example, based on a ProcedureRequest (= BasedOn), a task is created to fulfil a procedureRequest ( = FocusOn ) to collect a specimen from a patient.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to An identifier that links together multiple tasks and other requests that were created in the same context. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // An identifier that links together multiple tasks and other requests that were created in the same context.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Task that this particular task is part of.
    property partOfList : TFhirReferenceList{TFhirTask} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current status of the task.
    property status : TFhirTaskStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to An explanation as to why this task is held, failed, was refused, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // An explanation as to why this task is held, failed, was refused, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Contains business-specific nuances of the business state. (defined for API consistency)
    property businessStatus : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;
    // Contains business-specific nuances of the business state.
    property businessStatusElement : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;

    // Indicates the "level" of actionability associated with the Task.  I.e. Is this a proposed task, a planned task, an actionable task, etc.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the Task should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A name or code (or both) briefly describing what the task involves. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name or code (or both) briefly describing what the task involves.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A free-text description of what is to be performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free-text description of what is to be performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The request being actioned or the resource being manipulated by this task. (defined for API consistency)
    property focus : TFhirReference{TFhirReference} read FFocus write SetFocus;
    // The request being actioned or the resource being manipulated by this task.
    property focusElement : TFhirReference{TFhirReference} read FFocus write SetFocus;

    // Typed access to The entity who benefits from the performance of the service specified in the task (e.g., the patient). (defined for API consistency)
    property for_ : TFhirReference{TFhirReference} read FFor_ write SetFor_;
    // The entity who benefits from the performance of the service specified in the task (e.g., the patient).
    property for_Element : TFhirReference{TFhirReference} read FFor_ write SetFor_;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end). (defined for API consistency)
    property executionPeriod : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;
    // Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end).
    property executionPeriodElement : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;

    // Typed access to The date and time this task was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date and time this task was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The date and time of last modification to this task.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date and time of last modification to this task.
    property lastModifiedElement : TFhirDateTime read FLastModified write SetLastModified;

    // Typed access to The creator of the task. (defined for API consistency)
    property requester : TFhirTaskRequester read FRequester write SetRequester;
    // The creator of the task.
    property requesterElement : TFhirTaskRequester read FRequester write SetRequester;

    // The type of participant that can execute the task.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to Individual organization or Device currently responsible for task execution. (defined for API consistency)
    property owner : TFhirReference{Resource} read FOwner write SetOwner;
    // Individual organization or Device currently responsible for task execution.
    property ownerElement : TFhirReference{Resource} read FOwner write SetOwner;

    // Typed access to A description or code indicating why this task needs to be performed. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A description or code indicating why this task needs to be performed.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Free-text information captured about the task as it progresses.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Links to Provenance records for past versions of this Task that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the task.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Typed access to If the Task.focus is a request resource and the task is seeking fulfillment (i.e is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned. (defined for API consistency)
    property restriction : TFhirTaskRestriction read FRestriction write SetRestriction;
    // If the Task.focus is a request resource and the task is seeking fulfillment (i.e is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
    property restrictionElement : TFhirTaskRestriction read FRestriction write SetRestriction;

    // Additional information that may be needed in the execution of the task.
    property inputList : TFhirTaskInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Outputs produced by the Task.
    property outputList : TFhirTaskOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

  end;

  TFhirTaskListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskList;
    function GetCurrent : TFhirTask;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTask read GetCurrent;
  end;

  TFhirTaskList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTask;
    procedure SetItemN(index : Integer; value : TFhirTask);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskList; Overload;
    function Clone : TFhirTaskList; Overload;
    function GetEnumerator : TFhirTaskListEnumerator;

    //  Add a FhirTask to the end of the list.
    function Append : TFhirTask;

    // Add an already existing FhirTask to the end of the list.
    procedure AddItem(value : TFhirTask); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTask) : Integer;

    // Insert FhirTask before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTask;

    // Insert an existing FhirTask before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTask);

    // Get the iIndexth FhirTask. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTask);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTask;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTasks[index : Integer] : TFhirTask read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TASK}

{$IFDEF FHIR_TESTREPORT}

  // A participant in the test execution, either the execution engine, a client, or a server.
  TFhirTestReportParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    FDisplay : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirReportParticipantTypeEnum;
    Procedure SetType_ST(value : TFhirReportParticipantTypeEnum);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportParticipant; overload;
    function Clone : TFhirTestReportParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of participant.
    property type_ : TFhirReportParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri of the participant. An absolute URL is preferred.
    property uri : String read GetUriST write SetUriST;
    // The uri of the participant. An absolute URL is preferred.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to The display name of the participant.
    property display : String read GetDisplayST write SetDisplayST;
    // The display name of the participant.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirTestReportParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportParticipantList;
    function GetCurrent : TFhirTestReportParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportParticipant read GetCurrent;
  end;

  TFhirTestReportParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportParticipant;
    procedure SetItemN(index : Integer; value : TFhirTestReportParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportParticipantList; Overload;
    function Clone : TFhirTestReportParticipantList; Overload;
    function GetEnumerator : TFhirTestReportParticipantListEnumerator;

    //  Add a FhirTestReportParticipant to the end of the list.
    function Append : TFhirTestReportParticipant;

    // Add an already existing FhirTestReportParticipant to the end of the list.
    procedure AddItem(value : TFhirTestReportParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportParticipant) : Integer;

    // Insert FhirTestReportParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportParticipant;

    // Insert an existing FhirTestReportParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportParticipant);

    // Get the iIndexth FhirTestReportParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportParticipants[index : Integer] : TFhirTestReportParticipant read GetItemN write SetItemN; default;
  End;

  // The results of the series of required setup operations before the tests were executed.
  TFhirTestReportSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportSetupActionList;
    function GetActionList : TFhirTestReportSetupActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetup; overload;
    function Clone : TFhirTestReportSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupList;
    function GetCurrent : TFhirTestReportSetup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetup read GetCurrent;
  end;

  TFhirTestReportSetupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetup;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupList; Overload;
    function Clone : TFhirTestReportSetupList; Overload;
    function GetEnumerator : TFhirTestReportSetupListEnumerator;

    //  Add a FhirTestReportSetup to the end of the list.
    function Append : TFhirTestReportSetup;

    // Add an already existing FhirTestReportSetup to the end of the list.
    procedure AddItem(value : TFhirTestReportSetup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetup) : Integer;

    // Insert FhirTestReportSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetup;

    // Insert an existing FhirTestReportSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetup);

    // Get the iIndexth FhirTestReportSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportSetups[index : Integer] : TFhirTestReportSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    Procedure SetAssert(value : TFhirTestReportSetupActionAssert);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupAction; overload;
    function Clone : TFhirTestReportSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The operation performed. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // The operation performed.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionList;
    function GetCurrent : TFhirTestReportSetupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupAction read GetCurrent;
  end;

  TFhirTestReportSetupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionList; Overload;
    function Clone : TFhirTestReportSetupActionList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionListEnumerator;

    //  Add a FhirTestReportSetupAction to the end of the list.
    function Append : TFhirTestReportSetupAction;

    // Add an already existing FhirTestReportSetupAction to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupAction) : Integer;

    // Insert FhirTestReportSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupAction;

    // Insert an existing FhirTestReportSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupAction);

    // Get the iIndexth FhirTestReportSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportSetupActions[index : Integer] : TFhirTestReportSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation performed.
  TFhirTestReportSetupActionOperation = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirUri;
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportActionResultCodesEnum;
    Procedure SetResultST(value : TFhirReportActionResultCodesEnum);
    Procedure SetMessage(value : TFhirMarkdown);
    Function GetMessageST : String;
    Procedure SetMessageST(value : String);
    Procedure SetDetail(value : TFhirUri);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionOperation; overload;
    function Clone : TFhirTestReportSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The result of this operation.
    property result : TFhirReportActionResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirUri read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionOperationList;
    function GetCurrent : TFhirTestReportSetupActionOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionOperation read GetCurrent;
  end;

  TFhirTestReportSetupActionOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionOperationList; Overload;
    function Clone : TFhirTestReportSetupActionOperationList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;

    //  Add a FhirTestReportSetupActionOperation to the end of the list.
    function Append : TFhirTestReportSetupActionOperation;

    // Add an already existing FhirTestReportSetupActionOperation to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupActionOperation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionOperation) : Integer;

    // Insert FhirTestReportSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionOperation;

    // Insert an existing FhirTestReportSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionOperation);

    // Get the iIndexth FhirTestReportSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionOperation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionOperation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportSetupActionOperations[index : Integer] : TFhirTestReportSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // The results of the assertion performed on the previous operations.
  TFhirTestReportSetupActionAssert = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirString;
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportActionResultCodesEnum;
    Procedure SetResultST(value : TFhirReportActionResultCodesEnum);
    Procedure SetMessage(value : TFhirMarkdown);
    Function GetMessageST : String;
    Procedure SetMessageST(value : String);
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionAssert; overload;
    function Clone : TFhirTestReportSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The result of this assertion.
    property result : TFhirReportActionResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirString read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionAssertList;
    function GetCurrent : TFhirTestReportSetupActionAssert;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionAssert read GetCurrent;
  end;

  TFhirTestReportSetupActionAssertList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionAssertList; Overload;
    function Clone : TFhirTestReportSetupActionAssertList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;

    //  Add a FhirTestReportSetupActionAssert to the end of the list.
    function Append : TFhirTestReportSetupActionAssert;

    // Add an already existing FhirTestReportSetupActionAssert to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupActionAssert); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionAssert) : Integer;

    // Insert FhirTestReportSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionAssert;

    // Insert an existing FhirTestReportSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionAssert);

    // Get the iIndexth FhirTestReportSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionAssert);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionAssert;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportSetupActionAsserts[index : Integer] : TFhirTestReportSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test executed from the test script.
  TFhirTestReportTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestReportTestActionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestReportTestActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTest; overload;
    function Clone : TFhirTestReportTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestList;
    function GetCurrent : TFhirTestReportTest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTest read GetCurrent;
  end;

  TFhirTestReportTestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTest;
    procedure SetItemN(index : Integer; value : TFhirTestReportTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTestList; Overload;
    function Clone : TFhirTestReportTestList; Overload;
    function GetEnumerator : TFhirTestReportTestListEnumerator;

    //  Add a FhirTestReportTest to the end of the list.
    function Append : TFhirTestReportTest;

    // Add an already existing FhirTestReportTest to the end of the list.
    procedure AddItem(value : TFhirTestReportTest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTest) : Integer;

    // Insert FhirTestReportTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTest;

    // Insert an existing FhirTestReportTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTest);

    // Get the iIndexth FhirTestReportTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportTests[index : Integer] : TFhirTestReportTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    Procedure SetAssert(value : TFhirTestReportSetupActionAssert);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTestAction; overload;
    function Clone : TFhirTestReportTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestActionList;
    function GetCurrent : TFhirTestReportTestAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTestAction read GetCurrent;
  end;

  TFhirTestReportTestActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTestActionList; Overload;
    function Clone : TFhirTestReportTestActionList; Overload;
    function GetEnumerator : TFhirTestReportTestActionListEnumerator;

    //  Add a FhirTestReportTestAction to the end of the list.
    function Append : TFhirTestReportTestAction;

    // Add an already existing FhirTestReportTestAction to the end of the list.
    procedure AddItem(value : TFhirTestReportTestAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTestAction) : Integer;

    // Insert FhirTestReportTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTestAction;

    // Insert an existing FhirTestReportTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTestAction);

    // Get the iIndexth FhirTestReportTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTestAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTestAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportTestActions[index : Integer] : TFhirTestReportTestAction read GetItemN write SetItemN; default;
  End;

  // The results of the series of operations required to clean up after the all the tests were executed (successfully or otherwise).
  TFhirTestReportTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportTeardownActionList;
    function GetActionList : TFhirTestReportTeardownActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardown; overload;
    function Clone : TFhirTestReportTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestReportTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownList;
    function GetCurrent : TFhirTestReportTeardown;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardown read GetCurrent;
  end;

  TFhirTestReportTeardownList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTeardownList; Overload;
    function Clone : TFhirTestReportTeardownList; Overload;
    function GetEnumerator : TFhirTestReportTeardownListEnumerator;

    //  Add a FhirTestReportTeardown to the end of the list.
    function Append : TFhirTestReportTeardown;

    // Add an already existing FhirTestReportTeardown to the end of the list.
    procedure AddItem(value : TFhirTestReportTeardown); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardown) : Integer;

    // Insert FhirTestReportTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardown;

    // Insert an existing FhirTestReportTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardown);

    // Get the iIndexth FhirTestReportTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardown);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardown;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportTeardowns[index : Integer] : TFhirTestReportTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestReportTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardownAction; overload;
    function Clone : TFhirTestReportTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestReportTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownActionList;
    function GetCurrent : TFhirTestReportTeardownAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardownAction read GetCurrent;
  end;

  TFhirTestReportTeardownActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTeardownActionList; Overload;
    function Clone : TFhirTestReportTeardownActionList; Overload;
    function GetEnumerator : TFhirTestReportTeardownActionListEnumerator;

    //  Add a FhirTestReportTeardownAction to the end of the list.
    function Append : TFhirTestReportTeardownAction;

    // Add an already existing FhirTestReportTeardownAction to the end of the list.
    procedure AddItem(value : TFhirTestReportTeardownAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardownAction) : Integer;

    // Insert FhirTestReportTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardownAction;

    // Insert an existing FhirTestReportTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardownAction);

    // Get the iIndexth FhirTestReportTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardownAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardownAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReportTeardownActions[index : Integer] : TFhirTestReportTeardownAction read GetItemN write SetItemN; default;
  End;

  // A summary of information based on the results of executing a TestScript.
  TFhirTestReport = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FTestScript : TFhirReference{TFhirTestScript};
    FResult : TFhirEnum;
    FScore : TFhirDecimal;
    FTester : TFhirString;
    FIssued : TFhirDateTime;
    FparticipantList : TFhirTestReportParticipantList;
    FSetup : TFhirTestReportSetup;
    FtestList : TFhirTestReportTestList;
    FTeardown : TFhirTestReportTeardown;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirReportStatusCodesEnum;
    Procedure SetStatusST(value : TFhirReportStatusCodesEnum);
    Procedure SetTestScript(value : TFhirReference{TFhirTestScript});
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportResultCodesEnum;
    Procedure SetResultST(value : TFhirReportResultCodesEnum);
    Procedure SetScore(value : TFhirDecimal);
    Function GetScoreST : String;
    Procedure SetScoreST(value : String);
    Procedure SetTester(value : TFhirString);
    Function GetTesterST : String;
    Procedure SetTesterST(value : String);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    function GetParticipantList : TFhirTestReportParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetSetup(value : TFhirTestReportSetup);
    function GetTestList : TFhirTestReportTestList;
    function GetHasTestList : Boolean;
    Procedure SetTeardown(value : TFhirTestReportTeardown);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReport; overload;
    function Clone : TFhirTestReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier for the TestScript assigned for external purposes outside the context of FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for the TestScript assigned for external purposes outside the context of FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A free text natural language name identifying the executed TestScript.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the executed TestScript.
    property nameElement : TFhirString read FName write SetName;

    // The current state of this test report.
    property status : TFhirReportStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`. (defined for API consistency)
    property testScript : TFhirReference{TFhirTestScript} read FTestScript write SetTestScript;
    // Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
    property testScriptElement : TFhirReference{TFhirTestScript} read FTestScript write SetTestScript;

    // The overall result from the execution of the TestScript.
    property result : TFhirReportResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property score : String read GetScoreST write SetScoreST;
    // The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property scoreElement : TFhirDecimal read FScore write SetScore;

    // Typed access to Name of the tester producing this report (Organization or individual).
    property tester : String read GetTesterST write SetTesterST;
    // Name of the tester producing this report (Organization or individual).
    property testerElement : TFhirString read FTester write SetTester;

    // Typed access to When the TestScript was executed and this TestReport was generated.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When the TestScript was executed and this TestReport was generated.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // A participant in the test execution, either the execution engine, a client, or a server.
    property participantList : TFhirTestReportParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The results of the series of required setup operations before the tests were executed. (defined for API consistency)
    property setup : TFhirTestReportSetup read FSetup write SetSetup;
    // The results of the series of required setup operations before the tests were executed.
    property setupElement : TFhirTestReportSetup read FSetup write SetSetup;

    // A test executed from the test script.
    property testList : TFhirTestReportTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to The results of the series of operations required to clean up after the all the tests were executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestReportTeardown read FTeardown write SetTeardown;
    // The results of the series of operations required to clean up after the all the tests were executed (successfully or otherwise).
    property teardownElement : TFhirTestReportTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportList;
    function GetCurrent : TFhirTestReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReport read GetCurrent;
  end;

  TFhirTestReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReport;
    procedure SetItemN(index : Integer; value : TFhirTestReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportList; Overload;
    function Clone : TFhirTestReportList; Overload;
    function GetEnumerator : TFhirTestReportListEnumerator;

    //  Add a FhirTestReport to the end of the list.
    function Append : TFhirTestReport;

    // Add an already existing FhirTestReport to the end of the list.
    procedure AddItem(value : TFhirTestReport); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReport) : Integer;

    // Insert FhirTestReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReport;

    // Insert an existing FhirTestReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReport);

    // Get the iIndexth FhirTestReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReport);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReport;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestReports[index : Integer] : TFhirTestReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTREPORT}

implementation

uses
  fhir3_utilities;

{$IFDEF FHIR_PARAMETERS}

{ TFhirParametersParameter }

constructor TFhirParametersParameter.Create;
begin
  inherited;
end;

destructor TFhirParametersParameter.Destroy;
begin
  FName.free;
  FValue.free;
  FResource.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirParametersParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParametersParameter(oSource).nameElement.Clone;
  value := TFhirParametersParameter(oSource).value.Clone;
  resource := TFhirParametersParameter(oSource).resource.Clone;
  if (TFhirParametersParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirParametersParameterList.Create;
    FPartList.Assign(TFhirParametersParameter(oSource).FPartList);
  end;
end;

procedure TFhirParametersParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirParametersParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'part', '@Parameters.parameter', true, TFhirParametersParameter, FPartList.Link)){3};
end;

function TFhirParametersParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParametersParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParametersParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'part') then result := PartList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParametersParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'part') then result := '@Parameters.parameter'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParametersParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := nil{4x}
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParametersParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParametersParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParametersParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirParametersParameter.Link : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Link);
end;

function TFhirParametersParameter.Clone : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Clone);
end;

function TFhirParametersParameter.equals(other : TObject) : boolean;
var
  o : TFhirParametersParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParametersParameter)) then
    result := false
  else
  begin
    o := TFhirParametersParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirParametersParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue) and isEmptyProp(FResource) and isEmptyProp(FpartList);
end;

procedure TFhirParametersParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
  fields.add('resource');
  fields.add('part');
end;

{ TFhirParametersParameter }

Procedure TFhirParametersParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirParametersParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirParametersParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirParametersParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirParametersParameter.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirParametersParameter.GetPartList : TFhirParametersParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirParametersParameterList.Create;
  result := FPartList;
end;

Function TFhirParametersParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirParametersParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FpartList.sizeInBytes);
end;

{ TFhirParametersParameterListEnumerator }

Constructor TFhirParametersParameterListEnumerator.Create(list : TFhirParametersParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersParameterListEnumerator.GetCurrent : TFhirParametersParameter;
begin
  Result := FList[FIndex];
end;

function TFhirParametersParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersParameterList }
procedure TFhirParametersParameterList.AddItem(value: TFhirParametersParameter);
begin
  assert(value.ClassName = 'TFhirParametersParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParametersParameter');
  add(value);
end;

function TFhirParametersParameterList.Append: TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.ClearItems;
begin
  Clear;
end;

function TFhirParametersParameterList.GetEnumerator : TFhirParametersParameterListEnumerator;
begin
  result := TFhirParametersParameterListEnumerator.Create(self.link);
end;

function TFhirParametersParameterList.Clone: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Clone);
end;

function TFhirParametersParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersParameterList.GetItemN(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirParametersParameter;
end;
function TFhirParametersParameterList.IndexOf(value: TFhirParametersParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersParameterList.Insert(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.InsertItem(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  Inherited Insert(index, value);
end;

function TFhirParametersParameterList.Item(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.Link: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Link);
end;

procedure TFhirParametersParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersParameterList.SetItemByIndex(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  FhirParametersParameters[index] := value;
end;

procedure TFhirParametersParameterList.SetItemN(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirParameters }

constructor TFhirParameters.Create;
begin
  inherited;
end;

destructor TFhirParameters.Destroy;
begin
  FParameterList.Free;
  inherited;
end;

function TFhirParameters.GetResourceType : TFhirResourceType;
begin
  result := frtParameters;
end;

procedure TFhirParameters.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirParameters(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParametersParameterList.Create;
    FParameterList.Assign(TFhirParameters(oSource).FParameterList);
  end;
end;

procedure TFhirParameters.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirParameters.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirParametersParameter, FParameterList.Link)){3};
end;

function TFhirParameters.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirParameters.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParameters.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'parameter') then result := ParameterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameters.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameters.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameters.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameters.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParameters.fhirType : string;
begin
  result := 'Parameters';
end;

function TFhirParameters.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterList);
end;

function TFhirParameters.equals(other : TObject) : boolean;
var
  o : TFhirParameters;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameters)) then
    result := false
  else
  begin
    o := TFhirParameters(other);
    result := compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirParameters.Link : TFhirParameters;
begin
  result := TFhirParameters(inherited Link);
end;

function TFhirParameters.Clone : TFhirParameters;
begin
  result := TFhirParameters(inherited Clone);
end;

procedure TFhirParameters.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('parameter');
end;

{ TFhirParameters }

Function TFhirParameters.GetParameterList : TFhirParametersParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParametersParameterList.Create;
  result := FParameterList;
end;

Function TFhirParameters.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirParameters.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FparameterList.sizeInBytes);
end;

{ TFhirParametersListEnumerator }

Constructor TFhirParametersListEnumerator.Create(list : TFhirParametersList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersListEnumerator.GetCurrent : TFhirParameters;
begin
  Result := FList[FIndex];
end;

function TFhirParametersListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersList }
procedure TFhirParametersList.AddItem(value: TFhirParameters);
begin
  assert(value.ClassName = 'TFhirParameters', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameters');
  add(value);
end;

function TFhirParametersList.Append: TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.ClearItems;
begin
  Clear;
end;

function TFhirParametersList.GetEnumerator : TFhirParametersListEnumerator;
begin
  result := TFhirParametersListEnumerator.Create(self.link);
end;

function TFhirParametersList.Clone: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Clone);
end;

function TFhirParametersList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersList.GetItemN(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameters;
end;
function TFhirParametersList.IndexOf(value: TFhirParameters): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersList.Insert(index: Integer): TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.InsertItem(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  Inherited Insert(index, value);
end;

function TFhirParametersList.Item(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.Link: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Link);
end;

procedure TFhirParametersList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersList.SetItemByIndex(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  FhirParameters[index] := value;
end;

procedure TFhirParametersList.SetItemN(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

{ TFhirAuditEventAgent }

constructor TFhirAuditEventAgent.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgent.Destroy;
begin
  FRoleList.Free;
  FReference.free;
  FUserId.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FLocation.free;
  FPolicyList.Free;
  FMedia.free;
  FNetwork.free;
  FPurposeOfUseList.Free;
  inherited;
end;

procedure TFhirAuditEventAgent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAuditEventAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirAuditEventAgent(oSource).FRoleList);
  end;
  reference := TFhirAuditEventAgent(oSource).reference.Clone;
  userId := TFhirAuditEventAgent(oSource).userId.Clone;
  altIdElement := TFhirAuditEventAgent(oSource).altIdElement.Clone;
  nameElement := TFhirAuditEventAgent(oSource).nameElement.Clone;
  requestorElement := TFhirAuditEventAgent(oSource).requestorElement.Clone;
  location := TFhirAuditEventAgent(oSource).location.Clone;
  if (TFhirAuditEventAgent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirAuditEventAgent(oSource).FPolicyList);
  end;
  media := TFhirAuditEventAgent(oSource).media.Clone;
  network := TFhirAuditEventAgent(oSource).network.Clone;
  if (TFhirAuditEventAgent(oSource).FPurposeOfUseList = nil) then
  begin
    FPurposeOfUseList.free;
    FPurposeOfUseList := nil;
  end
  else
  begin
    if FPurposeOfUseList = nil then
      FPurposeOfUseList := TFhirCodeableConceptList.Create;
    FPurposeOfUseList.Assign(TFhirAuditEventAgent(oSource).FPurposeOfUseList);
  end;
end;

procedure TFhirAuditEventAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'userId') Then
     list.add(self.link, 'userId', FUserId.Link);
  if (child_name = 'altId') Then
     list.add(self.link, 'altId', FAltId.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'media') Then
     list.add(self.link, 'media', FMedia.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'purposeOfUse') Then
    list.addAll(self, 'purposeOfUse', FPurposeOfUseList);
end;

procedure TFhirAuditEventAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', false, TFhirReference{Resource}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'Identifier', false, TFhirIdentifier, FUserId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altId', 'string', false, TFhirString, FAltId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', false, TFhirBoolean, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', false, TFhirCoding, FMedia.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', false, TFhirAuditEventAgentNetwork, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfUse', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfUseList.Link)){3};
end;

function TFhirAuditEventAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'userId') then
  begin
    UserId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'altId') then
  begin
    AltIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    RequestorElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'media') then
  begin
    Media := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirAuditEventAgentNetwork{4b};
    result := propValue;
  end
  else if (propName = 'purposeOfUse') then
  begin
    PurposeOfUseList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAuditEventAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := RoleList.new(){2}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'userId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'altId') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'requestor') then result := TFhirBoolean.create() {5b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'media') then result := TFhirCoding.create(){4b}
  else if (propName = 'network') then result := TFhirAuditEventAgentNetwork.create(){4b}
  else if (propName = 'purposeOfUse') then result := PurposeOfUseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'userId') then result := 'Identifier'
  else if (propName = 'altId') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'requestor') then result := 'boolean'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'media') then result := 'Coding'
  else if (propName = 'network') then result := ''
  else if (propName = 'purposeOfUse') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'userId') then UserIdElement := nil
  else if (propName = 'altId') then AltIdElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'media') then MediaElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'purposeOfUse') then deletePropertyValue('purposeOfUse', PurposeOfUseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'userId') then UserIdElement := new as TFhirIdentifier{4}
  else if (propName = 'altId') then AltIdElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'requestor') then RequestorElement := asBoolean(new){5b}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'media') then MediaElement := new as TFhirCoding{4}
  else if (propName = 'network') then NetworkElement := new as TFhirAuditEventAgentNetwork{4}
  else if (propName = 'purposeOfUse') then replacePropertyValue('purposeOfUse', PurposeOfUseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirAuditEventAgent.Link : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Link);
end;

function TFhirAuditEventAgent.Clone : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Clone);
end;

function TFhirAuditEventAgent.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgent)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgent(other);
    result := compareDeep(roleList, o.roleList, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(userIdElement, o.userIdElement, true) and compareDeep(altIdElement, o.altIdElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(requestorElement, o.requestorElement, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(policyList, o.policyList, true) and
      compareDeep(mediaElement, o.mediaElement, true) and compareDeep(networkElement, o.networkElement, true) and
      compareDeep(purposeOfUseList, o.purposeOfUseList, true);
  end;
end;

function TFhirAuditEventAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FroleList) and isEmptyProp(FReference) and isEmptyProp(FUserId) and isEmptyProp(FAltId) and isEmptyProp(FName) and isEmptyProp(FRequestor) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FMedia) and isEmptyProp(FNetwork) and isEmptyProp(FpurposeOfUseList);
end;

procedure TFhirAuditEventAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
  fields.add('userId');
  fields.add('altId');
  fields.add('name');
  fields.add('requestor');
  fields.add('location');
  fields.add('policy');
  fields.add('media');
  fields.add('network');
  fields.add('purposeOfUse');
end;

{ TFhirAuditEventAgent }

Function TFhirAuditEventAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirAuditEventAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

Procedure TFhirAuditEventAgent.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirAuditEventAgent.SetUserId(value : TFhirIdentifier);
begin
  FUserId.free;
  FUserId := value;
end;

Procedure TFhirAuditEventAgent.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

Function TFhirAuditEventAgent.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := FAltId.value;
end;

Procedure TFhirAuditEventAgent.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

Procedure TFhirAuditEventAgent.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventAgent.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventAgent.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventAgent.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirAuditEventAgent.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

Procedure TFhirAuditEventAgent.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

Procedure TFhirAuditEventAgent.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirAuditEventAgent.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirAuditEventAgent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirAuditEventAgent.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirAuditEventAgent.SetNetwork(value : TFhirAuditEventAgentNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirAuditEventAgent.GetPurposeOfUseList : TFhirCodeableConceptList;
begin
  if FPurposeOfUseList = nil then
    FPurposeOfUseList := TFhirCodeableConceptList.Create;
  result := FPurposeOfUseList;
end;

Function TFhirAuditEventAgent.GetHasPurposeOfUseList : boolean;
begin
  result := (FPurposeOfUseList <> nil) and (FPurposeOfUseList.count > 0);
end;

function TFhirAuditEventAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FroleList.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FUserId.sizeInBytes);
  inc(result, FAltId.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FMedia.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FpurposeOfUseList.sizeInBytes);
end;

{ TFhirAuditEventAgentListEnumerator }

Constructor TFhirAuditEventAgentListEnumerator.Create(list : TFhirAuditEventAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentListEnumerator.GetCurrent : TFhirAuditEventAgent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventAgentList }
procedure TFhirAuditEventAgentList.AddItem(value: TFhirAuditEventAgent);
begin
  assert(value.ClassName = 'TFhirAuditEventAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgent');
  add(value);
end;

function TFhirAuditEventAgentList.Append: TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentList.GetEnumerator : TFhirAuditEventAgentListEnumerator;
begin
  result := TFhirAuditEventAgentListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentList.Clone: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Clone);
end;

function TFhirAuditEventAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentList.GetItemN(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgent;
end;
function TFhirAuditEventAgentList.IndexOf(value: TFhirAuditEventAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentList.Insert(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.InsertItem(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentList.Item(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.Link: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Link);
end;

procedure TFhirAuditEventAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  FhirAuditEventAgents[index] := value;
end;

procedure TFhirAuditEventAgentList.SetItemN(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventAgentNetwork }

constructor TFhirAuditEventAgentNetwork.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgentNetwork.Destroy;
begin
  FAddress.free;
  FType_.free;
  inherited;
end;

procedure TFhirAuditEventAgentNetwork.Assign(oSource : TFslObject);
begin
  inherited;
  addressElement := TFhirAuditEventAgentNetwork(oSource).addressElement.Clone;
  FType_ := TFhirAuditEventAgentNetwork(oSource).FType_.Link;
end;

procedure TFhirAuditEventAgentNetwork.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirAuditEventAgentNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'address', 'string', false, TFhirString, FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirAuditEventAgentNetwork.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'address') then
  begin
    AddressElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgentNetwork.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventAgentNetwork.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'address') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgentNetwork.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'address') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgentNetwork.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgentNetwork.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgentNetwork.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgentNetwork.fhirType : string;
begin
  result := 'network';
end;

function TFhirAuditEventAgentNetwork.Link : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Link);
end;

function TFhirAuditEventAgentNetwork.Clone : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Clone);
end;

function TFhirAuditEventAgentNetwork.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventAgentNetwork;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgentNetwork)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgentNetwork(other);
    result := compareDeep(addressElement, o.addressElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirAuditEventAgentNetwork.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAddress) and isEmptyProp(FType_);
end;

procedure TFhirAuditEventAgentNetwork.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('address');
  fields.add('type');
end;

{ TFhirAuditEventAgentNetwork }

Procedure TFhirAuditEventAgentNetwork.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirAuditEventAgentNetwork.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirAuditEventAgentNetwork.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

Procedure TFhirAuditEventAgentNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventAgentNetwork.GetType_ST : TFhirNetworkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNetworkTypeEnum(0)
  else
    result := TFhirNetworkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNetworkTypeEnum, FType_.value));
end;

Procedure TFhirAuditEventAgentNetwork.SetType_ST(value : TFhirNetworkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNetworkTypeEnum[value], CODES_TFhirNetworkTypeEnum[value]);
end;

function TFhirAuditEventAgentNetwork.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAddress.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirAuditEventAgentNetworkListEnumerator }

Constructor TFhirAuditEventAgentNetworkListEnumerator.Create(list : TFhirAuditEventAgentNetworkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentNetworkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentNetworkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentNetworkListEnumerator.GetCurrent : TFhirAuditEventAgentNetwork;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentNetworkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventAgentNetworkList }
procedure TFhirAuditEventAgentNetworkList.AddItem(value: TFhirAuditEventAgentNetwork);
begin
  assert(value.ClassName = 'TFhirAuditEventAgentNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgentNetwork');
  add(value);
end;

function TFhirAuditEventAgentNetworkList.Append: TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentNetworkList.GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;
begin
  result := TFhirAuditEventAgentNetworkListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentNetworkList.Clone: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Clone);
end;

function TFhirAuditEventAgentNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentNetworkList.GetItemN(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgentNetwork;
end;
function TFhirAuditEventAgentNetworkList.IndexOf(value: TFhirAuditEventAgentNetwork): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentNetworkList.Insert(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.InsertItem(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentNetworkList.Item(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.Link: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Link);
end;

procedure TFhirAuditEventAgentNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentNetworkList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  FhirAuditEventAgentNetworks[index] := value;
end;

procedure TFhirAuditEventAgentNetworkList.SetItemN(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventSource }

constructor TFhirAuditEventSource.Create;
begin
  inherited;
end;

destructor TFhirAuditEventSource.Destroy;
begin
  FSite.free;
  FIdentifier.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirAuditEventSource.Assign(oSource : TFslObject);
begin
  inherited;
  siteElement := TFhirAuditEventSource(oSource).siteElement.Clone;
  identifier := TFhirAuditEventSource(oSource).identifier.Clone;
  if (TFhirAuditEventSource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodingList.Create;
    FType_List.Assign(TFhirAuditEventSource(oSource).FType_List);
  end;
end;

procedure TFhirAuditEventSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
end;

procedure TFhirAuditEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', false, TFhirString, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', true, TFhirCoding, FType_List.Link)){3};
end;

function TFhirAuditEventSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'site') then
  begin
    SiteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirAuditEventSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'site') then result := TFhirString.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'site') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := asString(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventSource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirAuditEventSource.Link : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Link);
end;

function TFhirAuditEventSource.Clone : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Clone);
end;

function TFhirAuditEventSource.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventSource)) then
    result := false
  else
  begin
    o := TFhirAuditEventSource(other);
    result := compareDeep(siteElement, o.siteElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(type_List, o.type_List, true);
  end;
end;

function TFhirAuditEventSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSite) and isEmptyProp(FIdentifier) and isEmptyProp(Ftype_List);
end;

procedure TFhirAuditEventSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('site');
  fields.add('identifier');
  fields.add('type');
end;

{ TFhirAuditEventSource }

Procedure TFhirAuditEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirAuditEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := FSite.value;
end;

Procedure TFhirAuditEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirAuditEventSource.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirAuditEventSource.GetType_List : TFhirCodingList;
begin
  if FType_List = nil then
    FType_List := TFhirCodingList.Create;
  result := FType_List;
end;

Function TFhirAuditEventSource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirAuditEventSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSite.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
end;

{ TFhirAuditEventSourceListEnumerator }

Constructor TFhirAuditEventSourceListEnumerator.Create(list : TFhirAuditEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventSourceListEnumerator.GetCurrent : TFhirAuditEventSource;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventSourceList }
procedure TFhirAuditEventSourceList.AddItem(value: TFhirAuditEventSource);
begin
  assert(value.ClassName = 'TFhirAuditEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventSource');
  add(value);
end;

function TFhirAuditEventSourceList.Append: TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventSourceList.GetEnumerator : TFhirAuditEventSourceListEnumerator;
begin
  result := TFhirAuditEventSourceListEnumerator.Create(self.link);
end;

function TFhirAuditEventSourceList.Clone: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Clone);
end;

function TFhirAuditEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventSourceList.GetItemN(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventSource;
end;
function TFhirAuditEventSourceList.IndexOf(value: TFhirAuditEventSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventSourceList.Insert(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.InsertItem(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  Inherited Insert(index, value);
end;

function TFhirAuditEventSourceList.Item(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.Link: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Link);
end;

procedure TFhirAuditEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventSourceList.SetItemByIndex(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  FhirAuditEventSources[index] := value;
end;

procedure TFhirAuditEventSourceList.SetItemN(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntity }

constructor TFhirAuditEventEntity.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntity.Destroy;
begin
  FIdentifier.free;
  FReference.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSecurityLabelList.Free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirAuditEventEntity.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirAuditEventEntity(oSource).identifier.Clone;
  reference := TFhirAuditEventEntity(oSource).reference.Clone;
  type_ := TFhirAuditEventEntity(oSource).type_.Clone;
  role := TFhirAuditEventEntity(oSource).role.Clone;
  lifecycle := TFhirAuditEventEntity(oSource).lifecycle.Clone;
  if (TFhirAuditEventEntity(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirAuditEventEntity(oSource).FSecurityLabelList);
  end;
  nameElement := TFhirAuditEventEntity(oSource).nameElement.Clone;
  descriptionElement := TFhirAuditEventEntity(oSource).descriptionElement.Clone;
  queryElement := TFhirAuditEventEntity(oSource).queryElement.Clone;
  if (TFhirAuditEventEntity(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirAuditEventEntityDetailList.Create;
    FDetailList.Assign(TFhirAuditEventEntity(oSource).FDetailList);
  end;
end;

procedure TFhirAuditEventEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(self.link, 'lifecycle', FLifecycle.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'query') Then
     list.add(self.link, 'query', FQuery.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirAuditEventEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'Coding', false, TFhirCoding, FLifecycle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', false, TFhirBase64Binary, FQuery.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirAuditEventEntityDetail, FDetailList.Link)){3};
end;

function TFhirAuditEventEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'lifecycle') then
  begin
    Lifecycle := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'query') then
  begin
    QueryElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirAuditEventEntityDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirAuditEventEntityDetail){2a}
  else inherited;
end;

function TFhirAuditEventEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'role') then result := TFhirCoding.create(){4b}
  else if (propName = 'lifecycle') then result := TFhirCoding.create(){4b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'query') then result := TFhirBase64Binary.create() {5b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'role') then result := 'Coding'
  else if (propName = 'lifecycle') then result := 'Coding'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'query') then result := 'base64Binary'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'lifecycle') then LifecycleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'query') then QueryElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'role') then RoleElement := new as TFhirCoding{4}
  else if (propName = 'lifecycle') then LifecycleElement := new as TFhirCoding{4}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'query') then QueryElement := asBase64Binary(new){5b}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntity.fhirType : string;
begin
  result := 'entity';
end;

function TFhirAuditEventEntity.Link : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Link);
end;

function TFhirAuditEventEntity.Clone : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Clone);
end;

function TFhirAuditEventEntity.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntity)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntity(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true) and
      compareDeep(lifecycleElement, o.lifecycleElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(queryElement, o.queryElement, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirAuditEventEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FReference) and isEmptyProp(FType_) and isEmptyProp(FRole) and isEmptyProp(FLifecycle) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FQuery) and isEmptyProp(FdetailList);
end;

procedure TFhirAuditEventEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('reference');
  fields.add('type');
  fields.add('role');
  fields.add('lifecycle');
  fields.add('securityLabel');
  fields.add('name');
  fields.add('description');
  fields.add('query');
  fields.add('detail');
end;

{ TFhirAuditEventEntity }

Procedure TFhirAuditEventEntity.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirAuditEventEntity.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirAuditEventEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAuditEventEntity.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirAuditEventEntity.SetLifecycle(value : TFhirCoding);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirAuditEventEntity.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirAuditEventEntity.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Procedure TFhirAuditEventEntity.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventEntity.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventEntity.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventEntity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAuditEventEntity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAuditEventEntity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAuditEventEntity.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirAuditEventEntity.GetQueryST : TBytes;
begin
  if FQuery = nil then
    result := nil
  else
    result := FQuery.value;
end;

Procedure TFhirAuditEventEntity.SetQueryST(value : TBytes);
begin
  if value <> nil then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := nil;
end;

Function TFhirAuditEventEntity.GetDetailList : TFhirAuditEventEntityDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirAuditEventEntityDetailList.Create;
  result := FDetailList;
end;

Function TFhirAuditEventEntity.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirAuditEventEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FLifecycle.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FQuery.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirAuditEventEntityListEnumerator }

Constructor TFhirAuditEventEntityListEnumerator.Create(list : TFhirAuditEventEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityListEnumerator.GetCurrent : TFhirAuditEventEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventEntityList }
procedure TFhirAuditEventEntityList.AddItem(value: TFhirAuditEventEntity);
begin
  assert(value.ClassName = 'TFhirAuditEventEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntity');
  add(value);
end;

function TFhirAuditEventEntityList.Append: TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityList.GetEnumerator : TFhirAuditEventEntityListEnumerator;
begin
  result := TFhirAuditEventEntityListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityList.Clone: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Clone);
end;

function TFhirAuditEventEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityList.GetItemN(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntity;
end;
function TFhirAuditEventEntityList.IndexOf(value: TFhirAuditEventEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityList.Insert(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.InsertItem(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityList.Item(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.Link: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Link);
end;

procedure TFhirAuditEventEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  FhirAuditEventEntities[index] := value;
end;

procedure TFhirAuditEventEntityList.SetItemN(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntityDetail }

constructor TFhirAuditEventEntityDetail.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntityDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirAuditEventEntityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirAuditEventEntityDetail(oSource).type_Element.Clone;
  valueElement := TFhirAuditEventEntityDetail(oSource).valueElement.Clone;
end;

procedure TFhirAuditEventEntityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirAuditEventEntityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', false, TFhirBase64Binary, FValue.Link));{2}
end;

function TFhirAuditEventEntityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventEntityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'string'
  else if (propName = 'value') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asString(new){5b}
  else if (propName = 'value') then ValueElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntityDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirAuditEventEntityDetail.Link : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Link);
end;

function TFhirAuditEventEntityDetail.Clone : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Clone);
end;

function TFhirAuditEventEntityDetail.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventEntityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntityDetail)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntityDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirAuditEventEntityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirAuditEventEntityDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
end;

{ TFhirAuditEventEntityDetail }

Procedure TFhirAuditEventEntityDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventEntityDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirAuditEventEntityDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirAuditEventEntityDetail.SetValue(value : TFhirBase64Binary);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirAuditEventEntityDetail.GetValueST : TBytes;
begin
  if FValue = nil then
    result := nil
  else
    result := FValue.value;
end;

Procedure TFhirAuditEventEntityDetail.SetValueST(value : TBytes);
begin
  if value <> nil then
  begin
    if FValue = nil then
      FValue := TFhirBase64Binary.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := nil;
end;

function TFhirAuditEventEntityDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirAuditEventEntityDetailListEnumerator }

Constructor TFhirAuditEventEntityDetailListEnumerator.Create(list : TFhirAuditEventEntityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityDetailListEnumerator.GetCurrent : TFhirAuditEventEntityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventEntityDetailList }
procedure TFhirAuditEventEntityDetailList.AddItem(value: TFhirAuditEventEntityDetail);
begin
  assert(value.ClassName = 'TFhirAuditEventEntityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntityDetail');
  add(value);
end;

function TFhirAuditEventEntityDetailList.Append: TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityDetailList.GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
begin
  result := TFhirAuditEventEntityDetailListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityDetailList.Clone: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Clone);
end;

function TFhirAuditEventEntityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityDetailList.GetItemN(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntityDetail;
end;
function TFhirAuditEventEntityDetailList.IndexOf(value: TFhirAuditEventEntityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityDetailList.Insert(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.InsertItem(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityDetailList.Item(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.Link: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Link);
end;

procedure TFhirAuditEventEntityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityDetailList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  FhirAuditEventEntityDetails[index] := value;
end;

procedure TFhirAuditEventEntityDetailList.SetItemN(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEvent }

constructor TFhirAuditEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FRecorded.free;
  FOutcome.free;
  FOutcomeDesc.free;
  FPurposeOfEventList.Free;
  FAgentList.Free;
  FSource.free;
  FEntityList.Free;
  inherited;
end;

function TFhirAuditEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAuditEvent;
end;

procedure TFhirAuditEvent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEvent(oSource).type_.Clone;
  if (TFhirAuditEvent(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodingList.Create;
    FSubtypeList.Assign(TFhirAuditEvent(oSource).FSubtypeList);
  end;
  FAction := TFhirAuditEvent(oSource).FAction.Link;
  recordedElement := TFhirAuditEvent(oSource).recordedElement.Clone;
  FOutcome := TFhirAuditEvent(oSource).FOutcome.Link;
  outcomeDescElement := TFhirAuditEvent(oSource).outcomeDescElement.Clone;
  if (TFhirAuditEvent(oSource).FPurposeOfEventList = nil) then
  begin
    FPurposeOfEventList.free;
    FPurposeOfEventList := nil;
  end
  else
  begin
    if FPurposeOfEventList = nil then
      FPurposeOfEventList := TFhirCodeableConceptList.Create;
    FPurposeOfEventList.Assign(TFhirAuditEvent(oSource).FPurposeOfEventList);
  end;
  if (TFhirAuditEvent(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirAuditEventAgentList.Create;
    FAgentList.Assign(TFhirAuditEvent(oSource).FAgentList);
  end;
  source := TFhirAuditEvent(oSource).source.Clone;
  if (TFhirAuditEvent(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirAuditEventEntityList.Create;
    FEntityList.Assign(TFhirAuditEvent(oSource).FEntityList);
  end;
end;

procedure TFhirAuditEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(self.link, 'outcomeDesc', FOutcomeDesc.Link);
  if (child_name = 'purposeOfEvent') Then
    list.addAll(self, 'purposeOfEvent', FPurposeOfEventList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
end;

procedure TFhirAuditEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'Coding', true, TFhirCoding, FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFHIREnum, FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', false, TFhirString, FOutcomeDesc.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfEvent', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirAuditEventAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirAuditEventSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'entity', '', true, TFhirAuditEventEntity, FEntityList.Link)){3};
end;

function TFhirAuditEvent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, propValue);
    result := propValue
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'outcomeDesc') then
  begin
    OutcomeDescElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'purposeOfEvent') then
  begin
    PurposeOfEventList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirAuditEventAgent){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirAuditEventSource{4b};
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirAuditEventEntity){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAuditEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirAuditEventAgent){2a}
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirAuditEventEntity){2a}
  else inherited;
end;

function TFhirAuditEvent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'subtype') then result := SubtypeList.new(){2}
  else if (propName = 'recorded') then result := TFhirInstant.create() {5b}
  else if (propName = 'outcomeDesc') then result := TFhirString.create() {5b}
  else if (propName = 'purposeOfEvent') then result := PurposeOfEventList.new(){2}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'source') then result := TFhirAuditEventSource.create(){4b}
  else if (propName = 'entity') then result := EntityList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'subtype') then result := 'Coding'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'outcomeDesc') then result := 'string'
  else if (propName = 'purposeOfEvent') then result := 'CodeableConcept'
  else if (propName = 'agent') then result := ''
  else if (propName = 'source') then result := ''
  else if (propName = 'entity') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEvent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value) {2}
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'outcomeDesc') then OutcomeDescElement := nil
  else if (propName = 'purposeOfEvent') then deletePropertyValue('purposeOfEvent', PurposeOfEventList, value) {2}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new) {2}
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, new){4}
  else if (propName = 'recorded') then RecordedElement := asInstant(new){5b}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, new){4}
  else if (propName = 'outcomeDesc') then OutcomeDescElement := asString(new){5b}
  else if (propName = 'purposeOfEvent') then replacePropertyValue('purposeOfEvent', PurposeOfEventList, existing, new) {2}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'source') then SourceElement := new as TFhirAuditEventSource{4}
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subtype') then SubtypeList.move(source, destination){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'entity') then EntityList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEvent.fhirType : string;
begin
  result := 'AuditEvent';
end;

function TFhirAuditEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FsubtypeList) and isEmptyProp(FAction) and isEmptyProp(FRecorded) and isEmptyProp(FOutcome) and isEmptyProp(FOutcomeDesc) and isEmptyProp(FpurposeOfEventList) and isEmptyProp(FagentList) and isEmptyProp(FSource) and isEmptyProp(FentityList);
end;

function TFhirAuditEvent.equals(other : TObject) : boolean;
var
  o : TFhirAuditEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEvent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeList, o.subtypeList, true) and
      compareDeep(actionElement, o.actionElement, true) and compareDeep(recordedElement, o.recordedElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(outcomeDescElement, o.outcomeDescElement, true) and
      compareDeep(purposeOfEventList, o.purposeOfEventList, true) and compareDeep(agentList, o.agentList, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(entityList, o.entityList, true);
  end;
end;

function TFhirAuditEvent.Link : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Link);
end;

function TFhirAuditEvent.Clone : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Clone);
end;

procedure TFhirAuditEvent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('type');
  fields.add('subtype');
  fields.add('action');
  fields.add('recorded');
  fields.add('outcome');
  fields.add('outcomeDesc');
  fields.add('purposeOfEvent');
  fields.add('agent');
  fields.add('source');
  fields.add('entity');
end;

{ TFhirAuditEvent }

Procedure TFhirAuditEvent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEvent.GetSubtypeList : TFhirCodingList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodingList.Create;
  result := FSubtypeList;
end;

Function TFhirAuditEvent.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

Procedure TFhirAuditEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirAuditEvent.GetActionST : TFhirAuditEventActionEnum;
begin
  if FAction = nil then
    result := TFhirAuditEventActionEnum(0)
  else
    result := TFhirAuditEventActionEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventActionEnum, FAction.value));
end;

Procedure TFhirAuditEvent.SetActionST(value : TFhirAuditEventActionEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[value], CODES_TFhirAuditEventActionEnum[value]);
end;

Procedure TFhirAuditEvent.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

Function TFhirAuditEvent.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

Procedure TFhirAuditEvent.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

Procedure TFhirAuditEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirAuditEvent.GetOutcomeST : TFhirAuditEventOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirAuditEventOutcomeEnum(0)
  else
    result := TFhirAuditEventOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventOutcomeEnum, FOutcome.value));
end;

Procedure TFhirAuditEvent.SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventOutcomeEnum[value], CODES_TFhirAuditEventOutcomeEnum[value]);
end;

Procedure TFhirAuditEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirAuditEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := FOutcomeDesc.value;
end;

Procedure TFhirAuditEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;

Function TFhirAuditEvent.GetPurposeOfEventList : TFhirCodeableConceptList;
begin
  if FPurposeOfEventList = nil then
    FPurposeOfEventList := TFhirCodeableConceptList.Create;
  result := FPurposeOfEventList;
end;

Function TFhirAuditEvent.GetHasPurposeOfEventList : boolean;
begin
  result := (FPurposeOfEventList <> nil) and (FPurposeOfEventList.count > 0);
end;

Function TFhirAuditEvent.GetAgentList : TFhirAuditEventAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirAuditEventAgentList.Create;
  result := FAgentList;
end;

Function TFhirAuditEvent.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Procedure TFhirAuditEvent.SetSource(value : TFhirAuditEventSource);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirAuditEvent.GetEntityList : TFhirAuditEventEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirAuditEventEntityList.Create;
  result := FEntityList;
end;

Function TFhirAuditEvent.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

function TFhirAuditEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FsubtypeList.sizeInBytes);
  inc(result, FAction.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FOutcomeDesc.sizeInBytes);
  inc(result, FpurposeOfEventList.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FentityList.sizeInBytes);
end;

{ TFhirAuditEventListEnumerator }

Constructor TFhirAuditEventListEnumerator.Create(list : TFhirAuditEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventListEnumerator.GetCurrent : TFhirAuditEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventList }
procedure TFhirAuditEventList.AddItem(value: TFhirAuditEvent);
begin
  assert(value.ClassName = 'TFhirAuditEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEvent');
  add(value);
end;

function TFhirAuditEventList.Append: TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventList.GetEnumerator : TFhirAuditEventListEnumerator;
begin
  result := TFhirAuditEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventList.Clone: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Clone);
end;

function TFhirAuditEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventList.GetItemN(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEvent;
end;
function TFhirAuditEventList.IndexOf(value: TFhirAuditEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventList.Insert(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.InsertItem(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventList.Item(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.Link: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Link);
end;

procedure TFhirAuditEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventList.SetItemByIndex(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  FhirAuditEvents[index] := value;
end;

procedure TFhirAuditEventList.SetItemN(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

{ TFhirBinary }

constructor TFhirBinary.Create;
begin
  inherited;
end;

destructor TFhirBinary.Destroy;
begin
  FContentType.free;
  FSecurityContext.free;
  FContent.free;
  inherited;
end;

function TFhirBinary.GetResourceType : TFhirResourceType;
begin
  result := frtBinary;
end;

procedure TFhirBinary.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirBinary(oSource).contentTypeElement.Clone;
  securityContext := TFhirBinary(oSource).securityContext.Clone;
  contentElement := TFhirBinary(oSource).contentElement.Clone;
end;

procedure TFhirBinary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'securityContext') Then
     list.add(self.link, 'securityContext', FSecurityContext.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
end;

procedure TFhirBinary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityContext', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSecurityContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'base64Binary', false, TFhirBase64Binary, FContent.Link));{2}
end;

function TFhirBinary.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'securityContext') then
  begin
    SecurityContext := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBinary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBinary.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create() {5b}
  else if (propName = 'securityContext') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'content') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBinary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'securityContext') then result := 'Reference'
  else if (propName = 'content') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBinary.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'securityContext') then SecurityContextElement := nil
  else if (propName = 'content') then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBinary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new){5b}
  else if (propName = 'securityContext') then SecurityContextElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'content') then ContentElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBinary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBinary.fhirType : string;
begin
  result := 'Binary';
end;

function TFhirBinary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FSecurityContext) and isEmptyProp(FContent);
end;

function TFhirBinary.equals(other : TObject) : boolean;
var
  o : TFhirBinary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBinary)) then
    result := false
  else
  begin
    o := TFhirBinary(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(securityContextElement, o.securityContextElement, true) and
      compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirBinary.Link : TFhirBinary;
begin
  result := TFhirBinary(inherited Link);
end;

function TFhirBinary.Clone : TFhirBinary;
begin
  result := TFhirBinary(inherited Clone);
end;

procedure TFhirBinary.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('securityContext');
  fields.add('content');
end;

{ TFhirBinary }

Procedure TFhirBinary.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirBinary.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

Procedure TFhirBinary.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

Procedure TFhirBinary.SetSecurityContext(value : TFhirReference{TFhirReference});
begin
  FSecurityContext.free;
  FSecurityContext := value;
end;

Procedure TFhirBinary.SetContent(value : TFhirBase64Binary);
begin
  FContent.free;
  FContent := value;
end;

Function TFhirBinary.GetContentST : TBytes;
begin
  if FContent = nil then
    result := nil
  else
    result := FContent.value;
end;

Procedure TFhirBinary.SetContentST(value : TBytes);
begin
  if value <> nil then
  begin
    if FContent = nil then
      FContent := TFhirBase64Binary.create;
    FContent.value := value
  end
  else if FContent <> nil then
    FContent.value := nil;
end;

function TFhirBinary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContentType.sizeInBytes);
  inc(result, FSecurityContext.sizeInBytes);
  inc(result, FContent.sizeInBytes);
end;

{ TFhirBinaryListEnumerator }

Constructor TFhirBinaryListEnumerator.Create(list : TFhirBinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBinaryListEnumerator.GetCurrent : TFhirBinary;
begin
  Result := FList[FIndex];
end;

function TFhirBinaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBinaryList }
procedure TFhirBinaryList.AddItem(value: TFhirBinary);
begin
  assert(value.ClassName = 'TFhirBinary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBinary');
  add(value);
end;

function TFhirBinaryList.Append: TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBinaryList.GetEnumerator : TFhirBinaryListEnumerator;
begin
  result := TFhirBinaryListEnumerator.Create(self.link);
end;

function TFhirBinaryList.Clone: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Clone);
end;

function TFhirBinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBinaryList.GetItemN(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBinary;
end;
function TFhirBinaryList.IndexOf(value: TFhirBinary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBinaryList.Insert(index: Integer): TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.InsertItem(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  Inherited Insert(index, value);
end;

function TFhirBinaryList.Item(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.Link: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Link);
end;

procedure TFhirBinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBinaryList.SetItemByIndex(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  FhirBinaries[index] := value;
end;

procedure TFhirBinaryList.SetItemN(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

{ TFhirBundleLink }

constructor TFhirBundleLink.Create;
begin
  inherited;
end;

destructor TFhirBundleLink.Destroy;
begin
  FRelation.free;
  FUrl.free;
  inherited;
end;

procedure TFhirBundleLink.Assign(oSource : TFslObject);
begin
  inherited;
  relationElement := TFhirBundleLink(oSource).relationElement.Clone;
  urlElement := TFhirBundleLink(oSource).urlElement.Clone;
end;

procedure TFhirBundleLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirBundleLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'string', false, TFhirString, FRelation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirBundleLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    RelationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirBundleLink.Link : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Link);
end;

function TFhirBundleLink.Clone : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Clone);
end;

function TFhirBundleLink.equals(other : TObject) : boolean;
var
  o : TFhirBundleLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleLink)) then
    result := false
  else
  begin
    o := TFhirBundleLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirBundleLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FUrl);
end;

procedure TFhirBundleLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relation');
  fields.add('url');
end;

{ TFhirBundleLink }

Procedure TFhirBundleLink.SetRelation(value : TFhirString);
begin
  FRelation.free;
  FRelation := value;
end;

Function TFhirBundleLink.GetRelationST : String;
begin
  if FRelation = nil then
    result := ''
  else
    result := FRelation.value;
end;

Procedure TFhirBundleLink.SetRelationST(value : String);
begin
  if value <> '' then
  begin
    if FRelation = nil then
      FRelation := TFhirString.create;
    FRelation.value := value
  end
  else if FRelation <> nil then
    FRelation.value := '';
end;

Procedure TFhirBundleLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirBundleLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRelation.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirBundleLinkListEnumerator }

Constructor TFhirBundleLinkListEnumerator.Create(list : TFhirBundleLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleLinkListEnumerator.GetCurrent : TFhirBundleLink;
begin
  Result := FList[FIndex];
end;

function TFhirBundleLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleLinkList }
procedure TFhirBundleLinkList.AddItem(value: TFhirBundleLink);
begin
  assert(value.ClassName = 'TFhirBundleLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleLink');
  add(value);
end;

function TFhirBundleLinkList.Append: TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.ClearItems;
begin
  Clear;
end;

function TFhirBundleLinkList.GetEnumerator : TFhirBundleLinkListEnumerator;
begin
  result := TFhirBundleLinkListEnumerator.Create(self.link);
end;

function TFhirBundleLinkList.Clone: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Clone);
end;

function TFhirBundleLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleLinkList.GetItemN(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleLink;
end;
function TFhirBundleLinkList.IndexOf(value: TFhirBundleLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleLinkList.Insert(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.InsertItem(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  Inherited Insert(index, value);
end;

function TFhirBundleLinkList.Item(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.Link: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Link);
end;

procedure TFhirBundleLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleLinkList.SetItemByIndex(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  FhirBundleLinks[index] := value;
end;

procedure TFhirBundleLinkList.SetItemN(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntry }

constructor TFhirBundleEntry.Create;
begin
  inherited;
end;

destructor TFhirBundleEntry.Destroy;
begin
  FLink_List.Free;
  FFullUrl.free;
  FResource.free;
  FSearch.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirBundleEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBundleEntry(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundleEntry(oSource).FLink_List);
  end;
  fullUrlElement := TFhirBundleEntry(oSource).fullUrlElement.Clone;
  resource := TFhirBundleEntry(oSource).resource.Clone;
  search := TFhirBundleEntry(oSource).search.Clone;
  request := TFhirBundleEntry(oSource).request.Clone;
  response := TFhirBundleEntry(oSource).response.Clone;
end;

procedure TFhirBundleEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'fullUrl') Then
     list.add(self.link, 'fullUrl', FFullUrl.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirBundleEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '@Bundle.link', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fullUrl', 'uri', false, TFhirUri, FFullUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'search', '', false, TFhirBundleEntrySearch, FSearch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', '', false, TFhirBundleEntryRequest, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirBundleEntryResponse, FResponse.Link));{2}
end;

function TFhirBundleEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'fullUrl') then
  begin
    FullUrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    Search := propValue as TFhirBundleEntrySearch{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirBundleEntryRequest{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirBundleEntryResponse{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else inherited;
end;

function TFhirBundleEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'fullUrl') then result := TFhirUri.create() {5b}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'search') then result := TFhirBundleEntrySearch.create(){4b}
  else if (propName = 'request') then result := TFhirBundleEntryRequest.create(){4b}
  else if (propName = 'response') then result := TFhirBundleEntryResponse.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := '@Bundle.link'
  else if (propName = 'fullUrl') then result := 'uri'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'search') then result := ''
  else if (propName = 'request') then result := ''
  else if (propName = 'response') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'fullUrl') then FullUrlElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'fullUrl') then FullUrlElement := asUri(new){5b}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'search') then SearchElement := new as TFhirBundleEntrySearch{4}
  else if (propName = 'request') then RequestElement := new as TFhirBundleEntryRequest{4}
  else if (propName = 'response') then ResponseElement := new as TFhirBundleEntryResponse{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirBundleEntry.Link : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Link);
end;

function TFhirBundleEntry.Clone : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Clone);
end;

function TFhirBundleEntry.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntry)) then
    result := false
  else
  begin
    o := TFhirBundleEntry(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(fullUrlElement, o.fullUrlElement, true) and
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(searchElement, o.searchElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirBundleEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FFullUrl) and isEmptyProp(FResource) and isEmptyProp(FSearch) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirBundleEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('link');
  fields.add('fullUrl');
  fields.add('resource');
  fields.add('search');
  fields.add('request');
  fields.add('response');
end;

{ TFhirBundleEntry }

Function TFhirBundleEntry.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundleEntry.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Procedure TFhirBundleEntry.SetFullUrl(value : TFhirUri);
begin
  FFullUrl.free;
  FFullUrl := value;
end;

Function TFhirBundleEntry.GetFullUrlST : String;
begin
  if FFullUrl = nil then
    result := ''
  else
    result := FFullUrl.value;
end;

Procedure TFhirBundleEntry.SetFullUrlST(value : String);
begin
  if value <> '' then
  begin
    if FFullUrl = nil then
      FFullUrl := TFhirUri.create;
    FFullUrl.value := value
  end
  else if FFullUrl <> nil then
    FFullUrl.value := '';
end;

Procedure TFhirBundleEntry.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Procedure TFhirBundleEntry.SetSearch(value : TFhirBundleEntrySearch);
begin
  FSearch.free;
  FSearch := value;
end;

Procedure TFhirBundleEntry.SetRequest(value : TFhirBundleEntryRequest);
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirBundleEntry.SetResponse(value : TFhirBundleEntryResponse);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirBundleEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Flink_List.sizeInBytes);
  inc(result, FFullUrl.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FSearch.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
end;

{ TFhirBundleEntryListEnumerator }

Constructor TFhirBundleEntryListEnumerator.Create(list : TFhirBundleEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryListEnumerator.GetCurrent : TFhirBundleEntry;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryList }
procedure TFhirBundleEntryList.AddItem(value: TFhirBundleEntry);
begin
  assert(value.ClassName = 'TFhirBundleEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntry');
  add(value);
end;

function TFhirBundleEntryList.Append: TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryList.GetEnumerator : TFhirBundleEntryListEnumerator;
begin
  result := TFhirBundleEntryListEnumerator.Create(self.link);
end;

function TFhirBundleEntryList.Clone: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Clone);
end;

function TFhirBundleEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryList.GetItemN(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntry;
end;
function TFhirBundleEntryList.IndexOf(value: TFhirBundleEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryList.Insert(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.InsertItem(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryList.Item(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.Link: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Link);
end;

procedure TFhirBundleEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryList.SetItemByIndex(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  FhirBundleEntries[index] := value;
end;

procedure TFhirBundleEntryList.SetItemN(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntrySearch }

constructor TFhirBundleEntrySearch.Create;
begin
  inherited;
end;

destructor TFhirBundleEntrySearch.Destroy;
begin
  FMode.free;
  FScore.free;
  inherited;
end;

procedure TFhirBundleEntrySearch.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirBundleEntrySearch(oSource).FMode.Link;
  scoreElement := TFhirBundleEntrySearch(oSource).scoreElement.Clone;
end;

procedure TFhirBundleEntrySearch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
end;

procedure TFhirBundleEntrySearch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));{2}
end;

function TFhirBundleEntrySearch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntrySearch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntrySearch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'score') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntrySearch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntrySearch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntrySearch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, new){4}
  else if (propName = 'score') then ScoreElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntrySearch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntrySearch.fhirType : string;
begin
  result := 'search';
end;

function TFhirBundleEntrySearch.Link : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Link);
end;

function TFhirBundleEntrySearch.Clone : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Clone);
end;

function TFhirBundleEntrySearch.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntrySearch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntrySearch)) then
    result := false
  else
  begin
    o := TFhirBundleEntrySearch(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(scoreElement, o.scoreElement, true);
  end;
end;

function TFhirBundleEntrySearch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FScore);
end;

procedure TFhirBundleEntrySearch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('score');
end;

{ TFhirBundleEntrySearch }

Procedure TFhirBundleEntrySearch.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirBundleEntrySearch.GetModeST : TFhirSearchEntryModeEnum;
begin
  if FMode = nil then
    result := TFhirSearchEntryModeEnum(0)
  else
    result := TFhirSearchEntryModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchEntryModeEnum, FMode.value));
end;

Procedure TFhirBundleEntrySearch.SetModeST(value : TFhirSearchEntryModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[value], CODES_TFhirSearchEntryModeEnum[value]);
end;

Procedure TFhirBundleEntrySearch.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

Function TFhirBundleEntrySearch.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

Procedure TFhirBundleEntrySearch.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

function TFhirBundleEntrySearch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FScore.sizeInBytes);
end;

{ TFhirBundleEntrySearchListEnumerator }

Constructor TFhirBundleEntrySearchListEnumerator.Create(list : TFhirBundleEntrySearchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntrySearchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntrySearchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntrySearchListEnumerator.GetCurrent : TFhirBundleEntrySearch;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntrySearchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntrySearchList }
procedure TFhirBundleEntrySearchList.AddItem(value: TFhirBundleEntrySearch);
begin
  assert(value.ClassName = 'TFhirBundleEntrySearch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntrySearch');
  add(value);
end;

function TFhirBundleEntrySearchList.Append: TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntrySearchList.GetEnumerator : TFhirBundleEntrySearchListEnumerator;
begin
  result := TFhirBundleEntrySearchListEnumerator.Create(self.link);
end;

function TFhirBundleEntrySearchList.Clone: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Clone);
end;

function TFhirBundleEntrySearchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntrySearchList.GetItemN(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntrySearch;
end;
function TFhirBundleEntrySearchList.IndexOf(value: TFhirBundleEntrySearch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntrySearchList.Insert(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.InsertItem(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  Inherited Insert(index, value);
end;

function TFhirBundleEntrySearchList.Item(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.Link: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Link);
end;

procedure TFhirBundleEntrySearchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntrySearchList.SetItemByIndex(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  FhirBundleEntrySearches[index] := value;
end;

procedure TFhirBundleEntrySearchList.SetItemN(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryRequest }

constructor TFhirBundleEntryRequest.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryRequest.Destroy;
begin
  FMethod.free;
  FUrl.free;
  FIfNoneMatch.free;
  FIfModifiedSince.free;
  FIfMatch.free;
  FIfNoneExist.free;
  inherited;
end;

procedure TFhirBundleEntryRequest.Assign(oSource : TFslObject);
begin
  inherited;
  FMethod := TFhirBundleEntryRequest(oSource).FMethod.Link;
  urlElement := TFhirBundleEntryRequest(oSource).urlElement.Clone;
  ifNoneMatchElement := TFhirBundleEntryRequest(oSource).ifNoneMatchElement.Clone;
  ifModifiedSinceElement := TFhirBundleEntryRequest(oSource).ifModifiedSinceElement.Clone;
  ifMatchElement := TFhirBundleEntryRequest(oSource).ifMatchElement.Clone;
  ifNoneExistElement := TFhirBundleEntryRequest(oSource).ifNoneExistElement.Clone;
end;

procedure TFhirBundleEntryRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'ifNoneMatch') Then
     list.add(self.link, 'ifNoneMatch', FIfNoneMatch.Link);
  if (child_name = 'ifModifiedSince') Then
     list.add(self.link, 'ifModifiedSince', FIfModifiedSince.Link);
  if (child_name = 'ifMatch') Then
     list.add(self.link, 'ifMatch', FIfMatch.Link);
  if (child_name = 'ifNoneExist') Then
     list.add(self.link, 'ifNoneExist', FIfNoneExist.Link);
end;

procedure TFhirBundleEntryRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFHIREnum, FMethod.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneMatch', 'string', false, TFhirString, FIfNoneMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifModifiedSince', 'instant', false, TFhirInstant, FIfModifiedSince.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifMatch', 'string', false, TFhirString, FIfMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneExist', 'string', false, TFhirString, FIfNoneExist.Link));{2}
end;

function TFhirBundleEntryRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneMatch') then
  begin
    IfNoneMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifModifiedSince') then
  begin
    IfModifiedSinceElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifMatch') then
  begin
    IfMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneExist') then
  begin
    IfNoneExistElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'ifNoneMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifModifiedSince') then result := TFhirInstant.create() {5b}
  else if (propName = 'ifMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifNoneExist') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'ifNoneMatch') then result := 'string'
  else if (propName = 'ifModifiedSince') then result := 'instant'
  else if (propName = 'ifMatch') then result := 'string'
  else if (propName = 'ifNoneExist') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := nil
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := nil
  else if (propName = 'ifMatch') then IfMatchElement := nil
  else if (propName = 'ifNoneExist') then IfNoneExistElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := asString(new){5b}
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := asInstant(new){5b}
  else if (propName = 'ifMatch') then IfMatchElement := asString(new){5b}
  else if (propName = 'ifNoneExist') then IfNoneExistElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryRequest.fhirType : string;
begin
  result := 'request';
end;

function TFhirBundleEntryRequest.Link : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Link);
end;

function TFhirBundleEntryRequest.Clone : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Clone);
end;

function TFhirBundleEntryRequest.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntryRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryRequest)) then
    result := false
  else
  begin
    o := TFhirBundleEntryRequest(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(ifNoneMatchElement, o.ifNoneMatchElement, true) and compareDeep(ifModifiedSinceElement, o.ifModifiedSinceElement, true) and
      compareDeep(ifMatchElement, o.ifMatchElement, true) and compareDeep(ifNoneExistElement, o.ifNoneExistElement, true);
  end;
end;

function TFhirBundleEntryRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FUrl) and isEmptyProp(FIfNoneMatch) and isEmptyProp(FIfModifiedSince) and isEmptyProp(FIfMatch) and isEmptyProp(FIfNoneExist);
end;

procedure TFhirBundleEntryRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('method');
  fields.add('url');
  fields.add('ifNoneMatch');
  fields.add('ifModifiedSince');
  fields.add('ifMatch');
  fields.add('ifNoneExist');
end;

{ TFhirBundleEntryRequest }

Procedure TFhirBundleEntryRequest.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

Function TFhirBundleEntryRequest.GetMethodST : TFhirHttpVerbEnum;
begin
  if FMethod = nil then
    result := TFhirHttpVerbEnum(0)
  else
    result := TFhirHttpVerbEnum(StringArrayIndexOfSensitive(CODES_TFhirHttpVerbEnum, FMethod.value));
end;

Procedure TFhirBundleEntryRequest.SetMethodST(value : TFhirHttpVerbEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirHttpVerbEnum[value], CODES_TFhirHttpVerbEnum[value]);
end;

Procedure TFhirBundleEntryRequest.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleEntryRequest.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleEntryRequest.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatch(value : TFhirString);
begin
  FIfNoneMatch.free;
  FIfNoneMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneMatchST : String;
begin
  if FIfNoneMatch = nil then
    result := ''
  else
    result := FIfNoneMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneMatch = nil then
      FIfNoneMatch := TFhirString.create;
    FIfNoneMatch.value := value
  end
  else if FIfNoneMatch <> nil then
    FIfNoneMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSince(value : TFhirInstant);
begin
  FIfModifiedSince.free;
  FIfModifiedSince := value;
end;

Function TFhirBundleEntryRequest.GetIfModifiedSinceST : TFslDateTime;
begin
  if FIfModifiedSince = nil then
    result := TFslDateTime.makeNull
  else
    result := FIfModifiedSince.value;
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSinceST(value : TFslDateTime);
begin
  if FIfModifiedSince = nil then
    FIfModifiedSince := TFhirInstant.create;
  FIfModifiedSince.value := value
end;

Procedure TFhirBundleEntryRequest.SetIfMatch(value : TFhirString);
begin
  FIfMatch.free;
  FIfMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfMatchST : String;
begin
  if FIfMatch = nil then
    result := ''
  else
    result := FIfMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfMatch = nil then
      FIfMatch := TFhirString.create;
    FIfMatch.value := value
  end
  else if FIfMatch <> nil then
    FIfMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExist(value : TFhirString);
begin
  FIfNoneExist.free;
  FIfNoneExist := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneExistST : String;
begin
  if FIfNoneExist = nil then
    result := ''
  else
    result := FIfNoneExist.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExistST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneExist = nil then
      FIfNoneExist := TFhirString.create;
    FIfNoneExist.value := value
  end
  else if FIfNoneExist <> nil then
    FIfNoneExist.value := '';
end;

function TFhirBundleEntryRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMethod.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FIfNoneMatch.sizeInBytes);
  inc(result, FIfModifiedSince.sizeInBytes);
  inc(result, FIfMatch.sizeInBytes);
  inc(result, FIfNoneExist.sizeInBytes);
end;

{ TFhirBundleEntryRequestListEnumerator }

Constructor TFhirBundleEntryRequestListEnumerator.Create(list : TFhirBundleEntryRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryRequestListEnumerator.GetCurrent : TFhirBundleEntryRequest;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryRequestList }
procedure TFhirBundleEntryRequestList.AddItem(value: TFhirBundleEntryRequest);
begin
  assert(value.ClassName = 'TFhirBundleEntryRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryRequest');
  add(value);
end;

function TFhirBundleEntryRequestList.Append: TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryRequestList.GetEnumerator : TFhirBundleEntryRequestListEnumerator;
begin
  result := TFhirBundleEntryRequestListEnumerator.Create(self.link);
end;

function TFhirBundleEntryRequestList.Clone: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Clone);
end;

function TFhirBundleEntryRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryRequestList.GetItemN(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryRequest;
end;
function TFhirBundleEntryRequestList.IndexOf(value: TFhirBundleEntryRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryRequestList.Insert(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.InsertItem(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryRequestList.Item(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.Link: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Link);
end;

procedure TFhirBundleEntryRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryRequestList.SetItemByIndex(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  FhirBundleEntryRequests[index] := value;
end;

procedure TFhirBundleEntryRequestList.SetItemN(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryResponse }

constructor TFhirBundleEntryResponse.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryResponse.Destroy;
begin
  FStatus.free;
  FLocation.free;
  FEtag.free;
  FLastModified.free;
  FOutcome.free;
  inherited;
end;

procedure TFhirBundleEntryResponse.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirBundleEntryResponse(oSource).statusElement.Clone;
  locationElement := TFhirBundleEntryResponse(oSource).locationElement.Clone;
  etagElement := TFhirBundleEntryResponse(oSource).etagElement.Clone;
  lastModifiedElement := TFhirBundleEntryResponse(oSource).lastModifiedElement.Clone;
  outcome := TFhirBundleEntryResponse(oSource).outcome.Clone;
end;

procedure TFhirBundleEntryResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'etag') Then
     list.add(self.link, 'etag', FEtag.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirBundleEntryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'string', false, TFhirString, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'uri', false, TFhirUri, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'etag', 'string', false, TFhirString, FEtag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastModified', 'instant', false, TFhirInstant, FLastModified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Resource', false, TFhirResource, FOutcome.Link));{2}
end;

function TFhirBundleEntryResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'etag') then
  begin
    EtagElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirResource{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := TFhirUri.create() {5b}
  else if (propName = 'etag') then result := TFhirString.create() {5b}
  else if (propName = 'lastModified') then result := TFhirInstant.create() {5b}
  else if (propName = 'outcome') then raise EFHIRException.create('Cannot make property Outcome')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'string'
  else if (propName = 'location') then result := 'uri'
  else if (propName = 'etag') then result := 'string'
  else if (propName = 'lastModified') then result := 'instant'
  else if (propName = 'outcome') then result := 'Resource'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'etag') then EtagElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asString(new){5b}
  else if (propName = 'location') then LocationElement := asUri(new){5b}
  else if (propName = 'etag') then EtagElement := asString(new){5b}
  else if (propName = 'lastModified') then LastModifiedElement := asInstant(new){5b}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirResource{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirBundleEntryResponse.Link : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Link);
end;

function TFhirBundleEntryResponse.Clone : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Clone);
end;

function TFhirBundleEntryResponse.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntryResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryResponse)) then
    result := false
  else
  begin
    o := TFhirBundleEntryResponse(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(etagElement, o.etagElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirBundleEntryResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FLocation) and isEmptyProp(FEtag) and isEmptyProp(FLastModified) and isEmptyProp(FOutcome);
end;

procedure TFhirBundleEntryResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('location');
  fields.add('etag');
  fields.add('lastModified');
  fields.add('outcome');
end;

{ TFhirBundleEntryResponse }

Procedure TFhirBundleEntryResponse.SetStatus(value : TFhirString);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirBundleEntryResponse.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

Procedure TFhirBundleEntryResponse.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirString.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLocation(value : TFhirUri);
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirBundleEntryResponse.GetLocationST : String;
begin
  if FLocation = nil then
    result := ''
  else
    result := FLocation.value;
end;

Procedure TFhirBundleEntryResponse.SetLocationST(value : String);
begin
  if value <> '' then
  begin
    if FLocation = nil then
      FLocation := TFhirUri.create;
    FLocation.value := value
  end
  else if FLocation <> nil then
    FLocation.value := '';
end;

Procedure TFhirBundleEntryResponse.SetEtag(value : TFhirString);
begin
  FEtag.free;
  FEtag := value;
end;

Function TFhirBundleEntryResponse.GetEtagST : String;
begin
  if FEtag = nil then
    result := ''
  else
    result := FEtag.value;
end;

Procedure TFhirBundleEntryResponse.SetEtagST(value : String);
begin
  if value <> '' then
  begin
    if FEtag = nil then
      FEtag := TFhirString.create;
    FEtag.value := value
  end
  else if FEtag <> nil then
    FEtag.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLastModified(value : TFhirInstant);
begin
  FLastModified.free;
  FLastModified := value;
end;

Function TFhirBundleEntryResponse.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

Procedure TFhirBundleEntryResponse.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirInstant.create;
  FLastModified.value := value
end;

Procedure TFhirBundleEntryResponse.SetOutcome(value : TFhirResource);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirBundleEntryResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FEtag.sizeInBytes);
  inc(result, FLastModified.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
end;

{ TFhirBundleEntryResponseListEnumerator }

Constructor TFhirBundleEntryResponseListEnumerator.Create(list : TFhirBundleEntryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryResponseListEnumerator.GetCurrent : TFhirBundleEntryResponse;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryResponseList }
procedure TFhirBundleEntryResponseList.AddItem(value: TFhirBundleEntryResponse);
begin
  assert(value.ClassName = 'TFhirBundleEntryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryResponse');
  add(value);
end;

function TFhirBundleEntryResponseList.Append: TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryResponseList.GetEnumerator : TFhirBundleEntryResponseListEnumerator;
begin
  result := TFhirBundleEntryResponseListEnumerator.Create(self.link);
end;

function TFhirBundleEntryResponseList.Clone: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Clone);
end;

function TFhirBundleEntryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryResponseList.GetItemN(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryResponse;
end;
function TFhirBundleEntryResponseList.IndexOf(value: TFhirBundleEntryResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryResponseList.Insert(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.InsertItem(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryResponseList.Item(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.Link: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Link);
end;

procedure TFhirBundleEntryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryResponseList.SetItemByIndex(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  FhirBundleEntryResponses[index] := value;
end;

procedure TFhirBundleEntryResponseList.SetItemN(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirBundle }

constructor TFhirBundle.Create;
begin
  inherited;
end;

destructor TFhirBundle.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FTotal.free;
  FLink_List.Free;
  FEntryList.Free;
  FSignature.free;
  inherited;
end;

function TFhirBundle.GetResourceType : TFhirResourceType;
begin
  result := frtBundle;
end;

procedure TFhirBundle.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirBundle(oSource).identifier.Clone;
  FType_ := TFhirBundle(oSource).FType_.Link;
  totalElement := TFhirBundle(oSource).totalElement.Clone;
  if (TFhirBundle(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundle(oSource).FLink_List);
  end;
  if (TFhirBundle(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirBundleEntryList.Create;
    FEntryList.Assign(TFhirBundle(oSource).FEntryList);
  end;
  signature := TFhirBundle(oSource).signature.Clone;
end;

procedure TFhirBundle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
end;

procedure TFhirBundle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'total', 'unsignedInt', false, TFhirUnsignedInt, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirBundleEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', false, TFhirSignature, FSignature.Link));{2}
end;

function TFhirBundle.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'total') then
  begin
    TotalElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirBundleEntry){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    Signature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBundle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirBundleEntry){2a}
  else inherited;
end;

function TFhirBundle.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'total') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'signature') then result := TFhirSignature.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'total') then result := 'unsignedInt'
  else if (propName = 'link') then result := ''
  else if (propName = 'entry') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundle.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'signature') then SignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, new){4}
  else if (propName = 'total') then TotalElement := asUnsignedInt(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'signature') then SignatureElement := new as TFhirSignature{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundle.fhirType : string;
begin
  result := 'Bundle';
end;

function TFhirBundle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FTotal) and isEmptyProp(Flink_List) and isEmptyProp(FentryList) and isEmptyProp(FSignature);
end;

function TFhirBundle.equals(other : TObject) : boolean;
var
  o : TFhirBundle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundle)) then
    result := false
  else
  begin
    o := TFhirBundle(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(totalElement, o.totalElement, true) and compareDeep(link_List, o.link_List, true) and
      compareDeep(entryList, o.entryList, true) and compareDeep(signatureElement, o.signatureElement, true);
  end;
end;

function TFhirBundle.Link : TFhirBundle;
begin
  result := TFhirBundle(inherited Link);
end;

function TFhirBundle.Clone : TFhirBundle;
begin
  result := TFhirBundle(inherited Clone);
end;

procedure TFhirBundle.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('total');
  fields.add('link');
  fields.add('entry');
  fields.add('signature');
end;

{ TFhirBundle }

Procedure TFhirBundle.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirBundle.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirBundle.GetType_ST : TFhirBundleTypeEnum;
begin
  if FType_ = nil then
    result := TFhirBundleTypeEnum(0)
  else
    result := TFhirBundleTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirBundleTypeEnum, FType_.value));
end;

Procedure TFhirBundle.SetType_ST(value : TFhirBundleTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[value], CODES_TFhirBundleTypeEnum[value]);
end;

Procedure TFhirBundle.SetTotal(value : TFhirUnsignedInt);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirBundle.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirBundle.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirUnsignedInt.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

Function TFhirBundle.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundle.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Function TFhirBundle.GetEntryList : TFhirBundleEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirBundleEntryList.Create;
  result := FEntryList;
end;

Function TFhirBundle.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirBundle.SetSignature(value : TFhirSignature);
begin
  FSignature.free;
  FSignature := value;
end;

function TFhirBundle.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FSignature.sizeInBytes);
end;

{ TFhirBundleListEnumerator }

Constructor TFhirBundleListEnumerator.Create(list : TFhirBundleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleListEnumerator.GetCurrent : TFhirBundle;
begin
  Result := FList[FIndex];
end;

function TFhirBundleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleList }
procedure TFhirBundleList.AddItem(value: TFhirBundle);
begin
  assert(value.ClassName = 'TFhirBundle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundle');
  add(value);
end;

function TFhirBundleList.Append: TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.ClearItems;
begin
  Clear;
end;

function TFhirBundleList.GetEnumerator : TFhirBundleListEnumerator;
begin
  result := TFhirBundleListEnumerator.Create(self.link);
end;

function TFhirBundleList.Clone: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Clone);
end;

function TFhirBundleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleList.GetItemN(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundle;
end;
function TFhirBundleList.IndexOf(value: TFhirBundle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleList.Insert(index: Integer): TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.InsertItem(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  Inherited Insert(index, value);
end;

function TFhirBundleList.Item(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.Link: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Link);
end;

procedure TFhirBundleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleList.SetItemByIndex(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  FhirBundles[index] := value;
end;

procedure TFhirBundleList.SetItemN(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CHARGEITEM}

{ TFhirChargeItemParticipant }

constructor TFhirChargeItemParticipant.Create;
begin
  inherited;
end;

destructor TFhirChargeItemParticipant.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirChargeItemParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirChargeItemParticipant(oSource).role.Clone;
  actor := TFhirChargeItemParticipant(oSource).actor.Clone;
end;

procedure TFhirChargeItemParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirChargeItemParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Organization|Patient|Device|RelatedPerson)', false, TFhirReference{Resource}, FActor.Link));{2}
end;

function TFhirChargeItemParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirChargeItemParticipant.Link : TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant(inherited Link);
end;

function TFhirChargeItemParticipant.Clone : TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant(inherited Clone);
end;

function TFhirChargeItemParticipant.equals(other : TObject) : boolean;
var
  o : TFhirChargeItemParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemParticipant)) then
    result := false
  else
  begin
    o := TFhirChargeItemParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirChargeItemParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirChargeItemParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

{ TFhirChargeItemParticipant }

Procedure TFhirChargeItemParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirChargeItemParticipant.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

function TFhirChargeItemParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirChargeItemParticipantListEnumerator }

Constructor TFhirChargeItemParticipantListEnumerator.Create(list : TFhirChargeItemParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemParticipantListEnumerator.GetCurrent : TFhirChargeItemParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemParticipantList }
procedure TFhirChargeItemParticipantList.AddItem(value: TFhirChargeItemParticipant);
begin
  assert(value.ClassName = 'TFhirChargeItemParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemParticipant');
  add(value);
end;

function TFhirChargeItemParticipantList.Append: TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemParticipantList.GetEnumerator : TFhirChargeItemParticipantListEnumerator;
begin
  result := TFhirChargeItemParticipantListEnumerator.Create(self.link);
end;

function TFhirChargeItemParticipantList.Clone: TFhirChargeItemParticipantList;
begin
  result := TFhirChargeItemParticipantList(inherited Clone);
end;

function TFhirChargeItemParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemParticipantList.GetItemN(index: Integer): TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant(ObjectByIndex[index]);
end;

function TFhirChargeItemParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemParticipant;
end;
function TFhirChargeItemParticipantList.IndexOf(value: TFhirChargeItemParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemParticipantList.Insert(index: Integer): TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemParticipantList.InsertItem(index: Integer; value: TFhirChargeItemParticipant);
begin
  assert(value is TFhirChargeItemParticipant);
  Inherited Insert(index, value);
end;

function TFhirChargeItemParticipantList.Item(index: Integer): TFhirChargeItemParticipant;
begin
  result := TFhirChargeItemParticipant(ObjectByIndex[index]);
end;

function TFhirChargeItemParticipantList.Link: TFhirChargeItemParticipantList;
begin
  result := TFhirChargeItemParticipantList(inherited Link);
end;

procedure TFhirChargeItemParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemParticipantList.SetItemByIndex(index: Integer; value: TFhirChargeItemParticipant);
begin
  assert(value is TFhirChargeItemParticipant);
  FhirChargeItemParticipants[index] := value;
end;

procedure TFhirChargeItemParticipantList.SetItemN(index: Integer; value: TFhirChargeItemParticipant);
begin
  assert(value is TFhirChargeItemParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItem }

constructor TFhirChargeItem.Create;
begin
  inherited;
end;

destructor TFhirChargeItem.Destroy;
begin
  FIdentifier.free;
  FDefinitionList.Free;
  FStatus.free;
  FPartOfList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FParticipantList.Free;
  FPerformingOrganization.free;
  FRequestingOrganization.free;
  FQuantity.free;
  FBodysiteList.Free;
  FFactorOverride.free;
  FPriceOverride.free;
  FOverrideReason.free;
  FEnterer.free;
  FEnteredDate.free;
  FReasonList.Free;
  FServiceList.Free;
  FAccountList.Free;
  FNoteList.Free;
  FSupportingInformationList.Free;
  inherited;
end;

function TFhirChargeItem.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItem;
end;

procedure TFhirChargeItem.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirChargeItem(oSource).identifier.Clone;
  if (TFhirChargeItem(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirUriList.Create;
    FDefinitionList.Assign(TFhirChargeItem(oSource).FDefinitionList);
  end;
  FStatus := TFhirChargeItem(oSource).FStatus.Link;
  if (TFhirChargeItem(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirChargeItem}.Create;
    FPartOfList.Assign(TFhirChargeItem(oSource).FPartOfList);
  end;
  code := TFhirChargeItem(oSource).code.Clone;
  subject := TFhirChargeItem(oSource).subject.Clone;
  context := TFhirChargeItem(oSource).context.Clone;
  occurrence := TFhirChargeItem(oSource).occurrence.Clone;
  if (TFhirChargeItem(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirChargeItemParticipantList.Create;
    FParticipantList.Assign(TFhirChargeItem(oSource).FParticipantList);
  end;
  performingOrganization := TFhirChargeItem(oSource).performingOrganization.Clone;
  requestingOrganization := TFhirChargeItem(oSource).requestingOrganization.Clone;
  quantity := TFhirChargeItem(oSource).quantity.Clone;
  if (TFhirChargeItem(oSource).FBodysiteList = nil) then
  begin
    FBodysiteList.free;
    FBodysiteList := nil;
  end
  else
  begin
    if FBodysiteList = nil then
      FBodysiteList := TFhirCodeableConceptList.Create;
    FBodysiteList.Assign(TFhirChargeItem(oSource).FBodysiteList);
  end;
  factorOverrideElement := TFhirChargeItem(oSource).factorOverrideElement.Clone;
  priceOverride := TFhirChargeItem(oSource).priceOverride.Clone;
  overrideReasonElement := TFhirChargeItem(oSource).overrideReasonElement.Clone;
  enterer := TFhirChargeItem(oSource).enterer.Clone;
  enteredDateElement := TFhirChargeItem(oSource).enteredDateElement.Clone;
  if (TFhirChargeItem(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirChargeItem(oSource).FReasonList);
  end;
  if (TFhirChargeItem(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirReferenceList{Resource}.Create;
    FServiceList.Assign(TFhirChargeItem(oSource).FServiceList);
  end;
  if (TFhirChargeItem(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList{TFhirAccount}.Create;
    FAccountList.Assign(TFhirChargeItem(oSource).FAccountList);
  end;
  if (TFhirChargeItem(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirChargeItem(oSource).FNoteList);
  end;
  if (TFhirChargeItem(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirChargeItem(oSource).FSupportingInformationList);
  end;
end;

procedure TFhirChargeItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'performingOrganization') Then
     list.add(self.link, 'performingOrganization', FPerformingOrganization.Link);
  if (child_name = 'requestingOrganization') Then
     list.add(self.link, 'requestingOrganization', FRequestingOrganization.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'bodysite') Then
    list.addAll(self, 'bodysite', FBodysiteList);
  if (child_name = 'factorOverride') Then
     list.add(self.link, 'factorOverride', FFactorOverride.Link);
  if (child_name = 'priceOverride') Then
     list.add(self.link, 'priceOverride', FPriceOverride.Link);
  if (child_name = 'overrideReason') Then
     list.add(self.link, 'overrideReason', FOverrideReason.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'enteredDate') Then
     list.add(self.link, 'enteredDate', FEnteredDate.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
end;

procedure TFhirChargeItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', true, TFhirUri, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(ChargeItem)', true, TFhirReference{TFhirChargeItem}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirChargeItemParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPerformingOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestingOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodysite', 'CodeableConcept', true, TFhirCodeableConcept, FBodysiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'factorOverride', 'decimal', false, TFhirDecimal, FFactorOverride.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priceOverride', 'Money', false, TFhirMoney, FPriceOverride.Link));{2}
  oList.add(TFHIRProperty.create(self, 'overrideReason', 'string', false, TFhirString, FOverrideReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner|Organization|Patient|Device|RelatedPerson)', false, TFhirReference{Resource}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enteredDate', 'dateTime', false, TFhirDateTime, FEnteredDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'service', 'Reference(DiagnosticReport|ImagingStudy|Immunization|MedicationAdministration|MedicationDispense|Observation|Procedure|SupplyDelivery)', true, TFhirReference{Resource}, FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'account', 'Reference(Account)', true, TFhirReference{TFhirAccount}, FAccountList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
end;

function TFhirChargeItem.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirChargeitemStatusEnum, CODES_TFhirChargeitemStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirChargeItem}){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirChargeItemParticipant){2a};
    result := propValue;
  end
  else if (propName = 'performingOrganization') then
  begin
    PerformingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestingOrganization') then
  begin
    RequestingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'bodysite') then
  begin
    BodysiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'factorOverride') then
  begin
    FactorOverrideElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'priceOverride') then
  begin
    PriceOverride := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'overrideReason') then
  begin
    OverrideReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'enteredDate') then
  begin
    EnteredDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference{TFhirAccount}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirChargeItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'definition') then DefinitionList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirChargeItem}){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirChargeItemParticipant){2a}
  else if (propName = 'bodysite') then BodysiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference{TFhirAccount}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirChargeItem.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'performingOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestingOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'bodysite') then result := BodysiteList.new(){2}
  else if (propName = 'factorOverride') then result := TFhirDecimal.create() {5b}
  else if (propName = 'priceOverride') then result := TFhirMoney.create(){4b}
  else if (propName = 'overrideReason') then result := TFhirString.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'enteredDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'service') then result := ServiceList.new(){2}
  else if (propName = 'account') then result := AccountList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'participant') then result := ''
  else if (propName = 'performingOrganization') then result := 'Reference'
  else if (propName = 'requestingOrganization') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'bodysite') then result := 'CodeableConcept'
  else if (propName = 'factorOverride') then result := 'decimal'
  else if (propName = 'priceOverride') then result := 'Money'
  else if (propName = 'overrideReason') then result := 'string'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'enteredDate') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItem.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := nil
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'bodysite') then deletePropertyValue('bodysite', BodysiteList, value) {2}
  else if (propName = 'factorOverride') then FactorOverrideElement := nil
  else if (propName = 'priceOverride') then PriceOverrideElement := nil
  else if (propName = 'overrideReason') then OverrideReasonElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'enteredDate') then EnteredDateElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value) {2}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirChargeitemStatusEnum, CODES_TFhirChargeitemStatusEnum, new){4}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'bodysite') then replacePropertyValue('bodysite', BodysiteList, existing, new) {2}
  else if (propName = 'factorOverride') then FactorOverrideElement := asDecimal(new){5b}
  else if (propName = 'priceOverride') then PriceOverrideElement := new as TFhirMoney{4}
  else if (propName = 'overrideReason') then OverrideReasonElement := asString(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{Resource}{4}
  else if (propName = 'enteredDate') then EnteredDateElement := asDateTime(new){5b}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new) {2}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'definition') then DefinitionList.move(source, destination){2}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'bodysite') then BodysiteList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'service') then ServiceList.move(source, destination){2a}
  else if (propName = 'account') then AccountList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItem.fhirType : string;
begin
  result := 'ChargeItem';
end;

function TFhirChargeItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FdefinitionList) and isEmptyProp(FStatus) and isEmptyProp(FpartOfList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FparticipantList) and isEmptyProp(FPerformingOrganization) and isEmptyProp(FRequestingOrganization) and isEmptyProp(FQuantity) and isEmptyProp(FbodysiteList) and isEmptyProp(FFactorOverride) and isEmptyProp(FPriceOverride) and isEmptyProp(FOverrideReason) and isEmptyProp(FEnterer) and isEmptyProp(FEnteredDate) and isEmptyProp(FreasonList) and isEmptyProp(FserviceList) and isEmptyProp(FaccountList) and isEmptyProp(FnoteList) and isEmptyProp(FsupportingInformationList);
end;

function TFhirChargeItem.equals(other : TObject) : boolean;
var
  o : TFhirChargeItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItem)) then
    result := false
  else
  begin
    o := TFhirChargeItem(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(partOfList, o.partOfList, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(participantList, o.participantList, true) and compareDeep(performingOrganizationElement, o.performingOrganizationElement, true) and
      compareDeep(requestingOrganizationElement, o.requestingOrganizationElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(bodysiteList, o.bodysiteList, true) and
      compareDeep(factorOverrideElement, o.factorOverrideElement, true) and compareDeep(priceOverrideElement, o.priceOverrideElement, true) and
      compareDeep(overrideReasonElement, o.overrideReasonElement, true) and compareDeep(entererElement, o.entererElement, true) and
      compareDeep(enteredDateElement, o.enteredDateElement, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(serviceList, o.serviceList, true) and compareDeep(accountList, o.accountList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(supportingInformationList, o.supportingInformationList, true);
  end;
end;

function TFhirChargeItem.Link : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Link);
end;

function TFhirChargeItem.Clone : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Clone);
end;

procedure TFhirChargeItem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('status');
  fields.add('partOf');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('participant');
  fields.add('performingOrganization');
  fields.add('requestingOrganization');
  fields.add('quantity');
  fields.add('bodysite');
  fields.add('factorOverride');
  fields.add('priceOverride');
  fields.add('overrideReason');
  fields.add('enterer');
  fields.add('enteredDate');
  fields.add('reason');
  fields.add('service');
  fields.add('account');
  fields.add('note');
  fields.add('supportingInformation');
end;

{ TFhirChargeItem }

Procedure TFhirChargeItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirChargeItem.GetDefinitionList : TFhirUriList;
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirUriList.Create;
  result := FDefinitionList;
end;

Function TFhirChargeItem.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Procedure TFhirChargeItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirChargeItem.GetStatusST : TFhirChargeitemStatusEnum;
begin
  if FStatus = nil then
    result := TFhirChargeitemStatusEnum(0)
  else
    result := TFhirChargeitemStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirChargeitemStatusEnum, FStatus.value));
end;

Procedure TFhirChargeItem.SetStatusST(value : TFhirChargeitemStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirChargeitemStatusEnum[value], CODES_TFhirChargeitemStatusEnum[value]);
end;

Function TFhirChargeItem.GetPartOfList : TFhirReferenceList{TFhirChargeItem};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirChargeItem}.Create;
  result := FPartOfList;
end;

Function TFhirChargeItem.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirChargeItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirChargeItem.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirChargeItem.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirChargeItem.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Function TFhirChargeItem.GetParticipantList : TFhirChargeItemParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirChargeItemParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirChargeItem.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirChargeItem.SetPerformingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FPerformingOrganization.free;
  FPerformingOrganization := value;
end;

Procedure TFhirChargeItem.SetRequestingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestingOrganization.free;
  FRequestingOrganization := value;
end;

Procedure TFhirChargeItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirChargeItem.GetBodysiteList : TFhirCodeableConceptList;
begin
  if FBodysiteList = nil then
    FBodysiteList := TFhirCodeableConceptList.Create;
  result := FBodysiteList;
end;

Function TFhirChargeItem.GetHasBodysiteList : boolean;
begin
  result := (FBodysiteList <> nil) and (FBodysiteList.count > 0);
end;

Procedure TFhirChargeItem.SetFactorOverride(value : TFhirDecimal);
begin
  FFactorOverride.free;
  FFactorOverride := value;
end;

Function TFhirChargeItem.GetFactorOverrideST : String;
begin
  if FFactorOverride = nil then
    result := ''
  else
    result := FFactorOverride.value;
end;

Procedure TFhirChargeItem.SetFactorOverrideST(value : String);
begin
  if value <> '' then
  begin
    if FFactorOverride = nil then
      FFactorOverride := TFhirDecimal.create;
    FFactorOverride.value := value
  end
  else if FFactorOverride <> nil then
    FFactorOverride.value := '';
end;

Procedure TFhirChargeItem.SetPriceOverride(value : TFhirMoney);
begin
  FPriceOverride.free;
  FPriceOverride := value;
end;

Procedure TFhirChargeItem.SetOverrideReason(value : TFhirString);
begin
  FOverrideReason.free;
  FOverrideReason := value;
end;

Function TFhirChargeItem.GetOverrideReasonST : String;
begin
  if FOverrideReason = nil then
    result := ''
  else
    result := FOverrideReason.value;
end;

Procedure TFhirChargeItem.SetOverrideReasonST(value : String);
begin
  if value <> '' then
  begin
    if FOverrideReason = nil then
      FOverrideReason := TFhirString.create;
    FOverrideReason.value := value
  end
  else if FOverrideReason <> nil then
    FOverrideReason.value := '';
end;

Procedure TFhirChargeItem.SetEnterer(value : TFhirReference{Resource});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirChargeItem.SetEnteredDate(value : TFhirDateTime);
begin
  FEnteredDate.free;
  FEnteredDate := value;
end;

Function TFhirChargeItem.GetEnteredDateST : TFslDateTime;
begin
  if FEnteredDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnteredDate.value;
end;

Procedure TFhirChargeItem.SetEnteredDateST(value : TFslDateTime);
begin
  if FEnteredDate = nil then
    FEnteredDate := TFhirDateTime.create;
  FEnteredDate.value := value
end;

Function TFhirChargeItem.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirChargeItem.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirChargeItem.GetServiceList : TFhirReferenceList{Resource};
begin
  if FServiceList = nil then
    FServiceList := TFhirReferenceList{Resource}.Create;
  result := FServiceList;
end;

Function TFhirChargeItem.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

Function TFhirChargeItem.GetAccountList : TFhirReferenceList{TFhirAccount};
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList{TFhirAccount}.Create;
  result := FAccountList;
end;

Function TFhirChargeItem.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

Function TFhirChargeItem.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirChargeItem.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirChargeItem.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirChargeItem.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

function TFhirChargeItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FPerformingOrganization.sizeInBytes);
  inc(result, FRequestingOrganization.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FbodysiteList.sizeInBytes);
  inc(result, FFactorOverride.sizeInBytes);
  inc(result, FPriceOverride.sizeInBytes);
  inc(result, FOverrideReason.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FEnteredDate.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FserviceList.sizeInBytes);
  inc(result, FaccountList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
end;

{ TFhirChargeItemListEnumerator }

Constructor TFhirChargeItemListEnumerator.Create(list : TFhirChargeItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemListEnumerator.GetCurrent : TFhirChargeItem;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemList }
procedure TFhirChargeItemList.AddItem(value: TFhirChargeItem);
begin
  assert(value.ClassName = 'TFhirChargeItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItem');
  add(value);
end;

function TFhirChargeItemList.Append: TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemList.GetEnumerator : TFhirChargeItemListEnumerator;
begin
  result := TFhirChargeItemListEnumerator.Create(self.link);
end;

function TFhirChargeItemList.Clone: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Clone);
end;

function TFhirChargeItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemList.GetItemN(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItem;
end;
function TFhirChargeItemList.IndexOf(value: TFhirChargeItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemList.Insert(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.InsertItem(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  Inherited Insert(index, value);
end;

function TFhirChargeItemList.Item(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.Link: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Link);
end;

procedure TFhirChargeItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemList.SetItemByIndex(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  FhirChargeItems[index] := value;
end;

procedure TFhirChargeItemList.SetItemN(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEM}

{$IFDEF FHIR_CLAIM}

{ TFhirClaimRelated }

constructor TFhirClaimRelated.Create;
begin
  inherited;
end;

destructor TFhirClaimRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirClaimRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirClaimRelated(oSource).claim.Clone;
  relationship := TFhirClaimRelated(oSource).relationship.Clone;
  reference := TFhirClaimRelated(oSource).reference.Clone;
end;

procedure TFhirClaimRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirClaimRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));{2}
end;

function TFhirClaimRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirClaimRelated.Link : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Link);
end;

function TFhirClaimRelated.Clone : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Clone);
end;

function TFhirClaimRelated.equals(other : TObject) : boolean;
var
  o : TFhirClaimRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimRelated)) then
    result := false
  else
  begin
    o := TFhirClaimRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirClaimRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirClaimRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

{ TFhirClaimRelated }

Procedure TFhirClaimRelated.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirClaimRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirClaimRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

function TFhirClaimRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirClaimRelatedListEnumerator }

Constructor TFhirClaimRelatedListEnumerator.Create(list : TFhirClaimRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimRelatedListEnumerator.GetCurrent : TFhirClaimRelated;
begin
  Result := FList[FIndex];
end;

function TFhirClaimRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimRelatedList }
procedure TFhirClaimRelatedList.AddItem(value: TFhirClaimRelated);
begin
  assert(value.ClassName = 'TFhirClaimRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimRelated');
  add(value);
end;

function TFhirClaimRelatedList.Append: TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirClaimRelatedList.GetEnumerator : TFhirClaimRelatedListEnumerator;
begin
  result := TFhirClaimRelatedListEnumerator.Create(self.link);
end;

function TFhirClaimRelatedList.Clone: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Clone);
end;

function TFhirClaimRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimRelatedList.GetItemN(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimRelated;
end;
function TFhirClaimRelatedList.IndexOf(value: TFhirClaimRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimRelatedList.Insert(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.InsertItem(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  Inherited Insert(index, value);
end;

function TFhirClaimRelatedList.Item(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.Link: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Link);
end;

procedure TFhirClaimRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimRelatedList.SetItemByIndex(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  FhirClaimRelateds[index] := value;
end;

procedure TFhirClaimRelatedList.SetItemN(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimPayee }

constructor TFhirClaimPayee.Create;
begin
  inherited;
end;

destructor TFhirClaimPayee.Destroy;
begin
  FType_.free;
  FResourceType.free;
  FParty.free;
  inherited;
end;

procedure TFhirClaimPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimPayee(oSource).type_.Clone;
  resourceType := TFhirClaimPayee(oSource).resourceType.Clone;
  party := TFhirClaimPayee(oSource).party.Clone;
end;

procedure TFhirClaimPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resourceType') Then
     list.add(self.link, 'resourceType', FResourceType.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirClaimPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resourceType', 'Coding', false, TFhirCoding, FResourceType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FParty.Link));{2}
end;

function TFhirClaimPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'resourceType') then
  begin
    ResourceType := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'resourceType') then result := TFhirCoding.create(){4b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'resourceType') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resourceType') then ResourceTypeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'resourceType') then ResourceTypeElement := new as TFhirCoding{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimPayee.fhirType : string;
begin
  result := 'payee';
end;

function TFhirClaimPayee.Link : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Link);
end;

function TFhirClaimPayee.Clone : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Clone);
end;

function TFhirClaimPayee.equals(other : TObject) : boolean;
var
  o : TFhirClaimPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimPayee)) then
    result := false
  else
  begin
    o := TFhirClaimPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceTypeElement, o.resourceTypeElement, true) and
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirClaimPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResourceType) and isEmptyProp(FParty);
end;

procedure TFhirClaimPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resourceType');
  fields.add('party');
end;

{ TFhirClaimPayee }

Procedure TFhirClaimPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimPayee.SetResourceType(value : TFhirCoding);
begin
  FResourceType.free;
  FResourceType := value;
end;

Procedure TFhirClaimPayee.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

function TFhirClaimPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResourceType.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirClaimPayeeListEnumerator }

Constructor TFhirClaimPayeeListEnumerator.Create(list : TFhirClaimPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimPayeeListEnumerator.GetCurrent : TFhirClaimPayee;
begin
  Result := FList[FIndex];
end;

function TFhirClaimPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimPayeeList }
procedure TFhirClaimPayeeList.AddItem(value: TFhirClaimPayee);
begin
  assert(value.ClassName = 'TFhirClaimPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimPayee');
  add(value);
end;

function TFhirClaimPayeeList.Append: TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirClaimPayeeList.GetEnumerator : TFhirClaimPayeeListEnumerator;
begin
  result := TFhirClaimPayeeListEnumerator.Create(self.link);
end;

function TFhirClaimPayeeList.Clone: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Clone);
end;

function TFhirClaimPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimPayeeList.GetItemN(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimPayee;
end;
function TFhirClaimPayeeList.IndexOf(value: TFhirClaimPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimPayeeList.Insert(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.InsertItem(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  Inherited Insert(index, value);
end;

function TFhirClaimPayeeList.Item(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.Link: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Link);
end;

procedure TFhirClaimPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimPayeeList.SetItemByIndex(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  FhirClaimPayees[index] := value;
end;

procedure TFhirClaimPayeeList.SetItemN(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimCareTeam }

constructor TFhirClaimCareTeam.Create;
begin
  inherited;
end;

destructor TFhirClaimCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirClaimCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirClaimCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirClaimCareTeam(oSource).responsibleElement.Clone;
  role := TFhirClaimCareTeam(oSource).role.Clone;
  qualification := TFhirClaimCareTeam(oSource).qualification.Clone;
end;

procedure TFhirClaimCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirClaimCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));{2}
end;

function TFhirClaimCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new){5b}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimCareTeam.fhirType : string;
begin
  result := 'careTeam';
end;

function TFhirClaimCareTeam.Link : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Link);
end;

function TFhirClaimCareTeam.Clone : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Clone);
end;

function TFhirClaimCareTeam.equals(other : TObject) : boolean;
var
  o : TFhirClaimCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimCareTeam)) then
    result := false
  else
  begin
    o := TFhirClaimCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirClaimCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirClaimCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

{ TFhirClaimCareTeam }

Procedure TFhirClaimCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimCareTeam.SetProvider(value : TFhirReference{Resource});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaimCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirClaimCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

Procedure TFhirClaimCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

Procedure TFhirClaimCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirClaimCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

function TFhirClaimCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirClaimCareTeamListEnumerator }

Constructor TFhirClaimCareTeamListEnumerator.Create(list : TFhirClaimCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimCareTeamListEnumerator.GetCurrent : TFhirClaimCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirClaimCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimCareTeamList }
procedure TFhirClaimCareTeamList.AddItem(value: TFhirClaimCareTeam);
begin
  assert(value.ClassName = 'TFhirClaimCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimCareTeam');
  add(value);
end;

function TFhirClaimCareTeamList.Append: TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirClaimCareTeamList.GetEnumerator : TFhirClaimCareTeamListEnumerator;
begin
  result := TFhirClaimCareTeamListEnumerator.Create(self.link);
end;

function TFhirClaimCareTeamList.Clone: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Clone);
end;

function TFhirClaimCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimCareTeamList.GetItemN(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimCareTeam;
end;
function TFhirClaimCareTeamList.IndexOf(value: TFhirClaimCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimCareTeamList.Insert(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.InsertItem(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  Inherited Insert(index, value);
end;

function TFhirClaimCareTeamList.Item(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.Link: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Link);
end;

procedure TFhirClaimCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimCareTeamList.SetItemByIndex(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  FhirClaimCareTeams[index] := value;
end;

procedure TFhirClaimCareTeamList.SetItemN(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimInformation }

constructor TFhirClaimInformation.Create;
begin
  inherited;
end;

destructor TFhirClaimInformation.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirClaimInformation.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimInformation(oSource).sequenceElement.Clone;
  category := TFhirClaimInformation(oSource).category.Clone;
  code := TFhirClaimInformation(oSource).code.Clone;
  timing := TFhirClaimInformation(oSource).timing.Clone;
  value := TFhirClaimInformation(oSource).value.Clone;
  reason := TFhirClaimInformation(oSource).reason.Clone;
end;

procedure TFhirClaimInformation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirClaimInformation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|Quantity|Attachment|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
end;

function TFhirClaimInformation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimInformation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimInformation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimInformation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimInformation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil{4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimInformation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimInformation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimInformation.fhirType : string;
begin
  result := 'information';
end;

function TFhirClaimInformation.Link : TFhirClaimInformation;
begin
  result := TFhirClaimInformation(inherited Link);
end;

function TFhirClaimInformation.Clone : TFhirClaimInformation;
begin
  result := TFhirClaimInformation(inherited Clone);
end;

function TFhirClaimInformation.equals(other : TObject) : boolean;
var
  o : TFhirClaimInformation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimInformation)) then
    result := false
  else
  begin
    o := TFhirClaimInformation(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirClaimInformation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirClaimInformation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

{ TFhirClaimInformation }

Procedure TFhirClaimInformation.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimInformation.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimInformation.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimInformation.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimInformation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimInformation.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirClaimInformation.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirClaimInformation.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

function TFhirClaimInformation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirClaimInformationListEnumerator }

Constructor TFhirClaimInformationListEnumerator.Create(list : TFhirClaimInformationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimInformationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimInformationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimInformationListEnumerator.GetCurrent : TFhirClaimInformation;
begin
  Result := FList[FIndex];
end;

function TFhirClaimInformationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimInformationList }
procedure TFhirClaimInformationList.AddItem(value: TFhirClaimInformation);
begin
  assert(value.ClassName = 'TFhirClaimInformation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimInformation');
  add(value);
end;

function TFhirClaimInformationList.Append: TFhirClaimInformation;
begin
  result := TFhirClaimInformation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInformationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimInformationList.GetEnumerator : TFhirClaimInformationListEnumerator;
begin
  result := TFhirClaimInformationListEnumerator.Create(self.link);
end;

function TFhirClaimInformationList.Clone: TFhirClaimInformationList;
begin
  result := TFhirClaimInformationList(inherited Clone);
end;

function TFhirClaimInformationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimInformationList.GetItemN(index: Integer): TFhirClaimInformation;
begin
  result := TFhirClaimInformation(ObjectByIndex[index]);
end;

function TFhirClaimInformationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimInformation;
end;
function TFhirClaimInformationList.IndexOf(value: TFhirClaimInformation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimInformationList.Insert(index: Integer): TFhirClaimInformation;
begin
  result := TFhirClaimInformation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInformationList.InsertItem(index: Integer; value: TFhirClaimInformation);
begin
  assert(value is TFhirClaimInformation);
  Inherited Insert(index, value);
end;

function TFhirClaimInformationList.Item(index: Integer): TFhirClaimInformation;
begin
  result := TFhirClaimInformation(ObjectByIndex[index]);
end;

function TFhirClaimInformationList.Link: TFhirClaimInformationList;
begin
  result := TFhirClaimInformationList(inherited Link);
end;

procedure TFhirClaimInformationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimInformationList.SetItemByIndex(index: Integer; value: TFhirClaimInformation);
begin
  assert(value is TFhirClaimInformation);
  FhirClaimInformations[index] := value;
end;

procedure TFhirClaimInformationList.SetItemN(index: Integer; value: TFhirClaimInformation);
begin
  assert(value is TFhirClaimInformation);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimDiagnosis }

constructor TFhirClaimDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirClaimDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirClaimDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirClaimDiagnosis(oSource).diagnosis.Clone;
  if (TFhirClaimDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimDiagnosis(oSource).FType_List);
  end;
  packageCode := TFhirClaimDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirClaimDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirClaimDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FDiagnosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));{2}
end;

function TFhirClaimDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirClaimDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis'){4x}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil{4x}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirType{4x}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirClaimDiagnosis.Link : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Link);
end;

function TFhirClaimDiagnosis.Clone : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Clone);
end;

function TFhirClaimDiagnosis.equals(other : TObject) : boolean;
var
  o : TFhirClaimDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimDiagnosis)) then
    result := false
  else
  begin
    o := TFhirClaimDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and
      compareDeep(type_List, o.type_List, true) and compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirClaimDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FPackageCode);
end;

procedure TFhirClaimDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('packageCode');
end;

{ TFhirClaimDiagnosis }

Procedure TFhirClaimDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimDiagnosis.SetDiagnosis(value : TFhirType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

Function TFhirClaimDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirClaimDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirClaimDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

function TFhirClaimDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirClaimDiagnosisListEnumerator }

Constructor TFhirClaimDiagnosisListEnumerator.Create(list : TFhirClaimDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimDiagnosisListEnumerator.GetCurrent : TFhirClaimDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimDiagnosisList }
procedure TFhirClaimDiagnosisList.AddItem(value: TFhirClaimDiagnosis);
begin
  assert(value.ClassName = 'TFhirClaimDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimDiagnosis');
  add(value);
end;

function TFhirClaimDiagnosisList.Append: TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimDiagnosisList.GetEnumerator : TFhirClaimDiagnosisListEnumerator;
begin
  result := TFhirClaimDiagnosisListEnumerator.Create(self.link);
end;

function TFhirClaimDiagnosisList.Clone: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Clone);
end;

function TFhirClaimDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimDiagnosisList.GetItemN(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimDiagnosis;
end;
function TFhirClaimDiagnosisList.IndexOf(value: TFhirClaimDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimDiagnosisList.Insert(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.InsertItem(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirClaimDiagnosisList.Item(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.Link: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Link);
end;

procedure TFhirClaimDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimDiagnosisList.SetItemByIndex(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  FhirClaimDiagnoses[index] := value;
end;

procedure TFhirClaimDiagnosisList.SetItemN(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimProcedure }

constructor TFhirClaimProcedure.Create;
begin
  inherited;
end;

destructor TFhirClaimProcedure.Destroy;
begin
  FSequence.free;
  FDate.free;
  FProcedure_.free;
  inherited;
end;

procedure TFhirClaimProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimProcedure(oSource).sequenceElement.Clone;
  dateElement := TFhirClaimProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirClaimProcedure(oSource).procedure_.Clone;
end;

procedure TFhirClaimProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
end;

procedure TFhirClaimProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference(Procedure)', false, TFhirType, FProcedure_.Link));{2}
end;

function TFhirClaimProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimProcedure.fhirType : string;
begin
  result := 'procedure';
end;

function TFhirClaimProcedure.Link : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Link);
end;

function TFhirClaimProcedure.Clone : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Clone);
end;

function TFhirClaimProcedure.equals(other : TObject) : boolean;
var
  o : TFhirClaimProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimProcedure)) then
    result := false
  else
  begin
    o := TFhirClaimProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(procedure_Element, o.procedure_Element, true);
  end;
end;

function TFhirClaimProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDate) and isEmptyProp(FProcedure_);
end;

procedure TFhirClaimProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('date');
  fields.add('procedure[x]');
end;

{ TFhirClaimProcedure }

Procedure TFhirClaimProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirClaimProcedure.SetProcedure_(value : TFhirType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirClaimProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
end;

{ TFhirClaimProcedureListEnumerator }

Constructor TFhirClaimProcedureListEnumerator.Create(list : TFhirClaimProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimProcedureListEnumerator.GetCurrent : TFhirClaimProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirClaimProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimProcedureList }
procedure TFhirClaimProcedureList.AddItem(value: TFhirClaimProcedure);
begin
  assert(value.ClassName = 'TFhirClaimProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimProcedure');
  add(value);
end;

function TFhirClaimProcedureList.Append: TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirClaimProcedureList.GetEnumerator : TFhirClaimProcedureListEnumerator;
begin
  result := TFhirClaimProcedureListEnumerator.Create(self.link);
end;

function TFhirClaimProcedureList.Clone: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Clone);
end;

function TFhirClaimProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimProcedureList.GetItemN(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimProcedure;
end;
function TFhirClaimProcedureList.IndexOf(value: TFhirClaimProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimProcedureList.Insert(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.InsertItem(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  Inherited Insert(index, value);
end;

function TFhirClaimProcedureList.Item(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.Link: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Link);
end;

procedure TFhirClaimProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimProcedureList.SetItemByIndex(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  FhirClaimProcedures[index] := value;
end;

procedure TFhirClaimProcedureList.SetItemN(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimInsurance }

constructor TFhirClaimInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimInsurance(oSource).focalElement.Clone;
  coverage := TFhirClaimInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimInsurance(oSource).businessArrangementElement.Clone;
  if (TFhirClaimInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimInsurance(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
end;

function TFhirClaimInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirClaimInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirClaimInsurance.Link : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Link);
end;

function TFhirClaimInsurance.Clone : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Clone);
end;

function TFhirClaimInsurance.equals(other : TObject) : boolean;
var
  o : TFhirClaimInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and
      compareDeep(preAuthRefList, o.preAuthRefList, true) and compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('preAuthRef');
  fields.add('claimResponse');
end;

{ TFhirClaimInsurance }

Procedure TFhirClaimInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Function TFhirClaimInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirClaimInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Procedure TFhirClaimInsurance.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

function TFhirClaimInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimInsuranceListEnumerator }

Constructor TFhirClaimInsuranceListEnumerator.Create(list : TFhirClaimInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimInsuranceListEnumerator.GetCurrent : TFhirClaimInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimInsuranceList }
procedure TFhirClaimInsuranceList.AddItem(value: TFhirClaimInsurance);
begin
  assert(value.ClassName = 'TFhirClaimInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimInsurance');
  add(value);
end;

function TFhirClaimInsuranceList.Append: TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimInsuranceList.GetEnumerator : TFhirClaimInsuranceListEnumerator;
begin
  result := TFhirClaimInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimInsuranceList.Clone: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Clone);
end;

function TFhirClaimInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimInsuranceList.GetItemN(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimInsurance;
end;
function TFhirClaimInsuranceList.IndexOf(value: TFhirClaimInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimInsuranceList.Insert(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.InsertItem(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimInsuranceList.Item(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.Link: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Link);
end;

procedure TFhirClaimInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  FhirClaimInsurances[index] := value;
end;

procedure TFhirClaimInsuranceList.SetItemN(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimAccident }

constructor TFhirClaimAccident.Create;
begin
  inherited;
end;

destructor TFhirClaimAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirClaimAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirClaimAccident(oSource).dateElement.Clone;
  type_ := TFhirClaimAccident(oSource).type_.Clone;
  location := TFhirClaimAccident(oSource).location.Clone;
end;

procedure TFhirClaimAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirClaimAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
end;

function TFhirClaimAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimAccident.fhirType : string;
begin
  result := 'accident';
end;

function TFhirClaimAccident.Link : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Link);
end;

function TFhirClaimAccident.Clone : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Clone);
end;

function TFhirClaimAccident.equals(other : TObject) : boolean;
var
  o : TFhirClaimAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimAccident)) then
    result := false
  else
  begin
    o := TFhirClaimAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirClaimAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirClaimAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

{ TFhirClaimAccident }

Procedure TFhirClaimAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirClaimAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimAccident.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirClaimAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirClaimAccidentListEnumerator }

Constructor TFhirClaimAccidentListEnumerator.Create(list : TFhirClaimAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimAccidentListEnumerator.GetCurrent : TFhirClaimAccident;
begin
  Result := FList[FIndex];
end;

function TFhirClaimAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimAccidentList }
procedure TFhirClaimAccidentList.AddItem(value: TFhirClaimAccident);
begin
  assert(value.ClassName = 'TFhirClaimAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimAccident');
  add(value);
end;

function TFhirClaimAccidentList.Append: TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimAccidentList.GetEnumerator : TFhirClaimAccidentListEnumerator;
begin
  result := TFhirClaimAccidentListEnumerator.Create(self.link);
end;

function TFhirClaimAccidentList.Clone: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Clone);
end;

function TFhirClaimAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimAccidentList.GetItemN(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimAccident;
end;
function TFhirClaimAccidentList.IndexOf(value: TFhirClaimAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimAccidentList.Insert(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.InsertItem(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  Inherited Insert(index, value);
end;

function TFhirClaimAccidentList.Item(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.Link: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Link);
end;

procedure TFhirClaimAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimAccidentList.SetItemByIndex(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  FhirClaimAccidents[index] := value;
end;

procedure TFhirClaimAccidentList.SetItemN(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItem }

constructor TFhirClaimItem.Create;
begin
  inherited;
end;

destructor TFhirClaimItem.Destroy;
begin
  FSequence.free;
  FCareTeamLinkIdList.Free;
  FDiagnosisLinkIdList.Free;
  FProcedureLinkIdList.Free;
  FInformationLinkIdList.Free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItem(oSource).sequenceElement.Clone;
  if (TFhirClaimItem(oSource).FCareTeamLinkIdList = nil) then
  begin
    FCareTeamLinkIdList.free;
    FCareTeamLinkIdList := nil;
  end
  else
  begin
    if FCareTeamLinkIdList = nil then
      FCareTeamLinkIdList := TFhirPositiveIntList.Create;
    FCareTeamLinkIdList.Assign(TFhirClaimItem(oSource).FCareTeamLinkIdList);
  end;
  if (TFhirClaimItem(oSource).FDiagnosisLinkIdList = nil) then
  begin
    FDiagnosisLinkIdList.free;
    FDiagnosisLinkIdList := nil;
  end
  else
  begin
    if FDiagnosisLinkIdList = nil then
      FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
    FDiagnosisLinkIdList.Assign(TFhirClaimItem(oSource).FDiagnosisLinkIdList);
  end;
  if (TFhirClaimItem(oSource).FProcedureLinkIdList = nil) then
  begin
    FProcedureLinkIdList.free;
    FProcedureLinkIdList := nil;
  end
  else
  begin
    if FProcedureLinkIdList = nil then
      FProcedureLinkIdList := TFhirPositiveIntList.Create;
    FProcedureLinkIdList.Assign(TFhirClaimItem(oSource).FProcedureLinkIdList);
  end;
  if (TFhirClaimItem(oSource).FInformationLinkIdList = nil) then
  begin
    FInformationLinkIdList.free;
    FInformationLinkIdList := nil;
  end
  else
  begin
    if FInformationLinkIdList = nil then
      FInformationLinkIdList := TFhirPositiveIntList.Create;
    FInformationLinkIdList.Assign(TFhirClaimItem(oSource).FInformationLinkIdList);
  end;
  revenue := TFhirClaimItem(oSource).revenue.Clone;
  category := TFhirClaimItem(oSource).category.Clone;
  service := TFhirClaimItem(oSource).service.Clone;
  if (TFhirClaimItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItem(oSource).FModifierList);
  end;
  if (TFhirClaimItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimItem(oSource).serviced.Clone;
  location := TFhirClaimItem(oSource).location.Clone;
  quantity := TFhirClaimItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItem(oSource).factorElement.Clone;
  net := TFhirClaimItem(oSource).net.Clone;
  if (TFhirClaimItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItem(oSource).FUdiList);
  end;
  bodySite := TFhirClaimItem(oSource).bodySite.Clone;
  if (TFhirClaimItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
    FEncounterList.Assign(TFhirClaimItem(oSource).FEncounterList);
  end;
  if (TFhirClaimItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimItemDetailList.Create;
    FDetailList.Assign(TFhirClaimItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamLinkId') Then
    list.addAll(self, 'careTeamLinkId', FCareTeamLinkIdList);
  if (child_name = 'diagnosisLinkId') Then
    list.addAll(self, 'diagnosisLinkId', FDiagnosisLinkIdList);
  if (child_name = 'procedureLinkId') Then
    list.addAll(self, 'procedureLinkId', FProcedureLinkIdList);
  if (child_name = 'informationLinkId') Then
    list.addAll(self, 'informationLinkId', FInformationLinkIdList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeamLinkId', 'positiveInt', true, TFhirPositiveInt, FCareTeamLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosisLinkId', 'positiveInt', true, TFhirPositiveInt, FDiagnosisLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedureLinkId', 'positiveInt', true, TFhirPositiveInt, FProcedureLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'informationLinkId', 'positiveInt', true, TFhirPositiveInt, FInformationLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', true, TFhirReference{TFhirEncounter}, FEncounterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'careTeamLinkId') then
  begin
    CareTeamLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisLinkId') then
  begin
    DiagnosisLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureLinkId') then
  begin
    ProcedureLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationLinkId') then
  begin
    InformationLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference{TFhirEncounter}){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamLinkId') then CareTeamLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'procedureLinkId') then ProcedureLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'informationLinkId') then InformationLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference{TFhirEncounter}){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimItemDetail){2a}
  else inherited;
end;

function TFhirClaimItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'careTeamLinkId') then result := CareTeamLinkIdList.new(){2}
  else if (propName = 'diagnosisLinkId') then result := DiagnosisLinkIdList.new(){2}
  else if (propName = 'procedureLinkId') then result := ProcedureLinkIdList.new(){2}
  else if (propName = 'informationLinkId') then result := InformationLinkIdList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'encounter') then result := EncounterList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamLinkId') then result := 'positiveInt'
  else if (propName = 'diagnosisLinkId') then result := 'positiveInt'
  else if (propName = 'procedureLinkId') then result := 'positiveInt'
  else if (propName = 'informationLinkId') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamLinkId') then deletePropertyValue('careTeamLinkId', CareTeamLinkIdList, value) {2}
  else if (propName = 'diagnosisLinkId') then deletePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, value) {2}
  else if (propName = 'procedureLinkId') then deletePropertyValue('procedureLinkId', ProcedureLinkIdList, value) {2}
  else if (propName = 'informationLinkId') then deletePropertyValue('informationLinkId', InformationLinkIdList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'careTeamLinkId') then replacePropertyValue('careTeamLinkId', CareTeamLinkIdList, existing, new) {2}
  else if (propName = 'diagnosisLinkId') then replacePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, existing, new) {2}
  else if (propName = 'procedureLinkId') then replacePropertyValue('procedureLinkId', ProcedureLinkIdList, existing, new) {2}
  else if (propName = 'informationLinkId') then replacePropertyValue('informationLinkId', InformationLinkIdList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamLinkId') then CareTeamLinkIdList.move(source, destination){2}
  else if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.move(source, destination){2}
  else if (propName = 'procedureLinkId') then ProcedureLinkIdList.move(source, destination){2}
  else if (propName = 'informationLinkId') then InformationLinkIdList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'encounter') then EncounterList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimItem.Link : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Link);
end;

function TFhirClaimItem.Clone : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Clone);
end;

function TFhirClaimItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItem)) then
    result := false
  else
  begin
    o := TFhirClaimItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamLinkIdList, o.careTeamLinkIdList, true) and
      compareDeep(diagnosisLinkIdList, o.diagnosisLinkIdList, true) and compareDeep(procedureLinkIdList, o.procedureLinkIdList, true) and
      compareDeep(informationLinkIdList, o.informationLinkIdList, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamLinkIdList) and isEmptyProp(FdiagnosisLinkIdList) and isEmptyProp(FprocedureLinkIdList) and isEmptyProp(FinformationLinkIdList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamLinkId');
  fields.add('diagnosisLinkId');
  fields.add('procedureLinkId');
  fields.add('informationLinkId');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('detail');
end;

{ TFhirClaimItem }

Procedure TFhirClaimItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirClaimItem.GetCareTeamLinkIdList : TFhirPositiveIntList;
begin
  if FCareTeamLinkIdList = nil then
    FCareTeamLinkIdList := TFhirPositiveIntList.Create;
  result := FCareTeamLinkIdList;
end;

Function TFhirClaimItem.GetHasCareTeamLinkIdList : boolean;
begin
  result := (FCareTeamLinkIdList <> nil) and (FCareTeamLinkIdList.count > 0);
end;

Function TFhirClaimItem.GetDiagnosisLinkIdList : TFhirPositiveIntList;
begin
  if FDiagnosisLinkIdList = nil then
    FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
  result := FDiagnosisLinkIdList;
end;

Function TFhirClaimItem.GetHasDiagnosisLinkIdList : boolean;
begin
  result := (FDiagnosisLinkIdList <> nil) and (FDiagnosisLinkIdList.count > 0);
end;

Function TFhirClaimItem.GetProcedureLinkIdList : TFhirPositiveIntList;
begin
  if FProcedureLinkIdList = nil then
    FProcedureLinkIdList := TFhirPositiveIntList.Create;
  result := FProcedureLinkIdList;
end;

Function TFhirClaimItem.GetHasProcedureLinkIdList : boolean;
begin
  result := (FProcedureLinkIdList <> nil) and (FProcedureLinkIdList.count > 0);
end;

Function TFhirClaimItem.GetInformationLinkIdList : TFhirPositiveIntList;
begin
  if FInformationLinkIdList = nil then
    FInformationLinkIdList := TFhirPositiveIntList.Create;
  result := FInformationLinkIdList;
end;

Function TFhirClaimItem.GetHasInformationLinkIdList : boolean;
begin
  result := (FInformationLinkIdList <> nil) and (FInformationLinkIdList.count > 0);
end;

Procedure TFhirClaimItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItem.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirClaimItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirClaimItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirClaimItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItem.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Procedure TFhirClaimItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirClaimItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirClaimItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirClaimItem.GetEncounterList : TFhirReferenceList{TFhirEncounter};
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
  result := FEncounterList;
end;

Function TFhirClaimItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

Function TFhirClaimItem.GetDetailList : TFhirClaimItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamLinkIdList.sizeInBytes);
  inc(result, FdiagnosisLinkIdList.sizeInBytes);
  inc(result, FprocedureLinkIdList.sizeInBytes);
  inc(result, FinformationLinkIdList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimItemListEnumerator }

Constructor TFhirClaimItemListEnumerator.Create(list : TFhirClaimItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemListEnumerator.GetCurrent : TFhirClaimItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemList }
procedure TFhirClaimItemList.AddItem(value: TFhirClaimItem);
begin
  assert(value.ClassName = 'TFhirClaimItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItem');
  add(value);
end;

function TFhirClaimItemList.Append: TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemList.GetEnumerator : TFhirClaimItemListEnumerator;
begin
  result := TFhirClaimItemListEnumerator.Create(self.link);
end;

function TFhirClaimItemList.Clone: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Clone);
end;

function TFhirClaimItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemList.GetItemN(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItem;
end;
function TFhirClaimItemList.IndexOf(value: TFhirClaimItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemList.Insert(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.InsertItem(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  Inherited Insert(index, value);
end;

function TFhirClaimItemList.Item(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.Link: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Link);
end;

procedure TFhirClaimItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemList.SetItemByIndex(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  FhirClaimItems[index] := value;
end;

procedure TFhirClaimItemList.SetItemN(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetail }

constructor TFhirClaimItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetail(oSource).category.Clone;
  service := TFhirClaimItemDetail(oSource).service.Clone;
  if (TFhirClaimItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetail(oSource).net.Clone;
  if (TFhirClaimItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItemDetail(oSource).FUdiList);
  end;
  if (TFhirClaimItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimItemDetail.Link : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Link);
end;

function TFhirClaimItemDetail.Clone : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Clone);
end;

function TFhirClaimItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiList, o.udiList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('subDetail');
end;

{ TFhirClaimItemDetail }

Procedure TFhirClaimItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItemDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirClaimItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItemDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirClaimItemDetail.GetSubDetailList : TFhirClaimItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimItemDetailListEnumerator }

Constructor TFhirClaimItemDetailListEnumerator.Create(list : TFhirClaimItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailListEnumerator.GetCurrent : TFhirClaimItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailList }
procedure TFhirClaimItemDetailList.AddItem(value: TFhirClaimItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetail');
  add(value);
end;

function TFhirClaimItemDetailList.Append: TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailList.GetEnumerator : TFhirClaimItemDetailListEnumerator;
begin
  result := TFhirClaimItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailList.Clone: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Clone);
end;

function TFhirClaimItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailList.GetItemN(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetail;
end;
function TFhirClaimItemDetailList.IndexOf(value: TFhirClaimItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailList.Insert(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailList.Item(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.Link: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  FhirClaimItemDetails[index] := value;
end;

procedure TFhirClaimItemDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetailSubDetail }

constructor TFhirClaimItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetailSubDetail(oSource).category.Clone;
  service := TFhirClaimItemDetailSubDetail(oSource).service.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItemDetailSubDetail(oSource).FUdiList);
  end;
end;

procedure TFhirClaimItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
end;

function TFhirClaimItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else inherited;
end;

function TFhirClaimItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimItemDetailSubDetail.Link : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Link);
end;

function TFhirClaimItemDetailSubDetail.Clone : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimItemDetailSubDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList);
end;

procedure TFhirClaimItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
end;

{ TFhirClaimItemDetailSubDetail }

Procedure TFhirClaimItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirClaimItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItemDetailSubDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirClaimItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailListEnumerator }

Constructor TFhirClaimItemDetailSubDetailListEnumerator.Create(list : TFhirClaimItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailList }
procedure TFhirClaimItemDetailSubDetailList.AddItem(value: TFhirClaimItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetailSubDetail');
  add(value);
end;

function TFhirClaimItemDetailSubDetailList.Append: TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailSubDetailList.GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailSubDetailList.Clone: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetailSubDetail;
end;
function TFhirClaimItemDetailSubDetailList.IndexOf(value: TFhirClaimItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailSubDetailList.Insert(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailSubDetailList.Item(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.Link: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  FhirClaimItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaim }

constructor TFhirClaim.Create;
begin
  inherited;
end;

destructor TFhirClaim.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubTypeList.Free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FOrganization.free;
  FPriority.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FCareTeamList.Free;
  FInformationList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FInsuranceList.Free;
  FAccident.free;
  FEmploymentImpacted.free;
  FHospitalization.free;
  FItemList.Free;
  FTotal.free;
  inherited;
end;

function TFhirClaim.GetResourceType : TFhirResourceType;
begin
  result := frtClaim;
end;

procedure TFhirClaim.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaim(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaim(oSource).FIdentifierList);
  end;
  FStatus := TFhirClaim(oSource).FStatus.Link;
  type_ := TFhirClaim(oSource).type_.Clone;
  if (TFhirClaim(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirClaim(oSource).FSubTypeList);
  end;
  FUse := TFhirClaim(oSource).FUse.Link;
  patient := TFhirClaim(oSource).patient.Clone;
  billablePeriod := TFhirClaim(oSource).billablePeriod.Clone;
  createdElement := TFhirClaim(oSource).createdElement.Clone;
  enterer := TFhirClaim(oSource).enterer.Clone;
  insurer := TFhirClaim(oSource).insurer.Clone;
  provider := TFhirClaim(oSource).provider.Clone;
  organization := TFhirClaim(oSource).organization.Clone;
  priority := TFhirClaim(oSource).priority.Clone;
  fundsReserve := TFhirClaim(oSource).fundsReserve.Clone;
  if (TFhirClaim(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirClaimRelatedList.Create;
    FRelatedList.Assign(TFhirClaim(oSource).FRelatedList);
  end;
  prescription := TFhirClaim(oSource).prescription.Clone;
  originalPrescription := TFhirClaim(oSource).originalPrescription.Clone;
  payee := TFhirClaim(oSource).payee.Clone;
  referral := TFhirClaim(oSource).referral.Clone;
  facility := TFhirClaim(oSource).facility.Clone;
  if (TFhirClaim(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirClaimCareTeamList.Create;
    FCareTeamList.Assign(TFhirClaim(oSource).FCareTeamList);
  end;
  if (TFhirClaim(oSource).FInformationList = nil) then
  begin
    FInformationList.free;
    FInformationList := nil;
  end
  else
  begin
    if FInformationList = nil then
      FInformationList := TFhirClaimInformationList.Create;
    FInformationList.Assign(TFhirClaim(oSource).FInformationList);
  end;
  if (TFhirClaim(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirClaimDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirClaim(oSource).FDiagnosisList);
  end;
  if (TFhirClaim(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirClaimProcedureList.Create;
    FProcedure_List.Assign(TFhirClaim(oSource).FProcedure_List);
  end;
  if (TFhirClaim(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaim(oSource).FInsuranceList);
  end;
  accident := TFhirClaim(oSource).accident.Clone;
  employmentImpacted := TFhirClaim(oSource).employmentImpacted.Clone;
  hospitalization := TFhirClaim(oSource).hospitalization.Clone;
  if (TFhirClaim(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimItemList.Create;
    FItemList.Assign(TFhirClaim(oSource).FItemList);
  end;
  total := TFhirClaim(oSource).total.Clone;
end;

procedure TFhirClaim.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'information') Then
    list.addAll(self, 'information', FInformationList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'employmentImpacted') Then
     list.add(self.link, 'employmentImpacted', FEmploymentImpacted.Link);
  if (child_name = 'hospitalization') Then
     list.add(self.link, 'hospitalization', FHospitalization.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
end;

procedure TFhirClaim.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirClaimRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationRequest|VisionPrescription)', false, TFhirReference{Resource}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FOriginalPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', '', false, TFhirClaimPayee, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference(ReferralRequest)', false, TFhirReference{TFhirReferralRequest}, FReferral.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeam', '', true, TFhirClaimCareTeam, FCareTeamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'information', '', true, TFhirClaimInformation, FInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirClaimDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedure', '', true, TFhirClaimProcedure, FProcedure_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirClaimInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'accident', '', false, TFhirClaimAccident, FAccident.Link));{2}
  oList.add(TFHIRProperty.create(self, 'employmentImpacted', 'Period', false, TFhirPeriod, FEmploymentImpacted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hospitalization', 'Period', false, TFhirPeriod, FHospitalization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'total', 'Money', false, TFhirMoney, FTotal.Link));{2}
end;

function TFhirClaim.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirClaimRelated){2a};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirClaimPayee{4b};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference{TFhirReferralRequest}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirClaimCareTeam){2a};
    result := propValue;
  end
  else if (propName = 'information') then
  begin
    InformationList.add(propValue as TFhirClaimInformation){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirClaimDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirClaimProcedure){2a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimInsurance){2a};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirClaimAccident{4b};
    result := propValue;
  end
  else if (propName = 'employmentImpacted') then
  begin
    EmploymentImpacted := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'hospitalization') then
  begin
    Hospitalization := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimItem){2a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaim.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirClaimRelated){2a}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirClaimCareTeam){2a}
  else if (propName = 'information') then InformationList.insertItem(index, propValue as TFhirClaimInformation){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirClaimDiagnosis){2a}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirClaimProcedure){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimInsurance){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimItem){2a}
  else inherited;
end;

function TFhirClaim.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := SubTypeList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'prescription') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'originalPrescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'payee') then result := TFhirClaimPayee.create(){4b}
  else if (propName = 'referral') then result := TFhirReference{TFhirReferralRequest}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'careTeam') then result := CareTeamList.new(){2}
  else if (propName = 'information') then result := InformationList.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'procedure') then result := Procedure_List.new(){2}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'accident') then result := TFhirClaimAccident.create(){4b}
  else if (propName = 'employmentImpacted') then result := TFhirPeriod.create(){4b}
  else if (propName = 'hospitalization') then result := TFhirPeriod.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'total') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaim.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := ''
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := ''
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'careTeam') then result := ''
  else if (propName = 'information') then result := ''
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'procedure') then result := ''
  else if (propName = 'insurance') then result := ''
  else if (propName = 'accident') then result := ''
  else if (propName = 'employmentImpacted') then result := 'Period'
  else if (propName = 'hospitalization') then result := 'Period'
  else if (propName = 'item') then result := ''
  else if (propName = 'total') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaim.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value) {2}
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {2}
  else if (propName = 'information') then deletePropertyValue('information', InformationList, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {2}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'employmentImpacted') then EmploymentImpactedElement := nil
  else if (propName = 'hospitalization') then HospitalizationElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'total') then TotalElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaim.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new) {2}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept{4}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{Resource}{4}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirClaimPayee{4}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference{TFhirReferralRequest}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {2}
  else if (propName = 'information') then replacePropertyValue('information', InformationList, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {2}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'accident') then AccidentElement := new as TFhirClaimAccident{4}
  else if (propName = 'employmentImpacted') then EmploymentImpactedElement := new as TFhirPeriod{4}
  else if (propName = 'hospitalization') then HospitalizationElement := new as TFhirPeriod{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'total') then TotalElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaim.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'subType') then SubTypeList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination){2a}
  else if (propName = 'information') then InformationList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'procedure') then Procedure_List.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaim.fhirType : string;
begin
  result := 'Claim';
end;

function TFhirClaim.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FcareTeamList) and isEmptyProp(FinformationList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident) and isEmptyProp(FEmploymentImpacted) and isEmptyProp(FHospitalization) and isEmptyProp(FitemList) and isEmptyProp(FTotal);
end;

function TFhirClaim.equals(other : TObject) : boolean;
var
  o : TFhirClaim;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaim)) then
    result := false
  else
  begin
    o := TFhirClaim(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and
      compareDeep(providerElement, o.providerElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(fundsReserveElement, o.fundsReserveElement, true) and
      compareDeep(relatedList, o.relatedList, true) and compareDeep(prescriptionElement, o.prescriptionElement, true) and
      compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(careTeamList, o.careTeamList, true) and
      compareDeep(informationList, o.informationList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(insuranceList, o.insuranceList, true) and
      compareDeep(accidentElement, o.accidentElement, true) and compareDeep(employmentImpactedElement, o.employmentImpactedElement, true) and
      compareDeep(hospitalizationElement, o.hospitalizationElement, true) and compareDeep(itemList, o.itemList, true) and
      compareDeep(totalElement, o.totalElement, true);
  end;
end;

function TFhirClaim.Link : TFhirClaim;
begin
  result := TFhirClaim(inherited Link);
end;

function TFhirClaim.Clone : TFhirClaim;
begin
  result := TFhirClaim(inherited Clone);
end;

procedure TFhirClaim.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('organization');
  fields.add('priority');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('careTeam');
  fields.add('information');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('insurance');
  fields.add('accident');
  fields.add('employmentImpacted');
  fields.add('hospitalization');
  fields.add('item');
  fields.add('total');
end;

{ TFhirClaim }

Function TFhirClaim.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaim.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaim.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClaim.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirClaim.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirClaim.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirClaim.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

Function TFhirClaim.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

Procedure TFhirClaim.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirClaim.GetUseST : TFhirClaimUseEnum;
begin
  if FUse = nil then
    result := TFhirClaimUseEnum(0)
  else
    result := TFhirClaimUseEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimUseEnum, FUse.value));
end;

Procedure TFhirClaim.SetUseST(value : TFhirClaimUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirClaimUseEnum[value], CODES_TFhirClaimUseEnum[value]);
end;

Procedure TFhirClaim.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirClaim.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

Procedure TFhirClaim.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaim.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaim.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaim.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirClaim.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirClaim.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaim.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirClaim.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirClaim.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

Function TFhirClaim.GetRelatedList : TFhirClaimRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirClaimRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirClaim.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Procedure TFhirClaim.SetPrescription(value : TFhirReference{Resource});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirClaim.SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

Procedure TFhirClaim.SetPayee(value : TFhirClaimPayee);
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirClaim.SetReferral(value : TFhirReference{TFhirReferralRequest});
begin
  FReferral.free;
  FReferral := value;
end;

Procedure TFhirClaim.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Function TFhirClaim.GetCareTeamList : TFhirClaimCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirClaimCareTeamList.Create;
  result := FCareTeamList;
end;

Function TFhirClaim.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

Function TFhirClaim.GetInformationList : TFhirClaimInformationList;
begin
  if FInformationList = nil then
    FInformationList := TFhirClaimInformationList.Create;
  result := FInformationList;
end;

Function TFhirClaim.GetHasInformationList : boolean;
begin
  result := (FInformationList <> nil) and (FInformationList.count > 0);
end;

Function TFhirClaim.GetDiagnosisList : TFhirClaimDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirClaimDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirClaim.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirClaim.GetProcedure_List : TFhirClaimProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirClaimProcedureList.Create;
  result := FProcedure_List;
end;

Function TFhirClaim.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

Function TFhirClaim.GetInsuranceList : TFhirClaimInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirClaim.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Procedure TFhirClaim.SetAccident(value : TFhirClaimAccident);
begin
  FAccident.free;
  FAccident := value;
end;

Procedure TFhirClaim.SetEmploymentImpacted(value : TFhirPeriod);
begin
  FEmploymentImpacted.free;
  FEmploymentImpacted := value;
end;

Procedure TFhirClaim.SetHospitalization(value : TFhirPeriod);
begin
  FHospitalization.free;
  FHospitalization := value;
end;

Function TFhirClaim.GetItemList : TFhirClaimItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimItemList.Create;
  result := FItemList;
end;

Function TFhirClaim.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Procedure TFhirClaim.SetTotal(value : TFhirMoney);
begin
  FTotal.free;
  FTotal := value;
end;

function TFhirClaim.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubTypeList.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FinformationList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FEmploymentImpacted.sizeInBytes);
  inc(result, FHospitalization.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
end;

{ TFhirClaimListEnumerator }

Constructor TFhirClaimListEnumerator.Create(list : TFhirClaimList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimListEnumerator.GetCurrent : TFhirClaim;
begin
  Result := FList[FIndex];
end;

function TFhirClaimListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimList }
procedure TFhirClaimList.AddItem(value: TFhirClaim);
begin
  assert(value.ClassName = 'TFhirClaim', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaim');
  add(value);
end;

function TFhirClaimList.Append: TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.ClearItems;
begin
  Clear;
end;

function TFhirClaimList.GetEnumerator : TFhirClaimListEnumerator;
begin
  result := TFhirClaimListEnumerator.Create(self.link);
end;

function TFhirClaimList.Clone: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Clone);
end;

function TFhirClaimList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimList.GetItemN(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaim;
end;
function TFhirClaimList.IndexOf(value: TFhirClaim): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimList.Insert(index: Integer): TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.InsertItem(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  Inherited Insert(index, value);
end;

function TFhirClaimList.Item(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.Link: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Link);
end;

procedure TFhirClaimList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimList.SetItemByIndex(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  FhirClaims[index] := value;
end;

procedure TFhirClaimList.SetItemN(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

{ TFhirClaimResponseItem }

constructor TFhirClaimResponseItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItem.Destroy;
begin
  FSequenceLinkId.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItem(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimResponseItem.Link : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Link);
end;

function TFhirClaimResponseItem.Clone : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Clone);
end;

function TFhirClaimResponseItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItem(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseItem }

Procedure TFhirClaimResponseItem.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItem.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItem.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItem.GetDetailList : TFhirClaimResponseItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemListEnumerator }

Constructor TFhirClaimResponseItemListEnumerator.Create(list : TFhirClaimResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemListEnumerator.GetCurrent : TFhirClaimResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemList }
procedure TFhirClaimResponseItemList.AddItem(value: TFhirClaimResponseItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItem');
  add(value);
end;

function TFhirClaimResponseItemList.Append: TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemList.GetEnumerator : TFhirClaimResponseItemListEnumerator;
begin
  result := TFhirClaimResponseItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemList.Clone: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Clone);
end;

function TFhirClaimResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemList.GetItemN(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItem;
end;
function TFhirClaimResponseItemList.IndexOf(value: TFhirClaimResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemList.Insert(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.InsertItem(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemList.Item(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.Link: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Link);
end;

procedure TFhirClaimResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  FhirClaimResponseItems[index] := value;
end;

procedure TFhirClaimResponseItemList.SetItemN(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemAdjudication }

constructor TFhirClaimResponseItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseItemAdjudication(oSource).category.Clone;
  reason := TFhirClaimResponseItemAdjudication(oSource).reason.Clone;
  amount := TFhirClaimResponseItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseItemAdjudication.Link : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Link);
end;

function TFhirClaimResponseItemAdjudication.Clone : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseItemAdjudication }

Procedure TFhirClaimResponseItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationListEnumerator }

Constructor TFhirClaimResponseItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationList }
procedure TFhirClaimResponseItemAdjudicationList.AddItem(value: TFhirClaimResponseItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemAdjudication');
  add(value);
end;

function TFhirClaimResponseItemAdjudicationList.Append: TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemAdjudicationList.GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemAdjudicationList.Clone: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemAdjudication;
end;
function TFhirClaimResponseItemAdjudicationList.IndexOf(value: TFhirClaimResponseItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemAdjudicationList.Item(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.Link: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  FhirClaimResponseItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetail }

constructor TFhirClaimResponseItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetail.Destroy;
begin
  FSequenceLinkId.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItemDetail(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimResponseItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimResponseItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseItemDetail.Link : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Link);
end;

function TFhirClaimResponseItemDetail.Clone : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetail(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirClaimResponseItemDetail }

Procedure TFhirClaimResponseItemDetail.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItemDetail.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItemDetail.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItemDetail.GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimResponseItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimResponseItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailList }
procedure TFhirClaimResponseItemDetailList.AddItem(value: TFhirClaimResponseItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailList.Append: TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailList.GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailList.Clone: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetail;
end;
function TFhirClaimResponseItemDetailList.IndexOf(value: TFhirClaimResponseItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailList.Insert(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailList.Item(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.Link: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  FhirClaimResponseItemDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetail }

constructor TFhirClaimResponseItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetail.Destroy;
begin
  FSequenceLinkId.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItemDetailSubDetail(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimResponseItemDetailSubDetail.Link : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetail.Clone : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetail(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirClaimResponseItemDetailSubDetail }

Procedure TFhirClaimResponseItemDetailSubDetail.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItemDetailSubDetail.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailList }
procedure TFhirClaimResponseItemDetailSubDetailList.AddItem(value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Append: TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailList.Clone: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetail;
end;
function TFhirClaimResponseItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.Link: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  FhirClaimResponseItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItem }

constructor TFhirClaimResponseAddItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItem.Destroy;
begin
  FSequenceLinkIdList.Free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FFee.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponseAddItem(oSource).FSequenceLinkIdList = nil) then
  begin
    FSequenceLinkIdList.free;
    FSequenceLinkIdList := nil;
  end
  else
  begin
    if FSequenceLinkIdList = nil then
      FSequenceLinkIdList := TFhirPositiveIntList.Create;
    FSequenceLinkIdList.Assign(TFhirClaimResponseAddItem(oSource).FSequenceLinkIdList);
  end;
  revenue := TFhirClaimResponseAddItem(oSource).revenue.Clone;
  category := TFhirClaimResponseAddItem(oSource).category.Clone;
  service := TFhirClaimResponseAddItem(oSource).service.Clone;
  if (TFhirClaimResponseAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItem(oSource).FModifierList);
  end;
  fee := TFhirClaimResponseAddItem(oSource).fee.Clone;
  if (TFhirClaimResponseAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseAddItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
    list.addAll(self, 'sequenceLinkId', FSequenceLinkIdList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', true, TFhirPositiveInt, FSequenceLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fee', 'Money', false, TFhirMoney, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseAddItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseAddItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := SequenceLinkIdList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'fee') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'fee') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then deletePropertyValue('sequenceLinkId', SequenceLinkIdList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then replacePropertyValue('sequenceLinkId', SequenceLinkIdList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'fee') then FeeElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItem.fhirType : string;
begin
  result := 'addItem';
end;

function TFhirClaimResponseAddItem.Link : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Link);
end;

function TFhirClaimResponseAddItem.Clone : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Clone);
end;

function TFhirClaimResponseAddItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItem(other);
    result := compareDeep(sequenceLinkIdList, o.sequenceLinkIdList, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(feeElement, o.feeElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsequenceLinkIdList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FFee) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('fee');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseAddItem }

Function TFhirClaimResponseAddItem.GetSequenceLinkIdList : TFhirPositiveIntList;
begin
  if FSequenceLinkIdList = nil then
    FSequenceLinkIdList := TFhirPositiveIntList.Create;
  result := FSequenceLinkIdList;
end;

Function TFhirClaimResponseAddItem.GetHasSequenceLinkIdList : boolean;
begin
  result := (FSequenceLinkIdList <> nil) and (FSequenceLinkIdList.count > 0);
end;

Procedure TFhirClaimResponseAddItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimResponseAddItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimResponseAddItem.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirClaimResponseAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimResponseAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirClaimResponseAddItem.SetFee(value : TFhirMoney);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirClaimResponseAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetDetailList : TFhirClaimResponseAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseAddItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsequenceLinkIdList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemListEnumerator }

Constructor TFhirClaimResponseAddItemListEnumerator.Create(list : TFhirClaimResponseAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemListEnumerator.GetCurrent : TFhirClaimResponseAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemList }
procedure TFhirClaimResponseAddItemList.AddItem(value: TFhirClaimResponseAddItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItem');
  add(value);
end;

function TFhirClaimResponseAddItemList.Append: TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemList.GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
begin
  result := TFhirClaimResponseAddItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemList.Clone: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Clone);
end;

function TFhirClaimResponseAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemList.GetItemN(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItem;
end;
function TFhirClaimResponseAddItemList.IndexOf(value: TFhirClaimResponseAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemList.Insert(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.InsertItem(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemList.Item(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.Link: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Link);
end;

procedure TFhirClaimResponseAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  FhirClaimResponseAddItems[index] := value;
end;

procedure TFhirClaimResponseAddItemList.SetItemN(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetail }

constructor TFhirClaimResponseAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetail.Destroy;
begin
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FFee.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  revenue := TFhirClaimResponseAddItemDetail(oSource).revenue.Clone;
  category := TFhirClaimResponseAddItemDetail(oSource).category.Clone;
  service := TFhirClaimResponseAddItemDetail(oSource).service.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetail(oSource).FModifierList);
  end;
  fee := TFhirClaimResponseAddItemDetail(oSource).fee.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fee', 'Money', false, TFhirMoney, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'fee') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'fee') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'fee') then FeeElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseAddItemDetail.Link : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetail.Clone : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetail(other);
    result := compareDeep(revenueElement, o.revenueElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(modifierList, o.modifierList, true) and
      compareDeep(feeElement, o.feeElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FFee) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('fee');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirClaimResponseAddItemDetail }

Procedure TFhirClaimResponseAddItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirClaimResponseAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirClaimResponseAddItemDetail.SetFee(value : TFhirMoney);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirClaimResponseAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseAddItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailListEnumerator }

Constructor TFhirClaimResponseAddItemDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailList }
procedure TFhirClaimResponseAddItemDetailList.AddItem(value: TFhirClaimResponseAddItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailList.Append: TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailList.Clone: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetail;
end;
function TFhirClaimResponseAddItemDetailList.IndexOf(value: TFhirClaimResponseAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.Link: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  FhirClaimResponseAddItemDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseError }

constructor TFhirClaimResponseError.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseError.Destroy;
begin
  FSequenceLinkId.free;
  FDetailSequenceLinkId.free;
  FSubdetailSequenceLinkId.free;
  FCode.free;
  inherited;
end;

procedure TFhirClaimResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseError(oSource).sequenceLinkIdElement.Clone;
  detailSequenceLinkIdElement := TFhirClaimResponseError(oSource).detailSequenceLinkIdElement.Clone;
  subdetailSequenceLinkIdElement := TFhirClaimResponseError(oSource).subdetailSequenceLinkIdElement.Clone;
  code := TFhirClaimResponseError(oSource).code.Clone;
end;

procedure TFhirClaimResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'detailSequenceLinkId') Then
     list.add(self.link, 'detailSequenceLinkId', FDetailSequenceLinkId.Link);
  if (child_name = 'subdetailSequenceLinkId') Then
     list.add(self.link, 'subdetailSequenceLinkId', FSubdetailSequenceLinkId.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClaimResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detailSequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FDetailSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subdetailSequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSubdetailSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirClaimResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detailSequenceLinkId') then
  begin
    DetailSequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subdetailSequenceLinkId') then
  begin
    SubdetailSequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'detailSequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'subdetailSequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'detailSequenceLinkId') then result := 'positiveInt'
  else if (propName = 'subdetailSequenceLinkId') then result := 'positiveInt'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'detailSequenceLinkId') then DetailSequenceLinkIdElement := nil
  else if (propName = 'subdetailSequenceLinkId') then SubdetailSequenceLinkIdElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'detailSequenceLinkId') then DetailSequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'subdetailSequenceLinkId') then SubdetailSequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseError.fhirType : string;
begin
  result := 'error';
end;

function TFhirClaimResponseError.Link : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Link);
end;

function TFhirClaimResponseError.Clone : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Clone);
end;

function TFhirClaimResponseError.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseError)) then
    result := false
  else
  begin
    o := TFhirClaimResponseError(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(detailSequenceLinkIdElement, o.detailSequenceLinkIdElement, true) and
      compareDeep(subdetailSequenceLinkIdElement, o.subdetailSequenceLinkIdElement, true) and
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClaimResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FDetailSequenceLinkId) and isEmptyProp(FSubdetailSequenceLinkId) and isEmptyProp(FCode);
end;

procedure TFhirClaimResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('detailSequenceLinkId');
  fields.add('subdetailSequenceLinkId');
  fields.add('code');
end;

{ TFhirClaimResponseError }

Procedure TFhirClaimResponseError.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetDetailSequenceLinkId(value : TFhirPositiveInt);
begin
  FDetailSequenceLinkId.free;
  FDetailSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetDetailSequenceLinkIdST : String;
begin
  if FDetailSequenceLinkId = nil then
    result := ''
  else
    result := FDetailSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetDetailSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequenceLinkId = nil then
      FDetailSequenceLinkId := TFhirPositiveInt.create;
    FDetailSequenceLinkId.value := value
  end
  else if FDetailSequenceLinkId <> nil then
    FDetailSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetSubdetailSequenceLinkId(value : TFhirPositiveInt);
begin
  FSubdetailSequenceLinkId.free;
  FSubdetailSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetSubdetailSequenceLinkIdST : String;
begin
  if FSubdetailSequenceLinkId = nil then
    result := ''
  else
    result := FSubdetailSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetSubdetailSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSubdetailSequenceLinkId = nil then
      FSubdetailSequenceLinkId := TFhirPositiveInt.create;
    FSubdetailSequenceLinkId.value := value
  end
  else if FSubdetailSequenceLinkId <> nil then
    FSubdetailSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirClaimResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FDetailSequenceLinkId.sizeInBytes);
  inc(result, FSubdetailSequenceLinkId.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirClaimResponseErrorListEnumerator }

Constructor TFhirClaimResponseErrorListEnumerator.Create(list : TFhirClaimResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseErrorListEnumerator.GetCurrent : TFhirClaimResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseErrorList }
procedure TFhirClaimResponseErrorList.AddItem(value: TFhirClaimResponseError);
begin
  assert(value.ClassName = 'TFhirClaimResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseError');
  add(value);
end;

function TFhirClaimResponseErrorList.Append: TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseErrorList.GetEnumerator : TFhirClaimResponseErrorListEnumerator;
begin
  result := TFhirClaimResponseErrorListEnumerator.Create(self.link);
end;

function TFhirClaimResponseErrorList.Clone: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Clone);
end;

function TFhirClaimResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseErrorList.GetItemN(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseError;
end;
function TFhirClaimResponseErrorList.IndexOf(value: TFhirClaimResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseErrorList.Insert(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.InsertItem(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseErrorList.Item(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.Link: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Link);
end;

procedure TFhirClaimResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseErrorList.SetItemByIndex(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  FhirClaimResponseErrors[index] := value;
end;

procedure TFhirClaimResponseErrorList.SetItemN(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponsePayment }

constructor TFhirClaimResponsePayment.Create;
begin
  inherited;
end;

destructor TFhirClaimResponsePayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirClaimResponsePayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimResponsePayment(oSource).type_.Clone;
  adjustment := TFhirClaimResponsePayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirClaimResponsePayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirClaimResponsePayment(oSource).dateElement.Clone;
  amount := TFhirClaimResponsePayment(oSource).amount.Clone;
  identifier := TFhirClaimResponsePayment(oSource).identifier.Clone;
end;

procedure TFhirClaimResponsePayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirClaimResponsePayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
end;

function TFhirClaimResponsePayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponsePayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponsePayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'adjustment') then result := TFhirMoney.create(){4b}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponsePayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponsePayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponsePayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney{4}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponsePayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponsePayment.fhirType : string;
begin
  result := 'payment';
end;

function TFhirClaimResponsePayment.Link : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Link);
end;

function TFhirClaimResponsePayment.Clone : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Clone);
end;

function TFhirClaimResponsePayment.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponsePayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponsePayment)) then
    result := false
  else
  begin
    o := TFhirClaimResponsePayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirClaimResponsePayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirClaimResponsePayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

{ TFhirClaimResponsePayment }

Procedure TFhirClaimResponsePayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimResponsePayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

Procedure TFhirClaimResponsePayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

Procedure TFhirClaimResponsePayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimResponsePayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimResponsePayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirClaimResponsePayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponsePayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirClaimResponsePayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirClaimResponsePaymentListEnumerator }

Constructor TFhirClaimResponsePaymentListEnumerator.Create(list : TFhirClaimResponsePaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponsePaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponsePaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponsePaymentListEnumerator.GetCurrent : TFhirClaimResponsePayment;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponsePaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponsePaymentList }
procedure TFhirClaimResponsePaymentList.AddItem(value: TFhirClaimResponsePayment);
begin
  assert(value.ClassName = 'TFhirClaimResponsePayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponsePayment');
  add(value);
end;

function TFhirClaimResponsePaymentList.Append: TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponsePaymentList.GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
begin
  result := TFhirClaimResponsePaymentListEnumerator.Create(self.link);
end;

function TFhirClaimResponsePaymentList.Clone: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Clone);
end;

function TFhirClaimResponsePaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponsePaymentList.GetItemN(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponsePayment;
end;
function TFhirClaimResponsePaymentList.IndexOf(value: TFhirClaimResponsePayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponsePaymentList.Insert(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.InsertItem(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  Inherited Insert(index, value);
end;

function TFhirClaimResponsePaymentList.Item(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.Link: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Link);
end;

procedure TFhirClaimResponsePaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponsePaymentList.SetItemByIndex(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  FhirClaimResponsePayments[index] := value;
end;

procedure TFhirClaimResponsePaymentList.SetItemN(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseProcessNote }

constructor TFhirClaimResponseProcessNote.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirClaimResponseProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirClaimResponseProcessNote(oSource).numberElement.Clone;
  type_ := TFhirClaimResponseProcessNote(oSource).type_.Clone;
  textElement := TFhirClaimResponseProcessNote(oSource).textElement.Clone;
  language := TFhirClaimResponseProcessNote(oSource).language.Clone;
end;

procedure TFhirClaimResponseProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirClaimResponseProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
end;

function TFhirClaimResponseProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirClaimResponseProcessNote.Link : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Link);
end;

function TFhirClaimResponseProcessNote.Clone : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Clone);
end;

function TFhirClaimResponseProcessNote.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseProcessNote)) then
    result := false
  else
  begin
    o := TFhirClaimResponseProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirClaimResponseProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirClaimResponseProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

{ TFhirClaimResponseProcessNote }

Procedure TFhirClaimResponseProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirClaimResponseProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirClaimResponseProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirClaimResponseProcessNote.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimResponseProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirClaimResponseProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirClaimResponseProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirClaimResponseProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirClaimResponseProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteListEnumerator }

Constructor TFhirClaimResponseProcessNoteListEnumerator.Create(list : TFhirClaimResponseProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseProcessNoteListEnumerator.GetCurrent : TFhirClaimResponseProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteList }
procedure TFhirClaimResponseProcessNoteList.AddItem(value: TFhirClaimResponseProcessNote);
begin
  assert(value.ClassName = 'TFhirClaimResponseProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseProcessNote');
  add(value);
end;

function TFhirClaimResponseProcessNoteList.Append: TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseProcessNoteList.GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
begin
  result := TFhirClaimResponseProcessNoteListEnumerator.Create(self.link);
end;

function TFhirClaimResponseProcessNoteList.Clone: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Clone);
end;

function TFhirClaimResponseProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseProcessNoteList.GetItemN(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseProcessNote;
end;
function TFhirClaimResponseProcessNoteList.IndexOf(value: TFhirClaimResponseProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseProcessNoteList.Insert(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.InsertItem(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseProcessNoteList.Item(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.Link: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Link);
end;

procedure TFhirClaimResponseProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseProcessNoteList.SetItemByIndex(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  FhirClaimResponseProcessNotes[index] := value;
end;

procedure TFhirClaimResponseProcessNoteList.SetItemN(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseInsurance }

constructor TFhirClaimResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimResponseInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimResponseInsurance(oSource).focalElement.Clone;
  coverage := TFhirClaimResponseInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimResponseInsurance(oSource).businessArrangementElement.Clone;
  if (TFhirClaimResponseInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimResponseInsurance(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimResponseInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
end;

function TFhirClaimResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirClaimResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirClaimResponseInsurance.Link : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Link);
end;

function TFhirClaimResponseInsurance.Clone : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Clone);
end;

function TFhirClaimResponseInsurance.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimResponseInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and
      compareDeep(preAuthRefList, o.preAuthRefList, true) and compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('preAuthRef');
  fields.add('claimResponse');
end;

{ TFhirClaimResponseInsurance }

Procedure TFhirClaimResponseInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimResponseInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimResponseInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimResponseInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimResponseInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimResponseInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimResponseInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimResponseInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimResponseInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimResponseInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Function TFhirClaimResponseInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirClaimResponseInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Procedure TFhirClaimResponseInsurance.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

function TFhirClaimResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceListEnumerator }

Constructor TFhirClaimResponseInsuranceListEnumerator.Create(list : TFhirClaimResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseInsuranceListEnumerator.GetCurrent : TFhirClaimResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceList }
procedure TFhirClaimResponseInsuranceList.AddItem(value: TFhirClaimResponseInsurance);
begin
  assert(value.ClassName = 'TFhirClaimResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseInsurance');
  add(value);
end;

function TFhirClaimResponseInsuranceList.Append: TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseInsuranceList.GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
begin
  result := TFhirClaimResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimResponseInsuranceList.Clone: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Clone);
end;

function TFhirClaimResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseInsuranceList.GetItemN(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseInsurance;
end;
function TFhirClaimResponseInsuranceList.IndexOf(value: TFhirClaimResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseInsuranceList.Insert(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.InsertItem(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseInsuranceList.Item(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.Link: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Link);
end;

procedure TFhirClaimResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  FhirClaimResponseInsurances[index] := value;
end;

procedure TFhirClaimResponseInsuranceList.SetItemN(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponse }

constructor TFhirClaimResponse.Create;
begin
  inherited;
end;

destructor TFhirClaimResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FCreated.free;
  FInsurer.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FPayeeType.free;
  FItemList.Free;
  FAddItemList.Free;
  FErrorList.Free;
  FTotalCost.free;
  FUnallocDeductable.free;
  FTotalBenefit.free;
  FPayment.free;
  FReserved.free;
  FForm.free;
  FProcessNoteList.Free;
  FCommunicationRequestList.Free;
  FInsuranceList.Free;
  inherited;
end;

function TFhirClaimResponse.GetResourceType : TFhirResourceType;
begin
  result := frtClaimResponse;
end;

procedure TFhirClaimResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaimResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirClaimResponse(oSource).FStatus.Link;
  patient := TFhirClaimResponse(oSource).patient.Clone;
  createdElement := TFhirClaimResponse(oSource).createdElement.Clone;
  insurer := TFhirClaimResponse(oSource).insurer.Clone;
  requestProvider := TFhirClaimResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirClaimResponse(oSource).requestOrganization.Clone;
  request := TFhirClaimResponse(oSource).request.Clone;
  outcome := TFhirClaimResponse(oSource).outcome.Clone;
  dispositionElement := TFhirClaimResponse(oSource).dispositionElement.Clone;
  payeeType := TFhirClaimResponse(oSource).payeeType.Clone;
  if (TFhirClaimResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimResponseItemList.Create;
    FItemList.Assign(TFhirClaimResponse(oSource).FItemList);
  end;
  if (TFhirClaimResponse(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirClaimResponseAddItemList.Create;
    FAddItemList.Assign(TFhirClaimResponse(oSource).FAddItemList);
  end;
  if (TFhirClaimResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirClaimResponseErrorList.Create;
    FErrorList.Assign(TFhirClaimResponse(oSource).FErrorList);
  end;
  totalCost := TFhirClaimResponse(oSource).totalCost.Clone;
  unallocDeductable := TFhirClaimResponse(oSource).unallocDeductable.Clone;
  totalBenefit := TFhirClaimResponse(oSource).totalBenefit.Clone;
  payment := TFhirClaimResponse(oSource).payment.Clone;
  reserved := TFhirClaimResponse(oSource).reserved.Clone;
  form := TFhirClaimResponse(oSource).form.Clone;
  if (TFhirClaimResponse(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirClaimResponse(oSource).FProcessNoteList);
  end;
  if (TFhirClaimResponse(oSource).FCommunicationRequestList = nil) then
  begin
    FCommunicationRequestList.free;
    FCommunicationRequestList := nil;
  end
  else
  begin
    if FCommunicationRequestList = nil then
      FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
    FCommunicationRequestList.Assign(TFhirClaimResponse(oSource).FCommunicationRequestList);
  end;
  if (TFhirClaimResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaimResponse(oSource).FInsuranceList);
  end;
end;

procedure TFhirClaimResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'payeeType') Then
     list.add(self.link, 'payeeType', FPayeeType.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
  if (child_name = 'totalCost') Then
     list.add(self.link, 'totalCost', FTotalCost.Link);
  if (child_name = 'unallocDeductable') Then
     list.add(self.link, 'unallocDeductable', FUnallocDeductable.Link);
  if (child_name = 'totalBenefit') Then
     list.add(self.link, 'totalBenefit', FTotalBenefit.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'reserved') Then
     list.add(self.link, 'reserved', FReserved.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'communicationRequest') Then
    list.addAll(self, 'communicationRequest', FCommunicationRequestList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
end;

procedure TFhirClaimResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payeeType', 'CodeableConcept', false, TFhirCodeableConcept, FPayeeType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimResponseItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addItem', '', true, TFhirClaimResponseAddItem, FAddItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'error', '', true, TFhirClaimResponseError, FErrorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'totalCost', 'Money', false, TFhirMoney, FTotalCost.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unallocDeductable', 'Money', false, TFhirMoney, FUnallocDeductable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'totalBenefit', 'Money', false, TFhirMoney, FTotalBenefit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payment', '', false, TFhirClaimResponsePayment, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reserved', 'Coding', false, TFhirCoding, FReserved.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirClaimResponseProcessNote, FProcessNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'communicationRequest', 'Reference(CommunicationRequest)', true, TFhirReference{TFhirCommunicationRequest}, FCommunicationRequestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirClaimResponseInsurance, FInsuranceList.Link)){3};
end;

function TFhirClaimResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payeeType') then
  begin
    PayeeType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimResponseItem){2a};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirClaimResponseAddItem){2a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirClaimResponseError){2a};
    result := propValue;
  end
  else if (propName = 'totalCost') then
  begin
    TotalCost := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'unallocDeductable') then
  begin
    UnallocDeductable := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'totalBenefit') then
  begin
    TotalBenefit := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirClaimResponsePayment{4b};
    result := propValue;
  end
  else if (propName = 'reserved') then
  begin
    Reserved := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirClaimResponseProcessNote){2a};
    result := propValue;
  end
  else if (propName = 'communicationRequest') then
  begin
    CommunicationRequestList.add(propValue as TFhirReference{TFhirCommunicationRequest}){2a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimResponseInsurance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaimResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimResponseItem){2a}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirClaimResponseAddItem){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirClaimResponseError){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirClaimResponseProcessNote){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.insertItem(index, propValue as TFhirReference{TFhirCommunicationRequest}){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimResponseInsurance){2a}
  else inherited;
end;

function TFhirClaimResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'payeeType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'addItem') then result := AddItemList.new(){2}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else if (propName = 'totalCost') then result := TFhirMoney.create(){4b}
  else if (propName = 'unallocDeductable') then result := TFhirMoney.create(){4b}
  else if (propName = 'totalBenefit') then result := TFhirMoney.create(){4b}
  else if (propName = 'payment') then result := TFhirClaimResponsePayment.create(){4b}
  else if (propName = 'reserved') then result := TFhirCoding.create(){4b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else if (propName = 'communicationRequest') then result := CommunicationRequestList.new(){2}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'payeeType') then result := 'CodeableConcept'
  else if (propName = 'item') then result := ''
  else if (propName = 'addItem') then result := ''
  else if (propName = 'error') then result := ''
  else if (propName = 'totalCost') then result := 'Money'
  else if (propName = 'unallocDeductable') then result := 'Money'
  else if (propName = 'totalBenefit') then result := 'Money'
  else if (propName = 'payment') then result := ''
  else if (propName = 'reserved') then result := 'Coding'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := ''
  else if (propName = 'communicationRequest') then result := 'Reference'
  else if (propName = 'insurance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'payeeType') then PayeeTypeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {2}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else if (propName = 'totalCost') then TotalCostElement := nil
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := nil
  else if (propName = 'totalBenefit') then TotalBenefitElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'reserved') then ReservedElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else if (propName = 'communicationRequest') then deletePropertyValue('communicationRequest', CommunicationRequestList, value) {2}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'payeeType') then PayeeTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {2}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else if (propName = 'totalCost') then TotalCostElement := new as TFhirMoney{4}
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := new as TFhirMoney{4}
  else if (propName = 'totalBenefit') then TotalBenefitElement := new as TFhirMoney{4}
  else if (propName = 'payment') then PaymentElement := new as TFhirClaimResponsePayment{4}
  else if (propName = 'reserved') then ReservedElement := new as TFhirCoding{4}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else if (propName = 'communicationRequest') then replacePropertyValue('communicationRequest', CommunicationRequestList, existing, new) {2}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'addItem') then AddItemList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponse.fhirType : string;
begin
  result := 'ClaimResponse';
end;

function TFhirClaimResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPayeeType) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FerrorList) and isEmptyProp(FTotalCost) and isEmptyProp(FUnallocDeductable) and isEmptyProp(FTotalBenefit) and isEmptyProp(FPayment) and isEmptyProp(FReserved) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FcommunicationRequestList) and isEmptyProp(FinsuranceList);
end;

function TFhirClaimResponse.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponse)) then
    result := false
  else
  begin
    o := TFhirClaimResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(insurerElement, o.insurerElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true) and
      compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(payeeTypeElement, o.payeeTypeElement, true) and
      compareDeep(itemList, o.itemList, true) and compareDeep(addItemList, o.addItemList, true) and
      compareDeep(errorList, o.errorList, true) and compareDeep(totalCostElement, o.totalCostElement, true) and
      compareDeep(unallocDeductableElement, o.unallocDeductableElement, true) and compareDeep(totalBenefitElement, o.totalBenefitElement, true) and
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(reservedElement, o.reservedElement, true) and
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and
      compareDeep(communicationRequestList, o.communicationRequestList, true) and compareDeep(insuranceList, o.insuranceList, true);
  end;
end;

function TFhirClaimResponse.Link : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Link);
end;

function TFhirClaimResponse.Clone : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Clone);
end;

procedure TFhirClaimResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('created');
  fields.add('insurer');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('payeeType');
  fields.add('item');
  fields.add('addItem');
  fields.add('error');
  fields.add('totalCost');
  fields.add('unallocDeductable');
  fields.add('totalBenefit');
  fields.add('payment');
  fields.add('reserved');
  fields.add('form');
  fields.add('processNote');
  fields.add('communicationRequest');
  fields.add('insurance');
end;

{ TFhirClaimResponse }

Function TFhirClaimResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaimResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaimResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClaimResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirClaimResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirClaimResponse.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirClaimResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaimResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaimResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaimResponse.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirClaimResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirClaimResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Procedure TFhirClaimResponse.SetRequest(value : TFhirReference{TFhirClaim});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirClaimResponse.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirClaimResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirClaimResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirClaimResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirClaimResponse.SetPayeeType(value : TFhirCodeableConcept);
begin
  FPayeeType.free;
  FPayeeType := value;
end;

Function TFhirClaimResponse.GetItemList : TFhirClaimResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimResponseItemList.Create;
  result := FItemList;
end;

Function TFhirClaimResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirClaimResponse.GetAddItemList : TFhirClaimResponseAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirClaimResponseAddItemList.Create;
  result := FAddItemList;
end;

Function TFhirClaimResponse.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

Function TFhirClaimResponse.GetErrorList : TFhirClaimResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirClaimResponseErrorList.Create;
  result := FErrorList;
end;

Function TFhirClaimResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

Procedure TFhirClaimResponse.SetTotalCost(value : TFhirMoney);
begin
  FTotalCost.free;
  FTotalCost := value;
end;

Procedure TFhirClaimResponse.SetUnallocDeductable(value : TFhirMoney);
begin
  FUnallocDeductable.free;
  FUnallocDeductable := value;
end;

Procedure TFhirClaimResponse.SetTotalBenefit(value : TFhirMoney);
begin
  FTotalBenefit.free;
  FTotalBenefit := value;
end;

Procedure TFhirClaimResponse.SetPayment(value : TFhirClaimResponsePayment);
begin
  FPayment.free;
  FPayment := value;
end;

Procedure TFhirClaimResponse.SetReserved(value : TFhirCoding);
begin
  FReserved.free;
  FReserved := value;
end;

Procedure TFhirClaimResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirClaimResponse.GetProcessNoteList : TFhirClaimResponseProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirClaimResponse.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

Function TFhirClaimResponse.GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
begin
  if FCommunicationRequestList = nil then
    FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
  result := FCommunicationRequestList;
end;

Function TFhirClaimResponse.GetHasCommunicationRequestList : boolean;
begin
  result := (FCommunicationRequestList <> nil) and (FCommunicationRequestList.count > 0);
end;

Function TFhirClaimResponse.GetInsuranceList : TFhirClaimResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimResponseInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirClaimResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirClaimResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPayeeType.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
  inc(result, FTotalCost.sizeInBytes);
  inc(result, FUnallocDeductable.sizeInBytes);
  inc(result, FTotalBenefit.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FReserved.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FcommunicationRequestList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
end;

{ TFhirClaimResponseListEnumerator }

Constructor TFhirClaimResponseListEnumerator.Create(list : TFhirClaimResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseListEnumerator.GetCurrent : TFhirClaimResponse;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseList }
procedure TFhirClaimResponseList.AddItem(value: TFhirClaimResponse);
begin
  assert(value.ClassName = 'TFhirClaimResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponse');
  add(value);
end;

function TFhirClaimResponseList.Append: TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseList.GetEnumerator : TFhirClaimResponseListEnumerator;
begin
  result := TFhirClaimResponseListEnumerator.Create(self.link);
end;

function TFhirClaimResponseList.Clone: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Clone);
end;

function TFhirClaimResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseList.GetItemN(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponse;
end;
function TFhirClaimResponseList.IndexOf(value: TFhirClaimResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseList.Insert(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.InsertItem(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseList.Item(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.Link: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Link);
end;

procedure TFhirClaimResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseList.SetItemByIndex(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  FhirClaimResponses[index] := value;
end;

procedure TFhirClaimResponseList.SetItemN(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_CONSENT}

{ TFhirConsentActor }

constructor TFhirConsentActor.Create;
begin
  inherited;
end;

destructor TFhirConsentActor.Destroy;
begin
  FRole.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentActor.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirConsentActor(oSource).role.Clone;
  reference := TFhirConsentActor(oSource).reference.Clone;
end;

procedure TFhirConsentActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Device|Group|CareTeam|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FReference.Link));{2}
end;

function TFhirConsentActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentActor.fhirType : string;
begin
  result := 'actor';
end;

function TFhirConsentActor.Link : TFhirConsentActor;
begin
  result := TFhirConsentActor(inherited Link);
end;

function TFhirConsentActor.Clone : TFhirConsentActor;
begin
  result := TFhirConsentActor(inherited Clone);
end;

function TFhirConsentActor.equals(other : TObject) : boolean;
var
  o : TFhirConsentActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentActor)) then
    result := false
  else
  begin
    o := TFhirConsentActor(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FReference);
end;

procedure TFhirConsentActor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
end;

{ TFhirConsentActor }

Procedure TFhirConsentActor.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirConsentActor.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentActor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentActorListEnumerator }

Constructor TFhirConsentActorListEnumerator.Create(list : TFhirConsentActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentActorListEnumerator.GetCurrent : TFhirConsentActor;
begin
  Result := FList[FIndex];
end;

function TFhirConsentActorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentActorList }
procedure TFhirConsentActorList.AddItem(value: TFhirConsentActor);
begin
  assert(value.ClassName = 'TFhirConsentActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentActor');
  add(value);
end;

function TFhirConsentActorList.Append: TFhirConsentActor;
begin
  result := TFhirConsentActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentActorList.ClearItems;
begin
  Clear;
end;

function TFhirConsentActorList.GetEnumerator : TFhirConsentActorListEnumerator;
begin
  result := TFhirConsentActorListEnumerator.Create(self.link);
end;

function TFhirConsentActorList.Clone: TFhirConsentActorList;
begin
  result := TFhirConsentActorList(inherited Clone);
end;

function TFhirConsentActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentActorList.GetItemN(index: Integer): TFhirConsentActor;
begin
  result := TFhirConsentActor(ObjectByIndex[index]);
end;

function TFhirConsentActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentActor;
end;
function TFhirConsentActorList.IndexOf(value: TFhirConsentActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentActorList.Insert(index: Integer): TFhirConsentActor;
begin
  result := TFhirConsentActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentActorList.InsertItem(index: Integer; value: TFhirConsentActor);
begin
  assert(value is TFhirConsentActor);
  Inherited Insert(index, value);
end;

function TFhirConsentActorList.Item(index: Integer): TFhirConsentActor;
begin
  result := TFhirConsentActor(ObjectByIndex[index]);
end;

function TFhirConsentActorList.Link: TFhirConsentActorList;
begin
  result := TFhirConsentActorList(inherited Link);
end;

procedure TFhirConsentActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentActorList.SetItemByIndex(index: Integer; value: TFhirConsentActor);
begin
  assert(value is TFhirConsentActor);
  FhirConsentActors[index] := value;
end;

procedure TFhirConsentActorList.SetItemN(index: Integer; value: TFhirConsentActor);
begin
  assert(value is TFhirConsentActor);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentPolicy }

constructor TFhirConsentPolicy.Create;
begin
  inherited;
end;

destructor TFhirConsentPolicy.Destroy;
begin
  FAuthority.free;
  FUri.free;
  inherited;
end;

procedure TFhirConsentPolicy.Assign(oSource : TFslObject);
begin
  inherited;
  authorityElement := TFhirConsentPolicy(oSource).authorityElement.Clone;
  uriElement := TFhirConsentPolicy(oSource).uriElement.Clone;
end;

procedure TFhirConsentPolicy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
end;

procedure TFhirConsentPolicy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'uri', false, TFhirUri, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
end;

function TFhirConsentPolicy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    AuthorityElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentPolicy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentPolicy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirUri.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentPolicy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'uri'
  else if (propName = 'uri') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentPolicy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentPolicy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := asUri(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentPolicy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentPolicy.fhirType : string;
begin
  result := 'policy';
end;

function TFhirConsentPolicy.Link : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Link);
end;

function TFhirConsentPolicy.Clone : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Clone);
end;

function TFhirConsentPolicy.equals(other : TObject) : boolean;
var
  o : TFhirConsentPolicy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentPolicy)) then
    result := false
  else
  begin
    o := TFhirConsentPolicy(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(uriElement, o.uriElement, true);
  end;
end;

function TFhirConsentPolicy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FUri);
end;

procedure TFhirConsentPolicy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authority');
  fields.add('uri');
end;

{ TFhirConsentPolicy }

Procedure TFhirConsentPolicy.SetAuthority(value : TFhirUri);
begin
  FAuthority.free;
  FAuthority := value;
end;

Function TFhirConsentPolicy.GetAuthorityST : String;
begin
  if FAuthority = nil then
    result := ''
  else
    result := FAuthority.value;
end;

Procedure TFhirConsentPolicy.SetAuthorityST(value : String);
begin
  if value <> '' then
  begin
    if FAuthority = nil then
      FAuthority := TFhirUri.create;
    FAuthority.value := value
  end
  else if FAuthority <> nil then
    FAuthority.value := '';
end;

Procedure TFhirConsentPolicy.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirConsentPolicy.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirConsentPolicy.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

function TFhirConsentPolicy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthority.sizeInBytes);
  inc(result, FUri.sizeInBytes);
end;

{ TFhirConsentPolicyListEnumerator }

Constructor TFhirConsentPolicyListEnumerator.Create(list : TFhirConsentPolicyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentPolicyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentPolicyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentPolicyListEnumerator.GetCurrent : TFhirConsentPolicy;
begin
  Result := FList[FIndex];
end;

function TFhirConsentPolicyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentPolicyList }
procedure TFhirConsentPolicyList.AddItem(value: TFhirConsentPolicy);
begin
  assert(value.ClassName = 'TFhirConsentPolicy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentPolicy');
  add(value);
end;

function TFhirConsentPolicyList.Append: TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.ClearItems;
begin
  Clear;
end;

function TFhirConsentPolicyList.GetEnumerator : TFhirConsentPolicyListEnumerator;
begin
  result := TFhirConsentPolicyListEnumerator.Create(self.link);
end;

function TFhirConsentPolicyList.Clone: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Clone);
end;

function TFhirConsentPolicyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentPolicyList.GetItemN(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentPolicy;
end;
function TFhirConsentPolicyList.IndexOf(value: TFhirConsentPolicy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentPolicyList.Insert(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.InsertItem(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  Inherited Insert(index, value);
end;

function TFhirConsentPolicyList.Item(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.Link: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Link);
end;

procedure TFhirConsentPolicyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentPolicyList.SetItemByIndex(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  FhirConsentPolicies[index] := value;
end;

procedure TFhirConsentPolicyList.SetItemN(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentData }

constructor TFhirConsentData.Create;
begin
  inherited;
end;

destructor TFhirConsentData.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentData.Assign(oSource : TFslObject);
begin
  inherited;
  FMeaning := TFhirConsentData(oSource).FMeaning.Link;
  reference := TFhirConsentData(oSource).reference.Clone;
end;

procedure TFhirConsentData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFHIREnum, FMeaning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
end;

function TFhirConsentData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new){4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentData.fhirType : string;
begin
  result := 'data';
end;

function TFhirConsentData.Link : TFhirConsentData;
begin
  result := TFhirConsentData(inherited Link);
end;

function TFhirConsentData.Clone : TFhirConsentData;
begin
  result := TFhirConsentData(inherited Clone);
end;

function TFhirConsentData.equals(other : TObject) : boolean;
var
  o : TFhirConsentData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentData)) then
    result := false
  else
  begin
    o := TFhirConsentData(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirConsentData.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

{ TFhirConsentData }

Procedure TFhirConsentData.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

Function TFhirConsentData.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

Procedure TFhirConsentData.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

Procedure TFhirConsentData.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentData.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeaning.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentDataListEnumerator }

Constructor TFhirConsentDataListEnumerator.Create(list : TFhirConsentDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentDataListEnumerator.GetCurrent : TFhirConsentData;
begin
  Result := FList[FIndex];
end;

function TFhirConsentDataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentDataList }
procedure TFhirConsentDataList.AddItem(value: TFhirConsentData);
begin
  assert(value.ClassName = 'TFhirConsentData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentData');
  add(value);
end;

function TFhirConsentDataList.Append: TFhirConsentData;
begin
  result := TFhirConsentData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentDataList.ClearItems;
begin
  Clear;
end;

function TFhirConsentDataList.GetEnumerator : TFhirConsentDataListEnumerator;
begin
  result := TFhirConsentDataListEnumerator.Create(self.link);
end;

function TFhirConsentDataList.Clone: TFhirConsentDataList;
begin
  result := TFhirConsentDataList(inherited Clone);
end;

function TFhirConsentDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentDataList.GetItemN(index: Integer): TFhirConsentData;
begin
  result := TFhirConsentData(ObjectByIndex[index]);
end;

function TFhirConsentDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentData;
end;
function TFhirConsentDataList.IndexOf(value: TFhirConsentData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentDataList.Insert(index: Integer): TFhirConsentData;
begin
  result := TFhirConsentData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentDataList.InsertItem(index: Integer; value: TFhirConsentData);
begin
  assert(value is TFhirConsentData);
  Inherited Insert(index, value);
end;

function TFhirConsentDataList.Item(index: Integer): TFhirConsentData;
begin
  result := TFhirConsentData(ObjectByIndex[index]);
end;

function TFhirConsentDataList.Link: TFhirConsentDataList;
begin
  result := TFhirConsentDataList(inherited Link);
end;

procedure TFhirConsentDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentDataList.SetItemByIndex(index: Integer; value: TFhirConsentData);
begin
  assert(value is TFhirConsentData);
  FhirConsentData[index] := value;
end;

procedure TFhirConsentDataList.SetItemN(index: Integer; value: TFhirConsentData);
begin
  assert(value is TFhirConsentData);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentExcept }

constructor TFhirConsentExcept.Create;
begin
  inherited;
end;

destructor TFhirConsentExcept.Destroy;
begin
  FType_.free;
  FPeriod.free;
  FActorList.Free;
  FActionList.Free;
  FSecurityLabelList.Free;
  FPurposeList.Free;
  FClass_List.Free;
  FCodeList.Free;
  FDataPeriod.free;
  FDataList.Free;
  inherited;
end;

procedure TFhirConsentExcept.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirConsentExcept(oSource).FType_.Link;
  period := TFhirConsentExcept(oSource).period.Clone;
  if (TFhirConsentExcept(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirConsentExceptActorList.Create;
    FActorList.Assign(TFhirConsentExcept(oSource).FActorList);
  end;
  if (TFhirConsentExcept(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirConsentExcept(oSource).FActionList);
  end;
  if (TFhirConsentExcept(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirConsentExcept(oSource).FSecurityLabelList);
  end;
  if (TFhirConsentExcept(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodingList.Create;
    FPurposeList.Assign(TFhirConsentExcept(oSource).FPurposeList);
  end;
  if (TFhirConsentExcept(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCodingList.Create;
    FClass_List.Assign(TFhirConsentExcept(oSource).FClass_List);
  end;
  if (TFhirConsentExcept(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirConsentExcept(oSource).FCodeList);
  end;
  dataPeriod := TFhirConsentExcept(oSource).dataPeriod.Clone;
  if (TFhirConsentExcept(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirConsentExceptDataList.Create;
    FDataList.Assign(TFhirConsentExcept(oSource).FDataList);
  end;
end;

procedure TFhirConsentExcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'dataPeriod') Then
     list.add(self.link, 'dataPeriod', FDataPeriod.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
end;

procedure TFhirConsentExcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', '', true, TFhirConsentExceptActor, FActorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'Coding', true, TFhirCoding, FPurposeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', true, TFhirCoding, FClass_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dataPeriod', 'Period', false, TFhirPeriod, FDataPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', '', true, TFhirConsentExceptData, FDataList.Link)){3};
end;

function TFhirConsentExcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConsentExceptTypeEnum, CODES_TFhirConsentExceptTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirConsentExceptActor){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'dataPeriod') then
  begin
    DataPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirConsentExceptData){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentExcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirConsentExceptActor){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirConsentExceptData){2a}
  else inherited;
end;

function TFhirConsentExcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'purpose') then result := PurposeList.new(){2}
  else if (propName = 'class') then result := Class_List.new(){2}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'dataPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'data') then result := DataList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentExcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'actor') then result := ''
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'purpose') then result := 'Coding'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'dataPeriod') then result := 'Period'
  else if (propName = 'data') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentExcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value) {2}
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value) {2}
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentExcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConsentExceptTypeEnum, CODES_TFhirConsentExceptTypeEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new) {2}
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new) {2}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentExcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actor') then ActorList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'purpose') then PurposeList.move(source, destination){2a}
  else if (propName = 'class') then Class_List.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'data') then DataList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentExcept.fhirType : string;
begin
  result := 'except';
end;

function TFhirConsentExcept.Link : TFhirConsentExcept;
begin
  result := TFhirConsentExcept(inherited Link);
end;

function TFhirConsentExcept.Clone : TFhirConsentExcept;
begin
  result := TFhirConsentExcept(inherited Clone);
end;

function TFhirConsentExcept.equals(other : TObject) : boolean;
var
  o : TFhirConsentExcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentExcept)) then
    result := false
  else
  begin
    o := TFhirConsentExcept(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(purposeList, o.purposeList, true) and
      compareDeep(class_List, o.class_List, true) and compareDeep(codeList, o.codeList, true) and
      compareDeep(dataPeriodElement, o.dataPeriodElement, true) and compareDeep(dataList, o.dataList, true);
  end;
end;

function TFhirConsentExcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FpurposeList) and isEmptyProp(Fclass_List) and isEmptyProp(FcodeList) and isEmptyProp(FDataPeriod) and isEmptyProp(FdataList);
end;

procedure TFhirConsentExcept.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('actor');
  fields.add('action');
  fields.add('securityLabel');
  fields.add('purpose');
  fields.add('class');
  fields.add('code');
  fields.add('dataPeriod');
  fields.add('data');
end;

{ TFhirConsentExcept }

Procedure TFhirConsentExcept.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConsentExcept.GetType_ST : TFhirConsentExceptTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConsentExceptTypeEnum(0)
  else
    result := TFhirConsentExceptTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentExceptTypeEnum, FType_.value));
end;

Procedure TFhirConsentExcept.SetType_ST(value : TFhirConsentExceptTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConsentExceptTypeEnum[value], CODES_TFhirConsentExceptTypeEnum[value]);
end;

Procedure TFhirConsentExcept.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirConsentExcept.GetActorList : TFhirConsentExceptActorList;
begin
  if FActorList = nil then
    FActorList := TFhirConsentExceptActorList.Create;
  result := FActorList;
end;

Function TFhirConsentExcept.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Function TFhirConsentExcept.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirConsentExcept.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirConsentExcept.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirConsentExcept.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirConsentExcept.GetPurposeList : TFhirCodingList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodingList.Create;
  result := FPurposeList;
end;

Function TFhirConsentExcept.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

Function TFhirConsentExcept.GetClass_List : TFhirCodingList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCodingList.Create;
  result := FClass_List;
end;

Function TFhirConsentExcept.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

Function TFhirConsentExcept.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirConsentExcept.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirConsentExcept.SetDataPeriod(value : TFhirPeriod);
begin
  FDataPeriod.free;
  FDataPeriod := value;
end;

Function TFhirConsentExcept.GetDataList : TFhirConsentExceptDataList;
begin
  if FDataList = nil then
    FDataList := TFhirConsentExceptDataList.Create;
  result := FDataList;
end;

Function TFhirConsentExcept.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

function TFhirConsentExcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FpurposeList.sizeInBytes);
  inc(result, Fclass_List.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FDataPeriod.sizeInBytes);
  inc(result, FdataList.sizeInBytes);
end;

{ TFhirConsentExceptListEnumerator }

Constructor TFhirConsentExceptListEnumerator.Create(list : TFhirConsentExceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentExceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentExceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentExceptListEnumerator.GetCurrent : TFhirConsentExcept;
begin
  Result := FList[FIndex];
end;

function TFhirConsentExceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentExceptList }
procedure TFhirConsentExceptList.AddItem(value: TFhirConsentExcept);
begin
  assert(value.ClassName = 'TFhirConsentExcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentExcept');
  add(value);
end;

function TFhirConsentExceptList.Append: TFhirConsentExcept;
begin
  result := TFhirConsentExcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptList.ClearItems;
begin
  Clear;
end;

function TFhirConsentExceptList.GetEnumerator : TFhirConsentExceptListEnumerator;
begin
  result := TFhirConsentExceptListEnumerator.Create(self.link);
end;

function TFhirConsentExceptList.Clone: TFhirConsentExceptList;
begin
  result := TFhirConsentExceptList(inherited Clone);
end;

function TFhirConsentExceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentExceptList.GetItemN(index: Integer): TFhirConsentExcept;
begin
  result := TFhirConsentExcept(ObjectByIndex[index]);
end;

function TFhirConsentExceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentExcept;
end;
function TFhirConsentExceptList.IndexOf(value: TFhirConsentExcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentExceptList.Insert(index: Integer): TFhirConsentExcept;
begin
  result := TFhirConsentExcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptList.InsertItem(index: Integer; value: TFhirConsentExcept);
begin
  assert(value is TFhirConsentExcept);
  Inherited Insert(index, value);
end;

function TFhirConsentExceptList.Item(index: Integer): TFhirConsentExcept;
begin
  result := TFhirConsentExcept(ObjectByIndex[index]);
end;

function TFhirConsentExceptList.Link: TFhirConsentExceptList;
begin
  result := TFhirConsentExceptList(inherited Link);
end;

procedure TFhirConsentExceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentExceptList.SetItemByIndex(index: Integer; value: TFhirConsentExcept);
begin
  assert(value is TFhirConsentExcept);
  FhirConsentExcepts[index] := value;
end;

procedure TFhirConsentExceptList.SetItemN(index: Integer; value: TFhirConsentExcept);
begin
  assert(value is TFhirConsentExcept);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentExceptActor }

constructor TFhirConsentExceptActor.Create;
begin
  inherited;
end;

destructor TFhirConsentExceptActor.Destroy;
begin
  FRole.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentExceptActor.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirConsentExceptActor(oSource).role.Clone;
  reference := TFhirConsentExceptActor(oSource).reference.Clone;
end;

procedure TFhirConsentExceptActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentExceptActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Device|Group|CareTeam|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FReference.Link));{2}
end;

function TFhirConsentExceptActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentExceptActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentExceptActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentExceptActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentExceptActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentExceptActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentExceptActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentExceptActor.fhirType : string;
begin
  result := 'actor';
end;

function TFhirConsentExceptActor.Link : TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor(inherited Link);
end;

function TFhirConsentExceptActor.Clone : TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor(inherited Clone);
end;

function TFhirConsentExceptActor.equals(other : TObject) : boolean;
var
  o : TFhirConsentExceptActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentExceptActor)) then
    result := false
  else
  begin
    o := TFhirConsentExceptActor(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentExceptActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FReference);
end;

procedure TFhirConsentExceptActor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
end;

{ TFhirConsentExceptActor }

Procedure TFhirConsentExceptActor.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirConsentExceptActor.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentExceptActor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentExceptActorListEnumerator }

Constructor TFhirConsentExceptActorListEnumerator.Create(list : TFhirConsentExceptActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentExceptActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentExceptActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentExceptActorListEnumerator.GetCurrent : TFhirConsentExceptActor;
begin
  Result := FList[FIndex];
end;

function TFhirConsentExceptActorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentExceptActorList }
procedure TFhirConsentExceptActorList.AddItem(value: TFhirConsentExceptActor);
begin
  assert(value.ClassName = 'TFhirConsentExceptActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentExceptActor');
  add(value);
end;

function TFhirConsentExceptActorList.Append: TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptActorList.ClearItems;
begin
  Clear;
end;

function TFhirConsentExceptActorList.GetEnumerator : TFhirConsentExceptActorListEnumerator;
begin
  result := TFhirConsentExceptActorListEnumerator.Create(self.link);
end;

function TFhirConsentExceptActorList.Clone: TFhirConsentExceptActorList;
begin
  result := TFhirConsentExceptActorList(inherited Clone);
end;

function TFhirConsentExceptActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentExceptActorList.GetItemN(index: Integer): TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor(ObjectByIndex[index]);
end;

function TFhirConsentExceptActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentExceptActor;
end;
function TFhirConsentExceptActorList.IndexOf(value: TFhirConsentExceptActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentExceptActorList.Insert(index: Integer): TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptActorList.InsertItem(index: Integer; value: TFhirConsentExceptActor);
begin
  assert(value is TFhirConsentExceptActor);
  Inherited Insert(index, value);
end;

function TFhirConsentExceptActorList.Item(index: Integer): TFhirConsentExceptActor;
begin
  result := TFhirConsentExceptActor(ObjectByIndex[index]);
end;

function TFhirConsentExceptActorList.Link: TFhirConsentExceptActorList;
begin
  result := TFhirConsentExceptActorList(inherited Link);
end;

procedure TFhirConsentExceptActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentExceptActorList.SetItemByIndex(index: Integer; value: TFhirConsentExceptActor);
begin
  assert(value is TFhirConsentExceptActor);
  FhirConsentExceptActors[index] := value;
end;

procedure TFhirConsentExceptActorList.SetItemN(index: Integer; value: TFhirConsentExceptActor);
begin
  assert(value is TFhirConsentExceptActor);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentExceptData }

constructor TFhirConsentExceptData.Create;
begin
  inherited;
end;

destructor TFhirConsentExceptData.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentExceptData.Assign(oSource : TFslObject);
begin
  inherited;
  FMeaning := TFhirConsentExceptData(oSource).FMeaning.Link;
  reference := TFhirConsentExceptData(oSource).reference.Clone;
end;

procedure TFhirConsentExceptData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentExceptData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFHIREnum, FMeaning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
end;

function TFhirConsentExceptData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentExceptData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentExceptData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentExceptData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentExceptData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentExceptData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new){4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentExceptData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentExceptData.fhirType : string;
begin
  result := 'data';
end;

function TFhirConsentExceptData.Link : TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData(inherited Link);
end;

function TFhirConsentExceptData.Clone : TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData(inherited Clone);
end;

function TFhirConsentExceptData.equals(other : TObject) : boolean;
var
  o : TFhirConsentExceptData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentExceptData)) then
    result := false
  else
  begin
    o := TFhirConsentExceptData(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentExceptData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirConsentExceptData.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

{ TFhirConsentExceptData }

Procedure TFhirConsentExceptData.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

Function TFhirConsentExceptData.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

Procedure TFhirConsentExceptData.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

Procedure TFhirConsentExceptData.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentExceptData.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeaning.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentExceptDataListEnumerator }

Constructor TFhirConsentExceptDataListEnumerator.Create(list : TFhirConsentExceptDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentExceptDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentExceptDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentExceptDataListEnumerator.GetCurrent : TFhirConsentExceptData;
begin
  Result := FList[FIndex];
end;

function TFhirConsentExceptDataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentExceptDataList }
procedure TFhirConsentExceptDataList.AddItem(value: TFhirConsentExceptData);
begin
  assert(value.ClassName = 'TFhirConsentExceptData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentExceptData');
  add(value);
end;

function TFhirConsentExceptDataList.Append: TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptDataList.ClearItems;
begin
  Clear;
end;

function TFhirConsentExceptDataList.GetEnumerator : TFhirConsentExceptDataListEnumerator;
begin
  result := TFhirConsentExceptDataListEnumerator.Create(self.link);
end;

function TFhirConsentExceptDataList.Clone: TFhirConsentExceptDataList;
begin
  result := TFhirConsentExceptDataList(inherited Clone);
end;

function TFhirConsentExceptDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentExceptDataList.GetItemN(index: Integer): TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData(ObjectByIndex[index]);
end;

function TFhirConsentExceptDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentExceptData;
end;
function TFhirConsentExceptDataList.IndexOf(value: TFhirConsentExceptData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentExceptDataList.Insert(index: Integer): TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentExceptDataList.InsertItem(index: Integer; value: TFhirConsentExceptData);
begin
  assert(value is TFhirConsentExceptData);
  Inherited Insert(index, value);
end;

function TFhirConsentExceptDataList.Item(index: Integer): TFhirConsentExceptData;
begin
  result := TFhirConsentExceptData(ObjectByIndex[index]);
end;

function TFhirConsentExceptDataList.Link: TFhirConsentExceptDataList;
begin
  result := TFhirConsentExceptDataList(inherited Link);
end;

procedure TFhirConsentExceptDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentExceptDataList.SetItemByIndex(index: Integer; value: TFhirConsentExceptData);
begin
  assert(value is TFhirConsentExceptData);
  FhirConsentExceptData[index] := value;
end;

procedure TFhirConsentExceptDataList.SetItemN(index: Integer; value: TFhirConsentExceptData);
begin
  assert(value is TFhirConsentExceptData);
  ObjectByIndex[index] := value;
end;

{ TFhirConsent }

constructor TFhirConsent.Create;
begin
  inherited;
end;

destructor TFhirConsent.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FCategoryList.Free;
  FPatient.free;
  FPeriod.free;
  FDateTime.free;
  FConsentingPartyList.Free;
  FActorList.Free;
  FActionList.Free;
  FOrganizationList.Free;
  FSource.free;
  FPolicyList.Free;
  FPolicyRule.free;
  FSecurityLabelList.Free;
  FPurposeList.Free;
  FDataPeriod.free;
  FDataList.Free;
  FExcept_List.Free;
  inherited;
end;

function TFhirConsent.GetResourceType : TFhirResourceType;
begin
  result := frtConsent;
end;

procedure TFhirConsent.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirConsent(oSource).identifier.Clone;
  FStatus := TFhirConsent(oSource).FStatus.Link;
  if (TFhirConsent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirConsent(oSource).FCategoryList);
  end;
  patient := TFhirConsent(oSource).patient.Clone;
  period := TFhirConsent(oSource).period.Clone;
  dateTimeElement := TFhirConsent(oSource).dateTimeElement.Clone;
  if (TFhirConsent(oSource).FConsentingPartyList = nil) then
  begin
    FConsentingPartyList.free;
    FConsentingPartyList := nil;
  end
  else
  begin
    if FConsentingPartyList = nil then
      FConsentingPartyList := TFhirReferenceList{Resource}.Create;
    FConsentingPartyList.Assign(TFhirConsent(oSource).FConsentingPartyList);
  end;
  if (TFhirConsent(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirConsentActorList.Create;
    FActorList.Assign(TFhirConsent(oSource).FActorList);
  end;
  if (TFhirConsent(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirConsent(oSource).FActionList);
  end;
  if (TFhirConsent(oSource).FOrganizationList = nil) then
  begin
    FOrganizationList.free;
    FOrganizationList := nil;
  end
  else
  begin
    if FOrganizationList = nil then
      FOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
    FOrganizationList.Assign(TFhirConsent(oSource).FOrganizationList);
  end;
  source := TFhirConsent(oSource).source.Clone;
  if (TFhirConsent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirConsentPolicyList.Create;
    FPolicyList.Assign(TFhirConsent(oSource).FPolicyList);
  end;
  policyRuleElement := TFhirConsent(oSource).policyRuleElement.Clone;
  if (TFhirConsent(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirConsent(oSource).FSecurityLabelList);
  end;
  if (TFhirConsent(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodingList.Create;
    FPurposeList.Assign(TFhirConsent(oSource).FPurposeList);
  end;
  dataPeriod := TFhirConsent(oSource).dataPeriod.Clone;
  if (TFhirConsent(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirConsentDataList.Create;
    FDataList.Assign(TFhirConsent(oSource).FDataList);
  end;
  if (TFhirConsent(oSource).FExcept_List = nil) then
  begin
    FExcept_List.free;
    FExcept_List := nil;
  end
  else
  begin
    if FExcept_List = nil then
      FExcept_List := TFhirConsentExceptList.Create;
    FExcept_List.Assign(TFhirConsent(oSource).FExcept_List);
  end;
end;

procedure TFhirConsent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'consentingParty') Then
    list.addAll(self, 'consentingParty', FConsentingPartyList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'organization') Then
    list.addAll(self, 'organization', FOrganizationList);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'policyRule') Then
     list.add(self.link, 'policyRule', FPolicyRule.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
  if (child_name = 'dataPeriod') Then
     list.add(self.link, 'dataPeriod', FDataPeriod.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'except') Then
    list.addAll(self, 'except', FExcept_List);
end;

procedure TFhirConsent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'consentingParty', 'Reference(Organization|Patient|Practitioner|RelatedPerson)', true, TFhirReference{Resource}, FConsentingPartyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', '', true, TFhirConsentActor, FActorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FOrganizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source[x]', 'Attachment|Identifier|Reference(Consent|DocumentReference|Contract|QuestionnaireResponse)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', '', true, TFhirConsentPolicy, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'policyRule', 'uri', false, TFhirUri, FPolicyRule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'Coding', true, TFhirCoding, FPurposeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dataPeriod', 'Period', false, TFhirPeriod, FDataPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', '', true, TFhirConsentData, FDataList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'except', '', true, TFhirConsentExcept, FExcept_List.Link)){3};
end;

function TFhirConsent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConsentStateCodesEnum, CODES_TFhirConsentStateCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'consentingParty') then
  begin
    ConsentingPartyList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirConsentActor){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    OrganizationList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Attachment', 'Identifier', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(propValue as TFhirConsentPolicy){2a};
    result := propValue;
  end
  else if (propName = 'policyRule') then
  begin
    PolicyRuleElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'dataPeriod') then
  begin
    DataPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirConsentData){2a};
    result := propValue;
  end
  else if (propName = 'except') then
  begin
    Except_List.add(propValue as TFhirConsentExcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirConsent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'consentingParty') then ConsentingPartyList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirConsentActor){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'organization') then OrganizationList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, propValue as TFhirConsentPolicy){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirConsentData){2a}
  else if (propName = 'except') then Except_List.insertItem(index, propValue as TFhirConsentExcept){2a}
  else inherited;
end;

function TFhirConsent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'consentingParty') then result := ConsentingPartyList.new(){2}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'organization') then result := OrganizationList.new(){2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Identifier', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'policyRule') then result := TFhirUri.create() {5b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'purpose') then result := PurposeList.new(){2}
  else if (propName = 'dataPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'data') then result := DataList.new(){2}
  else if (propName = 'except') then result := Except_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'consentingParty') then result := 'Reference'
  else if (propName = 'actor') then result := ''
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'source[x]') then result := 'Attachment|Identifier|Reference'
  else if (propName = 'policy') then result := ''
  else if (propName = 'policyRule') then result := 'uri'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'purpose') then result := 'Coding'
  else if (propName = 'dataPeriod') then result := 'Period'
  else if (propName = 'data') then result := ''
  else if (propName = 'except') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'consentingParty') then deletePropertyValue('consentingParty', ConsentingPartyList, value) {2}
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'organization') then deletePropertyValue('organization', OrganizationList, value) {2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Identifier', 'Reference'])) then SourceElement := nil{4x}
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'policyRule') then PolicyRuleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value) {2}
  else if (propName = 'except') then deletePropertyValue('except', Except_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConsentStateCodesEnum, CODES_TFhirConsentStateCodesEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new){5b}
  else if (propName = 'consentingParty') then replacePropertyValue('consentingParty', ConsentingPartyList, existing, new) {2}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'organization') then replacePropertyValue('organization', OrganizationList, existing, new) {2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Identifier', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'policyRule') then PolicyRuleElement := asUri(new){5b}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new) {2}
  else if (propName = 'except') then replacePropertyValue('except', Except_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'consentingParty') then ConsentingPartyList.move(source, destination){2a}
  else if (propName = 'actor') then ActorList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'organization') then OrganizationList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'purpose') then PurposeList.move(source, destination){2a}
  else if (propName = 'data') then DataList.move(source, destination){2a}
  else if (propName = 'except') then Except_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsent.fhirType : string;
begin
  result := 'Consent';
end;

function TFhirConsent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FPatient) and isEmptyProp(FPeriod) and isEmptyProp(FDateTime) and isEmptyProp(FconsentingPartyList) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(ForganizationList) and isEmptyProp(FSource) and isEmptyProp(FpolicyList) and isEmptyProp(FPolicyRule) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FpurposeList) and isEmptyProp(FDataPeriod) and isEmptyProp(FdataList) and isEmptyProp(Fexcept_List);
end;

function TFhirConsent.equals(other : TObject) : boolean;
var
  o : TFhirConsent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsent)) then
    result := false
  else
  begin
    o := TFhirConsent(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryList, o.categoryList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(dateTimeElement, o.dateTimeElement, true) and
      compareDeep(consentingPartyList, o.consentingPartyList, true) and compareDeep(actorList, o.actorList, true) and
      compareDeep(actionList, o.actionList, true) and compareDeep(organizationList, o.organizationList, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(policyList, o.policyList, true) and
      compareDeep(policyRuleElement, o.policyRuleElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and
      compareDeep(purposeList, o.purposeList, true) and compareDeep(dataPeriodElement, o.dataPeriodElement, true) and
      compareDeep(dataList, o.dataList, true) and compareDeep(except_List, o.except_List, true);
  end;
end;

function TFhirConsent.Link : TFhirConsent;
begin
  result := TFhirConsent(inherited Link);
end;

function TFhirConsent.Clone : TFhirConsent;
begin
  result := TFhirConsent(inherited Clone);
end;

procedure TFhirConsent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('patient');
  fields.add('period');
  fields.add('dateTime');
  fields.add('consentingParty');
  fields.add('actor');
  fields.add('action');
  fields.add('organization');
  fields.add('source[x]');
  fields.add('policy');
  fields.add('policyRule');
  fields.add('securityLabel');
  fields.add('purpose');
  fields.add('dataPeriod');
  fields.add('data');
  fields.add('except');
end;

{ TFhirConsent }

Procedure TFhirConsent.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirConsent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirConsent.GetStatusST : TFhirConsentStateCodesEnum;
begin
  if FStatus = nil then
    result := TFhirConsentStateCodesEnum(0)
  else
    result := TFhirConsentStateCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentStateCodesEnum, FStatus.value));
end;

Procedure TFhirConsent.SetStatusST(value : TFhirConsentStateCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConsentStateCodesEnum[value], CODES_TFhirConsentStateCodesEnum[value]);
end;

Function TFhirConsent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirConsent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirConsent.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirConsent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirConsent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirConsent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirConsent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

Function TFhirConsent.GetConsentingPartyList : TFhirReferenceList{Resource};
begin
  if FConsentingPartyList = nil then
    FConsentingPartyList := TFhirReferenceList{Resource}.Create;
  result := FConsentingPartyList;
end;

Function TFhirConsent.GetHasConsentingPartyList : boolean;
begin
  result := (FConsentingPartyList <> nil) and (FConsentingPartyList.count > 0);
end;

Function TFhirConsent.GetActorList : TFhirConsentActorList;
begin
  if FActorList = nil then
    FActorList := TFhirConsentActorList.Create;
  result := FActorList;
end;

Function TFhirConsent.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Function TFhirConsent.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirConsent.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirConsent.GetOrganizationList : TFhirReferenceList{TFhirOrganization};
begin
  if FOrganizationList = nil then
    FOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FOrganizationList;
end;

Function TFhirConsent.GetHasOrganizationList : boolean;
begin
  result := (FOrganizationList <> nil) and (FOrganizationList.count > 0);
end;

Procedure TFhirConsent.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirConsent.GetPolicyList : TFhirConsentPolicyList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirConsentPolicyList.Create;
  result := FPolicyList;
end;

Function TFhirConsent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirConsent.SetPolicyRule(value : TFhirUri);
begin
  FPolicyRule.free;
  FPolicyRule := value;
end;

Function TFhirConsent.GetPolicyRuleST : String;
begin
  if FPolicyRule = nil then
    result := ''
  else
    result := FPolicyRule.value;
end;

Procedure TFhirConsent.SetPolicyRuleST(value : String);
begin
  if value <> '' then
  begin
    if FPolicyRule = nil then
      FPolicyRule := TFhirUri.create;
    FPolicyRule.value := value
  end
  else if FPolicyRule <> nil then
    FPolicyRule.value := '';
end;

Function TFhirConsent.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirConsent.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirConsent.GetPurposeList : TFhirCodingList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodingList.Create;
  result := FPurposeList;
end;

Function TFhirConsent.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

Procedure TFhirConsent.SetDataPeriod(value : TFhirPeriod);
begin
  FDataPeriod.free;
  FDataPeriod := value;
end;

Function TFhirConsent.GetDataList : TFhirConsentDataList;
begin
  if FDataList = nil then
    FDataList := TFhirConsentDataList.Create;
  result := FDataList;
end;

Function TFhirConsent.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

Function TFhirConsent.GetExcept_List : TFhirConsentExceptList;
begin
  if FExcept_List = nil then
    FExcept_List := TFhirConsentExceptList.Create;
  result := FExcept_List;
end;

Function TFhirConsent.GetHasExcept_List : boolean;
begin
  result := (FExcept_List <> nil) and (FExcept_List.count > 0);
end;

function TFhirConsent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FconsentingPartyList.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, ForganizationList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FPolicyRule.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FpurposeList.sizeInBytes);
  inc(result, FDataPeriod.sizeInBytes);
  inc(result, FdataList.sizeInBytes);
  inc(result, Fexcept_List.sizeInBytes);
end;

{ TFhirConsentListEnumerator }

Constructor TFhirConsentListEnumerator.Create(list : TFhirConsentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentListEnumerator.GetCurrent : TFhirConsent;
begin
  Result := FList[FIndex];
end;

function TFhirConsentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentList }
procedure TFhirConsentList.AddItem(value: TFhirConsent);
begin
  assert(value.ClassName = 'TFhirConsent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsent');
  add(value);
end;

function TFhirConsentList.Append: TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.ClearItems;
begin
  Clear;
end;

function TFhirConsentList.GetEnumerator : TFhirConsentListEnumerator;
begin
  result := TFhirConsentListEnumerator.Create(self.link);
end;

function TFhirConsentList.Clone: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Clone);
end;

function TFhirConsentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentList.GetItemN(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsent;
end;
function TFhirConsentList.IndexOf(value: TFhirConsent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentList.Insert(index: Integer): TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.InsertItem(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  Inherited Insert(index, value);
end;

function TFhirConsentList.Item(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.Link: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Link);
end;

procedure TFhirConsentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentList.SetItemByIndex(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  FhirConsents[index] := value;
end;

procedure TFhirConsentList.SetItemN(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONSENT}

{$IFDEF FHIR_CONTRACT}

{ TFhirContractAgent }

constructor TFhirContractAgent.Create;
begin
  inherited;
end;

destructor TFhirContractAgent.Destroy;
begin
  FActor.free;
  FRoleList.Free;
  inherited;
end;

procedure TFhirContractAgent.Assign(oSource : TFslObject);
begin
  inherited;
  actor := TFhirContractAgent(oSource).actor.Clone;
  if (TFhirContractAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirContractAgent(oSource).FRoleList);
  end;
end;

procedure TFhirContractAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
end;

procedure TFhirContractAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Contract|Device|Group|Location|Organization|Patient|Practitioner|RelatedPerson|Substance)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
end;

function TFhirContractAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirContractAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirContractAgent.Link : TFhirContractAgent;
begin
  result := TFhirContractAgent(inherited Link);
end;

function TFhirContractAgent.Clone : TFhirContractAgent;
begin
  result := TFhirContractAgent(inherited Clone);
end;

function TFhirContractAgent.equals(other : TObject) : boolean;
var
  o : TFhirContractAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractAgent)) then
    result := false
  else
  begin
    o := TFhirContractAgent(other);
    result := compareDeep(actorElement, o.actorElement, true) and compareDeep(roleList, o.roleList, true);
  end;
end;

function TFhirContractAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActor) and isEmptyProp(FroleList);
end;

procedure TFhirContractAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actor');
  fields.add('role');
end;

{ TFhirContractAgent }

Procedure TFhirContractAgent.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Function TFhirContractAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirContractAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

function TFhirContractAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActor.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
end;

{ TFhirContractAgentListEnumerator }

Constructor TFhirContractAgentListEnumerator.Create(list : TFhirContractAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractAgentListEnumerator.GetCurrent : TFhirContractAgent;
begin
  Result := FList[FIndex];
end;

function TFhirContractAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractAgentList }
procedure TFhirContractAgentList.AddItem(value: TFhirContractAgent);
begin
  assert(value.ClassName = 'TFhirContractAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractAgent');
  add(value);
end;

function TFhirContractAgentList.Append: TFhirContractAgent;
begin
  result := TFhirContractAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractAgentList.ClearItems;
begin
  Clear;
end;

function TFhirContractAgentList.GetEnumerator : TFhirContractAgentListEnumerator;
begin
  result := TFhirContractAgentListEnumerator.Create(self.link);
end;

function TFhirContractAgentList.Clone: TFhirContractAgentList;
begin
  result := TFhirContractAgentList(inherited Clone);
end;

function TFhirContractAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractAgentList.GetItemN(index: Integer): TFhirContractAgent;
begin
  result := TFhirContractAgent(ObjectByIndex[index]);
end;

function TFhirContractAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractAgent;
end;
function TFhirContractAgentList.IndexOf(value: TFhirContractAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractAgentList.Insert(index: Integer): TFhirContractAgent;
begin
  result := TFhirContractAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractAgentList.InsertItem(index: Integer; value: TFhirContractAgent);
begin
  assert(value is TFhirContractAgent);
  Inherited Insert(index, value);
end;

function TFhirContractAgentList.Item(index: Integer): TFhirContractAgent;
begin
  result := TFhirContractAgent(ObjectByIndex[index]);
end;

function TFhirContractAgentList.Link: TFhirContractAgentList;
begin
  result := TFhirContractAgentList(inherited Link);
end;

procedure TFhirContractAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractAgentList.SetItemByIndex(index: Integer; value: TFhirContractAgent);
begin
  assert(value is TFhirContractAgent);
  FhirContractAgents[index] := value;
end;

procedure TFhirContractAgentList.SetItemN(index: Integer; value: TFhirContractAgent);
begin
  assert(value is TFhirContractAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirContractSigner }

constructor TFhirContractSigner.Create;
begin
  inherited;
end;

destructor TFhirContractSigner.Destroy;
begin
  FType_.free;
  FParty.free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirContractSigner.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractSigner(oSource).type_.Clone;
  party := TFhirContractSigner(oSource).party.Clone;
  if (TFhirContractSigner(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirContractSigner(oSource).FSignatureList);
  end;
end;

procedure TFhirContractSigner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirContractSigner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FParty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link)){3};
end;

function TFhirContractSigner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractSigner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature){2a}
  else inherited;
end;

function TFhirContractSigner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'signature') then result := SignatureList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractSigner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractSigner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractSigner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractSigner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'signature') then SignatureList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractSigner.fhirType : string;
begin
  result := 'signer';
end;

function TFhirContractSigner.Link : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Link);
end;

function TFhirContractSigner.Clone : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Clone);
end;

function TFhirContractSigner.equals(other : TObject) : boolean;
var
  o : TFhirContractSigner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractSigner)) then
    result := false
  else
  begin
    o := TFhirContractSigner(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true) and
      compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirContractSigner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty) and isEmptyProp(FsignatureList);
end;

procedure TFhirContractSigner.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
  fields.add('signature');
end;

{ TFhirContractSigner }

Procedure TFhirContractSigner.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractSigner.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

Function TFhirContractSigner.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

Function TFhirContractSigner.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

function TFhirContractSigner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
  inc(result, FsignatureList.sizeInBytes);
end;

{ TFhirContractSignerListEnumerator }

Constructor TFhirContractSignerListEnumerator.Create(list : TFhirContractSignerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractSignerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractSignerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractSignerListEnumerator.GetCurrent : TFhirContractSigner;
begin
  Result := FList[FIndex];
end;

function TFhirContractSignerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractSignerList }
procedure TFhirContractSignerList.AddItem(value: TFhirContractSigner);
begin
  assert(value.ClassName = 'TFhirContractSigner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractSigner');
  add(value);
end;

function TFhirContractSignerList.Append: TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.ClearItems;
begin
  Clear;
end;

function TFhirContractSignerList.GetEnumerator : TFhirContractSignerListEnumerator;
begin
  result := TFhirContractSignerListEnumerator.Create(self.link);
end;

function TFhirContractSignerList.Clone: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Clone);
end;

function TFhirContractSignerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractSignerList.GetItemN(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractSigner;
end;
function TFhirContractSignerList.IndexOf(value: TFhirContractSigner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractSignerList.Insert(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.InsertItem(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  Inherited Insert(index, value);
end;

function TFhirContractSignerList.Item(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.Link: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Link);
end;

procedure TFhirContractSignerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractSignerList.SetItemByIndex(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  FhirContractSigners[index] := value;
end;

procedure TFhirContractSignerList.SetItemN(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  ObjectByIndex[index] := value;
end;

{ TFhirContractValuedItem }

constructor TFhirContractValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  inherited;
end;

procedure TFhirContractValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractValuedItem(oSource).entity.Clone;
  identifier := TFhirContractValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractValuedItem(oSource).net.Clone;
end;

procedure TFhirContractValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
end;

procedure TFhirContractValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
end;

function TFhirContractValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity'){4x}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil{4x}
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirType{4x}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractValuedItem.fhirType : string;
begin
  result := 'valuedItem';
end;

function TFhirContractValuedItem.Link : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(inherited Link);
end;

function TFhirContractValuedItem.Clone : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(inherited Clone);
end;

function TFhirContractValuedItem.equals(other : TObject) : boolean;
var
  o : TFhirContractValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true);
  end;
end;

function TFhirContractValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet);
end;

procedure TFhirContractValuedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
end;

{ TFhirContractValuedItem }

Procedure TFhirContractValuedItem.SetEntity(value : TFhirType);
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirContractValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Function TFhirContractValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

Procedure TFhirContractValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

Procedure TFhirContractValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirContractValuedItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirContractValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirContractValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirContractValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirContractValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirContractValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirContractValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirContractValuedItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirContractValuedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
end;

{ TFhirContractValuedItemListEnumerator }

Constructor TFhirContractValuedItemListEnumerator.Create(list : TFhirContractValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractValuedItemListEnumerator.GetCurrent : TFhirContractValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractValuedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractValuedItemList }
procedure TFhirContractValuedItemList.AddItem(value: TFhirContractValuedItem);
begin
  assert(value.ClassName = 'TFhirContractValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractValuedItem');
  add(value);
end;

function TFhirContractValuedItemList.Append: TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractValuedItemList.GetEnumerator : TFhirContractValuedItemListEnumerator;
begin
  result := TFhirContractValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractValuedItemList.Clone: TFhirContractValuedItemList;
begin
  result := TFhirContractValuedItemList(inherited Clone);
end;

function TFhirContractValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractValuedItemList.GetItemN(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(ObjectByIndex[index]);
end;

function TFhirContractValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractValuedItem;
end;
function TFhirContractValuedItemList.IndexOf(value: TFhirContractValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractValuedItemList.Insert(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractValuedItemList.InsertItem(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractValuedItemList.Item(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(ObjectByIndex[index]);
end;

function TFhirContractValuedItemList.Link: TFhirContractValuedItemList;
begin
  result := TFhirContractValuedItemList(inherited Link);
end;

procedure TFhirContractValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  FhirContractValuedItems[index] := value;
end;

procedure TFhirContractValuedItemList.SetItemN(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTerm }

constructor TFhirContractTerm.Create;
begin
  inherited;
end;

destructor TFhirContractTerm.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FType_.free;
  FSubType.free;
  FTopicList.Free;
  FActionList.Free;
  FActionReasonList.Free;
  FSecurityLabelList.Free;
  FAgentList.Free;
  FText.free;
  FValuedItemList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirContractTerm.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContractTerm(oSource).identifier.Clone;
  issuedElement := TFhirContractTerm(oSource).issuedElement.Clone;
  applies := TFhirContractTerm(oSource).applies.Clone;
  type_ := TFhirContractTerm(oSource).type_.Clone;
  subType := TFhirContractTerm(oSource).subType.Clone;
  if (TFhirContractTerm(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirReferenceList{TFhirReference}.Create;
    FTopicList.Assign(TFhirContractTerm(oSource).FTopicList);
  end;
  if (TFhirContractTerm(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirContractTerm(oSource).FActionList);
  end;
  if (TFhirContractTerm(oSource).FActionReasonList = nil) then
  begin
    FActionReasonList.free;
    FActionReasonList := nil;
  end
  else
  begin
    if FActionReasonList = nil then
      FActionReasonList := TFhirCodeableConceptList.Create;
    FActionReasonList.Assign(TFhirContractTerm(oSource).FActionReasonList);
  end;
  if (TFhirContractTerm(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirContractTerm(oSource).FSecurityLabelList);
  end;
  if (TFhirContractTerm(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirContractTermAgentList.Create;
    FAgentList.Assign(TFhirContractTerm(oSource).FAgentList);
  end;
  textElement := TFhirContractTerm(oSource).textElement.Clone;
  if (TFhirContractTerm(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractTermValuedItemList.Create;
    FValuedItemList.Assign(TFhirContractTerm(oSource).FValuedItemList);
  end;
  if (TFhirContractTerm(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirContractTermList.Create;
    FGroupList.Assign(TFhirContractTerm(oSource).FGroupList);
  end;
end;

procedure TFhirContractTerm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'actionReason') Then
    list.addAll(self, 'actionReason', FActionReasonList);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirContractTerm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actionReason', 'CodeableConcept', true, TFhirCodeableConcept, FActionReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirContractTermAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'valuedItem', '', true, TFhirContractTermValuedItem, FValuedItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '@Contract.term', true, TFhirContractTerm, FGroupList.Link)){3};
end;

function TFhirContractTerm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actionReason') then
  begin
    ActionReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirContractTermAgent){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractTermValuedItem){2a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTerm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actionReason') then ActionReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirContractTermAgent){2a}
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractTermValuedItem){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirContractTerm){2a}
  else inherited;
end;

function TFhirContractTerm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'actionReason') then result := ActionReasonList.new(){2}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'valuedItem') then result := ValuedItemList.new(){2}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTerm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'actionReason') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'agent') then result := ''
  else if (propName = 'text') then result := 'string'
  else if (propName = 'valuedItem') then result := ''
  else if (propName = 'group') then result := '@Contract.term'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTerm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'actionReason') then deletePropertyValue('actionReason', ActionReasonList, value) {2}
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value) {2}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTerm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'actionReason') then replacePropertyValue('actionReason', ActionReasonList, existing, new) {2}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new) {2}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTerm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'actionReason') then ActionReasonList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTerm.fhirType : string;
begin
  result := 'term';
end;

function TFhirContractTerm.Link : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Link);
end;

function TFhirContractTerm.Clone : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Clone);
end;

function TFhirContractTerm.equals(other : TObject) : boolean;
var
  o : TFhirContractTerm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTerm)) then
    result := false
  else
  begin
    o := TFhirContractTerm(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(subTypeElement, o.subTypeElement, true) and compareDeep(topicList, o.topicList, true) and
      compareDeep(actionList, o.actionList, true) and compareDeep(actionReasonList, o.actionReasonList, true) and
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(agentList, o.agentList, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(valuedItemList, o.valuedItemList, true) and
      compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirContractTerm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FtopicList) and isEmptyProp(FactionList) and isEmptyProp(FactionReasonList) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FagentList) and isEmptyProp(FText) and isEmptyProp(FvaluedItemList) and isEmptyProp(FgroupList);
end;

procedure TFhirContractTerm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('type');
  fields.add('subType');
  fields.add('topic');
  fields.add('action');
  fields.add('actionReason');
  fields.add('securityLabel');
  fields.add('agent');
  fields.add('text');
  fields.add('valuedItem');
  fields.add('group');
end;

{ TFhirContractTerm }

Procedure TFhirContractTerm.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTerm.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContractTerm.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContractTerm.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContractTerm.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Procedure TFhirContractTerm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractTerm.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Function TFhirContractTerm.GetTopicList : TFhirReferenceList{TFhirReference};
begin
  if FTopicList = nil then
    FTopicList := TFhirReferenceList{TFhirReference}.Create;
  result := FTopicList;
end;

Function TFhirContractTerm.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirContractTerm.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirContractTerm.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirContractTerm.GetActionReasonList : TFhirCodeableConceptList;
begin
  if FActionReasonList = nil then
    FActionReasonList := TFhirCodeableConceptList.Create;
  result := FActionReasonList;
end;

Function TFhirContractTerm.GetHasActionReasonList : boolean;
begin
  result := (FActionReasonList <> nil) and (FActionReasonList.count > 0);
end;

Function TFhirContractTerm.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirContractTerm.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirContractTerm.GetAgentList : TFhirContractTermAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirContractTermAgentList.Create;
  result := FAgentList;
end;

Function TFhirContractTerm.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Procedure TFhirContractTerm.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTerm.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTerm.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirContractTerm.GetValuedItemList : TFhirContractTermValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractTermValuedItemList.Create;
  result := FValuedItemList;
end;

Function TFhirContractTerm.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

Function TFhirContractTerm.GetGroupList : TFhirContractTermList;
begin
  if FGroupList = nil then
    FGroupList := TFhirContractTermList.Create;
  result := FGroupList;
end;

Function TFhirContractTerm.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirContractTerm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FactionReasonList.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FvaluedItemList.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirContractTermListEnumerator }

Constructor TFhirContractTermListEnumerator.Create(list : TFhirContractTermList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermListEnumerator.GetCurrent : TFhirContractTerm;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermList }
procedure TFhirContractTermList.AddItem(value: TFhirContractTerm);
begin
  assert(value.ClassName = 'TFhirContractTerm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTerm');
  add(value);
end;

function TFhirContractTermList.Append: TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermList.GetEnumerator : TFhirContractTermListEnumerator;
begin
  result := TFhirContractTermListEnumerator.Create(self.link);
end;

function TFhirContractTermList.Clone: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Clone);
end;

function TFhirContractTermList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermList.GetItemN(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTerm;
end;
function TFhirContractTermList.IndexOf(value: TFhirContractTerm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermList.Insert(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.InsertItem(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  Inherited Insert(index, value);
end;

function TFhirContractTermList.Item(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.Link: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Link);
end;

procedure TFhirContractTermList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermList.SetItemByIndex(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  FhirContractTerms[index] := value;
end;

procedure TFhirContractTermList.SetItemN(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAgent }

constructor TFhirContractTermAgent.Create;
begin
  inherited;
end;

destructor TFhirContractTermAgent.Destroy;
begin
  FActor.free;
  FRoleList.Free;
  inherited;
end;

procedure TFhirContractTermAgent.Assign(oSource : TFslObject);
begin
  inherited;
  actor := TFhirContractTermAgent(oSource).actor.Clone;
  if (TFhirContractTermAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirContractTermAgent(oSource).FRoleList);
  end;
end;

procedure TFhirContractTermAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
end;

procedure TFhirContractTermAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Contract|Device|Group|Location|Organization|Patient|Practitioner|RelatedPerson|Substance)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
end;

function TFhirContractTermAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirContractTermAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirContractTermAgent.Link : TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent(inherited Link);
end;

function TFhirContractTermAgent.Clone : TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent(inherited Clone);
end;

function TFhirContractTermAgent.equals(other : TObject) : boolean;
var
  o : TFhirContractTermAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAgent)) then
    result := false
  else
  begin
    o := TFhirContractTermAgent(other);
    result := compareDeep(actorElement, o.actorElement, true) and compareDeep(roleList, o.roleList, true);
  end;
end;

function TFhirContractTermAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActor) and isEmptyProp(FroleList);
end;

procedure TFhirContractTermAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actor');
  fields.add('role');
end;

{ TFhirContractTermAgent }

Procedure TFhirContractTermAgent.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Function TFhirContractTermAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirContractTermAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

function TFhirContractTermAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActor.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
end;

{ TFhirContractTermAgentListEnumerator }

Constructor TFhirContractTermAgentListEnumerator.Create(list : TFhirContractTermAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAgentListEnumerator.GetCurrent : TFhirContractTermAgent;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermAgentList }
procedure TFhirContractTermAgentList.AddItem(value: TFhirContractTermAgent);
begin
  assert(value.ClassName = 'TFhirContractTermAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAgent');
  add(value);
end;

function TFhirContractTermAgentList.Append: TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAgentList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAgentList.GetEnumerator : TFhirContractTermAgentListEnumerator;
begin
  result := TFhirContractTermAgentListEnumerator.Create(self.link);
end;

function TFhirContractTermAgentList.Clone: TFhirContractTermAgentList;
begin
  result := TFhirContractTermAgentList(inherited Clone);
end;

function TFhirContractTermAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAgentList.GetItemN(index: Integer): TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent(ObjectByIndex[index]);
end;

function TFhirContractTermAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAgent;
end;
function TFhirContractTermAgentList.IndexOf(value: TFhirContractTermAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAgentList.Insert(index: Integer): TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAgentList.InsertItem(index: Integer; value: TFhirContractTermAgent);
begin
  assert(value is TFhirContractTermAgent);
  Inherited Insert(index, value);
end;

function TFhirContractTermAgentList.Item(index: Integer): TFhirContractTermAgent;
begin
  result := TFhirContractTermAgent(ObjectByIndex[index]);
end;

function TFhirContractTermAgentList.Link: TFhirContractTermAgentList;
begin
  result := TFhirContractTermAgentList(inherited Link);
end;

procedure TFhirContractTermAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAgentList.SetItemByIndex(index: Integer; value: TFhirContractTermAgent);
begin
  assert(value is TFhirContractTermAgent);
  FhirContractTermAgents[index] := value;
end;

procedure TFhirContractTermAgentList.SetItemN(index: Integer; value: TFhirContractTermAgent);
begin
  assert(value is TFhirContractTermAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermValuedItem }

constructor TFhirContractTermValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractTermValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  inherited;
end;

procedure TFhirContractTermValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermValuedItem(oSource).entity.Clone;
  identifier := TFhirContractTermValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractTermValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractTermValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractTermValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractTermValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractTermValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractTermValuedItem(oSource).net.Clone;
end;

procedure TFhirContractTermValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
end;

procedure TFhirContractTermValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
end;

function TFhirContractTermValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractTermValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity'){4x}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil{4x}
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirType{4x}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermValuedItem.fhirType : string;
begin
  result := 'valuedItem';
end;

function TFhirContractTermValuedItem.Link : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(inherited Link);
end;

function TFhirContractTermValuedItem.Clone : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(inherited Clone);
end;

function TFhirContractTermValuedItem.equals(other : TObject) : boolean;
var
  o : TFhirContractTermValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractTermValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true);
  end;
end;

function TFhirContractTermValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet);
end;

procedure TFhirContractTermValuedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
end;

{ TFhirContractTermValuedItem }

Procedure TFhirContractTermValuedItem.SetEntity(value : TFhirType);
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirContractTermValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTermValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Function TFhirContractTermValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

Procedure TFhirContractTermValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

Procedure TFhirContractTermValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirContractTermValuedItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirContractTermValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirContractTermValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirContractTermValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirContractTermValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirContractTermValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirContractTermValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirContractTermValuedItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirContractTermValuedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
end;

{ TFhirContractTermValuedItemListEnumerator }

Constructor TFhirContractTermValuedItemListEnumerator.Create(list : TFhirContractTermValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermValuedItemListEnumerator.GetCurrent : TFhirContractTermValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermValuedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermValuedItemList }
procedure TFhirContractTermValuedItemList.AddItem(value: TFhirContractTermValuedItem);
begin
  assert(value.ClassName = 'TFhirContractTermValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermValuedItem');
  add(value);
end;

function TFhirContractTermValuedItemList.Append: TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermValuedItemList.GetEnumerator : TFhirContractTermValuedItemListEnumerator;
begin
  result := TFhirContractTermValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractTermValuedItemList.Clone: TFhirContractTermValuedItemList;
begin
  result := TFhirContractTermValuedItemList(inherited Clone);
end;

function TFhirContractTermValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermValuedItemList.GetItemN(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermValuedItem;
end;
function TFhirContractTermValuedItemList.IndexOf(value: TFhirContractTermValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermValuedItemList.Insert(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermValuedItemList.InsertItem(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractTermValuedItemList.Item(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermValuedItemList.Link: TFhirContractTermValuedItemList;
begin
  result := TFhirContractTermValuedItemList(inherited Link);
end;

procedure TFhirContractTermValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  FhirContractTermValuedItems[index] := value;
end;

procedure TFhirContractTermValuedItemList.SetItemN(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractFriendly }

constructor TFhirContractFriendly.Create;
begin
  inherited;
end;

destructor TFhirContractFriendly.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractFriendly.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractFriendly(oSource).content.Clone;
end;

procedure TFhirContractFriendly.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractFriendly.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractFriendly.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractFriendly.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractFriendly.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractFriendly.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractFriendly.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractFriendly.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractFriendly.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractFriendly.fhirType : string;
begin
  result := 'friendly';
end;

function TFhirContractFriendly.Link : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Link);
end;

function TFhirContractFriendly.Clone : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Clone);
end;

function TFhirContractFriendly.equals(other : TObject) : boolean;
var
  o : TFhirContractFriendly;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractFriendly)) then
    result := false
  else
  begin
    o := TFhirContractFriendly(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractFriendly.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractFriendly.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractFriendly }

Procedure TFhirContractFriendly.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractFriendly.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractFriendlyListEnumerator }

Constructor TFhirContractFriendlyListEnumerator.Create(list : TFhirContractFriendlyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractFriendlyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractFriendlyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractFriendlyListEnumerator.GetCurrent : TFhirContractFriendly;
begin
  Result := FList[FIndex];
end;

function TFhirContractFriendlyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractFriendlyList }
procedure TFhirContractFriendlyList.AddItem(value: TFhirContractFriendly);
begin
  assert(value.ClassName = 'TFhirContractFriendly', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractFriendly');
  add(value);
end;

function TFhirContractFriendlyList.Append: TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.ClearItems;
begin
  Clear;
end;

function TFhirContractFriendlyList.GetEnumerator : TFhirContractFriendlyListEnumerator;
begin
  result := TFhirContractFriendlyListEnumerator.Create(self.link);
end;

function TFhirContractFriendlyList.Clone: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Clone);
end;

function TFhirContractFriendlyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractFriendlyList.GetItemN(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractFriendly;
end;
function TFhirContractFriendlyList.IndexOf(value: TFhirContractFriendly): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractFriendlyList.Insert(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.InsertItem(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  Inherited Insert(index, value);
end;

function TFhirContractFriendlyList.Item(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.Link: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Link);
end;

procedure TFhirContractFriendlyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractFriendlyList.SetItemByIndex(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  FhirContractFriendlies[index] := value;
end;

procedure TFhirContractFriendlyList.SetItemN(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  ObjectByIndex[index] := value;
end;

{ TFhirContractLegal }

constructor TFhirContractLegal.Create;
begin
  inherited;
end;

destructor TFhirContractLegal.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractLegal.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractLegal(oSource).content.Clone;
end;

procedure TFhirContractLegal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractLegal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractLegal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractLegal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractLegal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractLegal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractLegal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractLegal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractLegal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractLegal.fhirType : string;
begin
  result := 'legal';
end;

function TFhirContractLegal.Link : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Link);
end;

function TFhirContractLegal.Clone : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Clone);
end;

function TFhirContractLegal.equals(other : TObject) : boolean;
var
  o : TFhirContractLegal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractLegal)) then
    result := false
  else
  begin
    o := TFhirContractLegal(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractLegal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractLegal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractLegal }

Procedure TFhirContractLegal.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractLegal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractLegalListEnumerator }

Constructor TFhirContractLegalListEnumerator.Create(list : TFhirContractLegalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractLegalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractLegalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractLegalListEnumerator.GetCurrent : TFhirContractLegal;
begin
  Result := FList[FIndex];
end;

function TFhirContractLegalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractLegalList }
procedure TFhirContractLegalList.AddItem(value: TFhirContractLegal);
begin
  assert(value.ClassName = 'TFhirContractLegal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractLegal');
  add(value);
end;

function TFhirContractLegalList.Append: TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.ClearItems;
begin
  Clear;
end;

function TFhirContractLegalList.GetEnumerator : TFhirContractLegalListEnumerator;
begin
  result := TFhirContractLegalListEnumerator.Create(self.link);
end;

function TFhirContractLegalList.Clone: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Clone);
end;

function TFhirContractLegalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractLegalList.GetItemN(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractLegal;
end;
function TFhirContractLegalList.IndexOf(value: TFhirContractLegal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractLegalList.Insert(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.InsertItem(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  Inherited Insert(index, value);
end;

function TFhirContractLegalList.Item(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.Link: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Link);
end;

procedure TFhirContractLegalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractLegalList.SetItemByIndex(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  FhirContractLegals[index] := value;
end;

procedure TFhirContractLegalList.SetItemN(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  ObjectByIndex[index] := value;
end;

{ TFhirContractRule }

constructor TFhirContractRule.Create;
begin
  inherited;
end;

destructor TFhirContractRule.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractRule.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractRule(oSource).content.Clone;
end;

procedure TFhirContractRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(DocumentReference)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractRule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirContractRule.Link : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Link);
end;

function TFhirContractRule.Clone : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Clone);
end;

function TFhirContractRule.equals(other : TObject) : boolean;
var
  o : TFhirContractRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractRule)) then
    result := false
  else
  begin
    o := TFhirContractRule(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractRule }

Procedure TFhirContractRule.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractRuleListEnumerator }

Constructor TFhirContractRuleListEnumerator.Create(list : TFhirContractRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractRuleListEnumerator.GetCurrent : TFhirContractRule;
begin
  Result := FList[FIndex];
end;

function TFhirContractRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractRuleList }
procedure TFhirContractRuleList.AddItem(value: TFhirContractRule);
begin
  assert(value.ClassName = 'TFhirContractRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractRule');
  add(value);
end;

function TFhirContractRuleList.Append: TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.ClearItems;
begin
  Clear;
end;

function TFhirContractRuleList.GetEnumerator : TFhirContractRuleListEnumerator;
begin
  result := TFhirContractRuleListEnumerator.Create(self.link);
end;

function TFhirContractRuleList.Clone: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Clone);
end;

function TFhirContractRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractRuleList.GetItemN(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractRule;
end;
function TFhirContractRuleList.IndexOf(value: TFhirContractRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractRuleList.Insert(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.InsertItem(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  Inherited Insert(index, value);
end;

function TFhirContractRuleList.Item(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.Link: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Link);
end;

procedure TFhirContractRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractRuleList.SetItemByIndex(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  FhirContractRules[index] := value;
end;

procedure TFhirContractRuleList.SetItemN(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  ObjectByIndex[index] := value;
end;

{ TFhirContract }

constructor TFhirContract.Create;
begin
  inherited;
end;

destructor TFhirContract.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FIssued.free;
  FApplies.free;
  FSubjectList.Free;
  FTopicList.Free;
  FAuthorityList.Free;
  FDomainList.Free;
  FType_.free;
  FSubTypeList.Free;
  FActionList.Free;
  FActionReasonList.Free;
  FDecisionType.free;
  FContentDerivative.free;
  FSecurityLabelList.Free;
  FAgentList.Free;
  FSignerList.Free;
  FValuedItemList.Free;
  FTermList.Free;
  FBinding.free;
  FFriendlyList.Free;
  FLegalList.Free;
  FRuleList.Free;
  inherited;
end;

function TFhirContract.GetResourceType : TFhirResourceType;
begin
  result := frtContract;
end;

procedure TFhirContract.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContract(oSource).identifier.Clone;
  FStatus := TFhirContract(oSource).FStatus.Link;
  issuedElement := TFhirContract(oSource).issuedElement.Clone;
  applies := TFhirContract(oSource).applies.Clone;
  if (TFhirContract(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirReference}.Create;
    FSubjectList.Assign(TFhirContract(oSource).FSubjectList);
  end;
  if (TFhirContract(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirReferenceList{TFhirReference}.Create;
    FTopicList.Assign(TFhirContract(oSource).FTopicList);
  end;
  if (TFhirContract(oSource).FAuthorityList = nil) then
  begin
    FAuthorityList.free;
    FAuthorityList := nil;
  end
  else
  begin
    if FAuthorityList = nil then
      FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
    FAuthorityList.Assign(TFhirContract(oSource).FAuthorityList);
  end;
  if (TFhirContract(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirReferenceList{TFhirLocation}.Create;
    FDomainList.Assign(TFhirContract(oSource).FDomainList);
  end;
  type_ := TFhirContract(oSource).type_.Clone;
  if (TFhirContract(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirContract(oSource).FSubTypeList);
  end;
  if (TFhirContract(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirContract(oSource).FActionList);
  end;
  if (TFhirContract(oSource).FActionReasonList = nil) then
  begin
    FActionReasonList.free;
    FActionReasonList := nil;
  end
  else
  begin
    if FActionReasonList = nil then
      FActionReasonList := TFhirCodeableConceptList.Create;
    FActionReasonList.Assign(TFhirContract(oSource).FActionReasonList);
  end;
  decisionType := TFhirContract(oSource).decisionType.Clone;
  contentDerivative := TFhirContract(oSource).contentDerivative.Clone;
  if (TFhirContract(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirContract(oSource).FSecurityLabelList);
  end;
  if (TFhirContract(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirContractAgentList.Create;
    FAgentList.Assign(TFhirContract(oSource).FAgentList);
  end;
  if (TFhirContract(oSource).FSignerList = nil) then
  begin
    FSignerList.free;
    FSignerList := nil;
  end
  else
  begin
    if FSignerList = nil then
      FSignerList := TFhirContractSignerList.Create;
    FSignerList.Assign(TFhirContract(oSource).FSignerList);
  end;
  if (TFhirContract(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractValuedItemList.Create;
    FValuedItemList.Assign(TFhirContract(oSource).FValuedItemList);
  end;
  if (TFhirContract(oSource).FTermList = nil) then
  begin
    FTermList.free;
    FTermList := nil;
  end
  else
  begin
    if FTermList = nil then
      FTermList := TFhirContractTermList.Create;
    FTermList.Assign(TFhirContract(oSource).FTermList);
  end;
  binding := TFhirContract(oSource).binding.Clone;
  if (TFhirContract(oSource).FFriendlyList = nil) then
  begin
    FFriendlyList.free;
    FFriendlyList := nil;
  end
  else
  begin
    if FFriendlyList = nil then
      FFriendlyList := TFhirContractFriendlyList.Create;
    FFriendlyList.Assign(TFhirContract(oSource).FFriendlyList);
  end;
  if (TFhirContract(oSource).FLegalList = nil) then
  begin
    FLegalList.free;
    FLegalList := nil;
  end
  else
  begin
    if FLegalList = nil then
      FLegalList := TFhirContractLegalList.Create;
    FLegalList.Assign(TFhirContract(oSource).FLegalList);
  end;
  if (TFhirContract(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirContractRuleList.Create;
    FRuleList.Assign(TFhirContract(oSource).FRuleList);
  end;
end;

procedure TFhirContract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'authority') Then
    list.addAll(self, 'authority', FAuthorityList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'actionReason') Then
    list.addAll(self, 'actionReason', FActionReasonList);
  if (child_name = 'decisionType') Then
     list.add(self.link, 'decisionType', FDecisionType.Link);
  if (child_name = 'contentDerivative') Then
     list.add(self.link, 'contentDerivative', FContentDerivative.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'signer') Then
    list.addAll(self, 'signer', FSignerList);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
  if (child_name = 'term') Then
    list.addAll(self, 'term', FTermList);
  if (child_name = 'binding[x]') or (child_name = 'binding') Then
     list.add(self.link, 'binding[x]', FBinding.Link);
  if (child_name = 'friendly') Then
    list.addAll(self, 'friendly', FFriendlyList);
  if (child_name = 'legal') Then
    list.addAll(self, 'legal', FLegalList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirContract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FAuthorityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'domain', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FDomainList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actionReason', 'CodeableConcept', true, TFhirCodeableConcept, FActionReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'decisionType', 'CodeableConcept', false, TFhirCodeableConcept, FDecisionType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contentDerivative', 'CodeableConcept', false, TFhirCodeableConcept, FContentDerivative.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirContractAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signer', '', true, TFhirContractSigner, FSignerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'valuedItem', '', true, TFhirContractValuedItem, FValuedItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'term', '', true, TFhirContractTerm, FTermList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'binding[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'friendly', '', true, TFhirContractFriendly, FFriendlyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'legal', '', true, TFhirContractLegal, FLegalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirContractRule, FRuleList.Link)){3};
end;

function TFhirContract.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirContractStatusEnum, CODES_TFhirContractStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    AuthorityList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actionReason') then
  begin
    ActionReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'decisionType') then
  begin
    DecisionType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'contentDerivative') then
  begin
    ContentDerivative := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirContractAgent){2a};
    result := propValue;
  end
  else if (propName = 'signer') then
  begin
    SignerList.add(propValue as TFhirContractSigner){2a};
    result := propValue;
  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractValuedItem){2a};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    TermList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then
  begin
    Binding := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'friendly') then
  begin
    FriendlyList.add(propValue as TFhirContractFriendly){2a};
    result := propValue;
  end
  else if (propName = 'legal') then
  begin
    LegalList.add(propValue as TFhirContractLegal){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirContractRule){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'authority') then AuthorityList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actionReason') then ActionReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirContractAgent){2a}
  else if (propName = 'signer') then SignerList.insertItem(index, propValue as TFhirContractSigner){2a}
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractValuedItem){2a}
  else if (propName = 'term') then TermList.insertItem(index, propValue as TFhirContractTerm){2a}
  else if (propName = 'friendly') then FriendlyList.insertItem(index, propValue as TFhirContractFriendly){2a}
  else if (propName = 'legal') then LegalList.insertItem(index, propValue as TFhirContractLegal){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirContractRule){2a}
  else inherited;
end;

function TFhirContract.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'authority') then result := AuthorityList.new(){2}
  else if (propName = 'domain') then result := DomainList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := SubTypeList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'actionReason') then result := ActionReasonList.new(){2}
  else if (propName = 'decisionType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'contentDerivative') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'signer') then result := SignerList.new(){2}
  else if (propName = 'valuedItem') then result := ValuedItemList.new(){2}
  else if (propName = 'term') then result := TermList.new(){2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Binding'){4x}
  else if (propName = 'friendly') then result := FriendlyList.new(){2}
  else if (propName = 'legal') then result := LegalList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'domain') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'actionReason') then result := 'CodeableConcept'
  else if (propName = 'decisionType') then result := 'CodeableConcept'
  else if (propName = 'contentDerivative') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'agent') then result := ''
  else if (propName = 'signer') then result := ''
  else if (propName = 'valuedItem') then result := ''
  else if (propName = 'term') then result := ''
  else if (propName = 'binding[x]') then result := 'Attachment|Reference'
  else if (propName = 'friendly') then result := ''
  else if (propName = 'legal') then result := ''
  else if (propName = 'rule') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContract.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'authority') then deletePropertyValue('authority', AuthorityList, value) {2}
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'actionReason') then deletePropertyValue('actionReason', ActionReasonList, value) {2}
  else if (propName = 'decisionType') then DecisionTypeElement := nil
  else if (propName = 'contentDerivative') then ContentDerivativeElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'signer') then deletePropertyValue('signer', SignerList, value) {2}
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value) {2}
  else if (propName = 'term') then deletePropertyValue('term', TermList, value) {2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then BindingElement := nil{4x}
  else if (propName = 'friendly') then deletePropertyValue('friendly', FriendlyList, value) {2}
  else if (propName = 'legal') then deletePropertyValue('legal', LegalList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirContractStatusEnum, CODES_TFhirContractStatusEnum, new){4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'authority') then replacePropertyValue('authority', AuthorityList, existing, new) {2}
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'actionReason') then replacePropertyValue('actionReason', ActionReasonList, existing, new) {2}
  else if (propName = 'decisionType') then DecisionTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'contentDerivative') then ContentDerivativeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'signer') then replacePropertyValue('signer', SignerList, existing, new) {2}
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new) {2}
  else if (propName = 'term') then replacePropertyValue('term', TermList, existing, new) {2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then BindingElement := new as TFhirType{4x}
  else if (propName = 'friendly') then replacePropertyValue('friendly', FriendlyList, existing, new) {2}
  else if (propName = 'legal') then replacePropertyValue('legal', LegalList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContract.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'authority') then AuthorityList.move(source, destination){2a}
  else if (propName = 'domain') then DomainList.move(source, destination){2a}
  else if (propName = 'subType') then SubTypeList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'actionReason') then ActionReasonList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'signer') then SignerList.move(source, destination){2a}
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination){2a}
  else if (propName = 'term') then TermList.move(source, destination){2a}
  else if (propName = 'friendly') then FriendlyList.move(source, destination){2a}
  else if (propName = 'legal') then LegalList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContract.fhirType : string;
begin
  result := 'Contract';
end;

function TFhirContract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FsubjectList) and isEmptyProp(FtopicList) and isEmptyProp(FauthorityList) and isEmptyProp(FdomainList) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FactionList) and isEmptyProp(FactionReasonList) and isEmptyProp(FDecisionType) and isEmptyProp(FContentDerivative) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FagentList) and isEmptyProp(FsignerList) and isEmptyProp(FvaluedItemList) and isEmptyProp(FtermList) and isEmptyProp(FBinding) and isEmptyProp(FfriendlyList) and isEmptyProp(FlegalList) and isEmptyProp(FruleList);
end;

function TFhirContract.equals(other : TObject) : boolean;
var
  o : TFhirContract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContract)) then
    result := false
  else
  begin
    o := TFhirContract(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(appliesElement, o.appliesElement, true) and
      compareDeep(subjectList, o.subjectList, true) and compareDeep(topicList, o.topicList, true) and
      compareDeep(authorityList, o.authorityList, true) and compareDeep(domainList, o.domainList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and
      compareDeep(actionList, o.actionList, true) and compareDeep(actionReasonList, o.actionReasonList, true) and
      compareDeep(decisionTypeElement, o.decisionTypeElement, true) and compareDeep(contentDerivativeElement, o.contentDerivativeElement, true) and
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(agentList, o.agentList, true) and
      compareDeep(signerList, o.signerList, true) and compareDeep(valuedItemList, o.valuedItemList, true) and
      compareDeep(termList, o.termList, true) and compareDeep(bindingElement, o.bindingElement, true) and
      compareDeep(friendlyList, o.friendlyList, true) and compareDeep(legalList, o.legalList, true) and
      compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirContract.Link : TFhirContract;
begin
  result := TFhirContract(inherited Link);
end;

function TFhirContract.Clone : TFhirContract;
begin
  result := TFhirContract(inherited Clone);
end;

procedure TFhirContract.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('issued');
  fields.add('applies');
  fields.add('subject');
  fields.add('topic');
  fields.add('authority');
  fields.add('domain');
  fields.add('type');
  fields.add('subType');
  fields.add('action');
  fields.add('actionReason');
  fields.add('decisionType');
  fields.add('contentDerivative');
  fields.add('securityLabel');
  fields.add('agent');
  fields.add('signer');
  fields.add('valuedItem');
  fields.add('term');
  fields.add('binding[x]');
  fields.add('friendly');
  fields.add('legal');
  fields.add('rule');
end;

{ TFhirContract }

Procedure TFhirContract.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContract.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirContract.GetStatusST : TFhirContractStatusEnum;
begin
  if FStatus = nil then
    result := TFhirContractStatusEnum(0)
  else
    result := TFhirContractStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirContractStatusEnum, FStatus.value));
end;

Procedure TFhirContract.SetStatusST(value : TFhirContractStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirContractStatusEnum[value], CODES_TFhirContractStatusEnum[value]);
end;

Procedure TFhirContract.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContract.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContract.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContract.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Function TFhirContract.GetSubjectList : TFhirReferenceList{TFhirReference};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirReference}.Create;
  result := FSubjectList;
end;

Function TFhirContract.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Function TFhirContract.GetTopicList : TFhirReferenceList{TFhirReference};
begin
  if FTopicList = nil then
    FTopicList := TFhirReferenceList{TFhirReference}.Create;
  result := FTopicList;
end;

Function TFhirContract.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirContract.GetAuthorityList : TFhirReferenceList{TFhirOrganization};
begin
  if FAuthorityList = nil then
    FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FAuthorityList;
end;

Function TFhirContract.GetHasAuthorityList : boolean;
begin
  result := (FAuthorityList <> nil) and (FAuthorityList.count > 0);
end;

Function TFhirContract.GetDomainList : TFhirReferenceList{TFhirLocation};
begin
  if FDomainList = nil then
    FDomainList := TFhirReferenceList{TFhirLocation}.Create;
  result := FDomainList;
end;

Function TFhirContract.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

Procedure TFhirContract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirContract.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

Function TFhirContract.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

Function TFhirContract.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirContract.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirContract.GetActionReasonList : TFhirCodeableConceptList;
begin
  if FActionReasonList = nil then
    FActionReasonList := TFhirCodeableConceptList.Create;
  result := FActionReasonList;
end;

Function TFhirContract.GetHasActionReasonList : boolean;
begin
  result := (FActionReasonList <> nil) and (FActionReasonList.count > 0);
end;

Procedure TFhirContract.SetDecisionType(value : TFhirCodeableConcept);
begin
  FDecisionType.free;
  FDecisionType := value;
end;

Procedure TFhirContract.SetContentDerivative(value : TFhirCodeableConcept);
begin
  FContentDerivative.free;
  FContentDerivative := value;
end;

Function TFhirContract.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirContract.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirContract.GetAgentList : TFhirContractAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirContractAgentList.Create;
  result := FAgentList;
end;

Function TFhirContract.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Function TFhirContract.GetSignerList : TFhirContractSignerList;
begin
  if FSignerList = nil then
    FSignerList := TFhirContractSignerList.Create;
  result := FSignerList;
end;

Function TFhirContract.GetHasSignerList : boolean;
begin
  result := (FSignerList <> nil) and (FSignerList.count > 0);
end;

Function TFhirContract.GetValuedItemList : TFhirContractValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractValuedItemList.Create;
  result := FValuedItemList;
end;

Function TFhirContract.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

Function TFhirContract.GetTermList : TFhirContractTermList;
begin
  if FTermList = nil then
    FTermList := TFhirContractTermList.Create;
  result := FTermList;
end;

Function TFhirContract.GetHasTermList : boolean;
begin
  result := (FTermList <> nil) and (FTermList.count > 0);
end;

Procedure TFhirContract.SetBinding(value : TFhirType);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirContract.GetFriendlyList : TFhirContractFriendlyList;
begin
  if FFriendlyList = nil then
    FFriendlyList := TFhirContractFriendlyList.Create;
  result := FFriendlyList;
end;

Function TFhirContract.GetHasFriendlyList : boolean;
begin
  result := (FFriendlyList <> nil) and (FFriendlyList.count > 0);
end;

Function TFhirContract.GetLegalList : TFhirContractLegalList;
begin
  if FLegalList = nil then
    FLegalList := TFhirContractLegalList.Create;
  result := FLegalList;
end;

Function TFhirContract.GetHasLegalList : boolean;
begin
  result := (FLegalList <> nil) and (FLegalList.count > 0);
end;

Function TFhirContract.GetRuleList : TFhirContractRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirContractRuleList.Create;
  result := FRuleList;
end;

Function TFhirContract.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirContract.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorityList.sizeInBytes);
  inc(result, FdomainList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubTypeList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FactionReasonList.sizeInBytes);
  inc(result, FDecisionType.sizeInBytes);
  inc(result, FContentDerivative.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FsignerList.sizeInBytes);
  inc(result, FvaluedItemList.sizeInBytes);
  inc(result, FtermList.sizeInBytes);
  inc(result, FBinding.sizeInBytes);
  inc(result, FfriendlyList.sizeInBytes);
  inc(result, FlegalList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
end;

{ TFhirContractListEnumerator }

Constructor TFhirContractListEnumerator.Create(list : TFhirContractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractListEnumerator.GetCurrent : TFhirContract;
begin
  Result := FList[FIndex];
end;

function TFhirContractListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractList }
procedure TFhirContractList.AddItem(value: TFhirContract);
begin
  assert(value.ClassName = 'TFhirContract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContract');
  add(value);
end;

function TFhirContractList.Append: TFhirContract;
begin
  result := TFhirContract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.ClearItems;
begin
  Clear;
end;

function TFhirContractList.GetEnumerator : TFhirContractListEnumerator;
begin
  result := TFhirContractListEnumerator.Create(self.link);
end;

function TFhirContractList.Clone: TFhirContractList;
begin
  result := TFhirContractList(inherited Clone);
end;

function TFhirContractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractList.GetItemN(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.ItemClass: TFslObjectClass;
begin
  result := TFhirContract;
end;
function TFhirContractList.IndexOf(value: TFhirContract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractList.Insert(index: Integer): TFhirContract;
begin
  result := TFhirContract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.InsertItem(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  Inherited Insert(index, value);
end;

function TFhirContractList.Item(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.Link: TFhirContractList;
begin
  result := TFhirContractList(inherited Link);
end;

procedure TFhirContractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractList.SetItemByIndex(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  FhirContracts[index] := value;
end;

procedure TFhirContractList.SetItemN(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_ELIGIBILITYREQUEST}

{ TFhirEligibilityRequest }

constructor TFhirEligibilityRequest.Create;
begin
  inherited;
end;

destructor TFhirEligibilityRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPriority.free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FEnterer.free;
  FProvider.free;
  FOrganization.free;
  FInsurer.free;
  FFacility.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FBenefitCategory.free;
  FBenefitSubCategory.free;
  inherited;
end;

function TFhirEligibilityRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEligibilityRequest;
end;

procedure TFhirEligibilityRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEligibilityRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEligibilityRequest(oSource).FIdentifierList);
  end;
  FStatus := TFhirEligibilityRequest(oSource).FStatus.Link;
  priority := TFhirEligibilityRequest(oSource).priority.Clone;
  patient := TFhirEligibilityRequest(oSource).patient.Clone;
  serviced := TFhirEligibilityRequest(oSource).serviced.Clone;
  createdElement := TFhirEligibilityRequest(oSource).createdElement.Clone;
  enterer := TFhirEligibilityRequest(oSource).enterer.Clone;
  provider := TFhirEligibilityRequest(oSource).provider.Clone;
  organization := TFhirEligibilityRequest(oSource).organization.Clone;
  insurer := TFhirEligibilityRequest(oSource).insurer.Clone;
  facility := TFhirEligibilityRequest(oSource).facility.Clone;
  coverage := TFhirEligibilityRequest(oSource).coverage.Clone;
  businessArrangementElement := TFhirEligibilityRequest(oSource).businessArrangementElement.Clone;
  benefitCategory := TFhirEligibilityRequest(oSource).benefitCategory.Clone;
  benefitSubCategory := TFhirEligibilityRequest(oSource).benefitSubCategory.Clone;
end;

procedure TFhirEligibilityRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'benefitCategory') Then
     list.add(self.link, 'benefitCategory', FBenefitCategory.Link);
  if (child_name = 'benefitSubCategory') Then
     list.add(self.link, 'benefitSubCategory', FBenefitSubCategory.Link);
end;

procedure TFhirEligibilityRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefitCategory', 'CodeableConcept', false, TFhirCodeableConcept, FBenefitCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefitSubCategory', 'CodeableConcept', false, TFhirCodeableConcept, FBenefitSubCategory.Link));{2}
end;

function TFhirEligibilityRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'benefitCategory') then
  begin
    BenefitCategory := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'benefitSubCategory') then
  begin
    BenefitSubCategory := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEligibilityRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEligibilityRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'benefitCategory') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'benefitSubCategory') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'benefitCategory') then result := 'CodeableConcept'
  else if (propName = 'benefitSubCategory') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'benefitCategory') then BenefitCategoryElement := nil
  else if (propName = 'benefitSubCategory') then BenefitSubCategoryElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'benefitCategory') then BenefitCategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'benefitSubCategory') then BenefitSubCategoryElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityRequest.fhirType : string;
begin
  result := 'EligibilityRequest';
end;

function TFhirEligibilityRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPriority) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FInsurer) and isEmptyProp(FFacility) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FBenefitCategory) and isEmptyProp(FBenefitSubCategory);
end;

function TFhirEligibilityRequest.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityRequest)) then
    result := false
  else
  begin
    o := TFhirEligibilityRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(entererElement, o.entererElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(insurerElement, o.insurerElement, true) and
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(coverageElement, o.coverageElement, true) and
      compareDeep(businessArrangementElement, o.businessArrangementElement, true) and
      compareDeep(benefitCategoryElement, o.benefitCategoryElement, true) and compareDeep(benefitSubCategoryElement, o.benefitSubCategoryElement, true);
  end;
end;

function TFhirEligibilityRequest.Link : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(inherited Link);
end;

function TFhirEligibilityRequest.Clone : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(inherited Clone);
end;

procedure TFhirEligibilityRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('priority');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('enterer');
  fields.add('provider');
  fields.add('organization');
  fields.add('insurer');
  fields.add('facility');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('benefitCategory');
  fields.add('benefitSubCategory');
end;

{ TFhirEligibilityRequest }

Function TFhirEligibilityRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEligibilityRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEligibilityRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEligibilityRequest.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEligibilityRequest.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEligibilityRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirEligibilityRequest.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirEligibilityRequest.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirEligibilityRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEligibilityRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEligibilityRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEligibilityRequest.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirEligibilityRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirEligibilityRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEligibilityRequest.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirEligibilityRequest.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Procedure TFhirEligibilityRequest.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirEligibilityRequest.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirEligibilityRequest.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirEligibilityRequest.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Procedure TFhirEligibilityRequest.SetBenefitCategory(value : TFhirCodeableConcept);
begin
  FBenefitCategory.free;
  FBenefitCategory := value;
end;

Procedure TFhirEligibilityRequest.SetBenefitSubCategory(value : TFhirCodeableConcept);
begin
  FBenefitSubCategory.free;
  FBenefitSubCategory := value;
end;

function TFhirEligibilityRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FBenefitCategory.sizeInBytes);
  inc(result, FBenefitSubCategory.sizeInBytes);
end;

{ TFhirEligibilityRequestListEnumerator }

Constructor TFhirEligibilityRequestListEnumerator.Create(list : TFhirEligibilityRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityRequestListEnumerator.GetCurrent : TFhirEligibilityRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityRequestList }
procedure TFhirEligibilityRequestList.AddItem(value: TFhirEligibilityRequest);
begin
  assert(value.ClassName = 'TFhirEligibilityRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityRequest');
  add(value);
end;

function TFhirEligibilityRequestList.Append: TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityRequestList.GetEnumerator : TFhirEligibilityRequestListEnumerator;
begin
  result := TFhirEligibilityRequestListEnumerator.Create(self.link);
end;

function TFhirEligibilityRequestList.Clone: TFhirEligibilityRequestList;
begin
  result := TFhirEligibilityRequestList(inherited Clone);
end;

function TFhirEligibilityRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityRequestList.GetItemN(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirEligibilityRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityRequest;
end;
function TFhirEligibilityRequestList.IndexOf(value: TFhirEligibilityRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityRequestList.Insert(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityRequestList.InsertItem(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  Inherited Insert(index, value);
end;

function TFhirEligibilityRequestList.Item(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirEligibilityRequestList.Link: TFhirEligibilityRequestList;
begin
  result := TFhirEligibilityRequestList(inherited Link);
end;

procedure TFhirEligibilityRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityRequestList.SetItemByIndex(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  FhirEligibilityRequests[index] := value;
end;

procedure TFhirEligibilityRequestList.SetItemN(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}

{$IFDEF FHIR_ELIGIBILITYRESPONSE}

{ TFhirEligibilityResponseInsurance }

constructor TFhirEligibilityResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponseInsurance.Destroy;
begin
  FCoverage.free;
  FContract.free;
  FBenefitBalanceList.Free;
  inherited;
end;

procedure TFhirEligibilityResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirEligibilityResponseInsurance(oSource).coverage.Clone;
  contract := TFhirEligibilityResponseInsurance(oSource).contract.Clone;
  if (TFhirEligibilityResponseInsurance(oSource).FBenefitBalanceList = nil) then
  begin
    FBenefitBalanceList.free;
    FBenefitBalanceList := nil;
  end
  else
  begin
    if FBenefitBalanceList = nil then
      FBenefitBalanceList := TFhirEligibilityResponseInsuranceBenefitBalanceList.Create;
    FBenefitBalanceList.Assign(TFhirEligibilityResponseInsurance(oSource).FBenefitBalanceList);
  end;
end;

procedure TFhirEligibilityResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'contract') Then
     list.add(self.link, 'contract', FContract.Link);
  if (child_name = 'benefitBalance') Then
    list.addAll(self, 'benefitBalance', FBenefitBalanceList);
end;

procedure TFhirEligibilityResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference(Contract)', false, TFhirReference{TFhirContract}, FContract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefitBalance', '', true, TFhirEligibilityResponseInsuranceBenefitBalance, FBenefitBalanceList.Link)){3};
end;

function TFhirEligibilityResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    Contract := propValue as TFhirReference{TFhirContract}{4b};
    result := propValue;
  end
  else if (propName = 'benefitBalance') then
  begin
    BenefitBalanceList.add(propValue as TFhirEligibilityResponseInsuranceBenefitBalance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEligibilityResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'benefitBalance') then BenefitBalanceList.insertItem(index, propValue as TFhirEligibilityResponseInsuranceBenefitBalance){2a}
  else inherited;
end;

function TFhirEligibilityResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'contract') then result := TFhirReference{TFhirContract}.create(){4b}
  else if (propName = 'benefitBalance') then result := BenefitBalanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'contract') then result := 'Reference'
  else if (propName = 'benefitBalance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'contract') then ContractElement := nil
  else if (propName = 'benefitBalance') then deletePropertyValue('benefitBalance', BenefitBalanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'contract') then ContractElement := new as TFhirReference{TFhirContract}{4}
  else if (propName = 'benefitBalance') then replacePropertyValue('benefitBalance', BenefitBalanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'benefitBalance') then BenefitBalanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponseInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirEligibilityResponseInsurance.Link : TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance(inherited Link);
end;

function TFhirEligibilityResponseInsurance.Clone : TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance(inherited Clone);
end;

function TFhirEligibilityResponseInsurance.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponseInsurance(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(contractElement, o.contractElement, true) and
      compareDeep(benefitBalanceList, o.benefitBalanceList, true);
  end;
end;

function TFhirEligibilityResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FContract) and isEmptyProp(FbenefitBalanceList);
end;

procedure TFhirEligibilityResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('contract');
  fields.add('benefitBalance');
end;

{ TFhirEligibilityResponseInsurance }

Procedure TFhirEligibilityResponseInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirEligibilityResponseInsurance.SetContract(value : TFhirReference{TFhirContract});
begin
  FContract.free;
  FContract := value;
end;

Function TFhirEligibilityResponseInsurance.GetBenefitBalanceList : TFhirEligibilityResponseInsuranceBenefitBalanceList;
begin
  if FBenefitBalanceList = nil then
    FBenefitBalanceList := TFhirEligibilityResponseInsuranceBenefitBalanceList.Create;
  result := FBenefitBalanceList;
end;

Function TFhirEligibilityResponseInsurance.GetHasBenefitBalanceList : boolean;
begin
  result := (FBenefitBalanceList <> nil) and (FBenefitBalanceList.count > 0);
end;

function TFhirEligibilityResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FContract.sizeInBytes);
  inc(result, FbenefitBalanceList.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceListEnumerator }

Constructor TFhirEligibilityResponseInsuranceListEnumerator.Create(list : TFhirEligibilityResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseInsuranceListEnumerator.GetCurrent : TFhirEligibilityResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceList }
procedure TFhirEligibilityResponseInsuranceList.AddItem(value: TFhirEligibilityResponseInsurance);
begin
  assert(value.ClassName = 'TFhirEligibilityResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponseInsurance');
  add(value);
end;

function TFhirEligibilityResponseInsuranceList.Append: TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseInsuranceList.GetEnumerator : TFhirEligibilityResponseInsuranceListEnumerator;
begin
  result := TFhirEligibilityResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseInsuranceList.Clone: TFhirEligibilityResponseInsuranceList;
begin
  result := TFhirEligibilityResponseInsuranceList(inherited Clone);
end;

function TFhirEligibilityResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseInsuranceList.GetItemN(index: Integer): TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponseInsurance;
end;
function TFhirEligibilityResponseInsuranceList.IndexOf(value: TFhirEligibilityResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseInsuranceList.Insert(index: Integer): TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceList.InsertItem(index: Integer; value: TFhirEligibilityResponseInsurance);
begin
  assert(value is TFhirEligibilityResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseInsuranceList.Item(index: Integer): TFhirEligibilityResponseInsurance;
begin
  result := TFhirEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceList.Link: TFhirEligibilityResponseInsuranceList;
begin
  result := TFhirEligibilityResponseInsuranceList(inherited Link);
end;

procedure TFhirEligibilityResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponseInsurance);
begin
  assert(value is TFhirEligibilityResponseInsurance);
  FhirEligibilityResponseInsurances[index] := value;
end;

procedure TFhirEligibilityResponseInsuranceList.SetItemN(index: Integer; value: TFhirEligibilityResponseInsurance);
begin
  assert(value is TFhirEligibilityResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirEligibilityResponseInsuranceBenefitBalance }

constructor TFhirEligibilityResponseInsuranceBenefitBalance.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponseInsuranceBenefitBalance.Destroy;
begin
  FCategory.free;
  FSubCategory.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FFinancialList.Free;
  inherited;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).category.Clone;
  subCategory := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).subCategory.Clone;
  excludedElement := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).excludedElement.Clone;
  nameElement := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).nameElement.Clone;
  descriptionElement := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).descriptionElement.Clone;
  network := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).network.Clone;
  unit_ := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).unit_.Clone;
  term := TFhirEligibilityResponseInsuranceBenefitBalance(oSource).term.Clone;
  if (TFhirEligibilityResponseInsuranceBenefitBalance(oSource).FFinancialList = nil) then
  begin
    FFinancialList.free;
    FFinancialList := nil;
  end
  else
  begin
    if FFinancialList = nil then
      FFinancialList := TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Create;
    FFinancialList.Assign(TFhirEligibilityResponseInsuranceBenefitBalance(oSource).FFinancialList);
  end;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'subCategory') Then
     list.add(self.link, 'subCategory', FSubCategory.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'financial') Then
    list.addAll(self, 'financial', FFinancialList);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subCategory', 'CodeableConcept', false, TFhirCodeableConcept, FSubCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'financial', '', true, TFhirEligibilityResponseInsuranceBenefitBalanceFinancial, FFinancialList.Link)){3};
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subCategory') then
  begin
    SubCategory := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'financial') then
  begin
    FinancialList.add(propValue as TFhirEligibilityResponseInsuranceBenefitBalanceFinancial){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'financial') then FinancialList.insertItem(index, propValue as TFhirEligibilityResponseInsuranceBenefitBalanceFinancial){2a}
  else inherited;
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subCategory') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'network') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'term') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'financial') then result := FinancialList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subCategory') then result := 'CodeableConcept'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'financial') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'subCategory') then SubCategoryElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'financial') then deletePropertyValue('financial', FinancialList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subCategory') then SubCategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept{4}
  else if (propName = 'financial') then replacePropertyValue('financial', FinancialList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'financial') then FinancialList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.fhirType : string;
begin
  result := 'benefitBalance';
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.Link : TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance(inherited Link);
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.Clone : TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance(inherited Clone);
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponseInsuranceBenefitBalance)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponseInsuranceBenefitBalance(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(subCategoryElement, o.subCategoryElement, true) and
      compareDeep(excludedElement, o.excludedElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(networkElement, o.networkElement, true) and
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(termElement, o.termElement, true) and
      compareDeep(financialList, o.financialList, true);
  end;
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FSubCategory) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FfinancialList);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('subCategory');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('financial');
end;

{ TFhirEligibilityResponseInsuranceBenefitBalance }

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetSubCategory(value : TFhirCodeableConcept);
begin
  FSubCategory.free;
  FSubCategory := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

Function TFhirEligibilityResponseInsuranceBenefitBalance.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirEligibilityResponseInsuranceBenefitBalance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirEligibilityResponseInsuranceBenefitBalance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalance.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

Function TFhirEligibilityResponseInsuranceBenefitBalance.GetFinancialList : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
begin
  if FFinancialList = nil then
    FFinancialList := TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Create;
  result := FFinancialList;
end;

Function TFhirEligibilityResponseInsuranceBenefitBalance.GetHasFinancialList : boolean;
begin
  result := (FFinancialList <> nil) and (FFinancialList.count > 0);
end;

function TFhirEligibilityResponseInsuranceBenefitBalance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FSubCategory.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FfinancialList.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator }

Constructor TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.Create(list : TFhirEligibilityResponseInsuranceBenefitBalanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.GetCurrent : TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceList }
procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.AddItem(value: TFhirEligibilityResponseInsuranceBenefitBalance);
begin
  assert(value.ClassName = 'TFhirEligibilityResponseInsuranceBenefitBalance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponseInsuranceBenefitBalance');
  add(value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Append: TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.GetEnumerator : TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Clone: TFhirEligibilityResponseInsuranceBenefitBalanceList;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceList(inherited Clone);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.GetItemN(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance;
end;
function TFhirEligibilityResponseInsuranceBenefitBalanceList.IndexOf(value: TFhirEligibilityResponseInsuranceBenefitBalance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Insert(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.InsertItem(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalance);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalance);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Item(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalance;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalance(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceList.Link: TFhirEligibilityResponseInsuranceBenefitBalanceList;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceList(inherited Link);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalance);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalance);
  FhirEligibilityResponseInsuranceBenefitBalances[index] := value;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceList.SetItemN(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalance);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalance);
  ObjectByIndex[index] := value;
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceFinancial }

constructor TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(oSource).type_.Clone;
  allowed := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(oSource).allowed.Clone;
  used := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(oSource).used.Clone;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirType, FAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|Money', false, TFhirType, FUsed.Link));{2}
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then
  begin
    Used := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed'){4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then raise EFHIRException.create('Cannot make property Used'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.fhirType : string;
begin
  result := 'financial';
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.Link : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(inherited Link);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.Clone : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(inherited Clone);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponseInsuranceBenefitBalanceFinancial)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceFinancial }

Procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.SetAllowed(value : TFhirType);
begin
  FAllowed.free;
  FAllowed := value;
end;

Procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.SetUsed(value : TFhirType);
begin
  FUsed.free;
  FUsed := value;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator }

Constructor TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.Create(list : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.GetCurrent : TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList }
procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.AddItem(value: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  assert(value.ClassName = 'TFhirEligibilityResponseInsuranceBenefitBalanceFinancial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponseInsuranceBenefitBalanceFinancial');
  add(value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Append: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.GetEnumerator : TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancialListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Clone: TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList(inherited Clone);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.GetItemN(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
end;
function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.IndexOf(value: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Insert(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.InsertItem(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Item(index: Integer): TFhirEligibilityResponseInsuranceBenefitBalanceFinancial;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Link: TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList;
begin
  result := TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList(inherited Link);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
  FhirEligibilityResponseInsuranceBenefitBalanceFinancials[index] := value;
end;

procedure TFhirEligibilityResponseInsuranceBenefitBalanceFinancialList.SetItemN(index: Integer; value: TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
begin
  assert(value is TFhirEligibilityResponseInsuranceBenefitBalanceFinancial);
  ObjectByIndex[index] := value;
end;

{ TFhirEligibilityResponseError }

constructor TFhirEligibilityResponseError.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponseError.Destroy;
begin
  FCode.free;
  inherited;
end;

procedure TFhirEligibilityResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirEligibilityResponseError(oSource).code.Clone;
end;

procedure TFhirEligibilityResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirEligibilityResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirEligibilityResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEligibilityResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEligibilityResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponseError.fhirType : string;
begin
  result := 'error';
end;

function TFhirEligibilityResponseError.Link : TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError(inherited Link);
end;

function TFhirEligibilityResponseError.Clone : TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError(inherited Clone);
end;

function TFhirEligibilityResponseError.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponseError)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponseError(other);
    result := compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirEligibilityResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode);
end;

procedure TFhirEligibilityResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
end;

{ TFhirEligibilityResponseError }

Procedure TFhirEligibilityResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirEligibilityResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
end;

{ TFhirEligibilityResponseErrorListEnumerator }

Constructor TFhirEligibilityResponseErrorListEnumerator.Create(list : TFhirEligibilityResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseErrorListEnumerator.GetCurrent : TFhirEligibilityResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseErrorList }
procedure TFhirEligibilityResponseErrorList.AddItem(value: TFhirEligibilityResponseError);
begin
  assert(value.ClassName = 'TFhirEligibilityResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponseError');
  add(value);
end;

function TFhirEligibilityResponseErrorList.Append: TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseErrorList.GetEnumerator : TFhirEligibilityResponseErrorListEnumerator;
begin
  result := TFhirEligibilityResponseErrorListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseErrorList.Clone: TFhirEligibilityResponseErrorList;
begin
  result := TFhirEligibilityResponseErrorList(inherited Clone);
end;

function TFhirEligibilityResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseErrorList.GetItemN(index: Integer): TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponseError;
end;
function TFhirEligibilityResponseErrorList.IndexOf(value: TFhirEligibilityResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseErrorList.Insert(index: Integer): TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseErrorList.InsertItem(index: Integer; value: TFhirEligibilityResponseError);
begin
  assert(value is TFhirEligibilityResponseError);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseErrorList.Item(index: Integer): TFhirEligibilityResponseError;
begin
  result := TFhirEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseErrorList.Link: TFhirEligibilityResponseErrorList;
begin
  result := TFhirEligibilityResponseErrorList(inherited Link);
end;

procedure TFhirEligibilityResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseErrorList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponseError);
begin
  assert(value is TFhirEligibilityResponseError);
  FhirEligibilityResponseErrors[index] := value;
end;

procedure TFhirEligibilityResponseErrorList.SetItemN(index: Integer; value: TFhirEligibilityResponseError);
begin
  assert(value is TFhirEligibilityResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirEligibilityResponse }

constructor TFhirEligibilityResponse.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FInsurer.free;
  FInforce.free;
  FInsuranceList.Free;
  FForm.free;
  FErrorList.Free;
  inherited;
end;

function TFhirEligibilityResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEligibilityResponse;
end;

procedure TFhirEligibilityResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEligibilityResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEligibilityResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirEligibilityResponse(oSource).FStatus.Link;
  createdElement := TFhirEligibilityResponse(oSource).createdElement.Clone;
  requestProvider := TFhirEligibilityResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirEligibilityResponse(oSource).requestOrganization.Clone;
  request := TFhirEligibilityResponse(oSource).request.Clone;
  outcome := TFhirEligibilityResponse(oSource).outcome.Clone;
  dispositionElement := TFhirEligibilityResponse(oSource).dispositionElement.Clone;
  insurer := TFhirEligibilityResponse(oSource).insurer.Clone;
  inforceElement := TFhirEligibilityResponse(oSource).inforceElement.Clone;
  if (TFhirEligibilityResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirEligibilityResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirEligibilityResponse(oSource).FInsuranceList);
  end;
  form := TFhirEligibilityResponse(oSource).form.Clone;
  if (TFhirEligibilityResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirEligibilityResponseErrorList.Create;
    FErrorList.Assign(TFhirEligibilityResponse(oSource).FErrorList);
  end;
end;

procedure TFhirEligibilityResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'inforce') Then
     list.add(self.link, 'inforce', FInforce.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirEligibilityResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(EligibilityRequest)', false, TFhirReference{TFhirEligibilityRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'inforce', 'boolean', false, TFhirBoolean, FInforce.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirEligibilityResponseInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'error', '', true, TFhirEligibilityResponseError, FErrorList.Link)){3};
end;

function TFhirEligibilityResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirEligibilityRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'inforce') then
  begin
    InforceElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirEligibilityResponseInsurance){2a};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirEligibilityResponseError){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEligibilityResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirEligibilityResponseInsurance){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirEligibilityResponseError){2a}
  else inherited;
end;

function TFhirEligibilityResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirEligibilityRequest}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'inforce') then result := TFhirBoolean.create() {5b}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'inforce') then result := 'boolean'
  else if (propName = 'insurance') then result := ''
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'error') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'inforce') then InforceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirEligibilityRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'inforce') then InforceElement := asBoolean(new){5b}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponse.fhirType : string;
begin
  result := 'EligibilityResponse';
end;

function TFhirEligibilityResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FInsurer) and isEmptyProp(FInforce) and isEmptyProp(FinsuranceList) and isEmptyProp(FForm) and isEmptyProp(FerrorList);
end;

function TFhirEligibilityResponse.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponse)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true) and
      compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(insurerElement, o.insurerElement, true) and
      compareDeep(inforceElement, o.inforceElement, true) and compareDeep(insuranceList, o.insuranceList, true) and
      compareDeep(formElement, o.formElement, true) and compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirEligibilityResponse.Link : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(inherited Link);
end;

function TFhirEligibilityResponse.Clone : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(inherited Clone);
end;

procedure TFhirEligibilityResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('insurer');
  fields.add('inforce');
  fields.add('insurance');
  fields.add('form');
  fields.add('error');
end;

{ TFhirEligibilityResponse }

Function TFhirEligibilityResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEligibilityResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEligibilityResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEligibilityResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEligibilityResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEligibilityResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEligibilityResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEligibilityResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEligibilityResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirEligibilityResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Procedure TFhirEligibilityResponse.SetRequest(value : TFhirReference{TFhirEligibilityRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirEligibilityResponse.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirEligibilityResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirEligibilityResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirEligibilityResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirEligibilityResponse.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirEligibilityResponse.SetInforce(value : TFhirBoolean);
begin
  FInforce.free;
  FInforce := value;
end;

Function TFhirEligibilityResponse.GetInforceST : Boolean;
begin
  if FInforce = nil then
    result := false
  else
    result := FInforce.value;
end;

Procedure TFhirEligibilityResponse.SetInforceST(value : Boolean);
begin
  if FInforce = nil then
    FInforce := TFhirBoolean.create;
  FInforce.value := value
end;

Function TFhirEligibilityResponse.GetInsuranceList : TFhirEligibilityResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirEligibilityResponseInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirEligibilityResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Procedure TFhirEligibilityResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirEligibilityResponse.GetErrorList : TFhirEligibilityResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirEligibilityResponseErrorList.Create;
  result := FErrorList;
end;

Function TFhirEligibilityResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

function TFhirEligibilityResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FInforce.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirEligibilityResponseListEnumerator }

Constructor TFhirEligibilityResponseListEnumerator.Create(list : TFhirEligibilityResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseListEnumerator.GetCurrent : TFhirEligibilityResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseList }
procedure TFhirEligibilityResponseList.AddItem(value: TFhirEligibilityResponse);
begin
  assert(value.ClassName = 'TFhirEligibilityResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponse');
  add(value);
end;

function TFhirEligibilityResponseList.Append: TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseList.GetEnumerator : TFhirEligibilityResponseListEnumerator;
begin
  result := TFhirEligibilityResponseListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseList.Clone: TFhirEligibilityResponseList;
begin
  result := TFhirEligibilityResponseList(inherited Clone);
end;

function TFhirEligibilityResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseList.GetItemN(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponse;
end;
function TFhirEligibilityResponseList.IndexOf(value: TFhirEligibilityResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseList.Insert(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseList.InsertItem(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseList.Item(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseList.Link: TFhirEligibilityResponseList;
begin
  result := TFhirEligibilityResponseList(inherited Link);
end;

procedure TFhirEligibilityResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  FhirEligibilityResponses[index] := value;
end;

procedure TFhirEligibilityResponseList.SetItemN(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

{ TFhirEnrollmentRequest }

constructor TFhirEnrollmentRequest.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FInsurer.free;
  FProvider.free;
  FOrganization.free;
  FSubject.free;
  FCoverage.free;
  inherited;
end;

function TFhirEnrollmentRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentRequest;
end;

procedure TFhirEnrollmentRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentRequest(oSource).FIdentifierList);
  end;
  FStatus := TFhirEnrollmentRequest(oSource).FStatus.Link;
  createdElement := TFhirEnrollmentRequest(oSource).createdElement.Clone;
  insurer := TFhirEnrollmentRequest(oSource).insurer.Clone;
  provider := TFhirEnrollmentRequest(oSource).provider.Clone;
  organization := TFhirEnrollmentRequest(oSource).organization.Clone;
  subject := TFhirEnrollmentRequest(oSource).subject.Clone;
  coverage := TFhirEnrollmentRequest(oSource).coverage.Clone;
end;

procedure TFhirEnrollmentRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
end;

procedure TFhirEnrollmentRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
end;

function TFhirEnrollmentRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentRequest.fhirType : string;
begin
  result := 'EnrollmentRequest';
end;

function TFhirEnrollmentRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FSubject) and isEmptyProp(FCoverage);
end;

function TFhirEnrollmentRequest.equals(other : TObject) : boolean;
var
  o : TFhirEnrollmentRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentRequest)) then
    result := false
  else
  begin
    o := TFhirEnrollmentRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and
      compareDeep(providerElement, o.providerElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(coverageElement, o.coverageElement, true);
  end;
end;

function TFhirEnrollmentRequest.Link : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Link);
end;

function TFhirEnrollmentRequest.Clone : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Clone);
end;

procedure TFhirEnrollmentRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('insurer');
  fields.add('provider');
  fields.add('organization');
  fields.add('subject');
  fields.add('coverage');
end;

{ TFhirEnrollmentRequest }

Function TFhirEnrollmentRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEnrollmentRequest.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEnrollmentRequest.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEnrollmentRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentRequest.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirEnrollmentRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirEnrollmentRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEnrollmentRequest.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirEnrollmentRequest.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

function TFhirEnrollmentRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
end;

{ TFhirEnrollmentRequestListEnumerator }

Constructor TFhirEnrollmentRequestListEnumerator.Create(list : TFhirEnrollmentRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentRequestListEnumerator.GetCurrent : TFhirEnrollmentRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentRequestList }
procedure TFhirEnrollmentRequestList.AddItem(value: TFhirEnrollmentRequest);
begin
  assert(value.ClassName = 'TFhirEnrollmentRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentRequest');
  add(value);
end;

function TFhirEnrollmentRequestList.Append: TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentRequestList.GetEnumerator : TFhirEnrollmentRequestListEnumerator;
begin
  result := TFhirEnrollmentRequestListEnumerator.Create(self.link);
end;

function TFhirEnrollmentRequestList.Clone: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Clone);
end;

function TFhirEnrollmentRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentRequestList.GetItemN(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentRequest;
end;
function TFhirEnrollmentRequestList.IndexOf(value: TFhirEnrollmentRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentRequestList.Insert(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.InsertItem(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentRequestList.Item(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.Link: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Link);
end;

procedure TFhirEnrollmentRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentRequestList.SetItemByIndex(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  FhirEnrollmentRequests[index] := value;
end;

procedure TFhirEnrollmentRequestList.SetItemN(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

{ TFhirEnrollmentResponse }

constructor TFhirEnrollmentResponse.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  inherited;
end;

function TFhirEnrollmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentResponse;
end;

procedure TFhirEnrollmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirEnrollmentResponse(oSource).FStatus.Link;
  request := TFhirEnrollmentResponse(oSource).request.Clone;
  outcome := TFhirEnrollmentResponse(oSource).outcome.Clone;
  dispositionElement := TFhirEnrollmentResponse(oSource).dispositionElement.Clone;
  createdElement := TFhirEnrollmentResponse(oSource).createdElement.Clone;
  organization := TFhirEnrollmentResponse(oSource).organization.Clone;
  requestProvider := TFhirEnrollmentResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirEnrollmentResponse(oSource).requestOrganization.Clone;
end;

procedure TFhirEnrollmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
end;

procedure TFhirEnrollmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(EnrollmentRequest)', false, TFhirReference{TFhirEnrollmentRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
end;

function TFhirEnrollmentResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirEnrollmentRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirEnrollmentRequest}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirEnrollmentRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentResponse.fhirType : string;
begin
  result := 'EnrollmentResponse';
end;

function TFhirEnrollmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization);
end;

function TFhirEnrollmentResponse.equals(other : TObject) : boolean;
var
  o : TFhirEnrollmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentResponse)) then
    result := false
  else
  begin
    o := TFhirEnrollmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true) and
      compareDeep(requestOrganizationElement, o.requestOrganizationElement, true);
  end;
end;

function TFhirEnrollmentResponse.Link : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Link);
end;

function TFhirEnrollmentResponse.Clone : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Clone);
end;

procedure TFhirEnrollmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
end;

{ TFhirEnrollmentResponse }

Function TFhirEnrollmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEnrollmentResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEnrollmentResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEnrollmentResponse.SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirEnrollmentResponse.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirEnrollmentResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirEnrollmentResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirEnrollmentResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirEnrollmentResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEnrollmentResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirEnrollmentResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

function TFhirEnrollmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
end;

{ TFhirEnrollmentResponseListEnumerator }

Constructor TFhirEnrollmentResponseListEnumerator.Create(list : TFhirEnrollmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentResponseListEnumerator.GetCurrent : TFhirEnrollmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentResponseList }
procedure TFhirEnrollmentResponseList.AddItem(value: TFhirEnrollmentResponse);
begin
  assert(value.ClassName = 'TFhirEnrollmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentResponse');
  add(value);
end;

function TFhirEnrollmentResponseList.Append: TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentResponseList.GetEnumerator : TFhirEnrollmentResponseListEnumerator;
begin
  result := TFhirEnrollmentResponseListEnumerator.Create(self.link);
end;

function TFhirEnrollmentResponseList.Clone: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Clone);
end;

function TFhirEnrollmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentResponseList.GetItemN(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentResponse;
end;
function TFhirEnrollmentResponseList.IndexOf(value: TFhirEnrollmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentResponseList.Insert(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.InsertItem(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentResponseList.Item(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.Link: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Link);
end;

procedure TFhirEnrollmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentResponseList.SetItemByIndex(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  FhirEnrollmentResponses[index] := value;
end;

procedure TFhirEnrollmentResponseList.SetItemN(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

{ TFhirExplanationOfBenefitRelated }

constructor TFhirExplanationOfBenefitRelated.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirExplanationOfBenefitRelated(oSource).claim.Clone;
  relationship := TFhirExplanationOfBenefitRelated(oSource).relationship.Clone;
  reference := TFhirExplanationOfBenefitRelated(oSource).reference.Clone;
end;

procedure TFhirExplanationOfBenefitRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirExplanationOfBenefitRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));{2}
end;

function TFhirExplanationOfBenefitRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirExplanationOfBenefitRelated.Link : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Link);
end;

function TFhirExplanationOfBenefitRelated.Clone : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Clone);
end;

function TFhirExplanationOfBenefitRelated.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitRelated)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirExplanationOfBenefitRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirExplanationOfBenefitRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

{ TFhirExplanationOfBenefitRelated }

Procedure TFhirExplanationOfBenefitRelated.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirExplanationOfBenefitRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirExplanationOfBenefitRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

function TFhirExplanationOfBenefitRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedListEnumerator }

Constructor TFhirExplanationOfBenefitRelatedListEnumerator.Create(list : TFhirExplanationOfBenefitRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.GetCurrent : TFhirExplanationOfBenefitRelated;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedList }
procedure TFhirExplanationOfBenefitRelatedList.AddItem(value: TFhirExplanationOfBenefitRelated);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitRelated');
  add(value);
end;

function TFhirExplanationOfBenefitRelatedList.Append: TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitRelatedList.GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
begin
  result := TFhirExplanationOfBenefitRelatedListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitRelatedList.Clone: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Clone);
end;

function TFhirExplanationOfBenefitRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitRelatedList.GetItemN(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitRelated;
end;
function TFhirExplanationOfBenefitRelatedList.IndexOf(value: TFhirExplanationOfBenefitRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitRelatedList.Insert(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitRelatedList.Item(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.Link: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Link);
end;

procedure TFhirExplanationOfBenefitRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  FhirExplanationOfBenefitRelateds[index] := value;
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayee }

constructor TFhirExplanationOfBenefitPayee.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayee.Destroy;
begin
  FType_.free;
  FResourceType.free;
  FParty.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayee(oSource).type_.Clone;
  resourceType := TFhirExplanationOfBenefitPayee(oSource).resourceType.Clone;
  party := TFhirExplanationOfBenefitPayee(oSource).party.Clone;
end;

procedure TFhirExplanationOfBenefitPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resourceType') Then
     list.add(self.link, 'resourceType', FResourceType.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirExplanationOfBenefitPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resourceType', 'CodeableConcept', false, TFhirCodeableConcept, FResourceType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FParty.Link));{2}
end;

function TFhirExplanationOfBenefitPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'resourceType') then
  begin
    ResourceType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'resourceType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'resourceType') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resourceType') then ResourceTypeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'resourceType') then ResourceTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayee.fhirType : string;
begin
  result := 'payee';
end;

function TFhirExplanationOfBenefitPayee.Link : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Link);
end;

function TFhirExplanationOfBenefitPayee.Clone : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Clone);
end;

function TFhirExplanationOfBenefitPayee.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayee)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceTypeElement, o.resourceTypeElement, true) and
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResourceType) and isEmptyProp(FParty);
end;

procedure TFhirExplanationOfBenefitPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resourceType');
  fields.add('party');
end;

{ TFhirExplanationOfBenefitPayee }

Procedure TFhirExplanationOfBenefitPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitPayee.SetResourceType(value : TFhirCodeableConcept);
begin
  FResourceType.free;
  FResourceType := value;
end;

Procedure TFhirExplanationOfBenefitPayee.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

function TFhirExplanationOfBenefitPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResourceType.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeListEnumerator }

Constructor TFhirExplanationOfBenefitPayeeListEnumerator.Create(list : TFhirExplanationOfBenefitPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayee;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeList }
procedure TFhirExplanationOfBenefitPayeeList.AddItem(value: TFhirExplanationOfBenefitPayee);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayee');
  add(value);
end;

function TFhirExplanationOfBenefitPayeeList.Append: TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPayeeList.GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
begin
  result := TFhirExplanationOfBenefitPayeeListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPayeeList.Clone: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Clone);
end;

function TFhirExplanationOfBenefitPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPayeeList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayee;
end;
function TFhirExplanationOfBenefitPayeeList.IndexOf(value: TFhirExplanationOfBenefitPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPayeeList.Insert(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPayeeList.Item(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.Link: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  FhirExplanationOfBenefitPayees[index] := value;
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitInformation }

constructor TFhirExplanationOfBenefitInformation.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitInformation.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitInformation.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitInformation(oSource).sequenceElement.Clone;
  category := TFhirExplanationOfBenefitInformation(oSource).category.Clone;
  code := TFhirExplanationOfBenefitInformation(oSource).code.Clone;
  timing := TFhirExplanationOfBenefitInformation(oSource).timing.Clone;
  value := TFhirExplanationOfBenefitInformation(oSource).value.Clone;
  reason := TFhirExplanationOfBenefitInformation(oSource).reason.Clone;
end;

procedure TFhirExplanationOfBenefitInformation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirExplanationOfBenefitInformation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|Quantity|Attachment|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', false, TFhirCoding, FReason.Link));{2}
end;

function TFhirExplanationOfBenefitInformation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitInformation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitInformation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'reason') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitInformation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitInformation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil{4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitInformation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'value', ['String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'reason') then ReasonElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitInformation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitInformation.fhirType : string;
begin
  result := 'information';
end;

function TFhirExplanationOfBenefitInformation.Link : TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation(inherited Link);
end;

function TFhirExplanationOfBenefitInformation.Clone : TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation(inherited Clone);
end;

function TFhirExplanationOfBenefitInformation.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitInformation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitInformation)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitInformation(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirExplanationOfBenefitInformation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirExplanationOfBenefitInformation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

{ TFhirExplanationOfBenefitInformation }

Procedure TFhirExplanationOfBenefitInformation.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitInformation.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitInformation.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitInformation.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitInformation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirExplanationOfBenefitInformation.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirExplanationOfBenefitInformation.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirExplanationOfBenefitInformation.SetReason(value : TFhirCoding);
begin
  FReason.free;
  FReason := value;
end;

function TFhirExplanationOfBenefitInformation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInformationListEnumerator }

Constructor TFhirExplanationOfBenefitInformationListEnumerator.Create(list : TFhirExplanationOfBenefitInformationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitInformationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitInformationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitInformationListEnumerator.GetCurrent : TFhirExplanationOfBenefitInformation;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitInformationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInformationList }
procedure TFhirExplanationOfBenefitInformationList.AddItem(value: TFhirExplanationOfBenefitInformation);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitInformation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitInformation');
  add(value);
end;

function TFhirExplanationOfBenefitInformationList.Append: TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInformationList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitInformationList.GetEnumerator : TFhirExplanationOfBenefitInformationListEnumerator;
begin
  result := TFhirExplanationOfBenefitInformationListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitInformationList.Clone: TFhirExplanationOfBenefitInformationList;
begin
  result := TFhirExplanationOfBenefitInformationList(inherited Clone);
end;

function TFhirExplanationOfBenefitInformationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitInformationList.GetItemN(index: Integer): TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInformationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitInformation;
end;
function TFhirExplanationOfBenefitInformationList.IndexOf(value: TFhirExplanationOfBenefitInformation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitInformationList.Insert(index: Integer): TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInformationList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitInformation);
begin
  assert(value is TFhirExplanationOfBenefitInformation);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitInformationList.Item(index: Integer): TFhirExplanationOfBenefitInformation;
begin
  result := TFhirExplanationOfBenefitInformation(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInformationList.Link: TFhirExplanationOfBenefitInformationList;
begin
  result := TFhirExplanationOfBenefitInformationList(inherited Link);
end;

procedure TFhirExplanationOfBenefitInformationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitInformationList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitInformation);
begin
  assert(value is TFhirExplanationOfBenefitInformation);
  FhirExplanationOfBenefitInformations[index] := value;
end;

procedure TFhirExplanationOfBenefitInformationList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitInformation);
begin
  assert(value is TFhirExplanationOfBenefitInformation);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitCareTeam }

constructor TFhirExplanationOfBenefitCareTeam.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirExplanationOfBenefitCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirExplanationOfBenefitCareTeam(oSource).responsibleElement.Clone;
  role := TFhirExplanationOfBenefitCareTeam(oSource).role.Clone;
  qualification := TFhirExplanationOfBenefitCareTeam(oSource).qualification.Clone;
end;

procedure TFhirExplanationOfBenefitCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirExplanationOfBenefitCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));{2}
end;

function TFhirExplanationOfBenefitCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new){5b}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitCareTeam.fhirType : string;
begin
  result := 'careTeam';
end;

function TFhirExplanationOfBenefitCareTeam.Link : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Link);
end;

function TFhirExplanationOfBenefitCareTeam.Clone : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeam.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitCareTeam)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirExplanationOfBenefitCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirExplanationOfBenefitCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

{ TFhirExplanationOfBenefitCareTeam }

Procedure TFhirExplanationOfBenefitCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetProvider(value : TFhirReference{Resource});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirExplanationOfBenefitCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

function TFhirExplanationOfBenefitCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamListEnumerator }

Constructor TFhirExplanationOfBenefitCareTeamListEnumerator.Create(list : TFhirExplanationOfBenefitCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.GetCurrent : TFhirExplanationOfBenefitCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamList }
procedure TFhirExplanationOfBenefitCareTeamList.AddItem(value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitCareTeam');
  add(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Append: TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitCareTeamList.GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
begin
  result := TFhirExplanationOfBenefitCareTeamListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitCareTeamList.Clone: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitCareTeamList.GetItemN(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitCareTeam;
end;
function TFhirExplanationOfBenefitCareTeamList.IndexOf(value: TFhirExplanationOfBenefitCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Insert(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitCareTeamList.Item(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.Link: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Link);
end;

procedure TFhirExplanationOfBenefitCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  FhirExplanationOfBenefitCareTeams[index] := value;
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitDiagnosis }

constructor TFhirExplanationOfBenefitDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirExplanationOfBenefitDiagnosis(oSource).diagnosis.Clone;
  if (TFhirExplanationOfBenefitDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitDiagnosis(oSource).FType_List);
  end;
  packageCode := TFhirExplanationOfBenefitDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirExplanationOfBenefitDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirExplanationOfBenefitDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FDiagnosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));{2}
end;

function TFhirExplanationOfBenefitDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis'){4x}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil{4x}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirType{4x}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirExplanationOfBenefitDiagnosis.Link : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Link);
end;

function TFhirExplanationOfBenefitDiagnosis.Clone : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosis.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitDiagnosis)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and
      compareDeep(type_List, o.type_List, true) and compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirExplanationOfBenefitDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FPackageCode);
end;

procedure TFhirExplanationOfBenefitDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('packageCode');
end;

{ TFhirExplanationOfBenefitDiagnosis }

Procedure TFhirExplanationOfBenefitDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetDiagnosis(value : TFhirType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

function TFhirExplanationOfBenefitDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisListEnumerator }

Constructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(list : TFhirExplanationOfBenefitDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.GetCurrent : TFhirExplanationOfBenefitDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisList }
procedure TFhirExplanationOfBenefitDiagnosisList.AddItem(value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitDiagnosis');
  add(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Append: TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
begin
  result := TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitDiagnosisList.Clone: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetItemN(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitDiagnosis;
end;
function TFhirExplanationOfBenefitDiagnosisList.IndexOf(value: TFhirExplanationOfBenefitDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Insert(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Item(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.Link: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Link);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  FhirExplanationOfBenefitDiagnoses[index] := value;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcedure }

constructor TFhirExplanationOfBenefitProcedure.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcedure.Destroy;
begin
  FSequence.free;
  FDate.free;
  FProcedure_.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitProcedure(oSource).sequenceElement.Clone;
  dateElement := TFhirExplanationOfBenefitProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirExplanationOfBenefitProcedure(oSource).procedure_.Clone;
end;

procedure TFhirExplanationOfBenefitProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
end;

procedure TFhirExplanationOfBenefitProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference(Procedure)', false, TFhirType, FProcedure_.Link));{2}
end;

function TFhirExplanationOfBenefitProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcedure.fhirType : string;
begin
  result := 'procedure';
end;

function TFhirExplanationOfBenefitProcedure.Link : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Link);
end;

function TFhirExplanationOfBenefitProcedure.Clone : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedure.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcedure)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(procedure_Element, o.procedure_Element, true);
  end;
end;

function TFhirExplanationOfBenefitProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDate) and isEmptyProp(FProcedure_);
end;

procedure TFhirExplanationOfBenefitProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('date');
  fields.add('procedure[x]');
end;

{ TFhirExplanationOfBenefitProcedure }

Procedure TFhirExplanationOfBenefitProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitProcedure.SetProcedure_(value : TFhirType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirExplanationOfBenefitProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureListEnumerator }

Constructor TFhirExplanationOfBenefitProcedureListEnumerator.Create(list : TFhirExplanationOfBenefitProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureList }
procedure TFhirExplanationOfBenefitProcedureList.AddItem(value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcedure');
  add(value);
end;

function TFhirExplanationOfBenefitProcedureList.Append: TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcedureList.GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcedureListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcedureList.Clone: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcedureList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcedure;
end;
function TFhirExplanationOfBenefitProcedureList.IndexOf(value: TFhirExplanationOfBenefitProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcedureList.Insert(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcedureList.Item(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.Link: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  FhirExplanationOfBenefitProcedures[index] := value;
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitInsurance }

constructor TFhirExplanationOfBenefitInsurance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitInsurance.Destroy;
begin
  FCoverage.free;
  FPreAuthRefList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirExplanationOfBenefitInsurance(oSource).coverage.Clone;
  if (TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList);
  end;
end;

procedure TFhirExplanationOfBenefitInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
end;

function TFhirExplanationOfBenefitInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirExplanationOfBenefitInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'preAuthRef') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirExplanationOfBenefitInsurance.Link : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Link);
end;

function TFhirExplanationOfBenefitInsurance.Clone : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Clone);
end;

function TFhirExplanationOfBenefitInsurance.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitInsurance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitInsurance(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true);
  end;
end;

function TFhirExplanationOfBenefitInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FpreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('preAuthRef');
end;

{ TFhirExplanationOfBenefitInsurance }

Procedure TFhirExplanationOfBenefitInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Function TFhirExplanationOfBenefitInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirExplanationOfBenefitInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

function TFhirExplanationOfBenefitInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceListEnumerator }

Constructor TFhirExplanationOfBenefitInsuranceListEnumerator.Create(list : TFhirExplanationOfBenefitInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.GetCurrent : TFhirExplanationOfBenefitInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceList }
procedure TFhirExplanationOfBenefitInsuranceList.AddItem(value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitInsurance');
  add(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Append: TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitInsuranceList.GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
begin
  result := TFhirExplanationOfBenefitInsuranceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitInsuranceList.Clone: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Clone);
end;

function TFhirExplanationOfBenefitInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitInsuranceList.GetItemN(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitInsurance;
end;
function TFhirExplanationOfBenefitInsuranceList.IndexOf(value: TFhirExplanationOfBenefitInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Insert(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitInsuranceList.Item(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.Link: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  FhirExplanationOfBenefitInsurances[index] := value;
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAccident }

constructor TFhirExplanationOfBenefitAccident.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirExplanationOfBenefitAccident(oSource).dateElement.Clone;
  type_ := TFhirExplanationOfBenefitAccident(oSource).type_.Clone;
  location := TFhirExplanationOfBenefitAccident(oSource).location.Clone;
end;

procedure TFhirExplanationOfBenefitAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirExplanationOfBenefitAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
end;

function TFhirExplanationOfBenefitAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAccident.fhirType : string;
begin
  result := 'accident';
end;

function TFhirExplanationOfBenefitAccident.Link : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Link);
end;

function TFhirExplanationOfBenefitAccident.Clone : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Clone);
end;

function TFhirExplanationOfBenefitAccident.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAccident)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirExplanationOfBenefitAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirExplanationOfBenefitAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

{ TFhirExplanationOfBenefitAccident }

Procedure TFhirExplanationOfBenefitAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitAccident.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirExplanationOfBenefitAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentListEnumerator }

Constructor TFhirExplanationOfBenefitAccidentListEnumerator.Create(list : TFhirExplanationOfBenefitAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.GetCurrent : TFhirExplanationOfBenefitAccident;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentList }
procedure TFhirExplanationOfBenefitAccidentList.AddItem(value: TFhirExplanationOfBenefitAccident);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAccident');
  add(value);
end;

function TFhirExplanationOfBenefitAccidentList.Append: TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAccidentList.GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
begin
  result := TFhirExplanationOfBenefitAccidentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAccidentList.Clone: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Clone);
end;

function TFhirExplanationOfBenefitAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAccidentList.GetItemN(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAccident;
end;
function TFhirExplanationOfBenefitAccidentList.IndexOf(value: TFhirExplanationOfBenefitAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAccidentList.Insert(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAccidentList.Item(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.Link: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  FhirExplanationOfBenefitAccidents[index] := value;
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItem }

constructor TFhirExplanationOfBenefitItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItem.Destroy;
begin
  FSequence.free;
  FCareTeamLinkIdList.Free;
  FDiagnosisLinkIdList.Free;
  FProcedureLinkIdList.Free;
  FInformationLinkIdList.Free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItem(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FCareTeamLinkIdList = nil) then
  begin
    FCareTeamLinkIdList.free;
    FCareTeamLinkIdList := nil;
  end
  else
  begin
    if FCareTeamLinkIdList = nil then
      FCareTeamLinkIdList := TFhirPositiveIntList.Create;
    FCareTeamLinkIdList.Assign(TFhirExplanationOfBenefitItem(oSource).FCareTeamLinkIdList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDiagnosisLinkIdList = nil) then
  begin
    FDiagnosisLinkIdList.free;
    FDiagnosisLinkIdList := nil;
  end
  else
  begin
    if FDiagnosisLinkIdList = nil then
      FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
    FDiagnosisLinkIdList.Assign(TFhirExplanationOfBenefitItem(oSource).FDiagnosisLinkIdList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProcedureLinkIdList = nil) then
  begin
    FProcedureLinkIdList.free;
    FProcedureLinkIdList := nil;
  end
  else
  begin
    if FProcedureLinkIdList = nil then
      FProcedureLinkIdList := TFhirPositiveIntList.Create;
    FProcedureLinkIdList.Assign(TFhirExplanationOfBenefitItem(oSource).FProcedureLinkIdList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FInformationLinkIdList = nil) then
  begin
    FInformationLinkIdList.free;
    FInformationLinkIdList := nil;
  end
  else
  begin
    if FInformationLinkIdList = nil then
      FInformationLinkIdList := TFhirPositiveIntList.Create;
    FInformationLinkIdList.Assign(TFhirExplanationOfBenefitItem(oSource).FInformationLinkIdList);
  end;
  revenue := TFhirExplanationOfBenefitItem(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItem(oSource).category.Clone;
  service := TFhirExplanationOfBenefitItem(oSource).service.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItem(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItem(oSource).FUdiList);
  end;
  bodySite := TFhirExplanationOfBenefitItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
    FEncounterList.Assign(TFhirExplanationOfBenefitItem(oSource).FEncounterList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamLinkId') Then
    list.addAll(self, 'careTeamLinkId', FCareTeamLinkIdList);
  if (child_name = 'diagnosisLinkId') Then
    list.addAll(self, 'diagnosisLinkId', FDiagnosisLinkIdList);
  if (child_name = 'procedureLinkId') Then
    list.addAll(self, 'procedureLinkId', FProcedureLinkIdList);
  if (child_name = 'informationLinkId') Then
    list.addAll(self, 'informationLinkId', FInformationLinkIdList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeamLinkId', 'positiveInt', true, TFhirPositiveInt, FCareTeamLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosisLinkId', 'positiveInt', true, TFhirPositiveInt, FDiagnosisLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedureLinkId', 'positiveInt', true, TFhirPositiveInt, FProcedureLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'informationLinkId', 'positiveInt', true, TFhirPositiveInt, FInformationLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', true, TFhirReference{TFhirEncounter}, FEncounterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirExplanationOfBenefitItemDetail, FDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'careTeamLinkId') then
  begin
    CareTeamLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisLinkId') then
  begin
    DiagnosisLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureLinkId') then
  begin
    ProcedureLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationLinkId') then
  begin
    InformationLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference{TFhirEncounter}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamLinkId') then CareTeamLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'procedureLinkId') then ProcedureLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'informationLinkId') then InformationLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference{TFhirEncounter}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'careTeamLinkId') then result := CareTeamLinkIdList.new(){2}
  else if (propName = 'diagnosisLinkId') then result := DiagnosisLinkIdList.new(){2}
  else if (propName = 'procedureLinkId') then result := ProcedureLinkIdList.new(){2}
  else if (propName = 'informationLinkId') then result := InformationLinkIdList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'encounter') then result := EncounterList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamLinkId') then result := 'positiveInt'
  else if (propName = 'diagnosisLinkId') then result := 'positiveInt'
  else if (propName = 'procedureLinkId') then result := 'positiveInt'
  else if (propName = 'informationLinkId') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamLinkId') then deletePropertyValue('careTeamLinkId', CareTeamLinkIdList, value) {2}
  else if (propName = 'diagnosisLinkId') then deletePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, value) {2}
  else if (propName = 'procedureLinkId') then deletePropertyValue('procedureLinkId', ProcedureLinkIdList, value) {2}
  else if (propName = 'informationLinkId') then deletePropertyValue('informationLinkId', InformationLinkIdList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'careTeamLinkId') then replacePropertyValue('careTeamLinkId', CareTeamLinkIdList, existing, new) {2}
  else if (propName = 'diagnosisLinkId') then replacePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, existing, new) {2}
  else if (propName = 'procedureLinkId') then replacePropertyValue('procedureLinkId', ProcedureLinkIdList, existing, new) {2}
  else if (propName = 'informationLinkId') then replacePropertyValue('informationLinkId', InformationLinkIdList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamLinkId') then CareTeamLinkIdList.move(source, destination){2}
  else if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.move(source, destination){2}
  else if (propName = 'procedureLinkId') then ProcedureLinkIdList.move(source, destination){2}
  else if (propName = 'informationLinkId') then InformationLinkIdList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'encounter') then EncounterList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirExplanationOfBenefitItem.Link : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Link);
end;

function TFhirExplanationOfBenefitItem.Clone : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Clone);
end;

function TFhirExplanationOfBenefitItem.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamLinkIdList, o.careTeamLinkIdList, true) and
      compareDeep(diagnosisLinkIdList, o.diagnosisLinkIdList, true) and compareDeep(procedureLinkIdList, o.procedureLinkIdList, true) and
      compareDeep(informationLinkIdList, o.informationLinkIdList, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamLinkIdList) and isEmptyProp(FdiagnosisLinkIdList) and isEmptyProp(FprocedureLinkIdList) and isEmptyProp(FinformationLinkIdList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamLinkId');
  fields.add('diagnosisLinkId');
  fields.add('procedureLinkId');
  fields.add('informationLinkId');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirExplanationOfBenefitItem }

Procedure TFhirExplanationOfBenefitItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirExplanationOfBenefitItem.GetCareTeamLinkIdList : TFhirPositiveIntList;
begin
  if FCareTeamLinkIdList = nil then
    FCareTeamLinkIdList := TFhirPositiveIntList.Create;
  result := FCareTeamLinkIdList;
end;

Function TFhirExplanationOfBenefitItem.GetHasCareTeamLinkIdList : boolean;
begin
  result := (FCareTeamLinkIdList <> nil) and (FCareTeamLinkIdList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetDiagnosisLinkIdList : TFhirPositiveIntList;
begin
  if FDiagnosisLinkIdList = nil then
    FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
  result := FDiagnosisLinkIdList;
end;

Function TFhirExplanationOfBenefitItem.GetHasDiagnosisLinkIdList : boolean;
begin
  result := (FDiagnosisLinkIdList <> nil) and (FDiagnosisLinkIdList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetProcedureLinkIdList : TFhirPositiveIntList;
begin
  if FProcedureLinkIdList = nil then
    FProcedureLinkIdList := TFhirPositiveIntList.Create;
  result := FProcedureLinkIdList;
end;

Function TFhirExplanationOfBenefitItem.GetHasProcedureLinkIdList : boolean;
begin
  result := (FProcedureLinkIdList <> nil) and (FProcedureLinkIdList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetInformationLinkIdList : TFhirPositiveIntList;
begin
  if FInformationLinkIdList = nil then
    FInformationLinkIdList := TFhirPositiveIntList.Create;
  result := FInformationLinkIdList;
end;

Function TFhirExplanationOfBenefitItem.GetHasInformationLinkIdList : boolean;
begin
  result := (FInformationLinkIdList <> nil) and (FInformationLinkIdList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirExplanationOfBenefitItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItem.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirExplanationOfBenefitItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirExplanationOfBenefitItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetEncounterList : TFhirReferenceList{TFhirEncounter};
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
  result := FEncounterList;
end;

Function TFhirExplanationOfBenefitItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetDetailList : TFhirExplanationOfBenefitItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirExplanationOfBenefitItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirExplanationOfBenefitItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamLinkIdList.sizeInBytes);
  inc(result, FdiagnosisLinkIdList.sizeInBytes);
  inc(result, FprocedureLinkIdList.sizeInBytes);
  inc(result, FinformationLinkIdList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemListEnumerator }

Constructor TFhirExplanationOfBenefitItemListEnumerator.Create(list : TFhirExplanationOfBenefitItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemList }
procedure TFhirExplanationOfBenefitItemList.AddItem(value: TFhirExplanationOfBenefitItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItem');
  add(value);
end;

function TFhirExplanationOfBenefitItemList.Append: TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemList.GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemList.Clone: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItem;
end;
function TFhirExplanationOfBenefitItemList.IndexOf(value: TFhirExplanationOfBenefitItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemList.Insert(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemList.Item(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.Link: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  FhirExplanationOfBenefitItems[index] := value;
end;

procedure TFhirExplanationOfBenefitItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemAdjudication }

constructor TFhirExplanationOfBenefitItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitItemAdjudication(oSource).category.Clone;
  reason := TFhirExplanationOfBenefitItemAdjudication(oSource).reason.Clone;
  amount := TFhirExplanationOfBenefitItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirExplanationOfBenefitItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirExplanationOfBenefitItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirExplanationOfBenefitItemAdjudication.Link : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Link);
end;

function TFhirExplanationOfBenefitItemAdjudication.Clone : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirExplanationOfBenefitItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirExplanationOfBenefitItemAdjudication }

Procedure TFhirExplanationOfBenefitItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirExplanationOfBenefitItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirExplanationOfBenefitItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationListEnumerator }

Constructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationList }
procedure TFhirExplanationOfBenefitItemAdjudicationList.AddItem(value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemAdjudication');
  add(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Append: TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Clone: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemAdjudication;
end;
function TFhirExplanationOfBenefitItemAdjudicationList.IndexOf(value: TFhirExplanationOfBenefitItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Insert(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Item(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Link: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  FhirExplanationOfBenefitItemAdjudications[index] := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetail }

constructor TFhirExplanationOfBenefitItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetail.Destroy;
begin
  FSequence.free;
  FType_.free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetail(oSource).sequenceElement.Clone;
  type_ := TFhirExplanationOfBenefitItemDetail(oSource).type_.Clone;
  revenue := TFhirExplanationOfBenefitItemDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetail(oSource).category.Clone;
  service := TFhirExplanationOfBenefitItemDetail(oSource).service.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirExplanationOfBenefitItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirExplanationOfBenefitItemDetail.Link : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetail.Clone : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(revenueElement, o.revenueElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(modifierList, o.modifierList, true) and
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(netElement, o.netElement, true) and compareDeep(udiList, o.udiList, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FType_) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirExplanationOfBenefitItemDetail }

Procedure TFhirExplanationOfBenefitItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailListEnumerator }

Constructor TFhirExplanationOfBenefitItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailList }
procedure TFhirExplanationOfBenefitItemDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Append: TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailList.Clone: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetail;
end;
function TFhirExplanationOfBenefitItemDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.Link: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  FhirExplanationOfBenefitItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

constructor TFhirExplanationOfBenefitItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FType_.free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).sequenceElement.Clone;
  type_ := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).type_.Clone;
  revenue := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).category.Clone;
  service := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).service.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Link : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Clone : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(revenueElement, o.revenueElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(modifierList, o.modifierList, true) and
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(netElement, o.netElement, true) and compareDeep(udiList, o.udiList, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FType_) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator }

Constructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailList }
procedure TFhirExplanationOfBenefitItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Append: TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Link: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  FhirExplanationOfBenefitItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItem }

constructor TFhirExplanationOfBenefitAddItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItem.Destroy;
begin
  FSequenceLinkIdList.Free;
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FFee.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSequenceLinkIdList = nil) then
  begin
    FSequenceLinkIdList.free;
    FSequenceLinkIdList := nil;
  end
  else
  begin
    if FSequenceLinkIdList = nil then
      FSequenceLinkIdList := TFhirPositiveIntList.Create;
    FSequenceLinkIdList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSequenceLinkIdList);
  end;
  revenue := TFhirExplanationOfBenefitAddItem(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitAddItem(oSource).category.Clone;
  service := TFhirExplanationOfBenefitAddItem(oSource).service.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FModifierList);
  end;
  fee := TFhirExplanationOfBenefitAddItem(oSource).fee.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
    list.addAll(self, 'sequenceLinkId', FSequenceLinkIdList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', true, TFhirPositiveInt, FSequenceLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fee', 'Money', false, TFhirMoney, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirExplanationOfBenefitAddItemDetail, FDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := SequenceLinkIdList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'fee') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'fee') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then deletePropertyValue('sequenceLinkId', SequenceLinkIdList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then replacePropertyValue('sequenceLinkId', SequenceLinkIdList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'fee') then FeeElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItem.fhirType : string;
begin
  result := 'addItem';
end;

function TFhirExplanationOfBenefitAddItem.Link : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Link);
end;

function TFhirExplanationOfBenefitAddItem.Clone : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItem.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItem(other);
    result := compareDeep(sequenceLinkIdList, o.sequenceLinkIdList, true) and compareDeep(revenueElement, o.revenueElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(feeElement, o.feeElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsequenceLinkIdList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FFee) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('fee');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirExplanationOfBenefitAddItem }

Function TFhirExplanationOfBenefitAddItem.GetSequenceLinkIdList : TFhirPositiveIntList;
begin
  if FSequenceLinkIdList = nil then
    FSequenceLinkIdList := TFhirPositiveIntList.Create;
  result := FSequenceLinkIdList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasSequenceLinkIdList : boolean;
begin
  result := (FSequenceLinkIdList <> nil) and (FSequenceLinkIdList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirExplanationOfBenefitAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItem.SetFee(value : TFhirMoney);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirExplanationOfBenefitAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsequenceLinkIdList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemListEnumerator }

Constructor TFhirExplanationOfBenefitAddItemListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemList }
procedure TFhirExplanationOfBenefitAddItemList.AddItem(value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItem');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemList.Append: TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemList.GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemList.Clone: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItem;
end;
function TFhirExplanationOfBenefitAddItemList.IndexOf(value: TFhirExplanationOfBenefitAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemList.Insert(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemList.Item(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.Link: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  FhirExplanationOfBenefitAddItems[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetail }

constructor TFhirExplanationOfBenefitAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetail.Destroy;
begin
  FRevenue.free;
  FCategory.free;
  FService.free;
  FModifierList.Free;
  FFee.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  revenue := TFhirExplanationOfBenefitAddItemDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitAddItemDetail(oSource).category.Clone;
  service := TFhirExplanationOfBenefitAddItemDetail(oSource).service.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList);
  end;
  fee := TFhirExplanationOfBenefitAddItemDetail(oSource).fee.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', false, TFhirCodeableConcept, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fee', 'Money', false, TFhirMoney, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirExplanationOfBenefitAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'service') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'fee') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'fee') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'fee') then FeeElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirExplanationOfBenefitAddItemDetail.Link : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetail.Clone : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetail(other);
    result := compareDeep(revenueElement, o.revenueElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(modifierList, o.modifierList, true) and
      compareDeep(feeElement, o.feeElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FService) and isEmptyProp(FmodifierList) and isEmptyProp(FFee) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('revenue');
  fields.add('category');
  fields.add('service');
  fields.add('modifier');
  fields.add('fee');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirExplanationOfBenefitAddItemDetail }

Procedure TFhirExplanationOfBenefitAddItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetService(value : TFhirCodeableConcept);
begin
  FService.free;
  FService := value;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetFee(value : TFhirMoney);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailListEnumerator }

Constructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailList }
procedure TFhirExplanationOfBenefitAddItemDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Append: TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Link: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  FhirExplanationOfBenefitAddItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayment }

constructor TFhirExplanationOfBenefitPayment.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayment(oSource).type_.Clone;
  adjustment := TFhirExplanationOfBenefitPayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirExplanationOfBenefitPayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirExplanationOfBenefitPayment(oSource).dateElement.Clone;
  amount := TFhirExplanationOfBenefitPayment(oSource).amount.Clone;
  identifier := TFhirExplanationOfBenefitPayment(oSource).identifier.Clone;
end;

procedure TFhirExplanationOfBenefitPayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirExplanationOfBenefitPayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
end;

function TFhirExplanationOfBenefitPayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'adjustment') then result := TFhirMoney.create(){4b}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney{4}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayment.fhirType : string;
begin
  result := 'payment';
end;

function TFhirExplanationOfBenefitPayment.Link : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Link);
end;

function TFhirExplanationOfBenefitPayment.Clone : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Clone);
end;

function TFhirExplanationOfBenefitPayment.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitPayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayment)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirExplanationOfBenefitPayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

{ TFhirExplanationOfBenefitPayment }

Procedure TFhirExplanationOfBenefitPayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitPayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitPayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirExplanationOfBenefitPayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentListEnumerator }

Constructor TFhirExplanationOfBenefitPaymentListEnumerator.Create(list : TFhirExplanationOfBenefitPaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayment;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentList }
procedure TFhirExplanationOfBenefitPaymentList.AddItem(value: TFhirExplanationOfBenefitPayment);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayment');
  add(value);
end;

function TFhirExplanationOfBenefitPaymentList.Append: TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPaymentList.GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
begin
  result := TFhirExplanationOfBenefitPaymentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPaymentList.Clone: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Clone);
end;

function TFhirExplanationOfBenefitPaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPaymentList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayment;
end;
function TFhirExplanationOfBenefitPaymentList.IndexOf(value: TFhirExplanationOfBenefitPayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPaymentList.Insert(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPaymentList.Item(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.Link: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  FhirExplanationOfBenefitPayments[index] := value;
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcessNote }

constructor TFhirExplanationOfBenefitProcessNote.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirExplanationOfBenefitProcessNote(oSource).numberElement.Clone;
  type_ := TFhirExplanationOfBenefitProcessNote(oSource).type_.Clone;
  textElement := TFhirExplanationOfBenefitProcessNote(oSource).textElement.Clone;
  language := TFhirExplanationOfBenefitProcessNote(oSource).language.Clone;
end;

procedure TFhirExplanationOfBenefitProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirExplanationOfBenefitProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
end;

function TFhirExplanationOfBenefitProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirExplanationOfBenefitProcessNote.Link : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Link);
end;

function TFhirExplanationOfBenefitProcessNote.Clone : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNote.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcessNote)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirExplanationOfBenefitProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirExplanationOfBenefitProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

{ TFhirExplanationOfBenefitProcessNote }

Procedure TFhirExplanationOfBenefitProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirExplanationOfBenefitProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirExplanationOfBenefitProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirExplanationOfBenefitProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteListEnumerator }

Constructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(list : TFhirExplanationOfBenefitProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteList }
procedure TFhirExplanationOfBenefitProcessNoteList.AddItem(value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcessNote');
  add(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Append: TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcessNoteList.Clone: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcessNote;
end;
function TFhirExplanationOfBenefitProcessNoteList.IndexOf(value: TFhirExplanationOfBenefitProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Insert(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Item(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.Link: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  FhirExplanationOfBenefitProcessNotes[index] := value;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalance }

constructor TFhirExplanationOfBenefitBenefitBalance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalance.Destroy;
begin
  FCategory.free;
  FSubCategory.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FFinancialList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitBenefitBalance(oSource).category.Clone;
  subCategory := TFhirExplanationOfBenefitBenefitBalance(oSource).subCategory.Clone;
  excludedElement := TFhirExplanationOfBenefitBenefitBalance(oSource).excludedElement.Clone;
  nameElement := TFhirExplanationOfBenefitBenefitBalance(oSource).nameElement.Clone;
  descriptionElement := TFhirExplanationOfBenefitBenefitBalance(oSource).descriptionElement.Clone;
  network := TFhirExplanationOfBenefitBenefitBalance(oSource).network.Clone;
  unit_ := TFhirExplanationOfBenefitBenefitBalance(oSource).unit_.Clone;
  term := TFhirExplanationOfBenefitBenefitBalance(oSource).term.Clone;
  if (TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList = nil) then
  begin
    FFinancialList.free;
    FFinancialList := nil;
  end
  else
  begin
    if FFinancialList = nil then
      FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
    FFinancialList.Assign(TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList);
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'subCategory') Then
     list.add(self.link, 'subCategory', FSubCategory.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'financial') Then
    list.addAll(self, 'financial', FFinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subCategory', 'CodeableConcept', false, TFhirCodeableConcept, FSubCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'financial', '', true, TFhirExplanationOfBenefitBenefitBalanceFinancial, FFinancialList.Link)){3};
end;

function TFhirExplanationOfBenefitBenefitBalance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subCategory') then
  begin
    SubCategory := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'financial') then
  begin
    FinancialList.add(propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'financial') then FinancialList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitBenefitBalance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subCategory') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'network') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'term') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'financial') then result := FinancialList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subCategory') then result := 'CodeableConcept'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'financial') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'subCategory') then SubCategoryElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'financial') then deletePropertyValue('financial', FinancialList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subCategory') then SubCategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept{4}
  else if (propName = 'financial') then replacePropertyValue('financial', FinancialList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'financial') then FinancialList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalance.fhirType : string;
begin
  result := 'benefitBalance';
end;

function TFhirExplanationOfBenefitBenefitBalance.Link : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalance.Clone : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalance.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalance(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(subCategoryElement, o.subCategoryElement, true) and
      compareDeep(excludedElement, o.excludedElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(networkElement, o.networkElement, true) and
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(termElement, o.termElement, true) and
      compareDeep(financialList, o.financialList, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FSubCategory) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FfinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('subCategory');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('financial');
end;

{ TFhirExplanationOfBenefitBenefitBalance }

Procedure TFhirExplanationOfBenefitBenefitBalance.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetSubCategory(value : TFhirCodeableConcept);
begin
  FSubCategory.free;
  FSubCategory := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  if FFinancialList = nil then
    FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
  result := FFinancialList;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetHasFinancialList : boolean;
begin
  result := (FFinancialList <> nil) and (FFinancialList.count > 0);
end;

function TFhirExplanationOfBenefitBenefitBalance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FSubCategory.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FfinancialList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceListEnumerator }

Constructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceList }
procedure TFhirExplanationOfBenefitBenefitBalanceList.AddItem(value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalance');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Append: TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Clone: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalance;
end;
function TFhirExplanationOfBenefitBenefitBalanceList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Link: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  FhirExplanationOfBenefitBenefitBalances[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).type_.Clone;
  allowed := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).allowed.Clone;
  used := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).used.Clone;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirType, FAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|Money', false, TFhirType, FUsed.Link));{2}
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then
  begin
    Used := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed'){4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then raise EFHIRException.create('Cannot make property Used'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.fhirType : string;
begin
  result := 'financial';
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Link : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalanceFinancial)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalanceFinancial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetAllowed(value : TFhirType);
begin
  FAllowed.free;
  FAllowed := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetUsed(value : TFhirType);
begin
  FUsed.free;
  FUsed := value;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator }

Constructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialList }
procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.AddItem(value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalanceFinancial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalanceFinancial');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Append: TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Clone: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial;
end;
function TFhirExplanationOfBenefitBenefitBalanceFinancialList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalanceFinancial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Link: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  FhirExplanationOfBenefitBenefitBalanceFinancials[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefit }

constructor TFhirExplanationOfBenefit.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefit.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubTypeList.Free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FOrganization.free;
  FReferral.free;
  FFacility.free;
  FClaim.free;
  FClaimResponse.free;
  FOutcome.free;
  FDisposition.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FInformationList.Free;
  FCareTeamList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FPrecedence.free;
  FInsurance.free;
  FAccident.free;
  FEmploymentImpacted.free;
  FHospitalization.free;
  FItemList.Free;
  FAddItemList.Free;
  FTotalCost.free;
  FUnallocDeductable.free;
  FTotalBenefit.free;
  FPayment.free;
  FForm.free;
  FProcessNoteList.Free;
  FBenefitBalanceList.Free;
  inherited;
end;

function TFhirExplanationOfBenefit.GetResourceType : TFhirResourceType;
begin
  result := frtExplanationOfBenefit;
end;

procedure TFhirExplanationOfBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefit(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExplanationOfBenefit(oSource).FIdentifierList);
  end;
  FStatus := TFhirExplanationOfBenefit(oSource).FStatus.Link;
  type_ := TFhirExplanationOfBenefit(oSource).type_.Clone;
  if (TFhirExplanationOfBenefit(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirExplanationOfBenefit(oSource).FSubTypeList);
  end;
  patient := TFhirExplanationOfBenefit(oSource).patient.Clone;
  billablePeriod := TFhirExplanationOfBenefit(oSource).billablePeriod.Clone;
  createdElement := TFhirExplanationOfBenefit(oSource).createdElement.Clone;
  enterer := TFhirExplanationOfBenefit(oSource).enterer.Clone;
  insurer := TFhirExplanationOfBenefit(oSource).insurer.Clone;
  provider := TFhirExplanationOfBenefit(oSource).provider.Clone;
  organization := TFhirExplanationOfBenefit(oSource).organization.Clone;
  referral := TFhirExplanationOfBenefit(oSource).referral.Clone;
  facility := TFhirExplanationOfBenefit(oSource).facility.Clone;
  claim := TFhirExplanationOfBenefit(oSource).claim.Clone;
  claimResponse := TFhirExplanationOfBenefit(oSource).claimResponse.Clone;
  outcome := TFhirExplanationOfBenefit(oSource).outcome.Clone;
  dispositionElement := TFhirExplanationOfBenefit(oSource).dispositionElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
    FRelatedList.Assign(TFhirExplanationOfBenefit(oSource).FRelatedList);
  end;
  prescription := TFhirExplanationOfBenefit(oSource).prescription.Clone;
  originalPrescription := TFhirExplanationOfBenefit(oSource).originalPrescription.Clone;
  payee := TFhirExplanationOfBenefit(oSource).payee.Clone;
  if (TFhirExplanationOfBenefit(oSource).FInformationList = nil) then
  begin
    FInformationList.free;
    FInformationList := nil;
  end
  else
  begin
    if FInformationList = nil then
      FInformationList := TFhirExplanationOfBenefitInformationList.Create;
    FInformationList.Assign(TFhirExplanationOfBenefit(oSource).FInformationList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
    FCareTeamList.Assign(TFhirExplanationOfBenefit(oSource).FCareTeamList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirExplanationOfBenefit(oSource).FDiagnosisList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
    FProcedure_List.Assign(TFhirExplanationOfBenefit(oSource).FProcedure_List);
  end;
  precedenceElement := TFhirExplanationOfBenefit(oSource).precedenceElement.Clone;
  insurance := TFhirExplanationOfBenefit(oSource).insurance.Clone;
  accident := TFhirExplanationOfBenefit(oSource).accident.Clone;
  employmentImpacted := TFhirExplanationOfBenefit(oSource).employmentImpacted.Clone;
  hospitalization := TFhirExplanationOfBenefit(oSource).hospitalization.Clone;
  if (TFhirExplanationOfBenefit(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirExplanationOfBenefitItemList.Create;
    FItemList.Assign(TFhirExplanationOfBenefit(oSource).FItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
    FAddItemList.Assign(TFhirExplanationOfBenefit(oSource).FAddItemList);
  end;
  totalCost := TFhirExplanationOfBenefit(oSource).totalCost.Clone;
  unallocDeductable := TFhirExplanationOfBenefit(oSource).unallocDeductable.Clone;
  totalBenefit := TFhirExplanationOfBenefit(oSource).totalBenefit.Clone;
  payment := TFhirExplanationOfBenefit(oSource).payment.Clone;
  form := TFhirExplanationOfBenefit(oSource).form.Clone;
  if (TFhirExplanationOfBenefit(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirExplanationOfBenefit(oSource).FProcessNoteList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FBenefitBalanceList = nil) then
  begin
    FBenefitBalanceList.free;
    FBenefitBalanceList := nil;
  end
  else
  begin
    if FBenefitBalanceList = nil then
      FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
    FBenefitBalanceList.Assign(TFhirExplanationOfBenefit(oSource).FBenefitBalanceList);
  end;
end;

procedure TFhirExplanationOfBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'information') Then
    list.addAll(self, 'information', FInformationList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'precedence') Then
     list.add(self.link, 'precedence', FPrecedence.Link);
  if (child_name = 'insurance') Then
     list.add(self.link, 'insurance', FInsurance.Link);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'employmentImpacted') Then
     list.add(self.link, 'employmentImpacted', FEmploymentImpacted.Link);
  if (child_name = 'hospitalization') Then
     list.add(self.link, 'hospitalization', FHospitalization.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'totalCost') Then
     list.add(self.link, 'totalCost', FTotalCost.Link);
  if (child_name = 'unallocDeductable') Then
     list.add(self.link, 'unallocDeductable', FUnallocDeductable.Link);
  if (child_name = 'totalBenefit') Then
     list.add(self.link, 'totalBenefit', FTotalBenefit.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'benefitBalance') Then
    list.addAll(self, 'benefitBalance', FBenefitBalanceList);
end;

procedure TFhirExplanationOfBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference(ReferralRequest)', false, TFhirReference{TFhirReferralRequest}, FReferral.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirExplanationOfBenefitRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationRequest|VisionPrescription)', false, TFhirReference{Resource}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FOriginalPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', '', false, TFhirExplanationOfBenefitPayee, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'information', '', true, TFhirExplanationOfBenefitInformation, FInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'careTeam', '', true, TFhirExplanationOfBenefitCareTeam, FCareTeamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirExplanationOfBenefitDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedure', '', true, TFhirExplanationOfBenefitProcedure, FProcedure_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'precedence', 'positiveInt', false, TFhirPositiveInt, FPrecedence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurance', '', false, TFhirExplanationOfBenefitInsurance, FInsurance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accident', '', false, TFhirExplanationOfBenefitAccident, FAccident.Link));{2}
  oList.add(TFHIRProperty.create(self, 'employmentImpacted', 'Period', false, TFhirPeriod, FEmploymentImpacted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hospitalization', 'Period', false, TFhirPeriod, FHospitalization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirExplanationOfBenefitItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addItem', '', true, TFhirExplanationOfBenefitAddItem, FAddItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'totalCost', 'Money', false, TFhirMoney, FTotalCost.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unallocDeductable', 'Money', false, TFhirMoney, FUnallocDeductable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'totalBenefit', 'Money', false, TFhirMoney, FTotalBenefit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payment', '', false, TFhirExplanationOfBenefitPayment, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirExplanationOfBenefitProcessNote, FProcessNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'benefitBalance', '', true, TFhirExplanationOfBenefitBenefitBalance, FBenefitBalanceList.Link)){3};
end;

function TFhirExplanationOfBenefit.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirExplanationofbenefitStatusEnum, CODES_TFhirExplanationofbenefitStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference{TFhirReferralRequest}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirExplanationOfBenefitRelated){2a};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirExplanationOfBenefitPayee{4b};
    result := propValue;
  end
  else if (propName = 'information') then
  begin
    InformationList.add(propValue as TFhirExplanationOfBenefitInformation){2a};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirExplanationOfBenefitCareTeam){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirExplanationOfBenefitDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirExplanationOfBenefitProcedure){2a};
    result := propValue;
  end
  else if (propName = 'precedence') then
  begin
    PrecedenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    Insurance := propValue as TFhirExplanationOfBenefitInsurance{4b};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirExplanationOfBenefitAccident{4b};
    result := propValue;
  end
  else if (propName = 'employmentImpacted') then
  begin
    EmploymentImpacted := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'hospitalization') then
  begin
    Hospitalization := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirExplanationOfBenefitItem){2a};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirExplanationOfBenefitAddItem){2a};
    result := propValue;
  end
  else if (propName = 'totalCost') then
  begin
    TotalCost := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'unallocDeductable') then
  begin
    UnallocDeductable := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'totalBenefit') then
  begin
    TotalBenefit := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirExplanationOfBenefitPayment{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirExplanationOfBenefitProcessNote){2a};
    result := propValue;
  end
  else if (propName = 'benefitBalance') then
  begin
    BenefitBalanceList.add(propValue as TFhirExplanationOfBenefitBenefitBalance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExplanationOfBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirExplanationOfBenefitRelated){2a}
  else if (propName = 'information') then InformationList.insertItem(index, propValue as TFhirExplanationOfBenefitInformation){2a}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirExplanationOfBenefitCareTeam){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirExplanationOfBenefitDiagnosis){2a}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirExplanationOfBenefitProcedure){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirExplanationOfBenefitItem){2a}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItem){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirExplanationOfBenefitProcessNote){2a}
  else if (propName = 'benefitBalance') then BenefitBalanceList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalance){2a}
  else inherited;
end;

function TFhirExplanationOfBenefit.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := SubTypeList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'referral') then result := TFhirReference{TFhirReferralRequest}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'prescription') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'originalPrescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'payee') then result := TFhirExplanationOfBenefitPayee.create(){4b}
  else if (propName = 'information') then result := InformationList.new(){2}
  else if (propName = 'careTeam') then result := CareTeamList.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'procedure') then result := Procedure_List.new(){2}
  else if (propName = 'precedence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'insurance') then result := TFhirExplanationOfBenefitInsurance.create(){4b}
  else if (propName = 'accident') then result := TFhirExplanationOfBenefitAccident.create(){4b}
  else if (propName = 'employmentImpacted') then result := TFhirPeriod.create(){4b}
  else if (propName = 'hospitalization') then result := TFhirPeriod.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'addItem') then result := AddItemList.new(){2}
  else if (propName = 'totalCost') then result := TFhirMoney.create(){4b}
  else if (propName = 'unallocDeductable') then result := TFhirMoney.create(){4b}
  else if (propName = 'totalBenefit') then result := TFhirMoney.create(){4b}
  else if (propName = 'payment') then result := TFhirExplanationOfBenefitPayment.create(){4b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else if (propName = 'benefitBalance') then result := BenefitBalanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'claim') then result := 'Reference'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'related') then result := ''
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := ''
  else if (propName = 'information') then result := ''
  else if (propName = 'careTeam') then result := ''
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'procedure') then result := ''
  else if (propName = 'precedence') then result := 'positiveInt'
  else if (propName = 'insurance') then result := ''
  else if (propName = 'accident') then result := ''
  else if (propName = 'employmentImpacted') then result := 'Period'
  else if (propName = 'hospitalization') then result := 'Period'
  else if (propName = 'item') then result := ''
  else if (propName = 'addItem') then result := ''
  else if (propName = 'totalCost') then result := 'Money'
  else if (propName = 'unallocDeductable') then result := 'Money'
  else if (propName = 'totalBenefit') then result := 'Money'
  else if (propName = 'payment') then result := ''
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := ''
  else if (propName = 'benefitBalance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefit.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'information') then deletePropertyValue('information', InformationList, value) {2}
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {2}
  else if (propName = 'precedence') then PrecedenceElement := nil
  else if (propName = 'insurance') then InsuranceElement := nil
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'employmentImpacted') then EmploymentImpactedElement := nil
  else if (propName = 'hospitalization') then HospitalizationElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {2}
  else if (propName = 'totalCost') then TotalCostElement := nil
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := nil
  else if (propName = 'totalBenefit') then TotalBenefitElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else if (propName = 'benefitBalance') then deletePropertyValue('benefitBalance', BenefitBalanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirExplanationofbenefitStatusEnum, CODES_TFhirExplanationofbenefitStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference{TFhirReferralRequest}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{Resource}{4}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirExplanationOfBenefitPayee{4}
  else if (propName = 'information') then replacePropertyValue('information', InformationList, existing, new) {2}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {2}
  else if (propName = 'precedence') then PrecedenceElement := asPositiveInt(new){5b}
  else if (propName = 'insurance') then InsuranceElement := new as TFhirExplanationOfBenefitInsurance{4}
  else if (propName = 'accident') then AccidentElement := new as TFhirExplanationOfBenefitAccident{4}
  else if (propName = 'employmentImpacted') then EmploymentImpactedElement := new as TFhirPeriod{4}
  else if (propName = 'hospitalization') then HospitalizationElement := new as TFhirPeriod{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {2}
  else if (propName = 'totalCost') then TotalCostElement := new as TFhirMoney{4}
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := new as TFhirMoney{4}
  else if (propName = 'totalBenefit') then TotalBenefitElement := new as TFhirMoney{4}
  else if (propName = 'payment') then PaymentElement := new as TFhirExplanationOfBenefitPayment{4}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else if (propName = 'benefitBalance') then replacePropertyValue('benefitBalance', BenefitBalanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'subType') then SubTypeList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'information') then InformationList.move(source, destination){2a}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'procedure') then Procedure_List.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'addItem') then AddItemList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else if (propName = 'benefitBalance') then BenefitBalanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefit.fhirType : string;
begin
  result := 'ExplanationOfBenefit';
end;

function TFhirExplanationOfBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FClaim) and isEmptyProp(FClaimResponse) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FinformationList) and isEmptyProp(FcareTeamList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FPrecedence) and isEmptyProp(FInsurance) and isEmptyProp(FAccident) and isEmptyProp(FEmploymentImpacted) and isEmptyProp(FHospitalization) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FTotalCost) and
    isEmptyProp(FUnallocDeductable) and isEmptyProp(FTotalBenefit) and isEmptyProp(FPayment) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FbenefitBalanceList);
end;

function TFhirExplanationOfBenefit.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefit)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefit(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(billablePeriodElement, o.billablePeriodElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(entererElement, o.entererElement, true) and
      compareDeep(insurerElement, o.insurerElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(referralElement, o.referralElement, true) and
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(claimElement, o.claimElement, true) and
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(relatedList, o.relatedList, true) and
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(informationList, o.informationList, true) and
      compareDeep(careTeamList, o.careTeamList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(precedenceElement, o.precedenceElement, true) and
      compareDeep(insuranceElement, o.insuranceElement, true) and compareDeep(accidentElement, o.accidentElement, true) and
      compareDeep(employmentImpactedElement, o.employmentImpactedElement, true) and
      compareDeep(hospitalizationElement, o.hospitalizationElement, true) and compareDeep(itemList, o.itemList, true) and
      compareDeep(addItemList, o.addItemList, true) and compareDeep(totalCostElement, o.totalCostElement, true) and
      compareDeep(unallocDeductableElement, o.unallocDeductableElement, true) and compareDeep(totalBenefitElement, o.totalBenefitElement, true) and
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(formElement, o.formElement, true) and
      compareDeep(processNoteList, o.processNoteList, true) and compareDeep(benefitBalanceList, o.benefitBalanceList, true);
  end;
end;

function TFhirExplanationOfBenefit.Link : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Link);
end;

function TFhirExplanationOfBenefit.Clone : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Clone);
end;

procedure TFhirExplanationOfBenefit.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('organization');
  fields.add('referral');
  fields.add('facility');
  fields.add('claim');
  fields.add('claimResponse');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('information');
  fields.add('careTeam');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('precedence');
  fields.add('insurance');
  fields.add('accident');
  fields.add('employmentImpacted');
  fields.add('hospitalization');
  fields.add('item');
  fields.add('addItem');
  fields.add('totalCost');
  fields.add('unallocDeductable');
  fields.add('totalBenefit');
  fields.add('payment');
  fields.add('form');
  fields.add('processNote');
  fields.add('benefitBalance');
end;

{ TFhirExplanationOfBenefit }

Function TFhirExplanationOfBenefit.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirExplanationOfBenefit.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirExplanationOfBenefit.GetStatusST : TFhirExplanationofbenefitStatusEnum;
begin
  if FStatus = nil then
    result := TFhirExplanationofbenefitStatusEnum(0)
  else
    result := TFhirExplanationofbenefitStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirExplanationofbenefitStatusEnum, FStatus.value));
end;

Procedure TFhirExplanationOfBenefit.SetStatusST(value : TFhirExplanationofbenefitStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirExplanationofbenefitStatusEnum[value], CODES_TFhirExplanationofbenefitStatusEnum[value]);
end;

Procedure TFhirExplanationOfBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirExplanationOfBenefit.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

Function TFhirExplanationOfBenefit.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirExplanationOfBenefit.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

Procedure TFhirExplanationOfBenefit.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirExplanationOfBenefit.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirExplanationOfBenefit.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirExplanationOfBenefit.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirExplanationOfBenefit.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirExplanationOfBenefit.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirExplanationOfBenefit.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirExplanationOfBenefit.SetReferral(value : TFhirReference{TFhirReferralRequest});
begin
  FReferral.free;
  FReferral := value;
end;

Procedure TFhirExplanationOfBenefit.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Procedure TFhirExplanationOfBenefit.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirExplanationOfBenefit.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

Procedure TFhirExplanationOfBenefit.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirExplanationOfBenefit.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirExplanationOfBenefit.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirExplanationOfBenefit.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Function TFhirExplanationOfBenefit.GetRelatedList : TFhirExplanationOfBenefitRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirExplanationOfBenefit.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPrescription(value : TFhirReference{Resource});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirExplanationOfBenefit.SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

Procedure TFhirExplanationOfBenefit.SetPayee(value : TFhirExplanationOfBenefitPayee);
begin
  FPayee.free;
  FPayee := value;
end;

Function TFhirExplanationOfBenefit.GetInformationList : TFhirExplanationOfBenefitInformationList;
begin
  if FInformationList = nil then
    FInformationList := TFhirExplanationOfBenefitInformationList.Create;
  result := FInformationList;
end;

Function TFhirExplanationOfBenefit.GetHasInformationList : boolean;
begin
  result := (FInformationList <> nil) and (FInformationList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
  result := FCareTeamList;
end;

Function TFhirExplanationOfBenefit.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirExplanationOfBenefit.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
  result := FProcedure_List;
end;

Function TFhirExplanationOfBenefit.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPrecedence(value : TFhirPositiveInt);
begin
  FPrecedence.free;
  FPrecedence := value;
end;

Function TFhirExplanationOfBenefit.GetPrecedenceST : String;
begin
  if FPrecedence = nil then
    result := ''
  else
    result := FPrecedence.value;
end;

Procedure TFhirExplanationOfBenefit.SetPrecedenceST(value : String);
begin
  if value <> '' then
  begin
    if FPrecedence = nil then
      FPrecedence := TFhirPositiveInt.create;
    FPrecedence.value := value
  end
  else if FPrecedence <> nil then
    FPrecedence.value := '';
end;

Procedure TFhirExplanationOfBenefit.SetInsurance(value : TFhirExplanationOfBenefitInsurance);
begin
  FInsurance.free;
  FInsurance := value;
end;

Procedure TFhirExplanationOfBenefit.SetAccident(value : TFhirExplanationOfBenefitAccident);
begin
  FAccident.free;
  FAccident := value;
end;

Procedure TFhirExplanationOfBenefit.SetEmploymentImpacted(value : TFhirPeriod);
begin
  FEmploymentImpacted.free;
  FEmploymentImpacted := value;
end;

Procedure TFhirExplanationOfBenefit.SetHospitalization(value : TFhirPeriod);
begin
  FHospitalization.free;
  FHospitalization := value;
end;

Function TFhirExplanationOfBenefit.GetItemList : TFhirExplanationOfBenefitItemList;
begin
  if FItemList = nil then
    FItemList := TFhirExplanationOfBenefitItemList.Create;
  result := FItemList;
end;

Function TFhirExplanationOfBenefit.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetAddItemList : TFhirExplanationOfBenefitAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
  result := FAddItemList;
end;

Function TFhirExplanationOfBenefit.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetTotalCost(value : TFhirMoney);
begin
  FTotalCost.free;
  FTotalCost := value;
end;

Procedure TFhirExplanationOfBenefit.SetUnallocDeductable(value : TFhirMoney);
begin
  FUnallocDeductable.free;
  FUnallocDeductable := value;
end;

Procedure TFhirExplanationOfBenefit.SetTotalBenefit(value : TFhirMoney);
begin
  FTotalBenefit.free;
  FTotalBenefit := value;
end;

Procedure TFhirExplanationOfBenefit.SetPayment(value : TFhirExplanationOfBenefitPayment);
begin
  FPayment.free;
  FPayment := value;
end;

Procedure TFhirExplanationOfBenefit.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirExplanationOfBenefit.GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirExplanationOfBenefit.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
begin
  if FBenefitBalanceList = nil then
    FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
  result := FBenefitBalanceList;
end;

Function TFhirExplanationOfBenefit.GetHasBenefitBalanceList : boolean;
begin
  result := (FBenefitBalanceList <> nil) and (FBenefitBalanceList.count > 0);
end;

function TFhirExplanationOfBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubTypeList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FClaim.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FinformationList.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FPrecedence.sizeInBytes);
  inc(result, FInsurance.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FEmploymentImpacted.sizeInBytes);
  inc(result, FHospitalization.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FTotalCost.sizeInBytes);
  inc(result, FUnallocDeductable.sizeInBytes);
  inc(result, FTotalBenefit.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FbenefitBalanceList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitListEnumerator }

Constructor TFhirExplanationOfBenefitListEnumerator.Create(list : TFhirExplanationOfBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitListEnumerator.GetCurrent : TFhirExplanationOfBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitList }
procedure TFhirExplanationOfBenefitList.AddItem(value: TFhirExplanationOfBenefit);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefit');
  add(value);
end;

function TFhirExplanationOfBenefitList.Append: TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitList.GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
begin
  result := TFhirExplanationOfBenefitListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitList.Clone: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Clone);
end;

function TFhirExplanationOfBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitList.GetItemN(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefit;
end;
function TFhirExplanationOfBenefitList.IndexOf(value: TFhirExplanationOfBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitList.Insert(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.InsertItem(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitList.Item(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.Link: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Link);
end;

procedure TFhirExplanationOfBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  FhirExplanationOfBenefits[index] := value;
end;

procedure TFhirExplanationOfBenefitList.SetItemN(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_GUIDANCERESPONSE}

{ TFhirGuidanceResponse }

constructor TFhirGuidanceResponse.Create;
begin
  inherited;
end;

destructor TFhirGuidanceResponse.Destroy;
begin
  FRequestId.free;
  FIdentifier.free;
  FModule.free;
  FStatus.free;
  FSubject.free;
  FContext.free;
  FOccurrenceDateTime.free;
  FPerformer.free;
  FReason.free;
  FNoteList.Free;
  FEvaluationMessageList.Free;
  FOutputParameters.free;
  FResult.free;
  FDataRequirementList.Free;
  inherited;
end;

function TFhirGuidanceResponse.GetResourceType : TFhirResourceType;
begin
  result := frtGuidanceResponse;
end;

procedure TFhirGuidanceResponse.Assign(oSource : TFslObject);
begin
  inherited;
  requestIdElement := TFhirGuidanceResponse(oSource).requestIdElement.Clone;
  identifier := TFhirGuidanceResponse(oSource).identifier.Clone;
  module := TFhirGuidanceResponse(oSource).module.Clone;
  FStatus := TFhirGuidanceResponse(oSource).FStatus.Link;
  subject := TFhirGuidanceResponse(oSource).subject.Clone;
  context := TFhirGuidanceResponse(oSource).context.Clone;
  occurrenceDateTimeElement := TFhirGuidanceResponse(oSource).occurrenceDateTimeElement.Clone;
  performer := TFhirGuidanceResponse(oSource).performer.Clone;
  reason := TFhirGuidanceResponse(oSource).reason.Clone;
  if (TFhirGuidanceResponse(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGuidanceResponse(oSource).FNoteList);
  end;
  if (TFhirGuidanceResponse(oSource).FEvaluationMessageList = nil) then
  begin
    FEvaluationMessageList.free;
    FEvaluationMessageList := nil;
  end
  else
  begin
    if FEvaluationMessageList = nil then
      FEvaluationMessageList := TFhirReferenceList{TFhirOperationOutcome}.Create;
    FEvaluationMessageList.Assign(TFhirGuidanceResponse(oSource).FEvaluationMessageList);
  end;
  outputParameters := TFhirGuidanceResponse(oSource).outputParameters.Clone;
  result := TFhirGuidanceResponse(oSource).result.Clone;
  if (TFhirGuidanceResponse(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirGuidanceResponse(oSource).FDataRequirementList);
  end;
end;

procedure TFhirGuidanceResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'requestId') Then
     list.add(self.link, 'requestId', FRequestId.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'module') Then
     list.add(self.link, 'module', FModule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrenceDateTime') Then
     list.add(self.link, 'occurrenceDateTime', FOccurrenceDateTime.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'evaluationMessage') Then
    list.addAll(self, 'evaluationMessage', FEvaluationMessageList);
  if (child_name = 'outputParameters') Then
     list.add(self.link, 'outputParameters', FOutputParameters.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
end;

procedure TFhirGuidanceResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'requestId', 'id', false, TFhirId, FRequestId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'module', 'Reference(ServiceDefinition)', false, TFhirReference{TFhirServiceDefinition}, FModule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrenceDateTime', 'dateTime', false, TFhirDateTime, FOccurrenceDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'evaluationMessage', 'Reference(OperationOutcome)', true, TFhirReference{TFhirOperationOutcome}, FEvaluationMessageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outputParameters', 'Reference(Parameters)', false, TFhirReference{TFhirParameters}, FOutputParameters.Link));{2}
  oList.add(TFHIRProperty.create(self, 'result', 'Reference(CarePlan|RequestGroup)', false, TFhirReference{Resource}, FResult.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link)){3};
end;

function TFhirGuidanceResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'requestId') then
  begin
    RequestIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'module') then
  begin
    Module := propValue as TFhirReference{TFhirServiceDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'occurrenceDateTime') then
  begin
    OccurrenceDateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'evaluationMessage') then
  begin
    EvaluationMessageList.add(propValue as TFhirReference{TFhirOperationOutcome}){2a};
    result := propValue;
  end
  else if (propName = 'outputParameters') then
  begin
    OutputParameters := propValue as TFhirReference{TFhirParameters}{4b};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    Result := propValue as TFhirReference{Resource}{4b};
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGuidanceResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'evaluationMessage') then EvaluationMessageList.insertItem(index, propValue as TFhirReference{TFhirOperationOutcome}){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else inherited;
end;

function TFhirGuidanceResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'requestId') then result := TFhirId.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'module') then result := TFhirReference{TFhirServiceDefinition}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'occurrenceDateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'performer') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'evaluationMessage') then result := EvaluationMessageList.new(){2}
  else if (propName = 'outputParameters') then result := TFhirReference{TFhirParameters}.create(){4b}
  else if (propName = 'result') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'dataRequirement') then result := DataRequirementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGuidanceResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'requestId') then result := 'id'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'module') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrenceDateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'evaluationMessage') then result := 'Reference'
  else if (propName = 'outputParameters') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGuidanceResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'requestId') then RequestIdElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'module') then ModuleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'evaluationMessage') then deletePropertyValue('evaluationMessage', EvaluationMessageList, value) {2}
  else if (propName = 'outputParameters') then OutputParametersElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGuidanceResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'requestId') then RequestIdElement := asId(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'module') then ModuleElement := new as TFhirReference{TFhirServiceDefinition}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := asDateTime(new){5b}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirDevice}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'evaluationMessage') then replacePropertyValue('evaluationMessage', EvaluationMessageList, existing, new) {2}
  else if (propName = 'outputParameters') then OutputParametersElement := new as TFhirReference{TFhirParameters}{4}
  else if (propName = 'result') then ResultElement := new as TFhirReference{Resource}{4}
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGuidanceResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'evaluationMessage') then EvaluationMessageList.move(source, destination){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGuidanceResponse.fhirType : string;
begin
  result := 'GuidanceResponse';
end;

function TFhirGuidanceResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequestId) and isEmptyProp(FIdentifier) and isEmptyProp(FModule) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrenceDateTime) and isEmptyProp(FPerformer) and isEmptyProp(FReason) and isEmptyProp(FnoteList) and isEmptyProp(FevaluationMessageList) and isEmptyProp(FOutputParameters) and isEmptyProp(FResult) and isEmptyProp(FdataRequirementList);
end;

function TFhirGuidanceResponse.equals(other : TObject) : boolean;
var
  o : TFhirGuidanceResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGuidanceResponse)) then
    result := false
  else
  begin
    o := TFhirGuidanceResponse(other);
    result := compareDeep(requestIdElement, o.requestIdElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(moduleElement, o.moduleElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(occurrenceDateTimeElement, o.occurrenceDateTimeElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(evaluationMessageList, o.evaluationMessageList, true) and
      compareDeep(outputParametersElement, o.outputParametersElement, true) and compareDeep(resultElement, o.resultElement, true) and
      compareDeep(dataRequirementList, o.dataRequirementList, true);
  end;
end;

function TFhirGuidanceResponse.Link : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Link);
end;

function TFhirGuidanceResponse.Clone : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Clone);
end;

procedure TFhirGuidanceResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('requestId');
  fields.add('identifier');
  fields.add('module');
  fields.add('status');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrenceDateTime');
  fields.add('performer');
  fields.add('reason[x]');
  fields.add('note');
  fields.add('evaluationMessage');
  fields.add('outputParameters');
  fields.add('result');
  fields.add('dataRequirement');
end;

{ TFhirGuidanceResponse }

Procedure TFhirGuidanceResponse.SetRequestId(value : TFhirId);
begin
  FRequestId.free;
  FRequestId := value;
end;

Function TFhirGuidanceResponse.GetRequestIdST : String;
begin
  if FRequestId = nil then
    result := ''
  else
    result := FRequestId.value;
end;

Procedure TFhirGuidanceResponse.SetRequestIdST(value : String);
begin
  if value <> '' then
  begin
    if FRequestId = nil then
      FRequestId := TFhirId.create;
    FRequestId.value := value
  end
  else if FRequestId <> nil then
    FRequestId.value := '';
end;

Procedure TFhirGuidanceResponse.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirGuidanceResponse.SetModule(value : TFhirReference{TFhirServiceDefinition});
begin
  FModule.free;
  FModule := value;
end;

Procedure TFhirGuidanceResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirGuidanceResponse.GetStatusST : TFhirGuidanceResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGuidanceResponseStatusEnum(0)
  else
    result := TFhirGuidanceResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidanceResponseStatusEnum, FStatus.value));
end;

Procedure TFhirGuidanceResponse.SetStatusST(value : TFhirGuidanceResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[value], CODES_TFhirGuidanceResponseStatusEnum[value]);
end;

Procedure TFhirGuidanceResponse.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirGuidanceResponse.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirGuidanceResponse.SetOccurrenceDateTime(value : TFhirDateTime);
begin
  FOccurrenceDateTime.free;
  FOccurrenceDateTime := value;
end;

Function TFhirGuidanceResponse.GetOccurrenceDateTimeST : TFslDateTime;
begin
  if FOccurrenceDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FOccurrenceDateTime.value;
end;

Procedure TFhirGuidanceResponse.SetOccurrenceDateTimeST(value : TFslDateTime);
begin
  if FOccurrenceDateTime = nil then
    FOccurrenceDateTime := TFhirDateTime.create;
  FOccurrenceDateTime.value := value
end;

Procedure TFhirGuidanceResponse.SetPerformer(value : TFhirReference{TFhirDevice});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirGuidanceResponse.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirGuidanceResponse.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirGuidanceResponse.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirGuidanceResponse.GetEvaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
begin
  if FEvaluationMessageList = nil then
    FEvaluationMessageList := TFhirReferenceList{TFhirOperationOutcome}.Create;
  result := FEvaluationMessageList;
end;

Function TFhirGuidanceResponse.GetHasEvaluationMessageList : boolean;
begin
  result := (FEvaluationMessageList <> nil) and (FEvaluationMessageList.count > 0);
end;

Procedure TFhirGuidanceResponse.SetOutputParameters(value : TFhirReference{TFhirParameters});
begin
  FOutputParameters.free;
  FOutputParameters := value;
end;

Procedure TFhirGuidanceResponse.SetResult(value : TFhirReference{Resource});
begin
  FResult.free;
  FResult := value;
end;

Function TFhirGuidanceResponse.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

Function TFhirGuidanceResponse.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

function TFhirGuidanceResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRequestId.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FModule.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrenceDateTime.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FevaluationMessageList.sizeInBytes);
  inc(result, FOutputParameters.sizeInBytes);
  inc(result, FResult.sizeInBytes);
  inc(result, FdataRequirementList.sizeInBytes);
end;

{ TFhirGuidanceResponseListEnumerator }

Constructor TFhirGuidanceResponseListEnumerator.Create(list : TFhirGuidanceResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGuidanceResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGuidanceResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGuidanceResponseListEnumerator.GetCurrent : TFhirGuidanceResponse;
begin
  Result := FList[FIndex];
end;

function TFhirGuidanceResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGuidanceResponseList }
procedure TFhirGuidanceResponseList.AddItem(value: TFhirGuidanceResponse);
begin
  assert(value.ClassName = 'TFhirGuidanceResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGuidanceResponse');
  add(value);
end;

function TFhirGuidanceResponseList.Append: TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.ClearItems;
begin
  Clear;
end;

function TFhirGuidanceResponseList.GetEnumerator : TFhirGuidanceResponseListEnumerator;
begin
  result := TFhirGuidanceResponseListEnumerator.Create(self.link);
end;

function TFhirGuidanceResponseList.Clone: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Clone);
end;

function TFhirGuidanceResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGuidanceResponseList.GetItemN(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirGuidanceResponse;
end;
function TFhirGuidanceResponseList.IndexOf(value: TFhirGuidanceResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGuidanceResponseList.Insert(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.InsertItem(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  Inherited Insert(index, value);
end;

function TFhirGuidanceResponseList.Item(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.Link: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Link);
end;

procedure TFhirGuidanceResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGuidanceResponseList.SetItemByIndex(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  FhirGuidanceResponses[index] := value;
end;

procedure TFhirGuidanceResponseList.SetItemN(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GUIDANCERESPONSE}

{$IFDEF FHIR_LINKAGE}

{ TFhirLinkageItem }

constructor TFhirLinkageItem.Create;
begin
  inherited;
end;

destructor TFhirLinkageItem.Destroy;
begin
  FType_.free;
  FResource.free;
  inherited;
end;

procedure TFhirLinkageItem.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirLinkageItem(oSource).FType_.Link;
  resource := TFhirLinkageItem(oSource).resource.Clone;
end;

procedure TFhirLinkageItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirLinkageItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));{2}
end;

function TFhirLinkageItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkageItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLinkageItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirReference.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkageItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkageItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkageItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, new){4}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkageItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkageItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirLinkageItem.Link : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Link);
end;

function TFhirLinkageItem.Clone : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Clone);
end;

function TFhirLinkageItem.equals(other : TObject) : boolean;
var
  o : TFhirLinkageItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkageItem)) then
    result := false
  else
  begin
    o := TFhirLinkageItem(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirLinkageItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource);
end;

procedure TFhirLinkageItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
end;

{ TFhirLinkageItem }

Procedure TFhirLinkageItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirLinkageItem.GetType_ST : TFhirLinkageTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkageTypeEnum(0)
  else
    result := TFhirLinkageTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkageTypeEnum, FType_.value));
end;

Procedure TFhirLinkageItem.SetType_ST(value : TFhirLinkageTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[value], CODES_TFhirLinkageTypeEnum[value]);
end;

Procedure TFhirLinkageItem.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

function TFhirLinkageItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResource.sizeInBytes);
end;

{ TFhirLinkageItemListEnumerator }

Constructor TFhirLinkageItemListEnumerator.Create(list : TFhirLinkageItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageItemListEnumerator.GetCurrent : TFhirLinkageItem;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLinkageItemList }
procedure TFhirLinkageItemList.AddItem(value: TFhirLinkageItem);
begin
  assert(value.ClassName = 'TFhirLinkageItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkageItem');
  add(value);
end;

function TFhirLinkageItemList.Append: TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageItemList.GetEnumerator : TFhirLinkageItemListEnumerator;
begin
  result := TFhirLinkageItemListEnumerator.Create(self.link);
end;

function TFhirLinkageItemList.Clone: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Clone);
end;

function TFhirLinkageItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageItemList.GetItemN(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkageItem;
end;
function TFhirLinkageItemList.IndexOf(value: TFhirLinkageItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageItemList.Insert(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.InsertItem(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  Inherited Insert(index, value);
end;

function TFhirLinkageItemList.Item(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.Link: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Link);
end;

procedure TFhirLinkageItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageItemList.SetItemByIndex(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  FhirLinkageItems[index] := value;
end;

procedure TFhirLinkageItemList.SetItemN(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  ObjectByIndex[index] := value;
end;

{ TFhirLinkage }

constructor TFhirLinkage.Create;
begin
  inherited;
end;

destructor TFhirLinkage.Destroy;
begin
  FActive.free;
  FAuthor.free;
  FItemList.Free;
  inherited;
end;

function TFhirLinkage.GetResourceType : TFhirResourceType;
begin
  result := frtLinkage;
end;

procedure TFhirLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  activeElement := TFhirLinkage(oSource).activeElement.Clone;
  author := TFhirLinkage(oSource).author.Clone;
  if (TFhirLinkage(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirLinkageItemList.Create;
    FItemList.Assign(TFhirLinkage(oSource).FItemList);
  end;
end;

procedure TFhirLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirLinkageItem, FItemList.Link)){3};
end;

function TFhirLinkage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirLinkageItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirLinkageItem){2a}
  else inherited;
end;

function TFhirLinkage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'active') then result := TFhirBoolean.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'active') then result := 'boolean'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkage.fhirType : string;
begin
  result := 'Linkage';
end;

function TFhirLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActive) and isEmptyProp(FAuthor) and isEmptyProp(FitemList);
end;

function TFhirLinkage.equals(other : TObject) : boolean;
var
  o : TFhirLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkage)) then
    result := false
  else
  begin
    o := TFhirLinkage(other);
    result := compareDeep(activeElement, o.activeElement, true) and compareDeep(authorElement, o.authorElement, true) and
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirLinkage.Link : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Link);
end;

function TFhirLinkage.Clone : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Clone);
end;

procedure TFhirLinkage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('active');
  fields.add('author');
  fields.add('item');
end;

{ TFhirLinkage }

Procedure TFhirLinkage.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirLinkage.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirLinkage.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

Procedure TFhirLinkage.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Function TFhirLinkage.GetItemList : TFhirLinkageItemList;
begin
  if FItemList = nil then
    FItemList := TFhirLinkageItemList.Create;
  result := FItemList;
end;

Function TFhirLinkage.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirLinkage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActive.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirLinkageListEnumerator }

Constructor TFhirLinkageListEnumerator.Create(list : TFhirLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageListEnumerator.GetCurrent : TFhirLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLinkageList }
procedure TFhirLinkageList.AddItem(value: TFhirLinkage);
begin
  assert(value.ClassName = 'TFhirLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkage');
  add(value);
end;

function TFhirLinkageList.Append: TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageList.GetEnumerator : TFhirLinkageListEnumerator;
begin
  result := TFhirLinkageListEnumerator.Create(self.link);
end;

function TFhirLinkageList.Clone: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Clone);
end;

function TFhirLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageList.GetItemN(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkage;
end;
function TFhirLinkageList.IndexOf(value: TFhirLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageList.Insert(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.InsertItem(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  Inherited Insert(index, value);
end;

function TFhirLinkageList.Item(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.Link: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Link);
end;

procedure TFhirLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageList.SetItemByIndex(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  FhirLinkages[index] := value;
end;

procedure TFhirLinkageList.SetItemN(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LINKAGE}

{$IFDEF FHIR_LIST}

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlag.free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TFslObject);
begin
  inherited;
  flag := TFhirListEntry(oSource).flag.Clone;
  deletedElement := TFhirListEntry(oSource).deletedElement.Clone;
  dateElement := TFhirListEntry(oSource).dateElement.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.add(self.link, 'flag', FFlag.Link);
  if (child_name = 'deleted') Then
     list.add(self.link, 'deleted', FDeleted.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', false, TFhirCodeableConcept, FFlag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', false, TFhirBoolean, FDeleted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Any)', false, TFhirReference{TFhirReference}, FItem.Link));{2}
end;

function TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'flag') then
  begin
    Flag := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'deleted') then
  begin
    DeletedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirListEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirListEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'flag') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'deleted') then result := TFhirBoolean.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'item') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirListEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'flag') then result := 'CodeableConcept'
  else if (propName = 'deleted') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirListEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := nil
  else if (propName = 'deleted') then DeletedElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirListEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := new as TFhirCodeableConcept{4}
  else if (propName = 'deleted') then DeletedElement := asBoolean(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'item') then ItemElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirListEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirListEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

function TFhirListEntry.equals(other : TObject) : boolean;
var
  o : TFhirListEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirListEntry)) then
    result := false
  else
  begin
    o := TFhirListEntry(other);
    result := compareDeep(flagElement, o.flagElement, true) and compareDeep(deletedElement, o.deletedElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirListEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFlag) and isEmptyProp(FDeleted) and isEmptyProp(FDate) and isEmptyProp(FItem);
end;

procedure TFhirListEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('flag');
  fields.add('deleted');
  fields.add('date');
  fields.add('item');
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetFlag(value : TFhirCodeableConcept);
begin
  FFlag.free;
  FFlag := value;
end;

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirListEntry.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirListEntry.SetItem(value : TFhirReference{TFhirReference});
begin
  FItem.free;
  FItem := value;
end;

function TFhirListEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFlag.sizeInBytes);
  inc(result, FDeleted.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirListEntryListEnumerator }

Constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;

function TFhirListEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;

function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirListEntry;
end;
function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirList }

constructor TFhirList.Create;
begin
  inherited;
end;

destructor TFhirList.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FMode.free;
  FTitle.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FSource.free;
  FOrderedBy.free;
  FNoteList.Free;
  FEntryList.Free;
  FEmptyReason.free;
  inherited;
end;

function TFhirList.GetResourceType : TFhirResourceType;
begin
  result := frtList;
end;

procedure TFhirList.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirList(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirList(oSource).FIdentifierList);
  end;
  FStatus := TFhirList(oSource).FStatus.Link;
  FMode := TFhirList(oSource).FMode.Link;
  titleElement := TFhirList(oSource).titleElement.Clone;
  code := TFhirList(oSource).code.Clone;
  subject := TFhirList(oSource).subject.Clone;
  encounter := TFhirList(oSource).encounter.Clone;
  dateElement := TFhirList(oSource).dateElement.Clone;
  source := TFhirList(oSource).source.Clone;
  orderedBy := TFhirList(oSource).orderedBy.Clone;
  if (TFhirList(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirList(oSource).FNoteList);
  end;
  if (TFhirList(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirListEntryList.Create;
    FEntryList.Assign(TFhirList(oSource).FEntryList);
  end;
  emptyReason := TFhirList(oSource).emptyReason.Clone;
end;

procedure TFhirList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
end;

procedure TFhirList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Practitioner|Patient|Device)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirListEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));{2}
end;

function TFhirList.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirListEntry){2a};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirListEntry){2a}
  else inherited;
end;

function TFhirList.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'entry') then result := ''
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirList.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, new){4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new){4}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirList.fhirType : string;
begin
  result := 'List';
end;

function TFhirList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FMode) and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FSource) and isEmptyProp(FOrderedBy) and isEmptyProp(FnoteList) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason);
end;

function TFhirList.equals(other : TObject) : boolean;
var
  o : TFhirList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirList)) then
    result := false
  else
  begin
    o := TFhirList(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(modeElement, o.modeElement, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(orderedByElement, o.orderedByElement, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(entryList, o.entryList, true) and
      compareDeep(emptyReasonElement, o.emptyReasonElement, true);
  end;
end;

function TFhirList.Link : TFhirList;
begin
  result := TFhirList(inherited Link);
end;

function TFhirList.Clone : TFhirList;
begin
  result := TFhirList(inherited Clone);
end;

procedure TFhirList.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('mode');
  fields.add('title');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('source');
  fields.add('orderedBy');
  fields.add('note');
  fields.add('entry');
  fields.add('emptyReason');
end;

{ TFhirList }

Function TFhirList.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirList.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirList.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirList.GetStatusST : TFhirListStatusEnum;
begin
  if FStatus = nil then
    result := TFhirListStatusEnum(0)
  else
    result := TFhirListStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirListStatusEnum, FStatus.value));
end;

Procedure TFhirList.SetStatusST(value : TFhirListStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[value], CODES_TFhirListStatusEnum[value]);
end;

Procedure TFhirList.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirList.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

Procedure TFhirList.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

Procedure TFhirList.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirList.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirList.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirList.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirList.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirList.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirList.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirList.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirList.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirList.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirList.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

Function TFhirList.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirList.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirList.GetEntryList : TFhirListEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirListEntryList.Create;
  result := FEntryList;
end;

Function TFhirList.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirList.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirList.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
end;

{ TFhirListListEnumerator }

Constructor TFhirListListEnumerator.Create(list : TFhirListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListListEnumerator.GetCurrent : TFhirList;
begin
  Result := FList[FIndex];
end;

function TFhirListListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListList }
procedure TFhirListList.AddItem(value: TFhirList);
begin
  assert(value.ClassName = 'TFhirList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirList');
  add(value);
end;

function TFhirListList.Append: TFhirList;
begin
  result := TFhirList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.ClearItems;
begin
  Clear;
end;

function TFhirListList.GetEnumerator : TFhirListListEnumerator;
begin
  result := TFhirListListEnumerator.Create(self.link);
end;

function TFhirListList.Clone: TFhirListList;
begin
  result := TFhirListList(inherited Clone);
end;

function TFhirListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListList.GetItemN(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.ItemClass: TFslObjectClass;
begin
  result := TFhirList;
end;
function TFhirListList.IndexOf(value: TFhirList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListList.Insert(index: Integer): TFhirList;
begin
  result := TFhirList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.InsertItem(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  Inherited Insert(index, value);
end;

function TFhirListList.Item(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.Link: TFhirListList;
begin
  result := TFhirListList(inherited Link);
end;

procedure TFhirListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListList.SetItemByIndex(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  FhirLists[index] := value;
end;

procedure TFhirListList.SetItemN(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEASUREREPORT}

{ TFhirMeasureReportGroup }

constructor TFhirMeasureReportGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroup.Destroy;
begin
  FIdentifier.free;
  FPopulationList.Free;
  FMeasureScore.free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroup.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureReportGroup(oSource).identifier.Clone;
  if (TFhirMeasureReportGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroup(oSource).FPopulationList);
  end;
  measureScoreElement := TFhirMeasureReportGroup(oSource).measureScoreElement.Clone;
  if (TFhirMeasureReportGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureReportGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureReportGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureReportGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', '', true, TFhirMeasureReportGroupPopulation, FPopulationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'measureScore', 'decimal', false, TFhirDecimal, FMeasureScore.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stratifier', '', true, TFhirMeasureReportGroupStratifier, FStratifierList.Link)){3};
end;

function TFhirMeasureReportGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupPopulation){2a};
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureReportGroupStratifier){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupPopulation){2a}
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureReportGroupStratifier){2a}
  else inherited;
end;

function TFhirMeasureReportGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else if (propName = 'measureScore') then result := TFhirDecimal.create() {5b}
  else if (propName = 'stratifier') then result := StratifierList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'population') then result := ''
  else if (propName = 'measureScore') then result := 'decimal'
  else if (propName = 'stratifier') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := asDecimal(new){5b}
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination){2a}
  else if (propName = 'stratifier') then StratifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirMeasureReportGroup.Link : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Link);
end;

function TFhirMeasureReportGroup.Clone : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Clone);
end;

function TFhirMeasureReportGroup.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReportGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroup(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(populationList, o.populationList, true) and
      compareDeep(measureScoreElement, o.measureScoreElement, true) and compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureReportGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureReportGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('population');
  fields.add('measureScore');
  fields.add('stratifier');
end;

{ TFhirMeasureReportGroup }

Procedure TFhirMeasureReportGroup.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMeasureReportGroup.GetPopulationList : TFhirMeasureReportGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMeasureReportGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

Procedure TFhirMeasureReportGroup.SetMeasureScore(value : TFhirDecimal);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

Function TFhirMeasureReportGroup.GetMeasureScoreST : String;
begin
  if FMeasureScore = nil then
    result := ''
  else
    result := FMeasureScore.value;
end;

Procedure TFhirMeasureReportGroup.SetMeasureScoreST(value : String);
begin
  if value <> '' then
  begin
    if FMeasureScore = nil then
      FMeasureScore := TFhirDecimal.create;
    FMeasureScore.value := value
  end
  else if FMeasureScore <> nil then
    FMeasureScore.value := '';
end;

Function TFhirMeasureReportGroup.GetStratifierList : TFhirMeasureReportGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
  result := FStratifierList;
end;

Function TFhirMeasureReportGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

function TFhirMeasureReportGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FMeasureScore.sizeInBytes);
  inc(result, FstratifierList.sizeInBytes);
end;

{ TFhirMeasureReportGroupListEnumerator }

Constructor TFhirMeasureReportGroupListEnumerator.Create(list : TFhirMeasureReportGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupListEnumerator.GetCurrent : TFhirMeasureReportGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupList }
procedure TFhirMeasureReportGroupList.AddItem(value: TFhirMeasureReportGroup);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroup');
  add(value);
end;

function TFhirMeasureReportGroupList.Append: TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupList.GetEnumerator : TFhirMeasureReportGroupListEnumerator;
begin
  result := TFhirMeasureReportGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupList.Clone: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Clone);
end;

function TFhirMeasureReportGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupList.GetItemN(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroup;
end;
function TFhirMeasureReportGroupList.IndexOf(value: TFhirMeasureReportGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupList.Insert(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.InsertItem(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupList.Item(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.Link: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Link);
end;

procedure TFhirMeasureReportGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  FhirMeasureReportGroups[index] := value;
end;

procedure TFhirMeasureReportGroupList.SetItemN(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupPopulation }

constructor TFhirMeasureReportGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupPopulation.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FCount.free;
  FPatients.free;
  inherited;
end;

procedure TFhirMeasureReportGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureReportGroupPopulation(oSource).identifier.Clone;
  code := TFhirMeasureReportGroupPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupPopulation(oSource).countElement.Clone;
  patients := TFhirMeasureReportGroupPopulation(oSource).patients.Clone;
end;

procedure TFhirMeasureReportGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'patients') Then
     list.add(self.link, 'patients', FPatients.Link);
end;

procedure TFhirMeasureReportGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patients', 'Reference(List)', false, TFhirReference{TFhirList}, FPatients.Link));{2}
end;

function TFhirMeasureReportGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patients') then
  begin
    Patients := propValue as TFhirReference{TFhirList}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'count') then result := TFhirInteger.create() {5b}
  else if (propName = 'patients') then result := TFhirReference{TFhirList}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'patients') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'patients') then PatientsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'count') then CountElement := asInteger(new){5b}
  else if (propName = 'patients') then PatientsElement := new as TFhirReference{TFhirList}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupPopulation.fhirType : string;
begin
  result := 'population';
end;

function TFhirMeasureReportGroupPopulation.Link : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Link);
end;

function TFhirMeasureReportGroupPopulation.Clone : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupPopulation.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReportGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupPopulation(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(countElement, o.countElement, true) and compareDeep(patientsElement, o.patientsElement, true);
  end;
end;

function TFhirMeasureReportGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FPatients);
end;

procedure TFhirMeasureReportGroupPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('count');
  fields.add('patients');
end;

{ TFhirMeasureReportGroupPopulation }

Procedure TFhirMeasureReportGroupPopulation.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureReportGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureReportGroupPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirMeasureReportGroupPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirMeasureReportGroupPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Procedure TFhirMeasureReportGroupPopulation.SetPatients(value : TFhirReference{TFhirList});
begin
  FPatients.free;
  FPatients := value;
end;

function TFhirMeasureReportGroupPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FPatients.sizeInBytes);
end;

{ TFhirMeasureReportGroupPopulationListEnumerator }

Constructor TFhirMeasureReportGroupPopulationListEnumerator.Create(list : TFhirMeasureReportGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupPopulationList }
procedure TFhirMeasureReportGroupPopulationList.AddItem(value: TFhirMeasureReportGroupPopulation);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupPopulation');
  add(value);
end;

function TFhirMeasureReportGroupPopulationList.Append: TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupPopulationList.GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupPopulationList.Clone: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupPopulation;
end;
function TFhirMeasureReportGroupPopulationList.IndexOf(value: TFhirMeasureReportGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupPopulationList.Insert(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupPopulationList.Item(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.Link: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  FhirMeasureReportGroupPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifier }

constructor TFhirMeasureReportGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifier.Destroy;
begin
  FIdentifier.free;
  FStratumList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureReportGroupStratifier(oSource).identifier.Clone;
  if (TFhirMeasureReportGroupStratifier(oSource).FStratumList = nil) then
  begin
    FStratumList.free;
    FStratumList := nil;
  end
  else
  begin
    if FStratumList = nil then
      FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
    FStratumList.Assign(TFhirMeasureReportGroupStratifier(oSource).FStratumList);
  end;
end;

procedure TFhirMeasureReportGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'stratum') Then
    list.addAll(self, 'stratum', FStratumList);
end;

procedure TFhirMeasureReportGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stratum', '', true, TFhirMeasureReportGroupStratifierStratum, FStratumList.Link)){3};
end;

function TFhirMeasureReportGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'stratum') then
  begin
    StratumList.add(propValue as TFhirMeasureReportGroupStratifierStratum){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'stratum') then StratumList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratum){2a}
  else inherited;
end;

function TFhirMeasureReportGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'stratum') then result := StratumList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'stratum') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'stratum') then deletePropertyValue('stratum', StratumList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'stratum') then replacePropertyValue('stratum', StratumList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'stratum') then StratumList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifier.fhirType : string;
begin
  result := 'stratifier';
end;

function TFhirMeasureReportGroupStratifier.Link : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Link);
end;

function TFhirMeasureReportGroupStratifier.Clone : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Clone);
end;

function TFhirMeasureReportGroupStratifier.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReportGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifier(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(stratumList, o.stratumList, true);
  end;
end;

function TFhirMeasureReportGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FstratumList);
end;

procedure TFhirMeasureReportGroupStratifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('stratum');
end;

{ TFhirMeasureReportGroupStratifier }

Procedure TFhirMeasureReportGroupStratifier.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMeasureReportGroupStratifier.GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
begin
  if FStratumList = nil then
    FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
  result := FStratumList;
end;

Function TFhirMeasureReportGroupStratifier.GetHasStratumList : boolean;
begin
  result := (FStratumList <> nil) and (FStratumList.count > 0);
end;

function TFhirMeasureReportGroupStratifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FstratumList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierListEnumerator }

Constructor TFhirMeasureReportGroupStratifierListEnumerator.Create(list : TFhirMeasureReportGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierList }
procedure TFhirMeasureReportGroupStratifierList.AddItem(value: TFhirMeasureReportGroupStratifier);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifier');
  add(value);
end;

function TFhirMeasureReportGroupStratifierList.Append: TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierList.GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierList.Clone: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifier;
end;
function TFhirMeasureReportGroupStratifierList.IndexOf(value: TFhirMeasureReportGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierList.Insert(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierList.Item(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.Link: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  FhirMeasureReportGroupStratifiers[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratum }

constructor TFhirMeasureReportGroupStratifierStratum.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratum.Destroy;
begin
  FValue.free;
  FPopulationList.Free;
  FMeasureScore.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratum.Assign(oSource : TFslObject);
begin
  inherited;
  valueElement := TFhirMeasureReportGroupStratifierStratum(oSource).valueElement.Clone;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList);
  end;
  measureScoreElement := TFhirMeasureReportGroupStratifierStratum(oSource).measureScoreElement.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratum.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratum.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', '', true, TFhirMeasureReportGroupStratifierStratumPopulation, FPopulationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'measureScore', 'decimal', false, TFhirDecimal, FMeasureScore.Link));{2}
end;

function TFhirMeasureReportGroupStratifierStratum.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupStratifierStratumPopulation){2a};
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratum.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumPopulation){2a}
  else inherited;
end;

function TFhirMeasureReportGroupStratifierStratum.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else if (propName = 'measureScore') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratum.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'string'
  else if (propName = 'population') then result := ''
  else if (propName = 'measureScore') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratum.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratum.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratum.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratum.fhirType : string;
begin
  result := 'stratum';
end;

function TFhirMeasureReportGroupStratifierStratum.Link : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratum.Clone : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratum.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReportGroupStratifierStratum;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratum)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratum(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(populationList, o.populationList, true) and
      compareDeep(measureScoreElement, o.measureScoreElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratum.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore);
end;

procedure TFhirMeasureReportGroupStratifierStratum.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('population');
  fields.add('measureScore');
end;

{ TFhirMeasureReportGroupStratifierStratum }

Procedure TFhirMeasureReportGroupStratifierStratum.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirMeasureReportGroupStratifierStratum.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Function TFhirMeasureReportGroupStratifierStratum.GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

Procedure TFhirMeasureReportGroupStratifierStratum.SetMeasureScore(value : TFhirDecimal);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetMeasureScoreST : String;
begin
  if FMeasureScore = nil then
    result := ''
  else
    result := FMeasureScore.value;
end;

Procedure TFhirMeasureReportGroupStratifierStratum.SetMeasureScoreST(value : String);
begin
  if value <> '' then
  begin
    if FMeasureScore = nil then
      FMeasureScore := TFhirDecimal.create;
    FMeasureScore.value := value
  end
  else if FMeasureScore <> nil then
    FMeasureScore.value := '';
end;

function TFhirMeasureReportGroupStratifierStratum.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FMeasureScore.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumListEnumerator }

Constructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratum;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumList }
procedure TFhirMeasureReportGroupStratifierStratumList.AddItem(value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratum', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratum');
  add(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Append: TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumList.Clone: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratum;
end;
function TFhirMeasureReportGroupStratifierStratumList.IndexOf(value: TFhirMeasureReportGroupStratifierStratum): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.Link: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  FhirMeasureReportGroupStratifierStrata[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

constructor TFhirMeasureReportGroupStratifierStratumPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulation.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FCount.free;
  FPatients.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).identifier.Clone;
  code := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).countElement.Clone;
  patients := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).patients.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'patients') Then
     list.add(self.link, 'patients', FPatients.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patients', 'Reference(List)', false, TFhirReference{TFhirList}, FPatients.Link));{2}
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patients') then
  begin
    Patients := propValue as TFhirReference{TFhirList}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'count') then result := TFhirInteger.create() {5b}
  else if (propName = 'patients') then result := TFhirReference{TFhirList}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'patients') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'patients') then PatientsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'count') then CountElement := asInteger(new){5b}
  else if (propName = 'patients') then PatientsElement := new as TFhirReference{TFhirList}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.fhirType : string;
begin
  result := 'population';
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Link : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Clone : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumPopulation(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(countElement, o.countElement, true) and compareDeep(patientsElement, o.patientsElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FPatients);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('count');
  fields.add('patients');
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirMeasureReportGroupStratifierStratumPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetPatients(value : TFhirReference{TFhirList});
begin
  FPatients.free;
  FPatients := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FPatients.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator }

Constructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationList }
procedure TFhirMeasureReportGroupStratifierStratumPopulationList.AddItem(value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumPopulation');
  add(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Append: TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Clone: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation;
end;
function TFhirMeasureReportGroupStratifierStratumPopulationList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Link: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  FhirMeasureReportGroupStratifierStratumPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReport }

constructor TFhirMeasureReport.Create;
begin
  inherited;
end;

destructor TFhirMeasureReport.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FMeasure.free;
  FPatient.free;
  FDate.free;
  FReportingOrganization.free;
  FPeriod.free;
  FGroupList.Free;
  FEvaluatedResources.free;
  inherited;
end;

function TFhirMeasureReport.GetResourceType : TFhirResourceType;
begin
  result := frtMeasureReport;
end;

procedure TFhirMeasureReport.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureReport(oSource).identifier.Clone;
  FStatus := TFhirMeasureReport(oSource).FStatus.Link;
  FType_ := TFhirMeasureReport(oSource).FType_.Link;
  measure := TFhirMeasureReport(oSource).measure.Clone;
  patient := TFhirMeasureReport(oSource).patient.Clone;
  dateElement := TFhirMeasureReport(oSource).dateElement.Clone;
  reportingOrganization := TFhirMeasureReport(oSource).reportingOrganization.Clone;
  period := TFhirMeasureReport(oSource).period.Clone;
  if (TFhirMeasureReport(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureReportGroupList.Create;
    FGroupList.Assign(TFhirMeasureReport(oSource).FGroupList);
  end;
  evaluatedResources := TFhirMeasureReport(oSource).evaluatedResources.Clone;
end;

procedure TFhirMeasureReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'reportingOrganization') Then
     list.add(self.link, 'reportingOrganization', FReportingOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'evaluatedResources') Then
     list.add(self.link, 'evaluatedResources', FEvaluatedResources.Link);
end;

procedure TFhirMeasureReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'measure', 'Reference(Measure)', false, TFhirReference{TFhirMeasure}, FMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reportingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FReportingOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirMeasureReportGroup, FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'evaluatedResources', 'Reference(Bundle)', false, TFhirReference{TFhirBundle}, FEvaluatedResources.Link));{2}
end;

function TFhirMeasureReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'measure') then
  begin
    Measure := propValue as TFhirReference{TFhirMeasure}{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reportingOrganization') then
  begin
    ReportingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureReportGroup){2a};
    result := propValue;
  end
  else if (propName = 'evaluatedResources') then
  begin
    EvaluatedResources := propValue as TFhirReference{TFhirBundle}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMeasureReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureReportGroup){2a}
  else inherited;
end;

function TFhirMeasureReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'measure') then result := TFhirReference{TFhirMeasure}.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reportingOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'group') then result := GroupList.new(){2}
  else if (propName = 'evaluatedResources') then result := TFhirReference{TFhirBundle}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'measure') then result := 'Reference'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'reportingOrganization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'group') then result := ''
  else if (propName = 'evaluatedResources') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'measure') then MeasureElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'reportingOrganization') then ReportingOrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else if (propName = 'evaluatedResources') then EvaluatedResourcesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, new){4}
  else if (propName = 'measure') then MeasureElement := new as TFhirReference{TFhirMeasure}{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'reportingOrganization') then ReportingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else if (propName = 'evaluatedResources') then EvaluatedResourcesElement := new as TFhirReference{TFhirBundle}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReport.fhirType : string;
begin
  result := 'MeasureReport';
end;

function TFhirMeasureReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FMeasure) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FReportingOrganization) and isEmptyProp(FPeriod) and isEmptyProp(FgroupList) and isEmptyProp(FEvaluatedResources);
end;

function TFhirMeasureReport.equals(other : TObject) : boolean;
var
  o : TFhirMeasureReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReport)) then
    result := false
  else
  begin
    o := TFhirMeasureReport(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(measureElement, o.measureElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(reportingOrganizationElement, o.reportingOrganizationElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(groupList, o.groupList, true) and
      compareDeep(evaluatedResourcesElement, o.evaluatedResourcesElement, true);
  end;
end;

function TFhirMeasureReport.Link : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Link);
end;

function TFhirMeasureReport.Clone : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Clone);
end;

procedure TFhirMeasureReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('measure');
  fields.add('patient');
  fields.add('date');
  fields.add('reportingOrganization');
  fields.add('period');
  fields.add('group');
  fields.add('evaluatedResources');
end;

{ TFhirMeasureReport }

Procedure TFhirMeasureReport.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMeasureReport.GetStatusST : TFhirMeasureReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMeasureReportStatusEnum(0)
  else
    result := TFhirMeasureReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportStatusEnum, FStatus.value));
end;

Procedure TFhirMeasureReport.SetStatusST(value : TFhirMeasureReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[value], CODES_TFhirMeasureReportStatusEnum[value]);
end;

Procedure TFhirMeasureReport.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMeasureReport.GetType_ST : TFhirMeasureReportTypeEnum;
begin
  if FType_ = nil then
    result := TFhirMeasureReportTypeEnum(0)
  else
    result := TFhirMeasureReportTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportTypeEnum, FType_.value));
end;

Procedure TFhirMeasureReport.SetType_ST(value : TFhirMeasureReportTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[value], CODES_TFhirMeasureReportTypeEnum[value]);
end;

Procedure TFhirMeasureReport.SetMeasure(value : TFhirReference{TFhirMeasure});
begin
  FMeasure.free;
  FMeasure := value;
end;

Procedure TFhirMeasureReport.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirMeasureReport.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirMeasureReport.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirMeasureReport.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirMeasureReport.SetReportingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FReportingOrganization.free;
  FReportingOrganization := value;
end;

Procedure TFhirMeasureReport.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirMeasureReport.GetGroupList : TFhirMeasureReportGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureReportGroupList.Create;
  result := FGroupList;
end;

Function TFhirMeasureReport.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

Procedure TFhirMeasureReport.SetEvaluatedResources(value : TFhirReference{TFhirBundle});
begin
  FEvaluatedResources.free;
  FEvaluatedResources := value;
end;

function TFhirMeasureReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FMeasure.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FReportingOrganization.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
  inc(result, FEvaluatedResources.sizeInBytes);
end;

{ TFhirMeasureReportListEnumerator }

Constructor TFhirMeasureReportListEnumerator.Create(list : TFhirMeasureReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportListEnumerator.GetCurrent : TFhirMeasureReport;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportList }
procedure TFhirMeasureReportList.AddItem(value: TFhirMeasureReport);
begin
  assert(value.ClassName = 'TFhirMeasureReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReport');
  add(value);
end;

function TFhirMeasureReportList.Append: TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportList.GetEnumerator : TFhirMeasureReportListEnumerator;
begin
  result := TFhirMeasureReportListEnumerator.Create(self.link);
end;

function TFhirMeasureReportList.Clone: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Clone);
end;

function TFhirMeasureReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportList.GetItemN(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReport;
end;
function TFhirMeasureReportList.IndexOf(value: TFhirMeasureReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportList.Insert(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.InsertItem(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportList.Item(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.Link: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Link);
end;

procedure TFhirMeasureReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportList.SetItemByIndex(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  FhirMeasureReports[index] := value;
end;

procedure TFhirMeasureReportList.SetItemN(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASUREREPORT}

{$IFDEF FHIR_MEDICATION}

{ TFhirMedicationIngredient }

constructor TFhirMedicationIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationIngredient(oSource).isActiveElement.Clone;
  amount := TFhirMedicationIngredient(oSource).amount.Clone;
end;

procedure TFhirMedicationIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirMedicationIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Substance|Medication)', false, TFhirType, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', false, TFhirRatio, FAmount.Link));{2}
end;

function TFhirMedicationIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else if (propName = 'isActive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'amount') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationIngredient.fhirType : string;
begin
  result := 'ingredient';
end;

function TFhirMedicationIngredient.Link : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Link);
end;

function TFhirMedicationIngredient.Clone : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Clone);
end;

function TFhirMedicationIngredient.equals(other : TObject) : boolean;
var
  o : TFhirMedicationIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirMedicationIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FAmount);
end;

procedure TFhirMedicationIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('isActive');
  fields.add('amount');
end;

{ TFhirMedicationIngredient }

Procedure TFhirMedicationIngredient.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

Function TFhirMedicationIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

Procedure TFhirMedicationIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

Procedure TFhirMedicationIngredient.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedicationIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FIsActive.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirMedicationIngredientListEnumerator }

Constructor TFhirMedicationIngredientListEnumerator.Create(list : TFhirMedicationIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationIngredientListEnumerator.GetCurrent : TFhirMedicationIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationIngredientList }
procedure TFhirMedicationIngredientList.AddItem(value: TFhirMedicationIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationIngredient');
  add(value);
end;

function TFhirMedicationIngredientList.Append: TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationIngredientList.GetEnumerator : TFhirMedicationIngredientListEnumerator;
begin
  result := TFhirMedicationIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationIngredientList.Clone: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Clone);
end;

function TFhirMedicationIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationIngredientList.GetItemN(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationIngredient;
end;
function TFhirMedicationIngredientList.IndexOf(value: TFhirMedicationIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationIngredientList.Insert(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.InsertItem(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationIngredientList.Item(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.Link: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Link);
end;

procedure TFhirMedicationIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  FhirMedicationIngredients[index] := value;
end;

procedure TFhirMedicationIngredientList.SetItemN(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackage }

constructor TFhirMedicationPackage.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackage.Destroy;
begin
  FContainer.free;
  FContentList.Free;
  FBatchList.Free;
  inherited;
end;

procedure TFhirMedicationPackage.Assign(oSource : TFslObject);
begin
  inherited;
  container := TFhirMedicationPackage(oSource).container.Clone;
  if (TFhirMedicationPackage(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirMedicationPackageContentList.Create;
    FContentList.Assign(TFhirMedicationPackage(oSource).FContentList);
  end;
  if (TFhirMedicationPackage(oSource).FBatchList = nil) then
  begin
    FBatchList.free;
    FBatchList := nil;
  end
  else
  begin
    if FBatchList = nil then
      FBatchList := TFhirMedicationPackageBatchList.Create;
    FBatchList.Assign(TFhirMedicationPackage(oSource).FBatchList);
  end;
end;

procedure TFhirMedicationPackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'container') Then
     list.add(self.link, 'container', FContainer.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'batch') Then
    list.addAll(self, 'batch', FBatchList);
end;

procedure TFhirMedicationPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'container', 'CodeableConcept', false, TFhirCodeableConcept, FContainer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirMedicationPackageContent, FContentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'batch', '', true, TFhirMedicationPackageBatch, FBatchList.Link)){3};
end;

function TFhirMedicationPackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'container') then
  begin
    Container := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirMedicationPackageContent){2a};
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    BatchList.add(propValue as TFhirMedicationPackageBatch){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationPackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirMedicationPackageContent){2a}
  else if (propName = 'batch') then BatchList.insertItem(index, propValue as TFhirMedicationPackageBatch){2a}
  else inherited;
end;

function TFhirMedicationPackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'container') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'content') then result := ContentList.new(){2}
  else if (propName = 'batch') then result := BatchList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationPackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'container') then result := 'CodeableConcept'
  else if (propName = 'content') then result := ''
  else if (propName = 'batch') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationPackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'container') then ContainerElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else if (propName = 'batch') then deletePropertyValue('batch', BatchList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationPackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'container') then ContainerElement := new as TFhirCodeableConcept{4}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else if (propName = 'batch') then replacePropertyValue('batch', BatchList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationPackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'content') then ContentList.move(source, destination){2a}
  else if (propName = 'batch') then BatchList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationPackage.fhirType : string;
begin
  result := 'package';
end;

function TFhirMedicationPackage.Link : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Link);
end;

function TFhirMedicationPackage.Clone : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Clone);
end;

function TFhirMedicationPackage.equals(other : TObject) : boolean;
var
  o : TFhirMedicationPackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationPackage)) then
    result := false
  else
  begin
    o := TFhirMedicationPackage(other);
    result := compareDeep(containerElement, o.containerElement, true) and compareDeep(contentList, o.contentList, true) and
      compareDeep(batchList, o.batchList, true);
  end;
end;

function TFhirMedicationPackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContainer) and isEmptyProp(FcontentList) and isEmptyProp(FbatchList);
end;

procedure TFhirMedicationPackage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('container');
  fields.add('content');
  fields.add('batch');
end;

{ TFhirMedicationPackage }

Procedure TFhirMedicationPackage.SetContainer(value : TFhirCodeableConcept);
begin
  FContainer.free;
  FContainer := value;
end;

Function TFhirMedicationPackage.GetContentList : TFhirMedicationPackageContentList;
begin
  if FContentList = nil then
    FContentList := TFhirMedicationPackageContentList.Create;
  result := FContentList;
end;

Function TFhirMedicationPackage.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

Function TFhirMedicationPackage.GetBatchList : TFhirMedicationPackageBatchList;
begin
  if FBatchList = nil then
    FBatchList := TFhirMedicationPackageBatchList.Create;
  result := FBatchList;
end;

Function TFhirMedicationPackage.GetHasBatchList : boolean;
begin
  result := (FBatchList <> nil) and (FBatchList.count > 0);
end;

function TFhirMedicationPackage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContainer.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FbatchList.sizeInBytes);
end;

{ TFhirMedicationPackageListEnumerator }

Constructor TFhirMedicationPackageListEnumerator.Create(list : TFhirMedicationPackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationPackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationPackageListEnumerator.GetCurrent : TFhirMedicationPackage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationPackageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationPackageList }
procedure TFhirMedicationPackageList.AddItem(value: TFhirMedicationPackage);
begin
  assert(value.ClassName = 'TFhirMedicationPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackage');
  add(value);
end;

function TFhirMedicationPackageList.Append: TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageList.GetEnumerator : TFhirMedicationPackageListEnumerator;
begin
  result := TFhirMedicationPackageListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageList.Clone: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Clone);
end;

function TFhirMedicationPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageList.GetItemN(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationPackage;
end;
function TFhirMedicationPackageList.IndexOf(value: TFhirMedicationPackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationPackageList.Insert(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageList.InsertItem(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageList.Item(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.Link: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Link);
end;

procedure TFhirMedicationPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageList.SetItemByIndex(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  FhirMedicationPackages[index] := value;
end;

procedure TFhirMedicationPackageList.SetItemN(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageContent }

constructor TFhirMedicationPackageContent.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageContent.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationPackageContent.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationPackageContent(oSource).item.Clone;
  amount := TFhirMedicationPackageContent(oSource).amount.Clone;
end;

procedure TFhirMedicationPackageContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirMedicationPackageContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirMedicationPackageContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationPackageContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationPackageContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationPackageContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationPackageContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationPackageContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationPackageContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationPackageContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirMedicationPackageContent.Link : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Link);
end;

function TFhirMedicationPackageContent.Clone : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Clone);
end;

function TFhirMedicationPackageContent.equals(other : TObject) : boolean;
var
  o : TFhirMedicationPackageContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationPackageContent)) then
    result := false
  else
  begin
    o := TFhirMedicationPackageContent(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirMedicationPackageContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FAmount);
end;

procedure TFhirMedicationPackageContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('amount');
end;

{ TFhirMedicationPackageContent }

Procedure TFhirMedicationPackageContent.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationPackageContent.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedicationPackageContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirMedicationPackageContentListEnumerator }

Constructor TFhirMedicationPackageContentListEnumerator.Create(list : TFhirMedicationPackageContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationPackageContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationPackageContentListEnumerator.GetCurrent : TFhirMedicationPackageContent;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationPackageContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationPackageContentList }
procedure TFhirMedicationPackageContentList.AddItem(value: TFhirMedicationPackageContent);
begin
  assert(value.ClassName = 'TFhirMedicationPackageContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageContent');
  add(value);
end;

function TFhirMedicationPackageContentList.Append: TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageContentList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageContentList.GetEnumerator : TFhirMedicationPackageContentListEnumerator;
begin
  result := TFhirMedicationPackageContentListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageContentList.Clone: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Clone);
end;

function TFhirMedicationPackageContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageContentList.GetItemN(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationPackageContent;
end;
function TFhirMedicationPackageContentList.IndexOf(value: TFhirMedicationPackageContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationPackageContentList.Insert(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageContentList.InsertItem(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageContentList.Item(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.Link: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Link);
end;

procedure TFhirMedicationPackageContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageContentList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  FhirMedicationPackageContents[index] := value;
end;

procedure TFhirMedicationPackageContentList.SetItemN(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageBatch }

constructor TFhirMedicationPackageBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationPackageBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationPackageBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationPackageBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationPackageBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationPackageBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));{2}
end;

function TFhirMedicationPackageBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationPackageBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationPackageBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationPackageBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationPackageBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationPackageBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationPackageBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationPackageBatch.fhirType : string;
begin
  result := 'batch';
end;

function TFhirMedicationPackageBatch.Link : TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch(inherited Link);
end;

function TFhirMedicationPackageBatch.Clone : TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch(inherited Clone);
end;

function TFhirMedicationPackageBatch.equals(other : TObject) : boolean;
var
  o : TFhirMedicationPackageBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationPackageBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationPackageBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationPackageBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationPackageBatch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

{ TFhirMedicationPackageBatch }

Procedure TFhirMedicationPackageBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirMedicationPackageBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirMedicationPackageBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirMedicationPackageBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirMedicationPackageBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirMedicationPackageBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

function TFhirMedicationPackageBatch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
end;

{ TFhirMedicationPackageBatchListEnumerator }

Constructor TFhirMedicationPackageBatchListEnumerator.Create(list : TFhirMedicationPackageBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationPackageBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationPackageBatchListEnumerator.GetCurrent : TFhirMedicationPackageBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationPackageBatchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationPackageBatchList }
procedure TFhirMedicationPackageBatchList.AddItem(value: TFhirMedicationPackageBatch);
begin
  assert(value.ClassName = 'TFhirMedicationPackageBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageBatch');
  add(value);
end;

function TFhirMedicationPackageBatchList.Append: TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageBatchList.GetEnumerator : TFhirMedicationPackageBatchListEnumerator;
begin
  result := TFhirMedicationPackageBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageBatchList.Clone: TFhirMedicationPackageBatchList;
begin
  result := TFhirMedicationPackageBatchList(inherited Clone);
end;

function TFhirMedicationPackageBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageBatchList.GetItemN(index: Integer): TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch(ObjectByIndex[index]);
end;

function TFhirMedicationPackageBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationPackageBatch;
end;
function TFhirMedicationPackageBatchList.IndexOf(value: TFhirMedicationPackageBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationPackageBatchList.Insert(index: Integer): TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageBatchList.InsertItem(index: Integer; value: TFhirMedicationPackageBatch);
begin
  assert(value is TFhirMedicationPackageBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageBatchList.Item(index: Integer): TFhirMedicationPackageBatch;
begin
  result := TFhirMedicationPackageBatch(ObjectByIndex[index]);
end;

function TFhirMedicationPackageBatchList.Link: TFhirMedicationPackageBatchList;
begin
  result := TFhirMedicationPackageBatchList(inherited Link);
end;

procedure TFhirMedicationPackageBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageBatch);
begin
  assert(value is TFhirMedicationPackageBatch);
  FhirMedicationPackageBatches[index] := value;
end;

procedure TFhirMedicationPackageBatchList.SetItemN(index: Integer; value: TFhirMedicationPackageBatch);
begin
  assert(value is TFhirMedicationPackageBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FCode.free;
  FStatus.free;
  FIsBrand.free;
  FIsOverTheCounter.free;
  FManufacturer.free;
  FForm.free;
  FIngredientList.Free;
  FPackage.free;
  FImageList.Free;
  inherited;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedication(oSource).code.Clone;
  FStatus := TFhirMedication(oSource).FStatus.Link;
  isBrandElement := TFhirMedication(oSource).isBrandElement.Clone;
  isOverTheCounterElement := TFhirMedication(oSource).isOverTheCounterElement.Clone;
  manufacturer := TFhirMedication(oSource).manufacturer.Clone;
  form := TFhirMedication(oSource).form.Clone;
  if (TFhirMedication(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationIngredientList.Create;
    FIngredientList.Assign(TFhirMedication(oSource).FIngredientList);
  end;
  package := TFhirMedication(oSource).package.Clone;
  if (TFhirMedication(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirMedication(oSource).FImageList);
  end;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'isBrand') Then
     list.add(self.link, 'isBrand', FIsBrand.Link);
  if (child_name = 'isOverTheCounter') Then
     list.add(self.link, 'isOverTheCounter', FIsOverTheCounter.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'package') Then
     list.add(self.link, 'package', FPackage.Link);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'isBrand', 'boolean', false, TFhirBoolean, FIsBrand.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isOverTheCounter', 'boolean', false, TFhirBoolean, FIsOverTheCounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', true, TFhirMedicationIngredient, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'package', '', false, TFhirMedicationPackage, FPackage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link)){3};
end;

function TFhirMedication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusEnum, CODES_TFhirMedicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'isBrand') then
  begin
    IsBrandElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'isOverTheCounter') then
  begin
    IsOverTheCounterElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationIngredient){2a};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    Package := propValue as TFhirMedicationPackage{4b};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationIngredient){2a}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirMedication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'isBrand') then result := TFhirBoolean.create() {5b}
  else if (propName = 'isOverTheCounter') then result := TFhirBoolean.create() {5b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'package') then result := TFhirMedicationPackage.create(){4b}
  else if (propName = 'image') then result := ImageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'isBrand') then result := 'boolean'
  else if (propName = 'isOverTheCounter') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'ingredient') then result := ''
  else if (propName = 'package') then result := ''
  else if (propName = 'image') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'isBrand') then IsBrandElement := nil
  else if (propName = 'isOverTheCounter') then IsOverTheCounterElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'package') then PackageElement := nil
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusEnum, CODES_TFhirMedicationStatusEnum, new){4}
  else if (propName = 'isBrand') then IsBrandElement := asBoolean(new){5b}
  else if (propName = 'isOverTheCounter') then IsOverTheCounterElement := asBoolean(new){5b}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'package') then PackageElement := new as TFhirMedicationPackage{4}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FIsBrand) and isEmptyProp(FIsOverTheCounter) and isEmptyProp(FManufacturer) and isEmptyProp(FForm) and isEmptyProp(FingredientList) and isEmptyProp(FPackage) and isEmptyProp(FimageList);
end;

function TFhirMedication.equals(other : TObject) : boolean;
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(isBrandElement, o.isBrandElement, true) and compareDeep(isOverTheCounterElement, o.isOverTheCounterElement, true) and
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(formElement, o.formElement, true) and
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(packageElement, o.packageElement, true) and
      compareDeep(imageList, o.imageList, true);
  end;
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('isBrand');
  fields.add('isOverTheCounter');
  fields.add('manufacturer');
  fields.add('form');
  fields.add('ingredient');
  fields.add('package');
  fields.add('image');
end;

{ TFhirMedication }

Procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedication.GetStatusST : TFhirMedicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusEnum(0)
  else
    result := TFhirMedicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusEnum, FStatus.value));
end;

Procedure TFhirMedication.SetStatusST(value : TFhirMedicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusEnum[value], CODES_TFhirMedicationStatusEnum[value]);
end;

Procedure TFhirMedication.SetIsBrand(value : TFhirBoolean);
begin
  FIsBrand.free;
  FIsBrand := value;
end;

Function TFhirMedication.GetIsBrandST : Boolean;
begin
  if FIsBrand = nil then
    result := false
  else
    result := FIsBrand.value;
end;

Procedure TFhirMedication.SetIsBrandST(value : Boolean);
begin
  if FIsBrand = nil then
    FIsBrand := TFhirBoolean.create;
  FIsBrand.value := value
end;

Procedure TFhirMedication.SetIsOverTheCounter(value : TFhirBoolean);
begin
  FIsOverTheCounter.free;
  FIsOverTheCounter := value;
end;

Function TFhirMedication.GetIsOverTheCounterST : Boolean;
begin
  if FIsOverTheCounter = nil then
    result := false
  else
    result := FIsOverTheCounter.value;
end;

Procedure TFhirMedication.SetIsOverTheCounterST(value : Boolean);
begin
  if FIsOverTheCounter = nil then
    FIsOverTheCounter := TFhirBoolean.create;
  FIsOverTheCounter.value := value
end;

Procedure TFhirMedication.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirMedication.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirMedication.GetIngredientList : TFhirMedicationIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationIngredientList.Create;
  result := FIngredientList;
end;

Function TFhirMedication.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Procedure TFhirMedication.SetPackage(value : TFhirMedicationPackage);
begin
  FPackage.free;
  FPackage := value;
end;

Function TFhirMedication.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

Function TFhirMedication.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

function TFhirMedication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIsBrand.sizeInBytes);
  inc(result, FIsOverTheCounter.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FPackage.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
end;

{ TFhirMedicationListEnumerator }

Constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationList }
procedure TFhirMedicationList.AddItem(value: TFhirMedication);
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_MESSAGEHEADER}

{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderDestination(oSource).nameElement.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointElement := TFhirMessageHeaderDestination(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
end;

function TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderDestination.fhirType : string;
begin
  result := 'destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

function TFhirMessageHeaderDestination.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderDestination)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderDestination(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTarget) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderDestination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('target');
  fields.add('endpoint');
end;

{ TFhirMessageHeaderDestination }

Procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirMessageHeaderDestination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationListEnumerator }

Constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderDestinationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationList }
procedure TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination);
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
end;

function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderDestination;
end;
function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderSource(oSource).nameElement.Clone;
  softwareElement := TFhirMessageHeaderSource(oSource).softwareElement.Clone;
  versionElement := TFhirMessageHeaderSource(oSource).versionElement.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointElement := TFhirMessageHeaderSource(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', false, TFhirString, FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', false, TFhirContactPoint, FContact.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
end;

function TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    SoftwareElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirContactPoint{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'software') then result := TFhirString.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := TFhirContactPoint.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'software') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'contact') then ContactElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'software') then SoftwareElement := asString(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'contact') then ContactElement := new as TFhirContactPoint{4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

function TFhirMessageHeaderSource.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderSource)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderSource(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(softwareElement, o.softwareElement, true) and
      compareDeep(versionElement, o.versionElement, true) and compareDeep(contactElement, o.contactElement, true) and
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FSoftware) and isEmptyProp(FVersion) and isEmptyProp(FContact) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('software');
  fields.add('version');
  fields.add('contact');
  fields.add('endpoint');
end;

{ TFhirMessageHeaderSource }

Procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

Procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageHeaderSource.SetContact(value : TFhirContactPoint);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirMessageHeaderSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FSoftware.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FContact.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
end;

{ TFhirMessageHeaderSourceListEnumerator }

Constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderSourceList }
procedure TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource);
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
end;

function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderSource;
end;
function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirMessageHeaderResponse(oSource).identifierElement.Clone;
  FCode := TFhirMessageHeaderResponse(oSource).FCode.Link;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', false, TFhirId, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Reference(OperationOutcome)', false, TFhirReference{TFhirOperationOutcome}, FDetails.Link));{2}
end;

function TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirReference{TFhirOperationOutcome}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirId.create() {5b}
  else if (propName = 'details') then result := TFhirReference{TFhirOperationOutcome}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'id'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asId(new){5b}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirReference{TFhirOperationOutcome}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

function TFhirMessageHeaderResponse.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderResponse)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(detailsElement, o.detailsElement, true);
  end;
end;

function TFhirMessageHeaderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FDetails);
end;

procedure TFhirMessageHeaderResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('details');
end;

{ TFhirMessageHeaderResponse }

Procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseCodeEnum;
begin
  if FCode = nil then
    result := TFhirResponseCodeEnum(0)
  else
    result := TFhirResponseCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirResponseCodeEnum, FCode.value));
end;

Procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseCodeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResponseCodeEnum[value], CODES_TFhirResponseCodeEnum[value]);
end;

Procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;

function TFhirMessageHeaderResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
end;

{ TFhirMessageHeaderResponseListEnumerator }

Constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderResponseList }
procedure TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse);
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
end;

function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderResponse;
end;
function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeader }

constructor TFhirMessageHeader.Create;
begin
  inherited;
end;

destructor TFhirMessageHeader.Destroy;
begin
  FEvent.free;
  FDestinationList.Free;
  FReceiver.free;
  FSender.free;
  FTimestamp.free;
  FEnterer.free;
  FAuthor.free;
  FSource.free;
  FResponsible.free;
  FReason.free;
  FResponse.free;
  FFocusList.Free;
  inherited;
end;

function TFhirMessageHeader.GetResourceType : TFhirResourceType;
begin
  result := frtMessageHeader;
end;

procedure TFhirMessageHeader.Assign(oSource : TFslObject);
begin
  inherited;
  event := TFhirMessageHeader(oSource).event.Clone;
  if (TFhirMessageHeader(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirMessageHeaderDestinationList.Create;
    FDestinationList.Assign(TFhirMessageHeader(oSource).FDestinationList);
  end;
  receiver := TFhirMessageHeader(oSource).receiver.Clone;
  sender := TFhirMessageHeader(oSource).sender.Clone;
  timestampElement := TFhirMessageHeader(oSource).timestampElement.Clone;
  enterer := TFhirMessageHeader(oSource).enterer.Clone;
  author := TFhirMessageHeader(oSource).author.Clone;
  source := TFhirMessageHeader(oSource).source.Clone;
  responsible := TFhirMessageHeader(oSource).responsible.Clone;
  reason := TFhirMessageHeader(oSource).reason.Clone;
  response := TFhirMessageHeader(oSource).response.Clone;
  if (TFhirMessageHeader(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList{TFhirReference}.Create;
    FFocusList.Assign(TFhirMessageHeader(oSource).FFocusList);
  end;
end;

procedure TFhirMessageHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
end;

procedure TFhirMessageHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event', 'Coding', false, TFhirCoding, FEvent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', '', true, TFhirMessageHeaderDestination, FDestinationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FReceiver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirMessageHeaderSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirMessageHeaderResponse, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference(Any)', true, TFhirReference{TFhirReference}, FFocusList.Link)){3};
end;

function TFhirMessageHeader.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'event') then
  begin
    Event := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirMessageHeaderDestination){2a};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    Receiver := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirMessageHeaderSource{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirMessageHeaderResponse{4b};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMessageHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirMessageHeaderDestination){2a}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirMessageHeader.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'event') then result := TFhirCoding.create(){4b}
  else if (propName = 'destination') then result := DestinationList.new(){2}
  else if (propName = 'receiver') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'sender') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'timestamp') then result := TFhirInstant.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'source') then result := TFhirMessageHeaderSource.create(){4b}
  else if (propName = 'responsible') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'response') then result := TFhirMessageHeaderResponse.create(){4b}
  else if (propName = 'focus') then result := FocusList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event') then result := 'Coding'
  else if (propName = 'destination') then result := ''
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := ''
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'response') then result := ''
  else if (propName = 'focus') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeader.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'event') then EventElement := nil
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value) {2}
  else if (propName = 'receiver') then ReceiverElement := nil
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'event') then EventElement := new as TFhirCoding{4}
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new) {2}
  else if (propName = 'receiver') then ReceiverElement := new as TFhirReference{Resource}{4}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'timestamp') then TimestampElement := asInstant(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'source') then SourceElement := new as TFhirMessageHeaderSource{4}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'response') then ResponseElement := new as TFhirMessageHeaderResponse{4}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeader.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'destination') then DestinationList.move(source, destination){2a}
  else if (propName = 'focus') then FocusList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeader.fhirType : string;
begin
  result := 'MessageHeader';
end;

function TFhirMessageHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEvent) and isEmptyProp(FdestinationList) and isEmptyProp(FReceiver) and isEmptyProp(FSender) and isEmptyProp(FTimestamp) and isEmptyProp(FEnterer) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FResponsible) and isEmptyProp(FReason) and isEmptyProp(FResponse) and isEmptyProp(FfocusList);
end;

function TFhirMessageHeader.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeader)) then
    result := false
  else
  begin
    o := TFhirMessageHeader(other);
    result := compareDeep(eventElement, o.eventElement, true) and compareDeep(destinationList, o.destinationList, true) and
      compareDeep(receiverElement, o.receiverElement, true) and compareDeep(senderElement, o.senderElement, true) and
      compareDeep(timestampElement, o.timestampElement, true) and compareDeep(entererElement, o.entererElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(focusList, o.focusList, true);
  end;
end;

function TFhirMessageHeader.Link : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Link);
end;

function TFhirMessageHeader.Clone : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Clone);
end;

procedure TFhirMessageHeader.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('event');
  fields.add('destination');
  fields.add('receiver');
  fields.add('sender');
  fields.add('timestamp');
  fields.add('enterer');
  fields.add('author');
  fields.add('source');
  fields.add('responsible');
  fields.add('reason');
  fields.add('response');
  fields.add('focus');
end;

{ TFhirMessageHeader }

Procedure TFhirMessageHeader.SetEvent(value : TFhirCoding);
begin
  FEvent.free;
  FEvent := value;
end;

Function TFhirMessageHeader.GetDestinationList : TFhirMessageHeaderDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirMessageHeaderDestinationList.Create;
  result := FDestinationList;
end;

Function TFhirMessageHeader.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

Procedure TFhirMessageHeader.SetReceiver(value : TFhirReference{Resource});
begin
  FReceiver.free;
  FReceiver := value;
end;

Procedure TFhirMessageHeader.SetSender(value : TFhirReference{Resource});
begin
  FSender.free;
  FSender := value;
end;

Procedure TFhirMessageHeader.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirMessageHeader.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

Procedure TFhirMessageHeader.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

Procedure TFhirMessageHeader.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirMessageHeader.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirMessageHeader.SetSource(value : TFhirMessageHeaderSource);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirMessageHeader.SetResponsible(value : TFhirReference{Resource});
begin
  FResponsible.free;
  FResponsible := value;
end;

Procedure TFhirMessageHeader.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirMessageHeader.SetResponse(value : TFhirMessageHeaderResponse);
begin
  FResponse.free;
  FResponse := value;
end;

Function TFhirMessageHeader.GetFocusList : TFhirReferenceList{TFhirReference};
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList{TFhirReference}.Create;
  result := FFocusList;
end;

Function TFhirMessageHeader.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

function TFhirMessageHeader.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEvent.sizeInBytes);
  inc(result, FdestinationList.sizeInBytes);
  inc(result, FReceiver.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FTimestamp.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
end;

{ TFhirMessageHeaderListEnumerator }

Constructor TFhirMessageHeaderListEnumerator.Create(list : TFhirMessageHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderListEnumerator.GetCurrent : TFhirMessageHeader;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderList }
procedure TFhirMessageHeaderList.AddItem(value: TFhirMessageHeader);
begin
  assert(value.ClassName = 'TFhirMessageHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeader');
  add(value);
end;

function TFhirMessageHeaderList.Append: TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderList.GetEnumerator : TFhirMessageHeaderListEnumerator;
begin
  result := TFhirMessageHeaderListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderList.Clone: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Clone);
end;

function TFhirMessageHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderList.GetItemN(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeader;
end;
function TFhirMessageHeaderList.IndexOf(value: TFhirMessageHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderList.Insert(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.InsertItem(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderList.Item(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.Link: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Link);
end;

procedure TFhirMessageHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderList.SetItemByIndex(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  FhirMessageHeaders[index] := value;
end;

procedure TFhirMessageHeaderList.SetItemN(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_OPERATIONOUTCOME}

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FCode.free;
  FDetails.free;
  FDiagnostics.free;
  FLocationList.Free;
  FExpressionList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TFslObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  FCode := TFhirOperationOutcomeIssue(oSource).FCode.Link;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  diagnosticsElement := TFhirOperationOutcomeIssue(oSource).diagnosticsElement.Clone;
  if (TFhirOperationOutcomeIssue(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirStringList.Create;
    FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
  end;
  if (TFhirOperationOutcomeIssue(oSource).FExpressionList = nil) then
  begin
    FExpressionList.free;
    FExpressionList := nil;
  end
  else
  begin
    if FExpressionList = nil then
      FExpressionList := TFhirStringList.Create;
    FExpressionList.Assign(TFhirOperationOutcomeIssue(oSource).FExpressionList);
  end;
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
  if (child_name = 'diagnostics') Then
     list.add(self.link, 'diagnostics', FDiagnostics.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'expression') Then
    list.addAll(self, 'expression', FExpressionList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'CodeableConcept', false, TFhirCodeableConcept, FDetails.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnostics', 'string', false, TFhirString, FDiagnostics.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', true, TFhirString, FLocationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'expression', 'string', true, TFhirString, FExpressionList.Link)){3};
end;

function TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'diagnostics') then
  begin
    DiagnosticsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'expression') then
  begin
    ExpressionList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcomeIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'location') then LocationList.insertItem(index, asString(propValue)){2}
  else if (propName = 'expression') then ExpressionList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirOperationOutcomeIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'details') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'diagnostics') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'expression') then result := ExpressionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcomeIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'severity') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'CodeableConcept'
  else if (propName = 'diagnostics') then result := 'string'
  else if (propName = 'location') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcomeIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else if (propName = 'diagnostics') then DiagnosticsElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'expression') then deletePropertyValue('expression', ExpressionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcomeIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, new){4}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirCodeableConcept{4}
  else if (propName = 'diagnostics') then DiagnosticsElement := asString(new){5b}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'expression') then replacePropertyValue('expression', ExpressionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcomeIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'location') then LocationList.move(source, destination){2}
  else if (propName = 'expression') then ExpressionList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcomeIssue.fhirType : string;
begin
  result := 'issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

function TFhirOperationOutcomeIssue.equals(other : TObject) : boolean;
var
  o : TFhirOperationOutcomeIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcomeIssue)) then
    result := false
  else
  begin
    o := TFhirOperationOutcomeIssue(other);
    result := compareDeep(severityElement, o.severityElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(detailsElement, o.detailsElement, true) and compareDeep(diagnosticsElement, o.diagnosticsElement, true) and
      compareDeep(locationList, o.locationList, true) and compareDeep(expressionList, o.expressionList, true);
  end;
end;

function TFhirOperationOutcomeIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FDetails) and isEmptyProp(FDiagnostics) and isEmptyProp(FlocationList) and isEmptyProp(FexpressionList);
end;

procedure TFhirOperationOutcomeIssue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('severity');
  fields.add('code');
  fields.add('details');
  fields.add('diagnostics');
  fields.add('location');
  fields.add('expression');
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverityEnum(0)
  else
    result := TFhirIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverityEnum, FSeverity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[value], CODES_TFhirIssueSeverityEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirOperationOutcomeIssue.GetCodeST : TFhirIssueTypeEnum;
begin
  if FCode = nil then
    result := TFhirIssueTypeEnum(0)
  else
    result := TFhirIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueTypeEnum, FCode.value));
end;

Procedure TFhirOperationOutcomeIssue.SetCodeST(value : TFhirIssueTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[value], CODES_TFhirIssueTypeEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirCodeableConcept);
begin
  FDetails.free;
  FDetails := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnostics(value : TFhirString);
begin
  FDiagnostics.free;
  FDiagnostics := value;
end;

Function TFhirOperationOutcomeIssue.GetDiagnosticsST : String;
begin
  if FDiagnostics = nil then
    result := ''
  else
    result := FDiagnostics.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnosticsST(value : String);
begin
  if value <> '' then
  begin
    if FDiagnostics = nil then
      FDiagnostics := TFhirString.create;
    FDiagnostics.value := value
  end
  else if FDiagnostics <> nil then
    FDiagnostics.value := '';
end;

Function TFhirOperationOutcomeIssue.GetLocationList : TFhirStringList;
begin
  if FLocationList = nil then
    FLocationList := TFhirStringList.Create;
  result := FLocationList;
end;

Function TFhirOperationOutcomeIssue.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Function TFhirOperationOutcomeIssue.GetExpressionList : TFhirStringList;
begin
  if FExpressionList = nil then
    FExpressionList := TFhirStringList.Create;
  result := FExpressionList;
end;

Function TFhirOperationOutcomeIssue.GetHasExpressionList : boolean;
begin
  result := (FExpressionList <> nil) and (FExpressionList.count > 0);
end;

function TFhirOperationOutcomeIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSeverity.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
  inc(result, FDiagnostics.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FexpressionList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueListEnumerator }

Constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;

function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcomeIssue;
end;
function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcome }

constructor TFhirOperationOutcome.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcome.Destroy;
begin
  FIssueList.Free;
  inherited;
end;

function TFhirOperationOutcome.GetResourceType : TFhirResourceType;
begin
  result := frtOperationOutcome;
end;

procedure TFhirOperationOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationOutcome(oSource).FIssueList = nil) then
  begin
    FIssueList.free;
    FIssueList := nil;
  end
  else
  begin
    if FIssueList = nil then
      FIssueList := TFhirOperationOutcomeIssueList.Create;
    FIssueList.Assign(TFhirOperationOutcome(oSource).FIssueList);
  end;
end;

procedure TFhirOperationOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issue') Then
    list.addAll(self, 'issue', FIssueList);
end;

procedure TFhirOperationOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issue', '', true, TFhirOperationOutcomeIssue, FIssueList.Link)){3};
end;

function TFhirOperationOutcome.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issue') then
  begin
    IssueList.add(propValue as TFhirOperationOutcomeIssue){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOperationOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'issue') then IssueList.insertItem(index, propValue as TFhirOperationOutcomeIssue){2a}
  else inherited;
end;

function TFhirOperationOutcome.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'issue') then result := IssueList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issue') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcome.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'issue') then deletePropertyValue('issue', IssueList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issue') then replacePropertyValue('issue', IssueList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'issue') then IssueList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcome.fhirType : string;
begin
  result := 'OperationOutcome';
end;

function TFhirOperationOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FissueList);
end;

function TFhirOperationOutcome.equals(other : TObject) : boolean;
var
  o : TFhirOperationOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcome)) then
    result := false
  else
  begin
    o := TFhirOperationOutcome(other);
    result := compareDeep(issueList, o.issueList, true);
  end;
end;

function TFhirOperationOutcome.Link : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Link);
end;

function TFhirOperationOutcome.Clone : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Clone);
end;

procedure TFhirOperationOutcome.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('issue');
end;

{ TFhirOperationOutcome }

Function TFhirOperationOutcome.GetIssueList : TFhirOperationOutcomeIssueList;
begin
  if FIssueList = nil then
    FIssueList := TFhirOperationOutcomeIssueList.Create;
  result := FIssueList;
end;

Function TFhirOperationOutcome.GetHasIssueList : boolean;
begin
  result := (FIssueList <> nil) and (FIssueList.count > 0);
end;

function TFhirOperationOutcome.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FissueList.sizeInBytes);
end;

{ TFhirOperationOutcomeListEnumerator }

Constructor TFhirOperationOutcomeListEnumerator.Create(list : TFhirOperationOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeListEnumerator.GetCurrent : TFhirOperationOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeList }
procedure TFhirOperationOutcomeList.AddItem(value: TFhirOperationOutcome);
begin
  assert(value.ClassName = 'TFhirOperationOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcome');
  add(value);
end;

function TFhirOperationOutcomeList.Append: TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeList.GetEnumerator : TFhirOperationOutcomeListEnumerator;
begin
  result := TFhirOperationOutcomeListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeList.Clone: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Clone);
end;

function TFhirOperationOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeList.GetItemN(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcome;
end;
function TFhirOperationOutcomeList.IndexOf(value: TFhirOperationOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeList.Insert(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.InsertItem(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeList.Item(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.Link: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Link);
end;

procedure TFhirOperationOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeList.SetItemByIndex(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  FhirOperationOutcomes[index] := value;
end;

procedure TFhirOperationOutcomeList.SetItemN(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_PAYMENTNOTICE}

{ TFhirPaymentNotice }

constructor TFhirPaymentNotice.Create;
begin
  inherited;
end;

destructor TFhirPaymentNotice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FResponse.free;
  FStatusDate.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  FPaymentStatus.free;
  inherited;
end;

function TFhirPaymentNotice.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentNotice;
end;

procedure TFhirPaymentNotice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentNotice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentNotice(oSource).FIdentifierList);
  end;
  FStatus := TFhirPaymentNotice(oSource).FStatus.Link;
  request := TFhirPaymentNotice(oSource).request.Clone;
  response := TFhirPaymentNotice(oSource).response.Clone;
  statusDateElement := TFhirPaymentNotice(oSource).statusDateElement.Clone;
  createdElement := TFhirPaymentNotice(oSource).createdElement.Clone;
  target := TFhirPaymentNotice(oSource).target.Clone;
  provider := TFhirPaymentNotice(oSource).provider.Clone;
  organization := TFhirPaymentNotice(oSource).organization.Clone;
  paymentStatus := TFhirPaymentNotice(oSource).paymentStatus.Clone;
end;

procedure TFhirPaymentNotice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'paymentStatus') Then
     list.add(self.link, 'paymentStatus', FPaymentStatus.Link);
end;

procedure TFhirPaymentNotice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'date', false, TFhirDate, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentStatus', 'CodeableConcept', false, TFhirCodeableConcept, FPaymentStatus.Link));{2}
end;

function TFhirPaymentNotice.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'paymentStatus') then
  begin
    PaymentStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentNotice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirPaymentNotice.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'statusDate') then result := TFhirDate.create() {5b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'paymentStatus') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentNotice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'statusDate') then result := 'date'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'paymentStatus') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentNotice.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'paymentStatus') then PaymentStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentNotice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'statusDate') then StatusDateElement := asDate(new){5b}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'paymentStatus') then PaymentStatusElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentNotice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentNotice.fhirType : string;
begin
  result := 'PaymentNotice';
end;

function TFhirPaymentNotice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FStatusDate) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FPaymentStatus);
end;

function TFhirPaymentNotice.equals(other : TObject) : boolean;
var
  o : TFhirPaymentNotice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentNotice)) then
    result := false
  else
  begin
    o := TFhirPaymentNotice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(paymentStatusElement, o.paymentStatusElement, true);
  end;
end;

function TFhirPaymentNotice.Link : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Link);
end;

function TFhirPaymentNotice.Clone : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Clone);
end;

procedure TFhirPaymentNotice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('response');
  fields.add('statusDate');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
  fields.add('paymentStatus');
end;

{ TFhirPaymentNotice }

Function TFhirPaymentNotice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentNotice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentNotice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirPaymentNotice.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirPaymentNotice.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirPaymentNotice.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentNotice.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirPaymentNotice.SetStatusDate(value : TFhirDate);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirPaymentNotice.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirPaymentNotice.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDate.create;
  FStatusDate.value := value
end;

Procedure TFhirPaymentNotice.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentNotice.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentNotice.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentNotice.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirPaymentNotice.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirPaymentNotice.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirPaymentNotice.SetPaymentStatus(value : TFhirCodeableConcept);
begin
  FPaymentStatus.free;
  FPaymentStatus := value;
end;

function TFhirPaymentNotice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FPaymentStatus.sizeInBytes);
end;

{ TFhirPaymentNoticeListEnumerator }

Constructor TFhirPaymentNoticeListEnumerator.Create(list : TFhirPaymentNoticeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentNoticeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentNoticeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentNoticeListEnumerator.GetCurrent : TFhirPaymentNotice;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentNoticeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentNoticeList }
procedure TFhirPaymentNoticeList.AddItem(value: TFhirPaymentNotice);
begin
  assert(value.ClassName = 'TFhirPaymentNotice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentNotice');
  add(value);
end;

function TFhirPaymentNoticeList.Append: TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentNoticeList.GetEnumerator : TFhirPaymentNoticeListEnumerator;
begin
  result := TFhirPaymentNoticeListEnumerator.Create(self.link);
end;

function TFhirPaymentNoticeList.Clone: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Clone);
end;

function TFhirPaymentNoticeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentNoticeList.GetItemN(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentNotice;
end;
function TFhirPaymentNoticeList.IndexOf(value: TFhirPaymentNotice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentNoticeList.Insert(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.InsertItem(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  Inherited Insert(index, value);
end;

function TFhirPaymentNoticeList.Item(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.Link: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Link);
end;

procedure TFhirPaymentNoticeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentNoticeList.SetItemByIndex(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  FhirPaymentNotices[index] := value;
end;

procedure TFhirPaymentNoticeList.SetItemN(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

{ TFhirPaymentReconciliationDetail }

constructor TFhirPaymentReconciliationDetail.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationDetail.Destroy;
begin
  FType_.free;
  FRequest.free;
  FResponse.free;
  FSubmitter.free;
  FPayee.free;
  FDate.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPaymentReconciliationDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPaymentReconciliationDetail(oSource).type_.Clone;
  request := TFhirPaymentReconciliationDetail(oSource).request.Clone;
  response := TFhirPaymentReconciliationDetail(oSource).response.Clone;
  submitter := TFhirPaymentReconciliationDetail(oSource).submitter.Clone;
  payee := TFhirPaymentReconciliationDetail(oSource).payee.Clone;
  dateElement := TFhirPaymentReconciliationDetail(oSource).dateElement.Clone;
  amount := TFhirPaymentReconciliationDetail(oSource).amount.Clone;
end;

procedure TFhirPaymentReconciliationDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'submitter') Then
     list.add(self.link, 'submitter', FSubmitter.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPaymentReconciliationDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'submitter', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FSubmitter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
end;

function TFhirPaymentReconciliationDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'submitter') then
  begin
    Submitter := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'submitter') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'payee') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'submitter') then result := 'Reference'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'submitter') then SubmitterElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'submitter') then SubmitterElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirPaymentReconciliationDetail.Link : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Link);
end;

function TFhirPaymentReconciliationDetail.Clone : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Clone);
end;

function TFhirPaymentReconciliationDetail.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliationDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationDetail)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(submitterElement, o.submitterElement, true) and
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPaymentReconciliationDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FSubmitter) and isEmptyProp(FPayee) and isEmptyProp(FDate) and isEmptyProp(FAmount);
end;

procedure TFhirPaymentReconciliationDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('request');
  fields.add('response');
  fields.add('submitter');
  fields.add('payee');
  fields.add('date');
  fields.add('amount');
end;

{ TFhirPaymentReconciliationDetail }

Procedure TFhirPaymentReconciliationDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetSubmitter(value : TFhirReference{TFhirOrganization});
begin
  FSubmitter.free;
  FSubmitter := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetPayee(value : TFhirReference{TFhirOrganization});
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirPaymentReconciliationDetail.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirPaymentReconciliationDetail.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirPaymentReconciliationDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FSubmitter.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailListEnumerator }

Constructor TFhirPaymentReconciliationDetailListEnumerator.Create(list : TFhirPaymentReconciliationDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationDetailListEnumerator.GetCurrent : TFhirPaymentReconciliationDetail;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailList }
procedure TFhirPaymentReconciliationDetailList.AddItem(value: TFhirPaymentReconciliationDetail);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationDetail');
  add(value);
end;

function TFhirPaymentReconciliationDetailList.Append: TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationDetailList.GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
begin
  result := TFhirPaymentReconciliationDetailListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationDetailList.Clone: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Clone);
end;

function TFhirPaymentReconciliationDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationDetailList.GetItemN(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationDetail;
end;
function TFhirPaymentReconciliationDetailList.IndexOf(value: TFhirPaymentReconciliationDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationDetailList.Insert(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.InsertItem(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationDetailList.Item(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.Link: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Link);
end;

procedure TFhirPaymentReconciliationDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationDetailList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  FhirPaymentReconciliationDetails[index] := value;
end;

procedure TFhirPaymentReconciliationDetailList.SetItemN(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliationProcessNote }

constructor TFhirPaymentReconciliationProcessNote.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationProcessNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirPaymentReconciliationProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPaymentReconciliationProcessNote(oSource).type_.Clone;
  textElement := TFhirPaymentReconciliationProcessNote(oSource).textElement.Clone;
end;

procedure TFhirPaymentReconciliationProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirPaymentReconciliationProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirPaymentReconciliationProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirPaymentReconciliationProcessNote.Link : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Link);
end;

function TFhirPaymentReconciliationProcessNote.Clone : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNote.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliationProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationProcessNote)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationProcessNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirPaymentReconciliationProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirPaymentReconciliationProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

{ TFhirPaymentReconciliationProcessNote }

Procedure TFhirPaymentReconciliationProcessNote.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPaymentReconciliationProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirPaymentReconciliationProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirPaymentReconciliationProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirPaymentReconciliationProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteListEnumerator }

Constructor TFhirPaymentReconciliationProcessNoteListEnumerator.Create(list : TFhirPaymentReconciliationProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.GetCurrent : TFhirPaymentReconciliationProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteList }
procedure TFhirPaymentReconciliationProcessNoteList.AddItem(value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationProcessNote');
  add(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Append: TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationProcessNoteList.GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
begin
  result := TFhirPaymentReconciliationProcessNoteListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationProcessNoteList.Clone: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationProcessNoteList.GetItemN(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationProcessNote;
end;
function TFhirPaymentReconciliationProcessNoteList.IndexOf(value: TFhirPaymentReconciliationProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Insert(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.InsertItem(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationProcessNoteList.Item(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.Link: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Link);
end;

procedure TFhirPaymentReconciliationProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  FhirPaymentReconciliationProcessNotes[index] := value;
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemN(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliation }

constructor TFhirPaymentReconciliation.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FCreated.free;
  FOrganization.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FDetailList.Free;
  FForm.free;
  FTotal.free;
  FProcessNoteList.Free;
  inherited;
end;

function TFhirPaymentReconciliation.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentReconciliation;
end;

procedure TFhirPaymentReconciliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentReconciliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentReconciliation(oSource).FIdentifierList);
  end;
  FStatus := TFhirPaymentReconciliation(oSource).FStatus.Link;
  period := TFhirPaymentReconciliation(oSource).period.Clone;
  createdElement := TFhirPaymentReconciliation(oSource).createdElement.Clone;
  organization := TFhirPaymentReconciliation(oSource).organization.Clone;
  request := TFhirPaymentReconciliation(oSource).request.Clone;
  outcome := TFhirPaymentReconciliation(oSource).outcome.Clone;
  dispositionElement := TFhirPaymentReconciliation(oSource).dispositionElement.Clone;
  requestProvider := TFhirPaymentReconciliation(oSource).requestProvider.Clone;
  requestOrganization := TFhirPaymentReconciliation(oSource).requestOrganization.Clone;
  if (TFhirPaymentReconciliation(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirPaymentReconciliationDetailList.Create;
    FDetailList.Assign(TFhirPaymentReconciliation(oSource).FDetailList);
  end;
  form := TFhirPaymentReconciliation(oSource).form.Clone;
  total := TFhirPaymentReconciliation(oSource).total.Clone;
  if (TFhirPaymentReconciliation(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirPaymentReconciliation(oSource).FProcessNoteList);
  end;
end;

procedure TFhirPaymentReconciliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
end;

procedure TFhirPaymentReconciliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(ProcessRequest)', false, TFhirReference{TFhirProcessRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirPaymentReconciliationDetail, FDetailList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'total', 'Money', false, TFhirMoney, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirPaymentReconciliationProcessNote, FProcessNoteList.Link)){3};
end;

function TFhirPaymentReconciliation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirProcessRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirPaymentReconciliationDetail){2a};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirPaymentReconciliationProcessNote){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentReconciliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirPaymentReconciliationDetail){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirPaymentReconciliationProcessNote){2a}
  else inherited;
end;

function TFhirPaymentReconciliation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirProcessRequest}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'total') then result := TFhirMoney.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'total') then result := 'Money'
  else if (propName = 'processNote') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirProcessRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'total') then TotalElement := new as TFhirMoney{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliation.fhirType : string;
begin
  result := 'PaymentReconciliation';
end;

function TFhirPaymentReconciliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FdetailList) and isEmptyProp(FForm) and isEmptyProp(FTotal) and isEmptyProp(FprocessNoteList);
end;

function TFhirPaymentReconciliation.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliation)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(detailList, o.detailList, true) and compareDeep(formElement, o.formElement, true) and
      compareDeep(totalElement, o.totalElement, true) and compareDeep(processNoteList, o.processNoteList, true);
  end;
end;

function TFhirPaymentReconciliation.Link : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Link);
end;

function TFhirPaymentReconciliation.Clone : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Clone);
end;

procedure TFhirPaymentReconciliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('created');
  fields.add('organization');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('detail');
  fields.add('form');
  fields.add('total');
  fields.add('processNote');
end;

{ TFhirPaymentReconciliation }

Function TFhirPaymentReconciliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentReconciliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirPaymentReconciliation.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirPaymentReconciliation.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirPaymentReconciliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPaymentReconciliation.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentReconciliation.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentReconciliation.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentReconciliation.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirPaymentReconciliation.SetRequest(value : TFhirReference{TFhirProcessRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliation.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirPaymentReconciliation.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirPaymentReconciliation.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirPaymentReconciliation.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirPaymentReconciliation.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirPaymentReconciliation.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Function TFhirPaymentReconciliation.GetDetailList : TFhirPaymentReconciliationDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirPaymentReconciliationDetailList.Create;
  result := FDetailList;
end;

Function TFhirPaymentReconciliation.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Procedure TFhirPaymentReconciliation.SetTotal(value : TFhirMoney);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirPaymentReconciliation.GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirPaymentReconciliation.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

function TFhirPaymentReconciliation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
end;

{ TFhirPaymentReconciliationListEnumerator }

Constructor TFhirPaymentReconciliationListEnumerator.Create(list : TFhirPaymentReconciliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationListEnumerator.GetCurrent : TFhirPaymentReconciliation;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationList }
procedure TFhirPaymentReconciliationList.AddItem(value: TFhirPaymentReconciliation);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliation');
  add(value);
end;

function TFhirPaymentReconciliationList.Append: TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationList.GetEnumerator : TFhirPaymentReconciliationListEnumerator;
begin
  result := TFhirPaymentReconciliationListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationList.Clone: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Clone);
end;

function TFhirPaymentReconciliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationList.GetItemN(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliation;
end;
function TFhirPaymentReconciliationList.IndexOf(value: TFhirPaymentReconciliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationList.Insert(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.InsertItem(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationList.Item(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.Link: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Link);
end;

procedure TFhirPaymentReconciliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  FhirPaymentReconciliations[index] := value;
end;

procedure TFhirPaymentReconciliationList.SetItemN(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_PROCESSREQUEST}

{ TFhirProcessRequestItem }

constructor TFhirProcessRequestItem.Create;
begin
  inherited;
end;

destructor TFhirProcessRequestItem.Destroy;
begin
  FSequenceLinkId.free;
  inherited;
end;

procedure TFhirProcessRequestItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirProcessRequestItem(oSource).sequenceLinkIdElement.Clone;
end;

procedure TFhirProcessRequestItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
end;

procedure TFhirProcessRequestItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'integer', false, TFhirInteger, FSequenceLinkId.Link));{2}
end;

function TFhirProcessRequestItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asInteger(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcessRequestItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcessRequestItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirInteger.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessRequestItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessRequestItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessRequestItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asInteger(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessRequestItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessRequestItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirProcessRequestItem.Link : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(inherited Link);
end;

function TFhirProcessRequestItem.Clone : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(inherited Clone);
end;

function TFhirProcessRequestItem.equals(other : TObject) : boolean;
var
  o : TFhirProcessRequestItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessRequestItem)) then
    result := false
  else
  begin
    o := TFhirProcessRequestItem(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true);
  end;
end;

function TFhirProcessRequestItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId);
end;

procedure TFhirProcessRequestItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
end;

{ TFhirProcessRequestItem }

Procedure TFhirProcessRequestItem.SetSequenceLinkId(value : TFhirInteger);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirProcessRequestItem.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirProcessRequestItem.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirInteger.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

function TFhirProcessRequestItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
end;

{ TFhirProcessRequestItemListEnumerator }

Constructor TFhirProcessRequestItemListEnumerator.Create(list : TFhirProcessRequestItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessRequestItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessRequestItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessRequestItemListEnumerator.GetCurrent : TFhirProcessRequestItem;
begin
  Result := FList[FIndex];
end;

function TFhirProcessRequestItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessRequestItemList }
procedure TFhirProcessRequestItemList.AddItem(value: TFhirProcessRequestItem);
begin
  assert(value.ClassName = 'TFhirProcessRequestItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessRequestItem');
  add(value);
end;

function TFhirProcessRequestItemList.Append: TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestItemList.ClearItems;
begin
  Clear;
end;

function TFhirProcessRequestItemList.GetEnumerator : TFhirProcessRequestItemListEnumerator;
begin
  result := TFhirProcessRequestItemListEnumerator.Create(self.link);
end;

function TFhirProcessRequestItemList.Clone: TFhirProcessRequestItemList;
begin
  result := TFhirProcessRequestItemList(inherited Clone);
end;

function TFhirProcessRequestItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessRequestItemList.GetItemN(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(ObjectByIndex[index]);
end;

function TFhirProcessRequestItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessRequestItem;
end;
function TFhirProcessRequestItemList.IndexOf(value: TFhirProcessRequestItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessRequestItemList.Insert(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestItemList.InsertItem(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  Inherited Insert(index, value);
end;

function TFhirProcessRequestItemList.Item(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(ObjectByIndex[index]);
end;

function TFhirProcessRequestItemList.Link: TFhirProcessRequestItemList;
begin
  result := TFhirProcessRequestItemList(inherited Link);
end;

procedure TFhirProcessRequestItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessRequestItemList.SetItemByIndex(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  FhirProcessRequestItems[index] := value;
end;

procedure TFhirProcessRequestItemList.SetItemN(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  ObjectByIndex[index] := value;
end;

{ TFhirProcessRequest }

constructor TFhirProcessRequest.Create;
begin
  inherited;
end;

destructor TFhirProcessRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FAction.free;
  FTarget.free;
  FCreated.free;
  FProvider.free;
  FOrganization.free;
  FRequest.free;
  FResponse.free;
  FNullify.free;
  FReference.free;
  FItemList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  FPeriod.free;
  inherited;
end;

function TFhirProcessRequest.GetResourceType : TFhirResourceType;
begin
  result := frtProcessRequest;
end;

procedure TFhirProcessRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcessRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcessRequest(oSource).FIdentifierList);
  end;
  FStatus := TFhirProcessRequest(oSource).FStatus.Link;
  FAction := TFhirProcessRequest(oSource).FAction.Link;
  target := TFhirProcessRequest(oSource).target.Clone;
  createdElement := TFhirProcessRequest(oSource).createdElement.Clone;
  provider := TFhirProcessRequest(oSource).provider.Clone;
  organization := TFhirProcessRequest(oSource).organization.Clone;
  request := TFhirProcessRequest(oSource).request.Clone;
  response := TFhirProcessRequest(oSource).response.Clone;
  nullifyElement := TFhirProcessRequest(oSource).nullifyElement.Clone;
  referenceElement := TFhirProcessRequest(oSource).referenceElement.Clone;
  if (TFhirProcessRequest(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirProcessRequestItemList.Create;
    FItemList.Assign(TFhirProcessRequest(oSource).FItemList);
  end;
  if (TFhirProcessRequest(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirStringList.Create;
    FIncludeList.Assign(TFhirProcessRequest(oSource).FIncludeList);
  end;
  if (TFhirProcessRequest(oSource).FExcludeList = nil) then
  begin
    FExcludeList.free;
    FExcludeList := nil;
  end
  else
  begin
    if FExcludeList = nil then
      FExcludeList := TFhirStringList.Create;
    FExcludeList.Assign(TFhirProcessRequest(oSource).FExcludeList);
  end;
  period := TFhirProcessRequest(oSource).period.Clone;
end;

procedure TFhirProcessRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'nullify') Then
     list.add(self.link, 'nullify', FNullify.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'exclude') Then
    list.addAll(self, 'exclude', FExcludeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirProcessRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFHIREnum, FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nullify', 'boolean', false, TFhirBoolean, FNullify.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'string', false, TFhirString, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirProcessRequestItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', 'string', true, TFhirString, FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', 'string', true, TFhirString, FExcludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirProcessRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirActionlistEnum, CODES_TFhirActionlistEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'nullify') then
  begin
    NullifyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirProcessRequestItem){2a};
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'exclude') then
  begin
    ExcludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcessRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirProcessRequestItem){2a}
  else if (propName = 'include') then IncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'exclude') then ExcludeList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirProcessRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'nullify') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reference') then result := TFhirString.create() {5b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'include') then result := IncludeList.new(){2}
  else if (propName = 'exclude') then result := ExcludeList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'nullify') then result := 'boolean'
  else if (propName = 'reference') then result := 'string'
  else if (propName = 'item') then result := ''
  else if (propName = 'include') then result := 'string'
  else if (propName = 'exclude') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'nullify') then NullifyElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value) {2}
  else if (propName = 'exclude') then deletePropertyValue('exclude', ExcludeList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirActionlistEnum, CODES_TFhirActionlistEnum, new){4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'nullify') then NullifyElement := asBoolean(new){5b}
  else if (propName = 'reference') then ReferenceElement := asString(new){5b}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new) {2}
  else if (propName = 'exclude') then replacePropertyValue('exclude', ExcludeList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'include') then IncludeList.move(source, destination){2}
  else if (propName = 'exclude') then ExcludeList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessRequest.fhirType : string;
begin
  result := 'ProcessRequest';
end;

function TFhirProcessRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FAction) and isEmptyProp(FTarget) and isEmptyProp(FCreated) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FNullify) and isEmptyProp(FReference) and isEmptyProp(FitemList) and isEmptyProp(FincludeList) and isEmptyProp(FexcludeList) and isEmptyProp(FPeriod);
end;

function TFhirProcessRequest.equals(other : TObject) : boolean;
var
  o : TFhirProcessRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessRequest)) then
    result := false
  else
  begin
    o := TFhirProcessRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(actionElement, o.actionElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(nullifyElement, o.nullifyElement, true) and
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(itemList, o.itemList, true) and
      compareDeep(includeList, o.includeList, true) and compareDeep(excludeList, o.excludeList, true) and
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirProcessRequest.Link : TFhirProcessRequest;
begin
  result := TFhirProcessRequest(inherited Link);
end;

function TFhirProcessRequest.Clone : TFhirProcessRequest;
begin
  result := TFhirProcessRequest(inherited Clone);
end;

procedure TFhirProcessRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('action');
  fields.add('target');
  fields.add('created');
  fields.add('provider');
  fields.add('organization');
  fields.add('request');
  fields.add('response');
  fields.add('nullify');
  fields.add('reference');
  fields.add('item');
  fields.add('include');
  fields.add('exclude');
  fields.add('period');
end;

{ TFhirProcessRequest }

Function TFhirProcessRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcessRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcessRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcessRequest.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirProcessRequest.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirProcessRequest.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirProcessRequest.GetActionST : TFhirActionlistEnum;
begin
  if FAction = nil then
    result := TFhirActionlistEnum(0)
  else
    result := TFhirActionlistEnum(StringArrayIndexOfSensitive(CODES_TFhirActionlistEnum, FAction.value));
end;

Procedure TFhirProcessRequest.SetActionST(value : TFhirActionlistEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirActionlistEnum[value], CODES_TFhirActionlistEnum[value]);
end;

Procedure TFhirProcessRequest.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirProcessRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirProcessRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirProcessRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirProcessRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirProcessRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirProcessRequest.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirProcessRequest.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirProcessRequest.SetNullify(value : TFhirBoolean);
begin
  FNullify.free;
  FNullify := value;
end;

Function TFhirProcessRequest.GetNullifyST : Boolean;
begin
  if FNullify = nil then
    result := false
  else
    result := FNullify.value;
end;

Procedure TFhirProcessRequest.SetNullifyST(value : Boolean);
begin
  if FNullify = nil then
    FNullify := TFhirBoolean.create;
  FNullify.value := value
end;

Procedure TFhirProcessRequest.SetReference(value : TFhirString);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProcessRequest.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirProcessRequest.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirString.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Function TFhirProcessRequest.GetItemList : TFhirProcessRequestItemList;
begin
  if FItemList = nil then
    FItemList := TFhirProcessRequestItemList.Create;
  result := FItemList;
end;

Function TFhirProcessRequest.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirProcessRequest.GetIncludeList : TFhirStringList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirStringList.Create;
  result := FIncludeList;
end;

Function TFhirProcessRequest.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

Function TFhirProcessRequest.GetExcludeList : TFhirStringList;
begin
  if FExcludeList = nil then
    FExcludeList := TFhirStringList.Create;
  result := FExcludeList;
end;

Function TFhirProcessRequest.GetHasExcludeList : boolean;
begin
  result := (FExcludeList <> nil) and (FExcludeList.count > 0);
end;

Procedure TFhirProcessRequest.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirProcessRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FAction.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FNullify.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FincludeList.sizeInBytes);
  inc(result, FexcludeList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirProcessRequestListEnumerator }

Constructor TFhirProcessRequestListEnumerator.Create(list : TFhirProcessRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessRequestListEnumerator.GetCurrent : TFhirProcessRequest;
begin
  Result := FList[FIndex];
end;

function TFhirProcessRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessRequestList }
procedure TFhirProcessRequestList.AddItem(value: TFhirProcessRequest);
begin
  assert(value.ClassName = 'TFhirProcessRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessRequest');
  add(value);
end;

function TFhirProcessRequestList.Append: TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestList.ClearItems;
begin
  Clear;
end;

function TFhirProcessRequestList.GetEnumerator : TFhirProcessRequestListEnumerator;
begin
  result := TFhirProcessRequestListEnumerator.Create(self.link);
end;

function TFhirProcessRequestList.Clone: TFhirProcessRequestList;
begin
  result := TFhirProcessRequestList(inherited Clone);
end;

function TFhirProcessRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessRequestList.GetItemN(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest(ObjectByIndex[index]);
end;

function TFhirProcessRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessRequest;
end;
function TFhirProcessRequestList.IndexOf(value: TFhirProcessRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessRequestList.Insert(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestList.InsertItem(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  Inherited Insert(index, value);
end;

function TFhirProcessRequestList.Item(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest(ObjectByIndex[index]);
end;

function TFhirProcessRequestList.Link: TFhirProcessRequestList;
begin
  result := TFhirProcessRequestList(inherited Link);
end;

procedure TFhirProcessRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessRequestList.SetItemByIndex(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  FhirProcessRequests[index] := value;
end;

procedure TFhirProcessRequestList.SetItemN(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCESSREQUEST}

{$IFDEF FHIR_PROCESSRESPONSE}

{ TFhirProcessResponseProcessNote }

constructor TFhirProcessResponseProcessNote.Create;
begin
  inherited;
end;

destructor TFhirProcessResponseProcessNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirProcessResponseProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProcessResponseProcessNote(oSource).type_.Clone;
  textElement := TFhirProcessResponseProcessNote(oSource).textElement.Clone;
end;

procedure TFhirProcessResponseProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirProcessResponseProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirProcessResponseProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcessResponseProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcessResponseProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessResponseProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessResponseProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessResponseProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessResponseProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessResponseProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirProcessResponseProcessNote.Link : TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote(inherited Link);
end;

function TFhirProcessResponseProcessNote.Clone : TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote(inherited Clone);
end;

function TFhirProcessResponseProcessNote.equals(other : TObject) : boolean;
var
  o : TFhirProcessResponseProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessResponseProcessNote)) then
    result := false
  else
  begin
    o := TFhirProcessResponseProcessNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirProcessResponseProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirProcessResponseProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

{ TFhirProcessResponseProcessNote }

Procedure TFhirProcessResponseProcessNote.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProcessResponseProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirProcessResponseProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirProcessResponseProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirProcessResponseProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirProcessResponseProcessNoteListEnumerator }

Constructor TFhirProcessResponseProcessNoteListEnumerator.Create(list : TFhirProcessResponseProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessResponseProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessResponseProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessResponseProcessNoteListEnumerator.GetCurrent : TFhirProcessResponseProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirProcessResponseProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessResponseProcessNoteList }
procedure TFhirProcessResponseProcessNoteList.AddItem(value: TFhirProcessResponseProcessNote);
begin
  assert(value.ClassName = 'TFhirProcessResponseProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessResponseProcessNote');
  add(value);
end;

function TFhirProcessResponseProcessNoteList.Append: TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirProcessResponseProcessNoteList.GetEnumerator : TFhirProcessResponseProcessNoteListEnumerator;
begin
  result := TFhirProcessResponseProcessNoteListEnumerator.Create(self.link);
end;

function TFhirProcessResponseProcessNoteList.Clone: TFhirProcessResponseProcessNoteList;
begin
  result := TFhirProcessResponseProcessNoteList(inherited Clone);
end;

function TFhirProcessResponseProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessResponseProcessNoteList.GetItemN(index: Integer): TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirProcessResponseProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessResponseProcessNote;
end;
function TFhirProcessResponseProcessNoteList.IndexOf(value: TFhirProcessResponseProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessResponseProcessNoteList.Insert(index: Integer): TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseProcessNoteList.InsertItem(index: Integer; value: TFhirProcessResponseProcessNote);
begin
  assert(value is TFhirProcessResponseProcessNote);
  Inherited Insert(index, value);
end;

function TFhirProcessResponseProcessNoteList.Item(index: Integer): TFhirProcessResponseProcessNote;
begin
  result := TFhirProcessResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirProcessResponseProcessNoteList.Link: TFhirProcessResponseProcessNoteList;
begin
  result := TFhirProcessResponseProcessNoteList(inherited Link);
end;

procedure TFhirProcessResponseProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessResponseProcessNoteList.SetItemByIndex(index: Integer; value: TFhirProcessResponseProcessNote);
begin
  assert(value is TFhirProcessResponseProcessNote);
  FhirProcessResponseProcessNotes[index] := value;
end;

procedure TFhirProcessResponseProcessNoteList.SetItemN(index: Integer; value: TFhirProcessResponseProcessNote);
begin
  assert(value is TFhirProcessResponseProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirProcessResponse }

constructor TFhirProcessResponse.Create;
begin
  inherited;
end;

destructor TFhirProcessResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FOrganization.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FForm.free;
  FProcessNoteList.Free;
  FErrorList.Free;
  FCommunicationRequestList.Free;
  inherited;
end;

function TFhirProcessResponse.GetResourceType : TFhirResourceType;
begin
  result := frtProcessResponse;
end;

procedure TFhirProcessResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcessResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcessResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirProcessResponse(oSource).FStatus.Link;
  createdElement := TFhirProcessResponse(oSource).createdElement.Clone;
  organization := TFhirProcessResponse(oSource).organization.Clone;
  request := TFhirProcessResponse(oSource).request.Clone;
  outcome := TFhirProcessResponse(oSource).outcome.Clone;
  dispositionElement := TFhirProcessResponse(oSource).dispositionElement.Clone;
  requestProvider := TFhirProcessResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirProcessResponse(oSource).requestOrganization.Clone;
  form := TFhirProcessResponse(oSource).form.Clone;
  if (TFhirProcessResponse(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirProcessResponseProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirProcessResponse(oSource).FProcessNoteList);
  end;
  if (TFhirProcessResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCodeableConceptList.Create;
    FErrorList.Assign(TFhirProcessResponse(oSource).FErrorList);
  end;
  if (TFhirProcessResponse(oSource).FCommunicationRequestList = nil) then
  begin
    FCommunicationRequestList.free;
    FCommunicationRequestList := nil;
  end
  else
  begin
    if FCommunicationRequestList = nil then
      FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
    FCommunicationRequestList.Assign(TFhirProcessResponse(oSource).FCommunicationRequestList);
  end;
end;

procedure TFhirProcessResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
  if (child_name = 'communicationRequest') Then
    list.addAll(self, 'communicationRequest', FCommunicationRequestList);
end;

procedure TFhirProcessResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirProcessResponseProcessNote, FProcessNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'error', 'CodeableConcept', true, TFhirCodeableConcept, FErrorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'communicationRequest', 'Reference(CommunicationRequest)', true, TFhirReference{TFhirCommunicationRequest}, FCommunicationRequestList.Link)){3};
end;

function TFhirProcessResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirProcessResponseProcessNote){2a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'communicationRequest') then
  begin
    CommunicationRequestList.add(propValue as TFhirReference{TFhirCommunicationRequest}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcessResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirProcessResponseProcessNote){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.insertItem(index, propValue as TFhirReference{TFhirCommunicationRequest}){2a}
  else inherited;
end;

function TFhirProcessResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else if (propName = 'communicationRequest') then result := CommunicationRequestList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := ''
  else if (propName = 'error') then result := 'CodeableConcept'
  else if (propName = 'communicationRequest') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else if (propName = 'communicationRequest') then deletePropertyValue('communicationRequest', CommunicationRequestList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else if (propName = 'communicationRequest') then replacePropertyValue('communicationRequest', CommunicationRequestList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessResponse.fhirType : string;
begin
  result := 'ProcessResponse';
end;

function TFhirProcessResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FerrorList) and isEmptyProp(FcommunicationRequestList);
end;

function TFhirProcessResponse.equals(other : TObject) : boolean;
var
  o : TFhirProcessResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessResponse)) then
    result := false
  else
  begin
    o := TFhirProcessResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true) and
      compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and
      compareDeep(errorList, o.errorList, true) and compareDeep(communicationRequestList, o.communicationRequestList, true);
  end;
end;

function TFhirProcessResponse.Link : TFhirProcessResponse;
begin
  result := TFhirProcessResponse(inherited Link);
end;

function TFhirProcessResponse.Clone : TFhirProcessResponse;
begin
  result := TFhirProcessResponse(inherited Clone);
end;

procedure TFhirProcessResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('organization');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('form');
  fields.add('processNote');
  fields.add('error');
  fields.add('communicationRequest');
end;

{ TFhirProcessResponse }

Function TFhirProcessResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcessResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcessResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcessResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirProcessResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirProcessResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirProcessResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirProcessResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirProcessResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirProcessResponse.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirProcessResponse.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirProcessResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirProcessResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirProcessResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirProcessResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirProcessResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Procedure TFhirProcessResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirProcessResponse.GetProcessNoteList : TFhirProcessResponseProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirProcessResponseProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirProcessResponse.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

Function TFhirProcessResponse.GetErrorList : TFhirCodeableConceptList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCodeableConceptList.Create;
  result := FErrorList;
end;

Function TFhirProcessResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

Function TFhirProcessResponse.GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
begin
  if FCommunicationRequestList = nil then
    FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
  result := FCommunicationRequestList;
end;

Function TFhirProcessResponse.GetHasCommunicationRequestList : boolean;
begin
  result := (FCommunicationRequestList <> nil) and (FCommunicationRequestList.count > 0);
end;

function TFhirProcessResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
  inc(result, FcommunicationRequestList.sizeInBytes);
end;

{ TFhirProcessResponseListEnumerator }

Constructor TFhirProcessResponseListEnumerator.Create(list : TFhirProcessResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessResponseListEnumerator.GetCurrent : TFhirProcessResponse;
begin
  Result := FList[FIndex];
end;

function TFhirProcessResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessResponseList }
procedure TFhirProcessResponseList.AddItem(value: TFhirProcessResponse);
begin
  assert(value.ClassName = 'TFhirProcessResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessResponse');
  add(value);
end;

function TFhirProcessResponseList.Append: TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseList.ClearItems;
begin
  Clear;
end;

function TFhirProcessResponseList.GetEnumerator : TFhirProcessResponseListEnumerator;
begin
  result := TFhirProcessResponseListEnumerator.Create(self.link);
end;

function TFhirProcessResponseList.Clone: TFhirProcessResponseList;
begin
  result := TFhirProcessResponseList(inherited Clone);
end;

function TFhirProcessResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessResponseList.GetItemN(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse(ObjectByIndex[index]);
end;

function TFhirProcessResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessResponse;
end;
function TFhirProcessResponseList.IndexOf(value: TFhirProcessResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessResponseList.Insert(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseList.InsertItem(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  Inherited Insert(index, value);
end;

function TFhirProcessResponseList.Item(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse(ObjectByIndex[index]);
end;

function TFhirProcessResponseList.Link: TFhirProcessResponseList;
begin
  result := TFhirProcessResponseList(inherited Link);
end;

procedure TFhirProcessResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessResponseList.SetItemByIndex(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  FhirProcessResponses[index] := value;
end;

procedure TFhirProcessResponseList.SetItemN(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCESSRESPONSE}

{$IFDEF FHIR_PROVENANCE}

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FRoleList.Free;
  FWho.free;
  FOnBehalfOf.free;
  FRelatedAgentType.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenanceAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirProvenanceAgent(oSource).FRoleList);
  end;
  who := TFhirProvenanceAgent(oSource).who.Clone;
  onBehalfOf := TFhirProvenanceAgent(oSource).onBehalfOf.Clone;
  relatedAgentType := TFhirProvenanceAgent(oSource).relatedAgentType.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who[x]') or (child_name = 'who') Then
     list.add(self.link, 'who[x]', FWho.Link);
  if (child_name = 'onBehalfOf[x]') or (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf[x]', FOnBehalfOf.Link);
  if (child_name = 'relatedAgentType') Then
     list.add(self.link, 'relatedAgentType', FRelatedAgentType.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'who[x]', 'uri|Reference(Practitioner|RelatedPerson|Patient|Device|Organization)', false, TFhirType, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf[x]', 'uri|Reference(Practitioner|RelatedPerson|Patient|Device|Organization)', false, TFhirType, FOnBehalfOf.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedAgentType', 'CodeableConcept', false, TFhirCodeableConcept, FRelatedAgentType.Link));{2}
end;

function TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'who', ['Uri', 'Reference'])) then
  begin
    Who := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onBehalfOf', ['Uri', 'Reference'])) then
  begin
    OnBehalfOf := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'relatedAgentType') then
  begin
    RelatedAgentType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirProvenanceAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := RoleList.new(){2}
  else if (isMatchingName(propName, 'who', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Who'){4x}
  else if (isMatchingName(propName, 'onBehalfOf', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property OnBehalfOf'){4x}
  else if (propName = 'relatedAgentType') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who[x]') then result := 'uri|Reference'
  else if (propName = 'onBehalfOf[x]') then result := 'uri|Reference'
  else if (propName = 'relatedAgentType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else if (isMatchingName(propName, 'who', ['Uri', 'Reference'])) then WhoElement := nil{4x}
  else if (isMatchingName(propName, 'onBehalfOf', ['Uri', 'Reference'])) then OnBehalfOfElement := nil{4x}
  else if (propName = 'relatedAgentType') then RelatedAgentTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else if (isMatchingName(propName, 'who', ['Uri', 'Reference'])) then WhoElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'onBehalfOf', ['Uri', 'Reference'])) then OnBehalfOfElement := new as TFhirType{4x}
  else if (propName = 'relatedAgentType') then RelatedAgentTypeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

function TFhirProvenanceAgent.equals(other : TObject) : boolean;
var
  o : TFhirProvenanceAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgent(other);
    result := compareDeep(roleList, o.roleList, true) and compareDeep(whoElement, o.whoElement, true) and
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and compareDeep(relatedAgentTypeElement, o.relatedAgentTypeElement, true);
  end;
end;

function TFhirProvenanceAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FRelatedAgentType);
end;

procedure TFhirProvenanceAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('who[x]');
  fields.add('onBehalfOf[x]');
  fields.add('relatedAgentType');
end;

{ TFhirProvenanceAgent }

Function TFhirProvenanceAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirProvenanceAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

Procedure TFhirProvenanceAgent.SetWho(value : TFhirType);
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirProvenanceAgent.SetOnBehalfOf(value : TFhirType);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

Procedure TFhirProvenanceAgent.SetRelatedAgentType(value : TFhirCodeableConcept);
begin
  FRelatedAgentType.free;
  FRelatedAgentType := value;
end;

function TFhirProvenanceAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FroleList.sizeInBytes);
  inc(result, FWho.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
  inc(result, FRelatedAgentType.sizeInBytes);
end;

{ TFhirProvenanceAgentListEnumerator }

Constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;

function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgent;
end;
function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FWhat.free;
  FAgentList.Free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TFslObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  what := TFhirProvenanceEntity(oSource).what.Clone;
  if (TFhirProvenanceEntity(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenanceEntity(oSource).FAgentList);
  end;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'what[x]') or (child_name = 'what') Then
     list.add(self.link, 'what[x]', FWhat.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFHIREnum, FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'what[x]', 'uri|Reference(Any)|Identifier', false, TFhirType, FWhat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', true, TFhirProvenanceAgent, FAgentList.Link)){3};
end;

function TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'what', ['Uri', 'Reference', 'Identifier'])) then
  begin
    What := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent){2a}
  else inherited;
end;

function TFhirProvenanceEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'what', ['Uri', 'Reference', 'Identifier'])) then raise EFHIRException.create('Cannot make property What'){4x}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'what[x]') then result := 'uri|Reference|Identifier'
  else if (propName = 'agent') then result := '@Provenance.agent'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (isMatchingName(propName, 'what', ['Uri', 'Reference', 'Identifier'])) then WhatElement := nil{4x}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, new){4}
  else if (isMatchingName(propName, 'what', ['Uri', 'Reference', 'Identifier'])) then WhatElement := new as TFhirType{4x}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'agent') then AgentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceEntity.fhirType : string;
begin
  result := 'entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

function TFhirProvenanceEntity.equals(other : TObject) : boolean;
var
  o : TFhirProvenanceEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceEntity)) then
    result := false
  else
  begin
    o := TFhirProvenanceEntity(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(whatElement, o.whatElement, true) and
      compareDeep(agentList, o.agentList, true);
  end;
end;

function TFhirProvenanceEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FWhat) and isEmptyProp(FagentList);
end;

procedure TFhirProvenanceEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('what[x]');
  fields.add('agent');
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRoleEnum;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRoleEnum(0)
  else
    result := TFhirProvenanceEntityRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRoleEnum, FRole.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[value], CODES_TFhirProvenanceEntityRoleEnum[value]);
end;

Procedure TFhirProvenanceEntity.SetWhat(value : TFhirType);
begin
  FWhat.free;
  FWhat := value;
end;

Function TFhirProvenanceEntity.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

Function TFhirProvenanceEntity.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

function TFhirProvenanceEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FWhat.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
end;

{ TFhirProvenanceEntityListEnumerator }

Constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;

function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceEntity;
end;
function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenance }

constructor TFhirProvenance.Create;
begin
  inherited;
end;

destructor TFhirProvenance.Destroy;
begin
  FTargetList.Free;
  FPeriod.free;
  FRecorded.free;
  FPolicyList.Free;
  FLocation.free;
  FReasonList.Free;
  FActivity.free;
  FAgentList.Free;
  FEntityList.Free;
  FSignatureList.Free;
  inherited;
end;

function TFhirProvenance.GetResourceType : TFhirResourceType;
begin
  result := frtProvenance;
end;

procedure TFhirProvenance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenance(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList{TFhirReference}.Create;
    FTargetList.Assign(TFhirProvenance(oSource).FTargetList);
  end;
  period := TFhirProvenance(oSource).period.Clone;
  recordedElement := TFhirProvenance(oSource).recordedElement.Clone;
  if (TFhirProvenance(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirProvenance(oSource).FPolicyList);
  end;
  location := TFhirProvenance(oSource).location.Clone;
  if (TFhirProvenance(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodingList.Create;
    FReasonList.Assign(TFhirProvenance(oSource).FReasonList);
  end;
  activity := TFhirProvenance(oSource).activity.Clone;
  if (TFhirProvenance(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenance(oSource).FAgentList);
  end;
  if (TFhirProvenance(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirProvenanceEntityList.Create;
    FEntityList.Assign(TFhirProvenance(oSource).FEntityList);
  end;
  if (TFhirProvenance(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirProvenance(oSource).FSignatureList);
  end;
end;

procedure TFhirProvenance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirProvenance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', true, TFhirCoding, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'activity', 'Coding', false, TFhirCoding, FActivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirProvenanceAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entity', '', true, TFhirProvenanceEntity, FEntityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link)){3};
end;

function TFhirProvenance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent){2a};
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirProvenanceEntity){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProvenance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent){2a}
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirProvenanceEntity){2a}
  else if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature){2a}
  else inherited;
end;

function TFhirProvenance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'recorded') then result := TFhirInstant.create() {5b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'activity') then result := TFhirCoding.create(){4b}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'entity') then result := EntityList.new(){2}
  else if (propName = 'signature') then result := SignatureList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'Coding'
  else if (propName = 'activity') then result := 'Coding'
  else if (propName = 'agent') then result := ''
  else if (propName = 'entity') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value) {2}
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'recorded') then RecordedElement := asInstant(new){5b}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'activity') then ActivityElement := new as TFhirCoding{4}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new) {2}
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'entity') then EntityList.move(source, destination){2a}
  else if (propName = 'signature') then SignatureList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenance.fhirType : string;
begin
  result := 'Provenance';
end;

function TFhirProvenance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FPeriod) and isEmptyProp(FRecorded) and isEmptyProp(FpolicyList) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FActivity) and isEmptyProp(FagentList) and isEmptyProp(FentityList) and isEmptyProp(FsignatureList);
end;

function TFhirProvenance.equals(other : TObject) : boolean;
var
  o : TFhirProvenance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenance)) then
    result := false
  else
  begin
    o := TFhirProvenance(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(policyList, o.policyList, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(activityElement, o.activityElement, true) and compareDeep(agentList, o.agentList, true) and
      compareDeep(entityList, o.entityList, true) and compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirProvenance.Link : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Link);
end;

function TFhirProvenance.Clone : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Clone);
end;

procedure TFhirProvenance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('target');
  fields.add('period');
  fields.add('recorded');
  fields.add('policy');
  fields.add('location');
  fields.add('reason');
  fields.add('activity');
  fields.add('agent');
  fields.add('entity');
  fields.add('signature');
end;

{ TFhirProvenance }

Function TFhirProvenance.GetTargetList : TFhirReferenceList{TFhirReference};
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList{TFhirReference}.Create;
  result := FTargetList;
end;

Function TFhirProvenance.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

Procedure TFhirProvenance.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirProvenance.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

Function TFhirProvenance.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

Procedure TFhirProvenance.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

Function TFhirProvenance.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirProvenance.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirProvenance.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirProvenance.GetReasonList : TFhirCodingList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodingList.Create;
  result := FReasonList;
end;

Function TFhirProvenance.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Procedure TFhirProvenance.SetActivity(value : TFhirCoding);
begin
  FActivity.free;
  FActivity := value;
end;

Function TFhirProvenance.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

Function TFhirProvenance.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Function TFhirProvenance.GetEntityList : TFhirProvenanceEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirProvenanceEntityList.Create;
  result := FEntityList;
end;

Function TFhirProvenance.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

Function TFhirProvenance.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

Function TFhirProvenance.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

function TFhirProvenance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FtargetList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FActivity.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FentityList.sizeInBytes);
  inc(result, FsignatureList.sizeInBytes);
end;

{ TFhirProvenanceListEnumerator }

Constructor TFhirProvenanceListEnumerator.Create(list : TFhirProvenanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceListEnumerator.GetCurrent : TFhirProvenance;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceList }
procedure TFhirProvenanceList.AddItem(value: TFhirProvenance);
begin
  assert(value.ClassName = 'TFhirProvenance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenance');
  add(value);
end;

function TFhirProvenanceList.Append: TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceList.GetEnumerator : TFhirProvenanceListEnumerator;
begin
  result := TFhirProvenanceListEnumerator.Create(self.link);
end;

function TFhirProvenanceList.Clone: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Clone);
end;

function TFhirProvenanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceList.GetItemN(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenance;
end;
function TFhirProvenanceList.IndexOf(value: TFhirProvenance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceList.Insert(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.InsertItem(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  Inherited Insert(index, value);
end;

function TFhirProvenanceList.Item(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.Link: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Link);
end;

procedure TFhirProvenanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceList.SetItemByIndex(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  FhirProvenances[index] := value;
end;

procedure TFhirProvenanceList.SetItemN(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_RESEARCHSTUDY}

{ TFhirResearchStudyArm }

constructor TFhirResearchStudyArm.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyArm.Destroy;
begin
  FName.free;
  FCode.free;
  FDescription.free;
  inherited;
end;

procedure TFhirResearchStudyArm.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyArm(oSource).nameElement.Clone;
  code := TFhirResearchStudyArm(oSource).code.Clone;
  descriptionElement := TFhirResearchStudyArm(oSource).descriptionElement.Clone;
end;

procedure TFhirResearchStudyArm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirResearchStudyArm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirResearchStudyArm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyArm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyArm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyArm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyArm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyArm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyArm.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyArm.fhirType : string;
begin
  result := 'arm';
end;

function TFhirResearchStudyArm.Link : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Link);
end;

function TFhirResearchStudyArm.Clone : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Clone);
end;

function TFhirResearchStudyArm.equals(other : TObject) : boolean;
var
  o : TFhirResearchStudyArm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyArm)) then
    result := false
  else
  begin
    o := TFhirResearchStudyArm(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirResearchStudyArm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FCode) and isEmptyProp(FDescription);
end;

procedure TFhirResearchStudyArm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('code');
  fields.add('description');
end;

{ TFhirResearchStudyArm }

Procedure TFhirResearchStudyArm.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirResearchStudyArm.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirResearchStudyArm.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirResearchStudyArm.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirResearchStudyArm.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirResearchStudyArm.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirResearchStudyArm.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchStudyArm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirResearchStudyArmListEnumerator }

Constructor TFhirResearchStudyArmListEnumerator.Create(list : TFhirResearchStudyArmList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyArmListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyArmListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyArmListEnumerator.GetCurrent : TFhirResearchStudyArm;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyArmListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchStudyArmList }
procedure TFhirResearchStudyArmList.AddItem(value: TFhirResearchStudyArm);
begin
  assert(value.ClassName = 'TFhirResearchStudyArm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyArm');
  add(value);
end;

function TFhirResearchStudyArmList.Append: TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyArmList.GetEnumerator : TFhirResearchStudyArmListEnumerator;
begin
  result := TFhirResearchStudyArmListEnumerator.Create(self.link);
end;

function TFhirResearchStudyArmList.Clone: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Clone);
end;

function TFhirResearchStudyArmList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyArmList.GetItemN(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyArm;
end;
function TFhirResearchStudyArmList.IndexOf(value: TFhirResearchStudyArm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyArmList.Insert(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.InsertItem(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyArmList.Item(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.Link: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Link);
end;

procedure TFhirResearchStudyArmList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyArmList.SetItemByIndex(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  FhirResearchStudyArms[index] := value;
end;

procedure TFhirResearchStudyArmList.SetItemN(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudy }

constructor TFhirResearchStudy.Create;
begin
  inherited;
end;

destructor TFhirResearchStudy.Destroy;
begin
  FIdentifierList.Free;
  FTitle.free;
  FProtocolList.Free;
  FPartOfList.Free;
  FStatus.free;
  FCategoryList.Free;
  FFocusList.Free;
  FContactList.Free;
  FRelatedArtifactList.Free;
  FKeywordList.Free;
  FJurisdictionList.Free;
  FDescription.free;
  FEnrollmentList.Free;
  FPeriod.free;
  FSponsor.free;
  FPrincipalInvestigator.free;
  FSiteList.Free;
  FReasonStopped.free;
  FNoteList.Free;
  FArmList.Free;
  inherited;
end;

function TFhirResearchStudy.GetResourceType : TFhirResourceType;
begin
  result := frtResearchStudy;
end;

procedure TFhirResearchStudy.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchStudy(oSource).FIdentifierList);
  end;
  titleElement := TFhirResearchStudy(oSource).titleElement.Clone;
  if (TFhirResearchStudy(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirReferenceList{TFhirPlanDefinition}.Create;
    FProtocolList.Assign(TFhirResearchStudy(oSource).FProtocolList);
  end;
  if (TFhirResearchStudy(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirResearchStudy}.Create;
    FPartOfList.Assign(TFhirResearchStudy(oSource).FPartOfList);
  end;
  FStatus := TFhirResearchStudy(oSource).FStatus.Link;
  if (TFhirResearchStudy(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirResearchStudy(oSource).FCategoryList);
  end;
  if (TFhirResearchStudy(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirCodeableConceptList.Create;
    FFocusList.Assign(TFhirResearchStudy(oSource).FFocusList);
  end;
  if (TFhirResearchStudy(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirResearchStudy(oSource).FContactList);
  end;
  if (TFhirResearchStudy(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchStudy(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchStudy(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodeableConceptList.Create;
    FKeywordList.Assign(TFhirResearchStudy(oSource).FKeywordList);
  end;
  if (TFhirResearchStudy(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirResearchStudy(oSource).FJurisdictionList);
  end;
  descriptionElement := TFhirResearchStudy(oSource).descriptionElement.Clone;
  if (TFhirResearchStudy(oSource).FEnrollmentList = nil) then
  begin
    FEnrollmentList.free;
    FEnrollmentList := nil;
  end
  else
  begin
    if FEnrollmentList = nil then
      FEnrollmentList := TFhirReferenceList{TFhirGroup}.Create;
    FEnrollmentList.Assign(TFhirResearchStudy(oSource).FEnrollmentList);
  end;
  period := TFhirResearchStudy(oSource).period.Clone;
  sponsor := TFhirResearchStudy(oSource).sponsor.Clone;
  principalInvestigator := TFhirResearchStudy(oSource).principalInvestigator.Clone;
  if (TFhirResearchStudy(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList{TFhirLocation}.Create;
    FSiteList.Assign(TFhirResearchStudy(oSource).FSiteList);
  end;
  reasonStopped := TFhirResearchStudy(oSource).reasonStopped.Clone;
  if (TFhirResearchStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirResearchStudy(oSource).FNoteList);
  end;
  if (TFhirResearchStudy(oSource).FArmList = nil) then
  begin
    FArmList.free;
    FArmList := nil;
  end
  else
  begin
    if FArmList = nil then
      FArmList := TFhirResearchStudyArmList.Create;
    FArmList.Assign(TFhirResearchStudy(oSource).FArmList);
  end;
end;

procedure TFhirResearchStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'enrollment') Then
    list.addAll(self, 'enrollment', FEnrollmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'sponsor') Then
     list.add(self.link, 'sponsor', FSponsor.Link);
  if (child_name = 'principalInvestigator') Then
     list.add(self.link, 'principalInvestigator', FPrincipalInvestigator.Link);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'reasonStopped') Then
     list.add(self.link, 'reasonStopped', FReasonStopped.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'arm') Then
    list.addAll(self, 'arm', FArmList);
end;

procedure TFhirResearchStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'protocol', 'Reference(PlanDefinition)', true, TFhirReference{TFhirPlanDefinition}, FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(ResearchStudy)', true, TFhirReference{TFhirResearchStudy}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focus', 'CodeableConcept', true, TFhirCodeableConcept, FFocusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'keyword', 'CodeableConcept', true, TFhirCodeableConcept, FKeywordList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enrollment', 'Reference(Group)', true, TFhirReference{TFhirGroup}, FEnrollmentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sponsor', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FSponsor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'principalInvestigator', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPrincipalInvestigator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonStopped', 'CodeableConcept', false, TFhirCodeableConcept, FReasonStopped.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'arm', '', true, TFhirResearchStudyArm, FArmList.Link)){3};
end;

function TFhirResearchStudy.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(propValue as TFhirReference{TFhirPlanDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirResearchStudy}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enrollment') then
  begin
    EnrollmentList.add(propValue as TFhirReference{TFhirGroup}){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'sponsor') then
  begin
    Sponsor := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'principalInvestigator') then
  begin
    PrincipalInvestigator := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'reasonStopped') then
  begin
    ReasonStopped := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'arm') then
  begin
    ArmList.add(propValue as TFhirResearchStudyArm){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'protocol') then ProtocolList.insertItem(index, propValue as TFhirReference{TFhirPlanDefinition}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirResearchStudy}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'enrollment') then EnrollmentList.insertItem(index, propValue as TFhirReference{TFhirGroup}){2a}
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'arm') then ArmList.insertItem(index, propValue as TFhirResearchStudyArm){2a}
  else inherited;
end;

function TFhirResearchStudy.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'protocol') then result := ProtocolList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'focus') then result := FocusList.new(){2}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'keyword') then result := KeywordList.new(){2}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new(){2}
  else if (propName = 'description') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'enrollment') then result := EnrollmentList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'sponsor') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'principalInvestigator') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'site') then result := SiteList.new(){2}
  else if (propName = 'reasonStopped') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'arm') then result := ArmList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'protocol') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'focus') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'keyword') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'enrollment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'sponsor') then result := 'Reference'
  else if (propName = 'principalInvestigator') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'reasonStopped') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'arm') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudy.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {2}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value) {2}
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'enrollment') then deletePropertyValue('enrollment', EnrollmentList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'sponsor') then SponsorElement := nil
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := nil
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value) {2}
  else if (propName = 'reasonStopped') then ReasonStoppedElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'arm') then deletePropertyValue('arm', ArmList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {2}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new) {2}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new){5b}
  else if (propName = 'enrollment') then replacePropertyValue('enrollment', EnrollmentList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'sponsor') then SponsorElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new) {2}
  else if (propName = 'reasonStopped') then ReasonStoppedElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'arm') then replacePropertyValue('arm', ArmList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'protocol') then ProtocolList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'focus') then FocusList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'keyword') then KeywordList.move(source, destination){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination){2a}
  else if (propName = 'enrollment') then EnrollmentList.move(source, destination){2a}
  else if (propName = 'site') then SiteList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'arm') then ArmList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudy.fhirType : string;
begin
  result := 'ResearchStudy';
end;

function TFhirResearchStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FTitle) and isEmptyProp(FprotocolList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FfocusList) and isEmptyProp(FcontactList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FkeywordList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FDescription) and isEmptyProp(FenrollmentList) and isEmptyProp(FPeriod) and isEmptyProp(FSponsor) and isEmptyProp(FPrincipalInvestigator) and isEmptyProp(FsiteList) and isEmptyProp(FReasonStopped) and isEmptyProp(FnoteList) and isEmptyProp(FarmList);
end;

function TFhirResearchStudy.equals(other : TObject) : boolean;
var
  o : TFhirResearchStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudy)) then
    result := false
  else
  begin
    o := TFhirResearchStudy(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(protocolList, o.protocolList, true) and compareDeep(partOfList, o.partOfList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(focusList, o.focusList, true) and compareDeep(contactList, o.contactList, true) and
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(keywordList, o.keywordList, true) and
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(enrollmentList, o.enrollmentList, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(sponsorElement, o.sponsorElement, true) and compareDeep(principalInvestigatorElement, o.principalInvestigatorElement, true) and
      compareDeep(siteList, o.siteList, true) and compareDeep(reasonStoppedElement, o.reasonStoppedElement, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(armList, o.armList, true);
  end;
end;

function TFhirResearchStudy.Link : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Link);
end;

function TFhirResearchStudy.Clone : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Clone);
end;

procedure TFhirResearchStudy.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('title');
  fields.add('protocol');
  fields.add('partOf');
  fields.add('status');
  fields.add('category');
  fields.add('focus');
  fields.add('contact');
  fields.add('relatedArtifact');
  fields.add('keyword');
  fields.add('jurisdiction');
  fields.add('description');
  fields.add('enrollment');
  fields.add('period');
  fields.add('sponsor');
  fields.add('principalInvestigator');
  fields.add('site');
  fields.add('reasonStopped');
  fields.add('note');
  fields.add('arm');
end;

{ TFhirResearchStudy }

Function TFhirResearchStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirResearchStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirResearchStudy.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirResearchStudy.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirResearchStudy.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Function TFhirResearchStudy.GetProtocolList : TFhirReferenceList{TFhirPlanDefinition};
begin
  if FProtocolList = nil then
    FProtocolList := TFhirReferenceList{TFhirPlanDefinition}.Create;
  result := FProtocolList;
end;

Function TFhirResearchStudy.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

Function TFhirResearchStudy.GetPartOfList : TFhirReferenceList{TFhirResearchStudy};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirResearchStudy}.Create;
  result := FPartOfList;
end;

Function TFhirResearchStudy.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirResearchStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirResearchStudy.GetStatusST : TFhirResearchStudyStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchStudyStatusEnum(0)
  else
    result := TFhirResearchStudyStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchStudyStatusEnum, FStatus.value));
end;

Procedure TFhirResearchStudy.SetStatusST(value : TFhirResearchStudyStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchStudyStatusEnum[value], CODES_TFhirResearchStudyStatusEnum[value]);
end;

Function TFhirResearchStudy.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirResearchStudy.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Function TFhirResearchStudy.GetFocusList : TFhirCodeableConceptList;
begin
  if FFocusList = nil then
    FFocusList := TFhirCodeableConceptList.Create;
  result := FFocusList;
end;

Function TFhirResearchStudy.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

Function TFhirResearchStudy.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

Function TFhirResearchStudy.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirResearchStudy.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirResearchStudy.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirResearchStudy.GetKeywordList : TFhirCodeableConceptList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodeableConceptList.Create;
  result := FKeywordList;
end;

Function TFhirResearchStudy.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

Function TFhirResearchStudy.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

Function TFhirResearchStudy.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

Procedure TFhirResearchStudy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirResearchStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirResearchStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirResearchStudy.GetEnrollmentList : TFhirReferenceList{TFhirGroup};
begin
  if FEnrollmentList = nil then
    FEnrollmentList := TFhirReferenceList{TFhirGroup}.Create;
  result := FEnrollmentList;
end;

Function TFhirResearchStudy.GetHasEnrollmentList : boolean;
begin
  result := (FEnrollmentList <> nil) and (FEnrollmentList.count > 0);
end;

Procedure TFhirResearchStudy.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirResearchStudy.SetSponsor(value : TFhirReference{TFhirOrganization});
begin
  FSponsor.free;
  FSponsor := value;
end;

Procedure TFhirResearchStudy.SetPrincipalInvestigator(value : TFhirReference{TFhirPractitioner});
begin
  FPrincipalInvestigator.free;
  FPrincipalInvestigator := value;
end;

Function TFhirResearchStudy.GetSiteList : TFhirReferenceList{TFhirLocation};
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList{TFhirLocation}.Create;
  result := FSiteList;
end;

Function TFhirResearchStudy.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

Procedure TFhirResearchStudy.SetReasonStopped(value : TFhirCodeableConcept);
begin
  FReasonStopped.free;
  FReasonStopped := value;
end;

Function TFhirResearchStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirResearchStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirResearchStudy.GetArmList : TFhirResearchStudyArmList;
begin
  if FArmList = nil then
    FArmList := TFhirResearchStudyArmList.Create;
  result := FArmList;
end;

Function TFhirResearchStudy.GetHasArmList : boolean;
begin
  result := (FArmList <> nil) and (FArmList.count > 0);
end;

function TFhirResearchStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FprotocolList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FkeywordList.sizeInBytes);
  inc(result, FjurisdictionList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FenrollmentList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FSponsor.sizeInBytes);
  inc(result, FPrincipalInvestigator.sizeInBytes);
  inc(result, FsiteList.sizeInBytes);
  inc(result, FReasonStopped.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FarmList.sizeInBytes);
end;

{ TFhirResearchStudyListEnumerator }

Constructor TFhirResearchStudyListEnumerator.Create(list : TFhirResearchStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyListEnumerator.GetCurrent : TFhirResearchStudy;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchStudyList }
procedure TFhirResearchStudyList.AddItem(value: TFhirResearchStudy);
begin
  assert(value.ClassName = 'TFhirResearchStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudy');
  add(value);
end;

function TFhirResearchStudyList.Append: TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyList.GetEnumerator : TFhirResearchStudyListEnumerator;
begin
  result := TFhirResearchStudyListEnumerator.Create(self.link);
end;

function TFhirResearchStudyList.Clone: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Clone);
end;

function TFhirResearchStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyList.GetItemN(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudy;
end;
function TFhirResearchStudyList.IndexOf(value: TFhirResearchStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyList.Insert(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.InsertItem(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyList.Item(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.Link: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Link);
end;

procedure TFhirResearchStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyList.SetItemByIndex(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  FhirResearchStudies[index] := value;
end;

procedure TFhirResearchStudyList.SetItemN(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSTUDY}

{$IFDEF FHIR_RESEARCHSUBJECT}

{ TFhirResearchSubject }

constructor TFhirResearchSubject.Create;
begin
  inherited;
end;

destructor TFhirResearchSubject.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FPeriod.free;
  FStudy.free;
  FIndividual.free;
  FAssignedArm.free;
  FActualArm.free;
  FConsent.free;
  inherited;
end;

function TFhirResearchSubject.GetResourceType : TFhirResourceType;
begin
  result := frtResearchSubject;
end;

procedure TFhirResearchSubject.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirResearchSubject(oSource).identifier.Clone;
  FStatus := TFhirResearchSubject(oSource).FStatus.Link;
  period := TFhirResearchSubject(oSource).period.Clone;
  study := TFhirResearchSubject(oSource).study.Clone;
  individual := TFhirResearchSubject(oSource).individual.Clone;
  assignedArmElement := TFhirResearchSubject(oSource).assignedArmElement.Clone;
  actualArmElement := TFhirResearchSubject(oSource).actualArmElement.Clone;
  consent := TFhirResearchSubject(oSource).consent.Clone;
end;

procedure TFhirResearchSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'study') Then
     list.add(self.link, 'study', FStudy.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
  if (child_name = 'assignedArm') Then
     list.add(self.link, 'assignedArm', FAssignedArm.Link);
  if (child_name = 'actualArm') Then
     list.add(self.link, 'actualArm', FActualArm.Link);
  if (child_name = 'consent') Then
     list.add(self.link, 'consent', FConsent.Link);
end;

procedure TFhirResearchSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'study', 'Reference(ResearchStudy)', false, TFhirReference{TFhirResearchStudy}, FStudy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'individual', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FIndividual.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assignedArm', 'string', false, TFhirString, FAssignedArm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actualArm', 'string', false, TFhirString, FActualArm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'consent', 'Reference(Consent)', false, TFhirReference{TFhirConsent}, FConsent.Link));{2}
end;

function TFhirResearchSubject.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    Study := propValue as TFhirReference{TFhirResearchStudy}{4b};
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'assignedArm') then
  begin
    AssignedArmElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'actualArm') then
  begin
    ActualArmElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'consent') then
  begin
    Consent := propValue as TFhirReference{TFhirConsent}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchSubject.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'study') then result := TFhirReference{TFhirResearchStudy}.create(){4b}
  else if (propName = 'individual') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'assignedArm') then result := TFhirString.create() {5b}
  else if (propName = 'actualArm') then result := TFhirString.create() {5b}
  else if (propName = 'consent') then result := TFhirReference{TFhirConsent}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'study') then result := 'Reference'
  else if (propName = 'individual') then result := 'Reference'
  else if (propName = 'assignedArm') then result := 'string'
  else if (propName = 'actualArm') then result := 'string'
  else if (propName = 'consent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchSubject.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'study') then StudyElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else if (propName = 'assignedArm') then AssignedArmElement := nil
  else if (propName = 'actualArm') then ActualArmElement := nil
  else if (propName = 'consent') then ConsentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'study') then StudyElement := new as TFhirReference{TFhirResearchStudy}{4}
  else if (propName = 'individual') then IndividualElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'assignedArm') then AssignedArmElement := asString(new){5b}
  else if (propName = 'actualArm') then ActualArmElement := asString(new){5b}
  else if (propName = 'consent') then ConsentElement := new as TFhirReference{TFhirConsent}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchSubject.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchSubject.fhirType : string;
begin
  result := 'ResearchSubject';
end;

function TFhirResearchSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FStudy) and isEmptyProp(FIndividual) and isEmptyProp(FAssignedArm) and isEmptyProp(FActualArm) and isEmptyProp(FConsent);
end;

function TFhirResearchSubject.equals(other : TObject) : boolean;
var
  o : TFhirResearchSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchSubject)) then
    result := false
  else
  begin
    o := TFhirResearchSubject(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(studyElement, o.studyElement, true) and
      compareDeep(individualElement, o.individualElement, true) and compareDeep(assignedArmElement, o.assignedArmElement, true) and
      compareDeep(actualArmElement, o.actualArmElement, true) and compareDeep(consentElement, o.consentElement, true);
  end;
end;

function TFhirResearchSubject.Link : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Link);
end;

function TFhirResearchSubject.Clone : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Clone);
end;

procedure TFhirResearchSubject.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('study');
  fields.add('individual');
  fields.add('assignedArm');
  fields.add('actualArm');
  fields.add('consent');
end;

{ TFhirResearchSubject }

Procedure TFhirResearchSubject.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirResearchSubject.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirResearchSubject.GetStatusST : TFhirResearchSubjectStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchSubjectStatusEnum(0)
  else
    result := TFhirResearchSubjectStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchSubjectStatusEnum, FStatus.value));
end;

Procedure TFhirResearchSubject.SetStatusST(value : TFhirResearchSubjectStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchSubjectStatusEnum[value], CODES_TFhirResearchSubjectStatusEnum[value]);
end;

Procedure TFhirResearchSubject.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirResearchSubject.SetStudy(value : TFhirReference{TFhirResearchStudy});
begin
  FStudy.free;
  FStudy := value;
end;

Procedure TFhirResearchSubject.SetIndividual(value : TFhirReference{TFhirPatient});
begin
  FIndividual.free;
  FIndividual := value;
end;

Procedure TFhirResearchSubject.SetAssignedArm(value : TFhirString);
begin
  FAssignedArm.free;
  FAssignedArm := value;
end;

Function TFhirResearchSubject.GetAssignedArmST : String;
begin
  if FAssignedArm = nil then
    result := ''
  else
    result := FAssignedArm.value;
end;

Procedure TFhirResearchSubject.SetAssignedArmST(value : String);
begin
  if value <> '' then
  begin
    if FAssignedArm = nil then
      FAssignedArm := TFhirString.create;
    FAssignedArm.value := value
  end
  else if FAssignedArm <> nil then
    FAssignedArm.value := '';
end;

Procedure TFhirResearchSubject.SetActualArm(value : TFhirString);
begin
  FActualArm.free;
  FActualArm := value;
end;

Function TFhirResearchSubject.GetActualArmST : String;
begin
  if FActualArm = nil then
    result := ''
  else
    result := FActualArm.value;
end;

Procedure TFhirResearchSubject.SetActualArmST(value : String);
begin
  if value <> '' then
  begin
    if FActualArm = nil then
      FActualArm := TFhirString.create;
    FActualArm.value := value
  end
  else if FActualArm <> nil then
    FActualArm.value := '';
end;

Procedure TFhirResearchSubject.SetConsent(value : TFhirReference{TFhirConsent});
begin
  FConsent.free;
  FConsent := value;
end;

function TFhirResearchSubject.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FStudy.sizeInBytes);
  inc(result, FIndividual.sizeInBytes);
  inc(result, FAssignedArm.sizeInBytes);
  inc(result, FActualArm.sizeInBytes);
  inc(result, FConsent.sizeInBytes);
end;

{ TFhirResearchSubjectListEnumerator }

Constructor TFhirResearchSubjectListEnumerator.Create(list : TFhirResearchSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchSubjectListEnumerator.GetCurrent : TFhirResearchSubject;
begin
  Result := FList[FIndex];
end;

function TFhirResearchSubjectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchSubjectList }
procedure TFhirResearchSubjectList.AddItem(value: TFhirResearchSubject);
begin
  assert(value.ClassName = 'TFhirResearchSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchSubject');
  add(value);
end;

function TFhirResearchSubjectList.Append: TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirResearchSubjectList.GetEnumerator : TFhirResearchSubjectListEnumerator;
begin
  result := TFhirResearchSubjectListEnumerator.Create(self.link);
end;

function TFhirResearchSubjectList.Clone: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Clone);
end;

function TFhirResearchSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchSubjectList.GetItemN(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchSubject;
end;
function TFhirResearchSubjectList.IndexOf(value: TFhirResearchSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchSubjectList.Insert(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.InsertItem(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  Inherited Insert(index, value);
end;

function TFhirResearchSubjectList.Item(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.Link: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Link);
end;

procedure TFhirResearchSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchSubjectList.SetItemByIndex(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  FhirResearchSubjects[index] := value;
end;

procedure TFhirResearchSubjectList.SetItemN(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSUBJECT}

{$IFDEF FHIR_SUBSCRIPTION}

{ TFhirSubscriptionChannel }

constructor TFhirSubscriptionChannel.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionChannel.Destroy;
begin
  FType_.free;
  FEndpoint.free;
  FPayload.free;
  FHeaderList.Free;
  inherited;
end;

procedure TFhirSubscriptionChannel.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirSubscriptionChannel(oSource).FType_.Link;
  endpointElement := TFhirSubscriptionChannel(oSource).endpointElement.Clone;
  payloadElement := TFhirSubscriptionChannel(oSource).payloadElement.Clone;
  if (TFhirSubscriptionChannel(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirSubscriptionChannel(oSource).FHeaderList);
  end;
end;

procedure TFhirSubscriptionChannel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'payload') Then
     list.add(self.link, 'payload', FPayload.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirSubscriptionChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payload', 'string', false, TFhirString, FPayload.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link)){3};
end;

function TFhirSubscriptionChannel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionChannel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'header') then HeaderList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirSubscriptionChannel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else if (propName = 'payload') then result := TFhirString.create() {5b}
  else if (propName = 'header') then result := HeaderList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionChannel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'endpoint') then result := 'uri'
  else if (propName = 'payload') then result := 'string'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionChannel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'payload') then PayloadElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionChannel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, new){4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else if (propName = 'payload') then PayloadElement := asString(new){5b}
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionChannel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'header') then HeaderList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionChannel.fhirType : string;
begin
  result := 'channel';
end;

function TFhirSubscriptionChannel.Link : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Link);
end;

function TFhirSubscriptionChannel.Clone : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Clone);
end;

function TFhirSubscriptionChannel.equals(other : TObject) : boolean;
var
  o : TFhirSubscriptionChannel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionChannel)) then
    result := false
  else
  begin
    o := TFhirSubscriptionChannel(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(endpointElement, o.endpointElement, true) and
      compareDeep(payloadElement, o.payloadElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirSubscriptionChannel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEndpoint) and isEmptyProp(FPayload) and isEmptyProp(FheaderList);
end;

procedure TFhirSubscriptionChannel.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('endpoint');
  fields.add('payload');
  fields.add('header');
end;

{ TFhirSubscriptionChannel }

Procedure TFhirSubscriptionChannel.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSubscriptionChannel.GetType_ST : TFhirSubscriptionChannelTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionChannelTypeEnum(0)
  else
    result := TFhirSubscriptionChannelTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionChannelTypeEnum, FType_.value));
end;

Procedure TFhirSubscriptionChannel.SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionChannelTypeEnum[value], CODES_TFhirSubscriptionChannelTypeEnum[value]);
end;

Procedure TFhirSubscriptionChannel.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirSubscriptionChannel.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirSubscriptionChannel.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirSubscriptionChannel.SetPayload(value : TFhirString);
begin
  FPayload.free;
  FPayload := value;
end;

Function TFhirSubscriptionChannel.GetPayloadST : String;
begin
  if FPayload = nil then
    result := ''
  else
    result := FPayload.value;
end;

Procedure TFhirSubscriptionChannel.SetPayloadST(value : String);
begin
  if value <> '' then
  begin
    if FPayload = nil then
      FPayload := TFhirString.create;
    FPayload.value := value
  end
  else if FPayload <> nil then
    FPayload.value := '';
end;

Function TFhirSubscriptionChannel.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

Function TFhirSubscriptionChannel.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

function TFhirSubscriptionChannel.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
  inc(result, FPayload.sizeInBytes);
  inc(result, FheaderList.sizeInBytes);
end;

{ TFhirSubscriptionChannelListEnumerator }

Constructor TFhirSubscriptionChannelListEnumerator.Create(list : TFhirSubscriptionChannelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionChannelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionChannelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionChannelListEnumerator.GetCurrent : TFhirSubscriptionChannel;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionChannelListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionChannelList }
procedure TFhirSubscriptionChannelList.AddItem(value: TFhirSubscriptionChannel);
begin
  assert(value.ClassName = 'TFhirSubscriptionChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionChannel');
  add(value);
end;

function TFhirSubscriptionChannelList.Append: TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionChannelList.GetEnumerator : TFhirSubscriptionChannelListEnumerator;
begin
  result := TFhirSubscriptionChannelListEnumerator.Create(self.link);
end;

function TFhirSubscriptionChannelList.Clone: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Clone);
end;

function TFhirSubscriptionChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionChannelList.GetItemN(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionChannel;
end;
function TFhirSubscriptionChannelList.IndexOf(value: TFhirSubscriptionChannel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionChannelList.Insert(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.InsertItem(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionChannelList.Item(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.Link: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Link);
end;

procedure TFhirSubscriptionChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionChannelList.SetItemByIndex(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  FhirSubscriptionChannels[index] := value;
end;

procedure TFhirSubscriptionChannelList.SetItemN(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscription }

constructor TFhirSubscription.Create;
begin
  inherited;
end;

destructor TFhirSubscription.Destroy;
begin
  FStatus.free;
  FContactList.Free;
  FEnd_.free;
  FReason.free;
  FCriteria.free;
  FError.free;
  FChannel.free;
  FTagList.Free;
  inherited;
end;

function TFhirSubscription.GetResourceType : TFhirResourceType;
begin
  result := frtSubscription;
end;

procedure TFhirSubscription.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirSubscription(oSource).FStatus.Link;
  if (TFhirSubscription(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirSubscription(oSource).FContactList);
  end;
  end_Element := TFhirSubscription(oSource).end_Element.Clone;
  reasonElement := TFhirSubscription(oSource).reasonElement.Clone;
  criteriaElement := TFhirSubscription(oSource).criteriaElement.Clone;
  errorElement := TFhirSubscription(oSource).errorElement.Clone;
  channel := TFhirSubscription(oSource).channel.Clone;
  if (TFhirSubscription(oSource).FTagList = nil) then
  begin
    FTagList.free;
    FTagList := nil;
  end
  else
  begin
    if FTagList = nil then
      FTagList := TFhirCodingList.Create;
    FTagList.Assign(TFhirSubscription(oSource).FTagList);
  end;
end;

procedure TFhirSubscription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'error') Then
     list.add(self.link, 'error', FError.Link);
  if (child_name = 'channel') Then
     list.add(self.link, 'channel', FChannel.Link);
  if (child_name = 'tag') Then
    list.addAll(self, 'tag', FTagList);
end;

procedure TFhirSubscription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
  oList.add(TFHIRProperty.create(self, 'error', 'string', false, TFhirString, FError.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', false, TFhirSubscriptionChannel, FChannel.Link));{2}
  oList.add(TFHIRProperty.create(self, 'tag', 'Coding', true, TFhirCoding, FTagList.Link)){3};
end;

function TFhirSubscription.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'channel') then
  begin
    Channel := propValue as TFhirSubscriptionChannel{4b};
    result := propValue;
  end
  else if (propName = 'tag') then
  begin
    TagList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubscription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'tag') then TagList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirSubscription.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'reason') then result := TFhirString.create() {5b}
  else if (propName = 'criteria') then result := TFhirString.create() {5b}
  else if (propName = 'error') then result := TFhirString.create() {5b}
  else if (propName = 'channel') then result := TFhirSubscriptionChannel.create(){4b}
  else if (propName = 'tag') then result := TagList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'criteria') then result := 'string'
  else if (propName = 'error') then result := 'string'
  else if (propName = 'channel') then result := ''
  else if (propName = 'tag') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscription.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'error') then ErrorElement := nil
  else if (propName = 'channel') then ChannelElement := nil
  else if (propName = 'tag') then deletePropertyValue('tag', TagList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, new){4}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'reason') then ReasonElement := asString(new){5b}
  else if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else if (propName = 'error') then ErrorElement := asString(new){5b}
  else if (propName = 'channel') then ChannelElement := new as TFhirSubscriptionChannel{4}
  else if (propName = 'tag') then replacePropertyValue('tag', TagList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'tag') then TagList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscription.fhirType : string;
begin
  result := 'Subscription';
end;

function TFhirSubscription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FcontactList) and isEmptyProp(FEnd_) and isEmptyProp(FReason) and isEmptyProp(FCriteria) and isEmptyProp(FError) and isEmptyProp(FChannel) and isEmptyProp(FtagList);
end;

function TFhirSubscription.equals(other : TObject) : boolean;
var
  o : TFhirSubscription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscription)) then
    result := false
  else
  begin
    o := TFhirSubscription(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(contactList, o.contactList, true) and
      compareDeep(end_Element, o.end_Element, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(errorElement, o.errorElement, true) and
      compareDeep(channelElement, o.channelElement, true) and compareDeep(tagList, o.tagList, true);
  end;
end;

function TFhirSubscription.Link : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Link);
end;

function TFhirSubscription.Clone : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Clone);
end;

procedure TFhirSubscription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('status');
  fields.add('contact');
  fields.add('end');
  fields.add('reason');
  fields.add('criteria');
  fields.add('error');
  fields.add('channel');
  fields.add('tag');
end;

{ TFhirSubscription }

Procedure TFhirSubscription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSubscription.GetStatusST : TFhirSubscriptionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusEnum(0)
  else
    result := TFhirSubscriptionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusEnum, FStatus.value));
end;

Procedure TFhirSubscription.SetStatusST(value : TFhirSubscriptionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[value], CODES_TFhirSubscriptionStatusEnum[value]);
end;

Function TFhirSubscription.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

Function TFhirSubscription.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirSubscription.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSubscription.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirSubscription.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Procedure TFhirSubscription.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirSubscription.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

Procedure TFhirSubscription.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

Procedure TFhirSubscription.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirSubscription.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirSubscription.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

Procedure TFhirSubscription.SetError(value : TFhirString);
begin
  FError.free;
  FError := value;
end;

Function TFhirSubscription.GetErrorST : String;
begin
  if FError = nil then
    result := ''
  else
    result := FError.value;
end;

Procedure TFhirSubscription.SetErrorST(value : String);
begin
  if value <> '' then
  begin
    if FError = nil then
      FError := TFhirString.create;
    FError.value := value
  end
  else if FError <> nil then
    FError.value := '';
end;

Procedure TFhirSubscription.SetChannel(value : TFhirSubscriptionChannel);
begin
  FChannel.free;
  FChannel := value;
end;

Function TFhirSubscription.GetTagList : TFhirCodingList;
begin
  if FTagList = nil then
    FTagList := TFhirCodingList.Create;
  result := FTagList;
end;

Function TFhirSubscription.GetHasTagList : boolean;
begin
  result := (FTagList <> nil) and (FTagList.count > 0);
end;

function TFhirSubscription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FCriteria.sizeInBytes);
  inc(result, FError.sizeInBytes);
  inc(result, FChannel.sizeInBytes);
  inc(result, FtagList.sizeInBytes);
end;

{ TFhirSubscriptionListEnumerator }

Constructor TFhirSubscriptionListEnumerator.Create(list : TFhirSubscriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionListEnumerator.GetCurrent : TFhirSubscription;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionList }
procedure TFhirSubscriptionList.AddItem(value: TFhirSubscription);
begin
  assert(value.ClassName = 'TFhirSubscription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscription');
  add(value);
end;

function TFhirSubscriptionList.Append: TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionList.GetEnumerator : TFhirSubscriptionListEnumerator;
begin
  result := TFhirSubscriptionListEnumerator.Create(self.link);
end;

function TFhirSubscriptionList.Clone: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Clone);
end;

function TFhirSubscriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionList.GetItemN(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscription;
end;
function TFhirSubscriptionList.IndexOf(value: TFhirSubscription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionList.Insert(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.InsertItem(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionList.Item(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.Link: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Link);
end;

procedure TFhirSubscriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionList.SetItemByIndex(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  FhirSubscriptions[index] := value;
end;

procedure TFhirSubscriptionList.SetItemN(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTION}

{$IFDEF FHIR_TASK}

{ TFhirTaskRequester }

constructor TFhirTaskRequester.Create;
begin
  inherited;
end;

destructor TFhirTaskRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirTaskRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirTaskRequester(oSource).agent.Clone;
  onBehalfOf := TFhirTaskRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirTaskRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirTaskRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirTaskRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirTaskRequester.Link : TFhirTaskRequester;
begin
  result := TFhirTaskRequester(inherited Link);
end;

function TFhirTaskRequester.Clone : TFhirTaskRequester;
begin
  result := TFhirTaskRequester(inherited Clone);
end;

function TFhirTaskRequester.equals(other : TObject) : boolean;
var
  o : TFhirTaskRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskRequester)) then
    result := false
  else
  begin
    o := TFhirTaskRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirTaskRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirTaskRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirTaskRequester }

Procedure TFhirTaskRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirTaskRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirTaskRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirTaskRequesterListEnumerator }

Constructor TFhirTaskRequesterListEnumerator.Create(list : TFhirTaskRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskRequesterListEnumerator.GetCurrent : TFhirTaskRequester;
begin
  Result := FList[FIndex];
end;

function TFhirTaskRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskRequesterList }
procedure TFhirTaskRequesterList.AddItem(value: TFhirTaskRequester);
begin
  assert(value.ClassName = 'TFhirTaskRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskRequester');
  add(value);
end;

function TFhirTaskRequesterList.Append: TFhirTaskRequester;
begin
  result := TFhirTaskRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirTaskRequesterList.GetEnumerator : TFhirTaskRequesterListEnumerator;
begin
  result := TFhirTaskRequesterListEnumerator.Create(self.link);
end;

function TFhirTaskRequesterList.Clone: TFhirTaskRequesterList;
begin
  result := TFhirTaskRequesterList(inherited Clone);
end;

function TFhirTaskRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskRequesterList.GetItemN(index: Integer): TFhirTaskRequester;
begin
  result := TFhirTaskRequester(ObjectByIndex[index]);
end;

function TFhirTaskRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskRequester;
end;
function TFhirTaskRequesterList.IndexOf(value: TFhirTaskRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskRequesterList.Insert(index: Integer): TFhirTaskRequester;
begin
  result := TFhirTaskRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRequesterList.InsertItem(index: Integer; value: TFhirTaskRequester);
begin
  assert(value is TFhirTaskRequester);
  Inherited Insert(index, value);
end;

function TFhirTaskRequesterList.Item(index: Integer): TFhirTaskRequester;
begin
  result := TFhirTaskRequester(ObjectByIndex[index]);
end;

function TFhirTaskRequesterList.Link: TFhirTaskRequesterList;
begin
  result := TFhirTaskRequesterList(inherited Link);
end;

procedure TFhirTaskRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskRequesterList.SetItemByIndex(index: Integer; value: TFhirTaskRequester);
begin
  assert(value is TFhirTaskRequester);
  FhirTaskRequesters[index] := value;
end;

procedure TFhirTaskRequesterList.SetItemN(index: Integer; value: TFhirTaskRequester);
begin
  assert(value is TFhirTaskRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskRestriction }

constructor TFhirTaskRestriction.Create;
begin
  inherited;
end;

destructor TFhirTaskRestriction.Destroy;
begin
  FRepetitions.free;
  FPeriod.free;
  FRecipientList.Free;
  inherited;
end;

procedure TFhirTaskRestriction.Assign(oSource : TFslObject);
begin
  inherited;
  repetitionsElement := TFhirTaskRestriction(oSource).repetitionsElement.Clone;
  period := TFhirTaskRestriction(oSource).period.Clone;
  if (TFhirTaskRestriction(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirTaskRestriction(oSource).FRecipientList);
  end;
end;

procedure TFhirTaskRestriction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'repetitions') Then
     list.add(self.link, 'repetitions', FRepetitions.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
end;

procedure TFhirTaskRestriction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'repetitions', 'positiveInt', false, TFhirPositiveInt, FRepetitions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Patient|Practitioner|RelatedPerson|Group|Organization)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
end;

function TFhirTaskRestriction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'repetitions') then
  begin
    RepetitionsElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskRestriction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirTaskRestriction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'repetitions') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskRestriction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'repetitions') then result := 'positiveInt'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recipient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskRestriction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskRestriction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := asPositiveInt(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskRestriction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskRestriction.fhirType : string;
begin
  result := 'restriction';
end;

function TFhirTaskRestriction.Link : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Link);
end;

function TFhirTaskRestriction.Clone : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Clone);
end;

function TFhirTaskRestriction.equals(other : TObject) : boolean;
var
  o : TFhirTaskRestriction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskRestriction)) then
    result := false
  else
  begin
    o := TFhirTaskRestriction(other);
    result := compareDeep(repetitionsElement, o.repetitionsElement, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(recipientList, o.recipientList, true);
  end;
end;

function TFhirTaskRestriction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRepetitions) and isEmptyProp(FPeriod) and isEmptyProp(FrecipientList);
end;

procedure TFhirTaskRestriction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('repetitions');
  fields.add('period');
  fields.add('recipient');
end;

{ TFhirTaskRestriction }

Procedure TFhirTaskRestriction.SetRepetitions(value : TFhirPositiveInt);
begin
  FRepetitions.free;
  FRepetitions := value;
end;

Function TFhirTaskRestriction.GetRepetitionsST : String;
begin
  if FRepetitions = nil then
    result := ''
  else
    result := FRepetitions.value;
end;

Procedure TFhirTaskRestriction.SetRepetitionsST(value : String);
begin
  if value <> '' then
  begin
    if FRepetitions = nil then
      FRepetitions := TFhirPositiveInt.create;
    FRepetitions.value := value
  end
  else if FRepetitions <> nil then
    FRepetitions.value := '';
end;

Procedure TFhirTaskRestriction.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirTaskRestriction.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirTaskRestriction.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

function TFhirTaskRestriction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRepetitions.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
end;

{ TFhirTaskRestrictionListEnumerator }

Constructor TFhirTaskRestrictionListEnumerator.Create(list : TFhirTaskRestrictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskRestrictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskRestrictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskRestrictionListEnumerator.GetCurrent : TFhirTaskRestriction;
begin
  Result := FList[FIndex];
end;

function TFhirTaskRestrictionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskRestrictionList }
procedure TFhirTaskRestrictionList.AddItem(value: TFhirTaskRestriction);
begin
  assert(value.ClassName = 'TFhirTaskRestriction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskRestriction');
  add(value);
end;

function TFhirTaskRestrictionList.Append: TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.ClearItems;
begin
  Clear;
end;

function TFhirTaskRestrictionList.GetEnumerator : TFhirTaskRestrictionListEnumerator;
begin
  result := TFhirTaskRestrictionListEnumerator.Create(self.link);
end;

function TFhirTaskRestrictionList.Clone: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Clone);
end;

function TFhirTaskRestrictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskRestrictionList.GetItemN(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskRestriction;
end;
function TFhirTaskRestrictionList.IndexOf(value: TFhirTaskRestriction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskRestrictionList.Insert(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.InsertItem(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  Inherited Insert(index, value);
end;

function TFhirTaskRestrictionList.Item(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.Link: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Link);
end;

procedure TFhirTaskRestrictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskRestrictionList.SetItemByIndex(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  FhirTaskRestrictions[index] := value;
end;

procedure TFhirTaskRestrictionList.SetItemN(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskInput }

constructor TFhirTaskInput.Create;
begin
  inherited;
end;

destructor TFhirTaskInput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskInput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskInput(oSource).type_.Clone;
  value := TFhirTaskInput(oSource).value.Clone;
end;

procedure TFhirTaskInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta', false, TFhirType, FValue.Link));{2}
end;

function TFhirTaskInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskInput.fhirType : string;
begin
  result := 'input';
end;

function TFhirTaskInput.Link : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Link);
end;

function TFhirTaskInput.Clone : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Clone);
end;

function TFhirTaskInput.equals(other : TObject) : boolean;
var
  o : TFhirTaskInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskInput)) then
    result := false
  else
  begin
    o := TFhirTaskInput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskInput.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirTaskInput }

Procedure TFhirTaskInput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTaskInput.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTaskInput.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTaskInputListEnumerator }

Constructor TFhirTaskInputListEnumerator.Create(list : TFhirTaskInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskInputListEnumerator.GetCurrent : TFhirTaskInput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskInputListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskInputList }
procedure TFhirTaskInputList.AddItem(value: TFhirTaskInput);
begin
  assert(value.ClassName = 'TFhirTaskInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskInput');
  add(value);
end;

function TFhirTaskInputList.Append: TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskInputList.GetEnumerator : TFhirTaskInputListEnumerator;
begin
  result := TFhirTaskInputListEnumerator.Create(self.link);
end;

function TFhirTaskInputList.Clone: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Clone);
end;

function TFhirTaskInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskInputList.GetItemN(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskInput;
end;
function TFhirTaskInputList.IndexOf(value: TFhirTaskInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskInputList.Insert(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.InsertItem(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  Inherited Insert(index, value);
end;

function TFhirTaskInputList.Item(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.Link: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Link);
end;

procedure TFhirTaskInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskInputList.SetItemByIndex(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  FhirTaskInputs[index] := value;
end;

procedure TFhirTaskInputList.SetItemN(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskOutput }

constructor TFhirTaskOutput.Create;
begin
  inherited;
end;

destructor TFhirTaskOutput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskOutput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskOutput(oSource).type_.Clone;
  value := TFhirTaskOutput(oSource).value.Clone;
end;

procedure TFhirTaskOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta', false, TFhirType, FValue.Link));{2}
end;

function TFhirTaskOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskOutput.fhirType : string;
begin
  result := 'output';
end;

function TFhirTaskOutput.Link : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Link);
end;

function TFhirTaskOutput.Clone : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Clone);
end;

function TFhirTaskOutput.equals(other : TObject) : boolean;
var
  o : TFhirTaskOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskOutput)) then
    result := false
  else
  begin
    o := TFhirTaskOutput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskOutput.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirTaskOutput }

Procedure TFhirTaskOutput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTaskOutput.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTaskOutput.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTaskOutputListEnumerator }

Constructor TFhirTaskOutputListEnumerator.Create(list : TFhirTaskOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskOutputListEnumerator.GetCurrent : TFhirTaskOutput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskOutputListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskOutputList }
procedure TFhirTaskOutputList.AddItem(value: TFhirTaskOutput);
begin
  assert(value.ClassName = 'TFhirTaskOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskOutput');
  add(value);
end;

function TFhirTaskOutputList.Append: TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskOutputList.GetEnumerator : TFhirTaskOutputListEnumerator;
begin
  result := TFhirTaskOutputListEnumerator.Create(self.link);
end;

function TFhirTaskOutputList.Clone: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Clone);
end;

function TFhirTaskOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskOutputList.GetItemN(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskOutput;
end;
function TFhirTaskOutputList.IndexOf(value: TFhirTaskOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskOutputList.Insert(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.InsertItem(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  Inherited Insert(index, value);
end;

function TFhirTaskOutputList.Item(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.Link: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Link);
end;

procedure TFhirTaskOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskOutputList.SetItemByIndex(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  FhirTaskOutputs[index] := value;
end;

procedure TFhirTaskOutputList.SetItemN(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirTask }

constructor TFhirTask.Create;
begin
  inherited;
end;

destructor TFhirTask.Destroy;
begin
  FIdentifierList.Free;
  FDefinition.free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FBusinessStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FDescription.free;
  FFocus.free;
  FFor_.free;
  FContext.free;
  FExecutionPeriod.free;
  FAuthoredOn.free;
  FLastModified.free;
  FRequester.free;
  FPerformerTypeList.Free;
  FOwner.free;
  FReason.free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  FRestriction.free;
  FInputList.Free;
  FOutputList.Free;
  inherited;
end;

function TFhirTask.GetResourceType : TFhirResourceType;
begin
  result := frtTask;
end;

procedure TFhirTask.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTask(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirTask(oSource).FIdentifierList);
  end;
  definition := TFhirTask(oSource).definition.Clone;
  if (TFhirTask(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirTask(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirTask(oSource).groupIdentifier.Clone;
  if (TFhirTask(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirTask}.Create;
    FPartOfList.Assign(TFhirTask(oSource).FPartOfList);
  end;
  FStatus := TFhirTask(oSource).FStatus.Link;
  statusReason := TFhirTask(oSource).statusReason.Clone;
  businessStatus := TFhirTask(oSource).businessStatus.Clone;
  FIntent := TFhirTask(oSource).FIntent.Link;
  FPriority := TFhirTask(oSource).FPriority.Link;
  code := TFhirTask(oSource).code.Clone;
  descriptionElement := TFhirTask(oSource).descriptionElement.Clone;
  focus := TFhirTask(oSource).focus.Clone;
  for_ := TFhirTask(oSource).for_.Clone;
  context := TFhirTask(oSource).context.Clone;
  executionPeriod := TFhirTask(oSource).executionPeriod.Clone;
  authoredOnElement := TFhirTask(oSource).authoredOnElement.Clone;
  lastModifiedElement := TFhirTask(oSource).lastModifiedElement.Clone;
  requester := TFhirTask(oSource).requester.Clone;
  if (TFhirTask(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirTask(oSource).FPerformerTypeList);
  end;
  owner := TFhirTask(oSource).owner.Clone;
  reason := TFhirTask(oSource).reason.Clone;
  if (TFhirTask(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirTask(oSource).FNoteList);
  end;
  if (TFhirTask(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirTask(oSource).FRelevantHistoryList);
  end;
  restriction := TFhirTask(oSource).restriction.Clone;
  if (TFhirTask(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirTaskInputList.Create;
    FInputList.Assign(TFhirTask(oSource).FInputList);
  end;
  if (TFhirTask(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirTaskOutputList.Create;
    FOutputList.Assign(TFhirTask(oSource).FOutputList);
  end;
end;

procedure TFhirTask.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'businessStatus') Then
     list.add(self.link, 'businessStatus', FBusinessStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'for') Then
     list.add(self.link, 'for', FFor_.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'executionPeriod') Then
     list.add(self.link, 'executionPeriod', FExecutionPeriod.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'restriction') Then
     list.add(self.link, 'restriction', FRestriction.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
end;

procedure TFhirTask.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'uri|Reference(ActivityDefinition)', false, TFhirType, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(Task)', true, TFhirReference{TFhirTask}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessStatus', 'CodeableConcept', false, TFhirCodeableConcept, FBusinessStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference(Any)', false, TFhirReference{TFhirReference}, FFocus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'for', 'Reference(Any)', false, TFhirReference{TFhirReference}, FFor_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'executionPeriod', 'Period', false, TFhirPeriod, FExecutionPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastModified', 'dateTime', false, TFhirDateTime, FLastModified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirTaskRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FOwner.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'restriction', '', false, TFhirTaskRestriction, FRestriction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'input', '', true, TFhirTaskInput, FInputList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'output', '', true, TFhirTaskOutput, FOutputList.Link)){3};
end;

function TFhirTask.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Uri', 'Reference'])) then
  begin
    Definition := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirTask}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'businessStatus') then
  begin
    BusinessStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_ := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'executionPeriod') then
  begin
    ExecutionPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirTaskRequester{4b};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else if (propName = 'restriction') then
  begin
    Restriction := propValue as TFhirTaskRestriction{4b};
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirTaskInput){2a};
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirTaskOutput){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTask.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirTask}){2a}
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirTaskInput){2a}
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirTaskOutput){2a}
  else inherited;
end;

function TFhirTask.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (isMatchingName(propName, 'definition', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Definition'){4x}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'businessStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'focus') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'for') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'executionPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'lastModified') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirTaskRequester.create(){4b}
  else if (propName = 'performerType') then result := PerformerTypeList.new(){2}
  else if (propName = 'owner') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else if (propName = 'restriction') then result := TFhirTaskRestriction.create(){4b}
  else if (propName = 'input') then result := InputList.new(){2}
  else if (propName = 'output') then result := OutputList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTask.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition[x]') then result := 'uri|Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'businessStatus') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'executionPeriod') then result := 'Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'lastModified') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'restriction') then result := ''
  else if (propName = 'input') then result := ''
  else if (propName = 'output') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTask.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (isMatchingName(propName, 'definition', ['Uri', 'Reference'])) then DefinitionElement := nil{4x}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'businessStatus') then BusinessStatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'for') then For_Element := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value) {2}
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else if (propName = 'restriction') then RestrictionElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value) {2}
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTask.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (isMatchingName(propName, 'definition', ['Uri', 'Reference'])) then DefinitionElement := new as TFhirType{4x}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, new){4}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'businessStatus') then BusinessStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'focus') then FocusElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'for') then For_Element := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'lastModified') then LastModifiedElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirTaskRequester{4}
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new) {2}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else if (propName = 'restriction') then RestrictionElement := new as TFhirTaskRestriction{4}
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new) {2}
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTask.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else if (propName = 'input') then InputList.move(source, destination){2a}
  else if (propName = 'output') then OutputList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTask.fhirType : string;
begin
  result := 'Task';
end;

function TFhirTask.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDefinition) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FBusinessStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FFocus) and isEmptyProp(FFor_) and isEmptyProp(FContext) and isEmptyProp(FExecutionPeriod) and isEmptyProp(FAuthoredOn) and isEmptyProp(FLastModified) and isEmptyProp(FRequester) and isEmptyProp(FperformerTypeList) and isEmptyProp(FOwner) and isEmptyProp(FReason) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FRestriction) and isEmptyProp(FinputList) and isEmptyProp(FoutputList);
end;

function TFhirTask.equals(other : TObject) : boolean;
var
  o : TFhirTask;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTask)) then
    result := false
  else
  begin
    o := TFhirTask(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionElement, o.definitionElement, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(businessStatusElement, o.businessStatusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(focusElement, o.focusElement, true) and compareDeep(for_Element, o.for_Element, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(executionPeriodElement, o.executionPeriodElement, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(performerTypeList, o.performerTypeList, true) and
      compareDeep(ownerElement, o.ownerElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and
      compareDeep(restrictionElement, o.restrictionElement, true) and compareDeep(inputList, o.inputList, true) and
      compareDeep(outputList, o.outputList, true);
  end;
end;

function TFhirTask.Link : TFhirTask;
begin
  result := TFhirTask(inherited Link);
end;

function TFhirTask.Clone : TFhirTask;
begin
  result := TFhirTask(inherited Clone);
end;

procedure TFhirTask.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition[x]');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('businessStatus');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('description');
  fields.add('focus');
  fields.add('for');
  fields.add('context');
  fields.add('executionPeriod');
  fields.add('authoredOn');
  fields.add('lastModified');
  fields.add('requester');
  fields.add('performerType');
  fields.add('owner');
  fields.add('reason');
  fields.add('note');
  fields.add('relevantHistory');
  fields.add('restriction');
  fields.add('input');
  fields.add('output');
end;

{ TFhirTask }

Function TFhirTask.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirTask.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirTask.SetDefinition(value : TFhirType);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirTask.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirTask.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirTask.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Function TFhirTask.GetPartOfList : TFhirReferenceList{TFhirTask};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirTask}.Create;
  result := FPartOfList;
end;

Function TFhirTask.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirTask.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirTask.GetStatusST : TFhirTaskStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTaskStatusEnum(0)
  else
    result := TFhirTaskStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskStatusEnum, FStatus.value));
end;

Procedure TFhirTask.SetStatusST(value : TFhirTaskStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[value], CODES_TFhirTaskStatusEnum[value]);
end;

Procedure TFhirTask.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Procedure TFhirTask.SetBusinessStatus(value : TFhirCodeableConcept);
begin
  FBusinessStatus.free;
  FBusinessStatus := value;
end;

Procedure TFhirTask.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirTask.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

Procedure TFhirTask.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

Procedure TFhirTask.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirTask.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirTask.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirTask.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirTask.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTask.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTask.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTask.SetFocus(value : TFhirReference{TFhirReference});
begin
  FFocus.free;
  FFocus := value;
end;

Procedure TFhirTask.SetFor_(value : TFhirReference{TFhirReference});
begin
  FFor_.free;
  FFor_ := value;
end;

Procedure TFhirTask.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirTask.SetExecutionPeriod(value : TFhirPeriod);
begin
  FExecutionPeriod.free;
  FExecutionPeriod := value;
end;

Procedure TFhirTask.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirTask.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirTask.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirTask.SetLastModified(value : TFhirDateTime);
begin
  FLastModified.free;
  FLastModified := value;
end;

Function TFhirTask.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

Procedure TFhirTask.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirDateTime.create;
  FLastModified.value := value
end;

Procedure TFhirTask.SetRequester(value : TFhirTaskRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Function TFhirTask.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

Function TFhirTask.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

Procedure TFhirTask.SetOwner(value : TFhirReference{Resource});
begin
  FOwner.free;
  FOwner := value;
end;

Procedure TFhirTask.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirTask.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirTask.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirTask.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirTask.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

Procedure TFhirTask.SetRestriction(value : TFhirTaskRestriction);
begin
  FRestriction.free;
  FRestriction := value;
end;

Function TFhirTask.GetInputList : TFhirTaskInputList;
begin
  if FInputList = nil then
    FInputList := TFhirTaskInputList.Create;
  result := FInputList;
end;

Function TFhirTask.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

Function TFhirTask.GetOutputList : TFhirTaskOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirTaskOutputList.Create;
  result := FOutputList;
end;

Function TFhirTask.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

function TFhirTask.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FBusinessStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FFocus.sizeInBytes);
  inc(result, FFor_.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FExecutionPeriod.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FLastModified.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FperformerTypeList.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
  inc(result, FRestriction.sizeInBytes);
  inc(result, FinputList.sizeInBytes);
  inc(result, FoutputList.sizeInBytes);
end;

{ TFhirTaskListEnumerator }

Constructor TFhirTaskListEnumerator.Create(list : TFhirTaskList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskListEnumerator.GetCurrent : TFhirTask;
begin
  Result := FList[FIndex];
end;

function TFhirTaskListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskList }
procedure TFhirTaskList.AddItem(value: TFhirTask);
begin
  assert(value.ClassName = 'TFhirTask', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTask');
  add(value);
end;

function TFhirTaskList.Append: TFhirTask;
begin
  result := TFhirTask.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.ClearItems;
begin
  Clear;
end;

function TFhirTaskList.GetEnumerator : TFhirTaskListEnumerator;
begin
  result := TFhirTaskListEnumerator.Create(self.link);
end;

function TFhirTaskList.Clone: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Clone);
end;

function TFhirTaskList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskList.GetItemN(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.ItemClass: TFslObjectClass;
begin
  result := TFhirTask;
end;
function TFhirTaskList.IndexOf(value: TFhirTask): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskList.Insert(index: Integer): TFhirTask;
begin
  result := TFhirTask.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.InsertItem(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  Inherited Insert(index, value);
end;

function TFhirTaskList.Item(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.Link: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Link);
end;

procedure TFhirTaskList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskList.SetItemByIndex(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  FhirTasks[index] := value;
end;

procedure TFhirTaskList.SetItemN(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TASK}

{$IFDEF FHIR_TESTREPORT}

{ TFhirTestReportParticipant }

constructor TFhirTestReportParticipant.Create;
begin
  inherited;
end;

destructor TFhirTestReportParticipant.Destroy;
begin
  FType_.free;
  FUri.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirTestReportParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirTestReportParticipant(oSource).FType_.Link;
  uriElement := TFhirTestReportParticipant(oSource).uriElement.Clone;
  displayElement := TFhirTestReportParticipant(oSource).displayElement.Clone;
end;

procedure TFhirTestReportParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirTestReportParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
end;

function TFhirTestReportParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirReportParticipantTypeEnum, CODES_TFhirReportParticipantTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirReportParticipantTypeEnum, CODES_TFhirReportParticipantTypeEnum, new){4}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirTestReportParticipant.Link : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Link);
end;

function TFhirTestReportParticipant.Clone : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Clone);
end;

function TFhirTestReportParticipant.equals(other : TObject) : boolean;
var
  o : TFhirTestReportParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportParticipant)) then
    result := false
  else
  begin
    o := TFhirTestReportParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true) and
      compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirTestReportParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri) and isEmptyProp(FDisplay);
end;

procedure TFhirTestReportParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
  fields.add('display');
end;

{ TFhirTestReportParticipant }

Procedure TFhirTestReportParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirTestReportParticipant.GetType_ST : TFhirReportParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirReportParticipantTypeEnum(0)
  else
    result := TFhirReportParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirReportParticipantTypeEnum, FType_.value));
end;

Procedure TFhirTestReportParticipant.SetType_ST(value : TFhirReportParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirReportParticipantTypeEnum[value], CODES_TFhirReportParticipantTypeEnum[value]);
end;

Procedure TFhirTestReportParticipant.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirTestReportParticipant.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirTestReportParticipant.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirTestReportParticipant.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirTestReportParticipant.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirTestReportParticipant.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirTestReportParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
end;

{ TFhirTestReportParticipantListEnumerator }

Constructor TFhirTestReportParticipantListEnumerator.Create(list : TFhirTestReportParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportParticipantListEnumerator.GetCurrent : TFhirTestReportParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportParticipantList }
procedure TFhirTestReportParticipantList.AddItem(value: TFhirTestReportParticipant);
begin
  assert(value.ClassName = 'TFhirTestReportParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportParticipant');
  add(value);
end;

function TFhirTestReportParticipantList.Append: TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportParticipantList.GetEnumerator : TFhirTestReportParticipantListEnumerator;
begin
  result := TFhirTestReportParticipantListEnumerator.Create(self.link);
end;

function TFhirTestReportParticipantList.Clone: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Clone);
end;

function TFhirTestReportParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportParticipantList.GetItemN(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportParticipant;
end;
function TFhirTestReportParticipantList.IndexOf(value: TFhirTestReportParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportParticipantList.Insert(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.InsertItem(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  Inherited Insert(index, value);
end;

function TFhirTestReportParticipantList.Item(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.Link: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Link);
end;

procedure TFhirTestReportParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportParticipantList.SetItemByIndex(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  FhirTestReportParticipants[index] := value;
end;

procedure TFhirTestReportParticipantList.SetItemN(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetup }

constructor TFhirTestReportSetup.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportSetupActionList.Create;
    FActionList.Assign(TFhirTestReportSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestReportSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportSetupAction, FActionList.Link)){3};
end;

function TFhirTestReportSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportSetupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportSetupAction){2a}
  else inherited;
end;

function TFhirTestReportSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetup.fhirType : string;
begin
  result := 'setup';
end;

function TFhirTestReportSetup.Link : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Link);
end;

function TFhirTestReportSetup.Clone : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Clone);
end;

function TFhirTestReportSetup.equals(other : TObject) : boolean;
var
  o : TFhirTestReportSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetup)) then
    result := false
  else
  begin
    o := TFhirTestReportSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportSetup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestReportSetup }

Function TFhirTestReportSetup.GetActionList : TFhirTestReportSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportSetupActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportSetup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportSetupListEnumerator }

Constructor TFhirTestReportSetupListEnumerator.Create(list : TFhirTestReportSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupListEnumerator.GetCurrent : TFhirTestReportSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupList }
procedure TFhirTestReportSetupList.AddItem(value: TFhirTestReportSetup);
begin
  assert(value.ClassName = 'TFhirTestReportSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetup');
  add(value);
end;

function TFhirTestReportSetupList.Append: TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupList.GetEnumerator : TFhirTestReportSetupListEnumerator;
begin
  result := TFhirTestReportSetupListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupList.Clone: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Clone);
end;

function TFhirTestReportSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupList.GetItemN(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetup;
end;
function TFhirTestReportSetupList.IndexOf(value: TFhirTestReportSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupList.Insert(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.InsertItem(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupList.Item(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.Link: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Link);
end;

procedure TFhirTestReportSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupList.SetItemByIndex(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  FhirTestReportSetups[index] := value;
end;

procedure TFhirTestReportSetupList.SetItemN(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupAction }

constructor TFhirTestReportSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportSetupAction(oSource).operation.Clone;
  assert := TFhirTestReportSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestReportSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestReportSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestReportSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportSetupAction.Link : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Link);
end;

function TFhirTestReportSetupAction.Clone : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Clone);
end;

function TFhirTestReportSetupAction.equals(other : TObject) : boolean;
var
  o : TFhirTestReportSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportSetupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestReportSetupAction }

Procedure TFhirTestReportSetupAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestReportSetupAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestReportSetupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestReportSetupActionListEnumerator }

Constructor TFhirTestReportSetupActionListEnumerator.Create(list : TFhirTestReportSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionListEnumerator.GetCurrent : TFhirTestReportSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionList }
procedure TFhirTestReportSetupActionList.AddItem(value: TFhirTestReportSetupAction);
begin
  assert(value.ClassName = 'TFhirTestReportSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupAction');
  add(value);
end;

function TFhirTestReportSetupActionList.Append: TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionList.GetEnumerator : TFhirTestReportSetupActionListEnumerator;
begin
  result := TFhirTestReportSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionList.Clone: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Clone);
end;

function TFhirTestReportSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionList.GetItemN(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupAction;
end;
function TFhirTestReportSetupActionList.IndexOf(value: TFhirTestReportSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionList.Insert(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.InsertItem(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionList.Item(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.Link: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Link);
end;

procedure TFhirTestReportSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  FhirTestReportSetupActions[index] := value;
end;

procedure TFhirTestReportSetupActionList.SetItemN(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionOperation }

constructor TFhirTestReportSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionOperation.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  FResult := TFhirTestReportSetupActionOperation(oSource).FResult.Link;
  messageElement := TFhirTestReportSetupActionOperation(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionOperation(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'uri', false, TFhirUri, FDetail.Link));{2}
end;

function TFhirTestReportSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'detail') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, new){4}
  else if (propName = 'message') then MessageElement := asMarkdown(new){5b}
  else if (propName = 'detail') then DetailElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirTestReportSetupActionOperation.Link : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Link);
end;

function TFhirTestReportSetupActionOperation.Clone : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Clone);
end;

function TFhirTestReportSetupActionOperation.equals(other : TObject) : boolean;
var
  o : TFhirTestReportSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionOperation(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

{ TFhirTestReportSetupActionOperation }

Procedure TFhirTestReportSetupActionOperation.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReportSetupActionOperation.GetResultST : TFhirReportActionResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportActionResultCodesEnum(0)
  else
    result := TFhirReportActionResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportActionResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReportSetupActionOperation.SetResultST(value : TFhirReportActionResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportActionResultCodesEnum[value], CODES_TFhirReportActionResultCodesEnum[value]);
end;

Procedure TFhirTestReportSetupActionOperation.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

Function TFhirTestReportSetupActionOperation.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

Procedure TFhirTestReportSetupActionOperation.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

Procedure TFhirTestReportSetupActionOperation.SetDetail(value : TFhirUri);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirTestReportSetupActionOperation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirTestReportSetupActionOperation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirUri.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

function TFhirTestReportSetupActionOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResult.sizeInBytes);
  inc(result, FMessage.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirTestReportSetupActionOperationListEnumerator }

Constructor TFhirTestReportSetupActionOperationListEnumerator.Create(list : TFhirTestReportSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionOperationListEnumerator.GetCurrent : TFhirTestReportSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionOperationList }
procedure TFhirTestReportSetupActionOperationList.AddItem(value: TFhirTestReportSetupActionOperation);
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionOperation');
  add(value);
end;

function TFhirTestReportSetupActionOperationList.Append: TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionOperationList.GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
begin
  result := TFhirTestReportSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionOperationList.Clone: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Clone);
end;

function TFhirTestReportSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionOperationList.GetItemN(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionOperation;
end;
function TFhirTestReportSetupActionOperationList.IndexOf(value: TFhirTestReportSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionOperationList.Insert(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionOperationList.Item(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.Link: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Link);
end;

procedure TFhirTestReportSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  FhirTestReportSetupActionOperations[index] := value;
end;

procedure TFhirTestReportSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionAssert }

constructor TFhirTestReportSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionAssert.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  FResult := TFhirTestReportSetupActionAssert(oSource).FResult.Link;
  messageElement := TFhirTestReportSetupActionAssert(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionAssert(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));{2}
end;

function TFhirTestReportSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'detail') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, new){4}
  else if (propName = 'message') then MessageElement := asMarkdown(new){5b}
  else if (propName = 'detail') then DetailElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionAssert.fhirType : string;
begin
  result := 'assert';
end;

function TFhirTestReportSetupActionAssert.Link : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Link);
end;

function TFhirTestReportSetupActionAssert.Clone : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Clone);
end;

function TFhirTestReportSetupActionAssert.equals(other : TObject) : boolean;
var
  o : TFhirTestReportSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionAssert(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

{ TFhirTestReportSetupActionAssert }

Procedure TFhirTestReportSetupActionAssert.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReportSetupActionAssert.GetResultST : TFhirReportActionResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportActionResultCodesEnum(0)
  else
    result := TFhirReportActionResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportActionResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReportSetupActionAssert.SetResultST(value : TFhirReportActionResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportActionResultCodesEnum[value], CODES_TFhirReportActionResultCodesEnum[value]);
end;

Procedure TFhirTestReportSetupActionAssert.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

Function TFhirTestReportSetupActionAssert.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

Procedure TFhirTestReportSetupActionAssert.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

Procedure TFhirTestReportSetupActionAssert.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirTestReportSetupActionAssert.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirTestReportSetupActionAssert.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

function TFhirTestReportSetupActionAssert.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResult.sizeInBytes);
  inc(result, FMessage.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirTestReportSetupActionAssertListEnumerator }

Constructor TFhirTestReportSetupActionAssertListEnumerator.Create(list : TFhirTestReportSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionAssertListEnumerator.GetCurrent : TFhirTestReportSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionAssertListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionAssertList }
procedure TFhirTestReportSetupActionAssertList.AddItem(value: TFhirTestReportSetupActionAssert);
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionAssert');
  add(value);
end;

function TFhirTestReportSetupActionAssertList.Append: TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionAssertList.GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
begin
  result := TFhirTestReportSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionAssertList.Clone: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Clone);
end;

function TFhirTestReportSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionAssertList.GetItemN(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionAssert;
end;
function TFhirTestReportSetupActionAssertList.IndexOf(value: TFhirTestReportSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionAssertList.Insert(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionAssertList.Item(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.Link: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Link);
end;

procedure TFhirTestReportSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  FhirTestReportSetupActionAsserts[index] := value;
end;

procedure TFhirTestReportSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTest }

constructor TFhirTestReportTest.Create;
begin
  inherited;
end;

destructor TFhirTestReportTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestReportTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestReportTest(oSource).descriptionElement.Clone;
  if (TFhirTestReportTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTestActionList.Create;
    FActionList.Assign(TFhirTestReportTest(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportTestAction, FActionList.Link)){3};
end;

function TFhirTestReportTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTestAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTestAction){2a}
  else inherited;
end;

function TFhirTestReportTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTest.fhirType : string;
begin
  result := 'test';
end;

function TFhirTestReportTest.Link : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Link);
end;

function TFhirTestReportTest.Clone : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Clone);
end;

function TFhirTestReportTest.equals(other : TObject) : boolean;
var
  o : TFhirTestReportTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTest)) then
    result := false
  else
  begin
    o := TFhirTestReportTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

{ TFhirTestReportTest }

Procedure TFhirTestReportTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestReportTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestReportTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestReportTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestReportTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestReportTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirTestReportTest.GetActionList : TFhirTestReportTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTestActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportTest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportTestListEnumerator }

Constructor TFhirTestReportTestListEnumerator.Create(list : TFhirTestReportTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestListEnumerator.GetCurrent : TFhirTestReportTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTestList }
procedure TFhirTestReportTestList.AddItem(value: TFhirTestReportTest);
begin
  assert(value.ClassName = 'TFhirTestReportTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTest');
  add(value);
end;

function TFhirTestReportTestList.Append: TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestList.GetEnumerator : TFhirTestReportTestListEnumerator;
begin
  result := TFhirTestReportTestListEnumerator.Create(self.link);
end;

function TFhirTestReportTestList.Clone: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Clone);
end;

function TFhirTestReportTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestList.GetItemN(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTest;
end;
function TFhirTestReportTestList.IndexOf(value: TFhirTestReportTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestList.Insert(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.InsertItem(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestList.Item(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.Link: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Link);
end;

procedure TFhirTestReportTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestList.SetItemByIndex(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  FhirTestReportTests[index] := value;
end;

procedure TFhirTestReportTestList.SetItemN(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTestAction }

constructor TFhirTestReportTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTestAction(oSource).operation.Clone;
  assert := TFhirTestReportTestAction(oSource).assert.Clone;
end;

procedure TFhirTestReportTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestReport.setup.action.operation', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '@TestReport.setup.action.assert', false, TFhirTestReportSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestReportTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestReport.setup.action.operation'
  else if (propName = 'assert') then result := '@TestReport.setup.action.assert'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTestAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportTestAction.Link : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Link);
end;

function TFhirTestReportTestAction.Clone : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Clone);
end;

function TFhirTestReportTestAction.equals(other : TObject) : boolean;
var
  o : TFhirTestReportTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTestAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportTestAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestReportTestAction }

Procedure TFhirTestReportTestAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestReportTestAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestReportTestAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestReportTestActionListEnumerator }

Constructor TFhirTestReportTestActionListEnumerator.Create(list : TFhirTestReportTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestActionListEnumerator.GetCurrent : TFhirTestReportTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTestActionList }
procedure TFhirTestReportTestActionList.AddItem(value: TFhirTestReportTestAction);
begin
  assert(value.ClassName = 'TFhirTestReportTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTestAction');
  add(value);
end;

function TFhirTestReportTestActionList.Append: TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestActionList.GetEnumerator : TFhirTestReportTestActionListEnumerator;
begin
  result := TFhirTestReportTestActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTestActionList.Clone: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Clone);
end;

function TFhirTestReportTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestActionList.GetItemN(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTestAction;
end;
function TFhirTestReportTestActionList.IndexOf(value: TFhirTestReportTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestActionList.Insert(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.InsertItem(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestActionList.Item(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.Link: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Link);
end;

procedure TFhirTestReportTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  FhirTestReportTestActions[index] := value;
end;

procedure TFhirTestReportTestActionList.SetItemN(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardown }

constructor TFhirTestReportTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTeardownActionList.Create;
    FActionList.Assign(TFhirTestReportTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportTeardownAction, FActionList.Link)){3};
end;

function TFhirTestReportTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTeardownAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTeardownAction){2a}
  else inherited;
end;

function TFhirTestReportTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardown.fhirType : string;
begin
  result := 'teardown';
end;

function TFhirTestReportTeardown.Link : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Link);
end;

function TFhirTestReportTeardown.Clone : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Clone);
end;

function TFhirTestReportTeardown.equals(other : TObject) : boolean;
var
  o : TFhirTestReportTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardown)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTeardown.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestReportTeardown }

Function TFhirTestReportTeardown.GetActionList : TFhirTestReportTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTeardownActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportTeardown.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportTeardownListEnumerator }

Constructor TFhirTestReportTeardownListEnumerator.Create(list : TFhirTestReportTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownListEnumerator.GetCurrent : TFhirTestReportTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTeardownList }
procedure TFhirTestReportTeardownList.AddItem(value: TFhirTestReportTeardown);
begin
  assert(value.ClassName = 'TFhirTestReportTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardown');
  add(value);
end;

function TFhirTestReportTeardownList.Append: TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownList.GetEnumerator : TFhirTestReportTeardownListEnumerator;
begin
  result := TFhirTestReportTeardownListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownList.Clone: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Clone);
end;

function TFhirTestReportTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownList.GetItemN(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardown;
end;
function TFhirTestReportTeardownList.IndexOf(value: TFhirTestReportTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownList.Insert(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.InsertItem(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownList.Item(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.Link: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Link);
end;

procedure TFhirTestReportTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  FhirTestReportTeardowns[index] := value;
end;

procedure TFhirTestReportTeardownList.SetItemN(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardownAction }

constructor TFhirTestReportTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestReportTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestReportTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestReportTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestReport.setup.action.operation', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
end;

function TFhirTestReportTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestReport.setup.action.operation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardownAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportTeardownAction.Link : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Link);
end;

function TFhirTestReportTeardownAction.Clone : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Clone);
end;

function TFhirTestReportTeardownAction.equals(other : TObject) : boolean;
var
  o : TFhirTestReportTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestReportTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestReportTeardownAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
end;

{ TFhirTestReportTeardownAction }

Procedure TFhirTestReportTeardownAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

function TFhirTestReportTeardownAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
end;

{ TFhirTestReportTeardownActionListEnumerator }

Constructor TFhirTestReportTeardownActionListEnumerator.Create(list : TFhirTestReportTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownActionListEnumerator.GetCurrent : TFhirTestReportTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTeardownActionList }
procedure TFhirTestReportTeardownActionList.AddItem(value: TFhirTestReportTeardownAction);
begin
  assert(value.ClassName = 'TFhirTestReportTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardownAction');
  add(value);
end;

function TFhirTestReportTeardownActionList.Append: TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownActionList.GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
begin
  result := TFhirTestReportTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownActionList.Clone: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Clone);
end;

function TFhirTestReportTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownActionList.GetItemN(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardownAction;
end;
function TFhirTestReportTeardownActionList.IndexOf(value: TFhirTestReportTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownActionList.Insert(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.InsertItem(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownActionList.Item(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.Link: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Link);
end;

procedure TFhirTestReportTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  FhirTestReportTeardownActions[index] := value;
end;

procedure TFhirTestReportTeardownActionList.SetItemN(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReport }

constructor TFhirTestReport.Create;
begin
  inherited;
end;

destructor TFhirTestReport.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FStatus.free;
  FTestScript.free;
  FResult.free;
  FScore.free;
  FTester.free;
  FIssued.free;
  FParticipantList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

function TFhirTestReport.GetResourceType : TFhirResourceType;
begin
  result := frtTestReport;
end;

procedure TFhirTestReport.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirTestReport(oSource).identifier.Clone;
  nameElement := TFhirTestReport(oSource).nameElement.Clone;
  FStatus := TFhirTestReport(oSource).FStatus.Link;
  testScript := TFhirTestReport(oSource).testScript.Clone;
  FResult := TFhirTestReport(oSource).FResult.Link;
  scoreElement := TFhirTestReport(oSource).scoreElement.Clone;
  testerElement := TFhirTestReport(oSource).testerElement.Clone;
  issuedElement := TFhirTestReport(oSource).issuedElement.Clone;
  if (TFhirTestReport(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirTestReportParticipantList.Create;
    FParticipantList.Assign(TFhirTestReport(oSource).FParticipantList);
  end;
  setup := TFhirTestReport(oSource).setup.Clone;
  if (TFhirTestReport(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestReportTestList.Create;
    FTestList.Assign(TFhirTestReport(oSource).FTestList);
  end;
  teardown := TFhirTestReport(oSource).teardown.Clone;
end;

procedure TFhirTestReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'testScript') Then
     list.add(self.link, 'testScript', FTestScript.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'tester') Then
     list.add(self.link, 'tester', FTester.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'testScript', 'Reference(TestScript)', false, TFhirReference{TFhirTestScript}, FTestScript.Link));{2}
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));{2}
  oList.add(TFHIRProperty.create(self, 'tester', 'string', false, TFhirString, FTester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirTestReportParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'setup', '', false, TFhirTestReportSetup, FSetup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'test', '', true, TFhirTestReportTest, FTestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'teardown', '', false, TFhirTestReportTeardown, FTeardown.Link));{2}
end;

function TFhirTestReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirReportStatusCodesEnum, CODES_TFhirReportStatusCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'testScript') then
  begin
    TestScript := propValue as TFhirReference{TFhirTestScript}{4b};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportResultCodesEnum, CODES_TFhirReportResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'tester') then
  begin
    TesterElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirTestReportParticipant){2a};
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestReportSetup{4b};
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestReportTest){2a};
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestReportTeardown{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTestReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirTestReportParticipant){2a}
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestReportTest){2a}
  else inherited;
end;

function TFhirTestReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'testScript') then result := TFhirReference{TFhirTestScript}.create(){4b}
  else if (propName = 'score') then result := TFhirDecimal.create() {5b}
  else if (propName = 'tester') then result := TFhirString.create() {5b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'setup') then result := TFhirTestReportSetup.create(){4b}
  else if (propName = 'test') then result := TestList.new(){2}
  else if (propName = 'teardown') then result := TFhirTestReportTeardown.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'testScript') then result := 'Reference'
  else if (propName = 'result') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else if (propName = 'tester') then result := 'string'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'participant') then result := ''
  else if (propName = 'setup') then result := ''
  else if (propName = 'test') then result := ''
  else if (propName = 'teardown') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'testScript') then TestScriptElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'tester') then TesterElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value) {2}
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirReportStatusCodesEnum, CODES_TFhirReportStatusCodesEnum, new){4}
  else if (propName = 'testScript') then TestScriptElement := new as TFhirReference{TFhirTestScript}{4}
  else if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportResultCodesEnum, CODES_TFhirReportResultCodesEnum, new){4}
  else if (propName = 'score') then ScoreElement := asDecimal(new){5b}
  else if (propName = 'tester') then TesterElement := asString(new){5b}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'setup') then SetupElement := new as TFhirTestReportSetup{4}
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new) {2}
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestReportTeardown{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'test') then TestList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReport.fhirType : string;
begin
  result := 'TestReport';
end;

function TFhirTestReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FTestScript) and isEmptyProp(FResult) and isEmptyProp(FScore) and isEmptyProp(FTester) and isEmptyProp(FIssued) and isEmptyProp(FparticipantList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

function TFhirTestReport.equals(other : TObject) : boolean;
var
  o : TFhirTestReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReport)) then
    result := false
  else
  begin
    o := TFhirTestReport(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(testScriptElement, o.testScriptElement, true) and
      compareDeep(resultElement, o.resultElement, true) and compareDeep(scoreElement, o.scoreElement, true) and
      compareDeep(testerElement, o.testerElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(participantList, o.participantList, true) and compareDeep(setupElement, o.setupElement, true) and
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestReport.Link : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Link);
end;

function TFhirTestReport.Clone : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Clone);
end;

procedure TFhirTestReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('status');
  fields.add('testScript');
  fields.add('result');
  fields.add('score');
  fields.add('tester');
  fields.add('issued');
  fields.add('participant');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

{ TFhirTestReport }

Procedure TFhirTestReport.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirTestReport.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestReport.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestReport.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirTestReport.GetStatusST : TFhirReportStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirReportStatusCodesEnum(0)
  else
    result := TFhirReportStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportStatusCodesEnum, FStatus.value));
end;

Procedure TFhirTestReport.SetStatusST(value : TFhirReportStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirReportStatusCodesEnum[value], CODES_TFhirReportStatusCodesEnum[value]);
end;

Procedure TFhirTestReport.SetTestScript(value : TFhirReference{TFhirTestScript});
begin
  FTestScript.free;
  FTestScript := value;
end;

Procedure TFhirTestReport.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReport.GetResultST : TFhirReportResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportResultCodesEnum(0)
  else
    result := TFhirReportResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReport.SetResultST(value : TFhirReportResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportResultCodesEnum[value], CODES_TFhirReportResultCodesEnum[value]);
end;

Procedure TFhirTestReport.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

Function TFhirTestReport.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

Procedure TFhirTestReport.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

Procedure TFhirTestReport.SetTester(value : TFhirString);
begin
  FTester.free;
  FTester := value;
end;

Function TFhirTestReport.GetTesterST : String;
begin
  if FTester = nil then
    result := ''
  else
    result := FTester.value;
end;

Procedure TFhirTestReport.SetTesterST(value : String);
begin
  if value <> '' then
  begin
    if FTester = nil then
      FTester := TFhirString.create;
    FTester.value := value
  end
  else if FTester <> nil then
    FTester.value := '';
end;

Procedure TFhirTestReport.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirTestReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirTestReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Function TFhirTestReport.GetParticipantList : TFhirTestReportParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirTestReportParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirTestReport.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirTestReport.SetSetup(value : TFhirTestReportSetup);
begin
  FSetup.free;
  FSetup := value;
end;

Function TFhirTestReport.GetTestList : TFhirTestReportTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestReportTestList.Create;
  result := FTestList;
end;

Function TFhirTestReport.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

Procedure TFhirTestReport.SetTeardown(value : TFhirTestReportTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

function TFhirTestReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FTestScript.sizeInBytes);
  inc(result, FResult.sizeInBytes);
  inc(result, FScore.sizeInBytes);
  inc(result, FTester.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FSetup.sizeInBytes);
  inc(result, FtestList.sizeInBytes);
  inc(result, FTeardown.sizeInBytes);
end;

{ TFhirTestReportListEnumerator }

Constructor TFhirTestReportListEnumerator.Create(list : TFhirTestReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportListEnumerator.GetCurrent : TFhirTestReport;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportList }
procedure TFhirTestReportList.AddItem(value: TFhirTestReport);
begin
  assert(value.ClassName = 'TFhirTestReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReport');
  add(value);
end;

function TFhirTestReportList.Append: TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportList.GetEnumerator : TFhirTestReportListEnumerator;
begin
  result := TFhirTestReportListEnumerator.Create(self.link);
end;

function TFhirTestReportList.Clone: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Clone);
end;

function TFhirTestReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportList.GetItemN(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReport;
end;
function TFhirTestReportList.IndexOf(value: TFhirTestReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportList.Insert(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.InsertItem(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  Inherited Insert(index, value);
end;

function TFhirTestReportList.Item(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.Link: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Link);
end;

procedure TFhirTestReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportList.SetItemByIndex(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  FhirTestReports[index] := value;
end;

procedure TFhirTestReportList.SetItemN(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTREPORT}

end.

